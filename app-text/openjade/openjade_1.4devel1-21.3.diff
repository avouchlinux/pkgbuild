--- openjade-1.4devel1.orig/INSTALL
+++ openjade-1.4devel1/INSTALL
@@ -1,3 +1,9 @@
+Copyright (C) 1994, 1995, 1996, 1999, 2000, 2001, 2002 Free Software
+Foundation, Inc.
+
+   This file is free documentation; the Free Software Foundation gives
+unlimited permission to copy, distribute and modify it.
+
 Basic Installation
 ==================
 
@@ -8,20 +14,27 @@
 those values to create a `Makefile' in each directory of the package.
 It may also create one or more `.h' files containing system-dependent
 definitions.  Finally, it creates a shell script `config.status' that
-you can run in the future to recreate the current configuration, a file
-`config.cache' that saves the results of its tests to speed up
-reconfiguring, and a file `config.log' containing compiler output
-(useful mainly for debugging `configure').
+you can run in the future to recreate the current configuration, and a
+file `config.log' containing compiler output (useful mainly for
+debugging `configure').
+
+   It can also use an optional file (typically called `config.cache'
+and enabled with `--cache-file=config.cache' or simply `-C') that saves
+the results of its tests to speed up reconfiguring.  (Caching is
+disabled by default to prevent problems with accidental use of stale
+cache files.)
 
    If you need to do unusual things to compile the package, please try
 to figure out how `configure' could check whether to do them, and mail
 diffs or instructions to the address given in the `README' so they can
-be considered for the next release.  If at some point `config.cache'
-contains results you don't want to keep, you may remove or edit it.
-
-   The file `configure.in' is used to create `configure' by a program
-called `autoconf'.  You only need `configure.in' if you want to change
-it or regenerate `configure' using a newer version of `autoconf'.
+be considered for the next release.  If you are using the cache, and at
+some point `config.cache' contains results you don't want to keep, you
+may remove or edit it.
+
+   The file `configure.ac' (or `configure.in') is used to create
+`configure' by a program called `autoconf'.  You only need
+`configure.ac' if you want to change it or regenerate `configure' using
+a newer version of `autoconf'.
 
 The simplest way to compile this package is:
 
@@ -55,14 +68,16 @@
 =====================
 
    Some systems require unusual options for compilation or linking that
-the `configure' script does not know about.  You can give `configure'
-initial values for variables by setting them in the environment.  Using
-a Bourne-compatible shell, you can do that on the command line like
-this:
-     CC=c89 CFLAGS=-O2 LIBS=-lposix ./configure
+the `configure' script does not know about.  Run `./configure --help'
+for details on some of the pertinent environment variables.
 
-Or on systems that have the `env' program, you can do it like this:
-     env CPPFLAGS=-I/usr/local/include LDFLAGS=-s ./configure
+   You can give `configure' initial values for configuration parameters
+by setting variables in the command line or in the environment.  Here
+is an example:
+
+     ./configure CC=c89 CFLAGS=-O2 LIBS=-lposix
+
+   *Note Defining Variables::, for more details.
 
 Compiling For Multiple Architectures
 ====================================
@@ -75,11 +90,11 @@
 the `configure' script.  `configure' automatically checks for the
 source code in the directory that `configure' is in and in `..'.
 
-   If you have to use a `make' that does not supports the `VPATH'
-variable, you have to compile the package for one architecture at a time
-in the source code directory.  After you have installed the package for
-one architecture, use `make distclean' before reconfiguring for another
-architecture.
+   If you have to use a `make' that does not support the `VPATH'
+variable, you have to compile the package for one architecture at a
+time in the source code directory.  After you have installed the
+package for one architecture, use `make distclean' before reconfiguring
+for another architecture.
 
 Installation Names
 ==================
@@ -122,22 +137,32 @@
 Specifying the System Type
 ==========================
 
-   There may be some features `configure' can not figure out
-automatically, but needs to determine by the type of host the package
-will run on.  Usually `configure' can figure that out, but if it prints
-a message saying it can not guess the host type, give it the
-`--host=TYPE' option.  TYPE can either be a short name for the system
-type, such as `sun4', or a canonical name with three fields:
+   There may be some features `configure' cannot figure out
+automatically, but needs to determine by the type of machine the package
+will run on.  Usually, assuming the package is built to be run on the
+_same_ architectures, `configure' can figure that out, but if it prints
+a message saying it cannot guess the machine type, give it the
+`--build=TYPE' option.  TYPE can either be a short name for the system
+type, such as `sun4', or a canonical name which has the form:
+
      CPU-COMPANY-SYSTEM
 
-See the file `config.sub' for the possible values of each field.  If
+where SYSTEM can have one of these forms:
+
+     OS KERNEL-OS
+
+   See the file `config.sub' for the possible values of each field.  If
 `config.sub' isn't included in this package, then this package doesn't
-need to know the host type.
+need to know the machine type.
 
-   If you are building compiler tools for cross-compiling, you can also
+   If you are _building_ compiler tools for cross-compiling, you should
 use the `--target=TYPE' option to select the type of system they will
-produce code for and the `--build=TYPE' option to select the type of
-system on which you are compiling the package.
+produce code for.
+
+   If you want to _use_ a cross compiler, that generates code for a
+platform different from the build platform, you should specify the
+"host" platform (i.e., that on which the generated programs will
+eventually be run) with `--host=TYPE'.
 
 Sharing Defaults
 ================
@@ -150,20 +175,44 @@
 `CONFIG_SITE' environment variable to the location of the site script.
 A warning: not all `configure' scripts look for a site script.
 
-Operation Controls
+Defining Variables
 ==================
 
+   Variables not defined in a site shell script can be set in the
+environment passed to `configure'.  However, some packages may run
+configure again during the build, and the customized values of these
+variables may be lost.  In order to avoid this problem, you should set
+them in the `configure' command line, using `VAR=value'.  For example:
+
+     ./configure CC=/usr/local2/bin/gcc
+
+will cause the specified gcc to be used as the C compiler (unless it is
+overridden in the site shell script).
+
+`configure' Invocation
+======================
+
    `configure' recognizes the following options to control how it
 operates.
 
-`--cache-file=FILE'
-     Use and save the results of the tests in FILE instead of
-     `./config.cache'.  Set FILE to `/dev/null' to disable caching, for
-     debugging `configure'.
-
 `--help'
+`-h'
      Print a summary of the options to `configure', and exit.
 
+`--version'
+`-V'
+     Print the version of Autoconf used to generate the `configure'
+     script, and exit.
+
+`--cache-file=FILE'
+     Enable the cache: use and save the results of the tests in FILE,
+     traditionally `config.cache'.  FILE defaults to `/dev/null' to
+     disable caching.
+
+`--config-cache'
+`-C'
+     Alias for `--cache-file=config.cache'.
+
 `--quiet'
 `--silent'
 `-q'
@@ -175,8 +224,6 @@
      Look for the package's source code in directory DIR.  Usually
      `configure' can determine that directory automatically.
 
-`--version'
-     Print the version of Autoconf used to generate the `configure'
-     script, and exit.
+`configure' also accepts some other, not widely useful, options.  Run
+`configure --help' for more details.
 
-`configure' also accepts some other, not widely useful, options.
--- openjade-1.4devel1.orig/Makefile.am
+++ openjade-1.4devel1/Makefile.am
@@ -3,17 +3,21 @@
 AUTOMAKE_OPTIONS = check-news
 
 ## FIXME groveoa is missing, since an .am with only EXTRA_DIST doesn't work.
-SUBDIRS = jadedoc dsssl grove spgrove style jade intl po
+SUBDIRS = jadedoc dsssl grove spgrove style jade intl po contrib unicode
 
 pkginclude_HEADERS = config.h
 
-docdir = $(prefix)/doc
+docdir = $(datadir)/doc
 pkgdocdir = $(docdir)/@PACKAGE@
 
 pkgdoc_DATA = README ABOUT-NLS NEWS COPYING AUTHORS ChangeLog
 
 BUILT_SOURCES = config.h msggen.pl
 
+# these are not in CVS and get generated by 'automake --add-missing'
+MAINTAINERCLEANFILES = config.h.in Makefile.in aclocal.m4 \
+	configure stamp-h.in
+
 ## Note that we include the windows-only aux files.
 ## We include msggen.pl, since it won't be generated on Windows.
 EXTRA_DIST = instmac.pl msggen.pl jade.dsw jade.mak \
@@ -26,7 +30,7 @@
 	  cp $(top_srcdir)/ChangeLog $(top_distdir); \
         fi
 
-dist-zip: dist-dir
+dist-zip: distdir
 	-chmod -R a+r $(distdir)
 	zip -rql $(distdir).zip $(distdir)
 	-rm -rf $(distdir)
--- openjade-1.4devel1.orig/NEWS
+++ openjade-1.4devel1/NEWS
@@ -31,6 +31,40 @@
 
 * (test => recipient) cond clauses are supported.
 
+* RTF output had extra spaces that were detrimental to display;
+  patch from Andrey Taranov.
+
+* Better time string support; it is possible to compare time, date and
+  datetime (not only datetime). Also partial formats (like YY-MM-DD,
+  YYYY-MM or HH:MM) are now supported.  Patch from Francis J. Lacoste.
+
+* Optimize sosofo-append to reduce its memory and stack usage when
+  using it to build long list of sosofos.  Patch from Francis
+  J. Lacoste.
+
+* For the TeX backend, turn on the twoside LaTeX feature by default.
+  Patch from Francis J. Lacoste.
+
+* Improve table support in the JadeTeX backend:
+  - Support for nested tables.  cell-after-column-margin: and
+    cell-before-column-margin: wasn't really working.
+  - Row spanning was broken. This patch only supports 'start row
+    alignment though.
+  - Paragraphs in cell spanning multiple column are now working.
+  - Support for the row-alignment: characteristic.
+  - Support for cell-background? and background-color properties.
+  Patch from Francis J. Lacoste.  To see benefits of this, requires
+  JadeTeX 3.2 or better.
+
+* Add support for the 'asis and 'asis-wrap values for the paragraph's
+  'lines:' characteristic.  Patch from Francis J. Lacoste.
+
+* Allow JadeTeX to resolve references to subdocs or to content
+  produced through a "sgml-parse" by hacking on the NodeIndex
+  instruction.  Patch from Jean-Marie Kubek.
+
+* remove contrib/jadetex, get it from upstream if you want it
+
 Changes in OpenJade 1.3
 
 * The SGML backend will no emit linebreaks when used as -t sgml-raw.
--- openjade-1.4devel1.orig/acinclude.m4
+++ openjade-1.4devel1/acinclude.m4
@@ -1,5 +1,5 @@
 dnl OJ_CHECK_SIZEOF(TYPE, HEADER [, CROSS-SIZE])
-AC_DEFUN(OJ_CHECK_SIZEOF,
+AC_DEFUN([OJ_CHECK_SIZEOF],
 [changequote(<<, >>)dnl
 dnl The name to #define.
 define(<<AC_TYPE_NAME>>, translit(sizeof_$1, [a-z *], [A-Z_P]))dnl
@@ -18,7 +18,7 @@
   exit(0);
 }], AC_CV_NAME=`cat conftestval`, AC_CV_NAME=0, ifelse([$3] , , AC_CV_NAME=$3))])dnl
 AC_MSG_RESULT($AC_CV_NAME)
-AC_DEFINE_UNQUOTED(AC_TYPE_NAME, $AC_CV_NAME)
+AC_DEFINE_UNQUOTED(AC_TYPE_NAME, $AC_CV_NAME, [Size of the $1 type])
 undefine([AC_TYPE_NAME])dnl
 undefine([AC_CV_NAME])dnl
 ])
@@ -31,7 +31,7 @@
 dnl
 dnl @author Matthias Clasen
 dnl
-AC_DEFUN(AC_CXX_PLACEMENT_OPERATOR_DELETE,
+AC_DEFUN([AC_CXX_PLACEMENT_OPERATOR_DELETE],
 [AC_CACHE_CHECK(whether the compiler supports placement operator delete,
 ac_cv_cxx_placement_operator_delete,
 [AC_LANG_SAVE
@@ -61,7 +61,7 @@
 dnl @version $Id: acinclude.m4,v 1.6 2000/01/13 20:31:46 clasen Exp $
 dnl @author Luc Maisonobe
 dnl
-AC_DEFUN(AC_CXX_TYPENAME,
+AC_DEFUN([AC_CXX_TYPENAME],
 [AC_CACHE_CHECK(whether the compiler recognizes typename,
 ac_cv_cxx_typename,
 [AC_LANG_SAVE
@@ -85,7 +85,7 @@
 dnl @version $Id: acinclude.m4,v 1.6 2000/01/13 20:31:46 clasen Exp $
 dnl @author Luc Maisonobe
 dnl
-AC_DEFUN(AC_CXX_NEW_FOR_SCOPING,
+AC_DEFUN([AC_CXX_NEW_FOR_SCOPING],
 [AC_CACHE_CHECK(whether the compiler accepts the new for scoping rules,
 ac_cv_cxx_new_for_scoping,
 [AC_LANG_SAVE
@@ -112,7 +112,7 @@
 dnl @version $Id: acinclude.m4,v 1.6 2000/01/13 20:31:46 clasen Exp $
 dnl @author Luc Maisonobe
 dnl
-AC_DEFUN(AC_CXX_EXPLICIT_INSTANTIATIONS,
+AC_DEFUN([AC_CXX_EXPLICIT_INSTANTIATIONS],
 [AC_CACHE_CHECK(whether the compiler supports explicit instantiations,
 ac_cv_cxx_explinst,
 [AC_LANG_SAVE
@@ -133,7 +133,7 @@
 dnl @version $Id: acinclude.m4,v 1.6 2000/01/13 20:31:46 clasen Exp $
 dnl @author Luc Maisonobe
 dnl
-AC_DEFUN(AC_CXX_DYNAMIC_CAST,
+AC_DEFUN([AC_CXX_DYNAMIC_CAST],
 [AC_CACHE_CHECK(whether the compiler supports dynamic_cast<>,
 ac_cv_cxx_dynamic_cast,
 [AC_LANG_SAVE
@@ -158,7 +158,7 @@
 dnl @version $Id: acinclude.m4,v 1.6 2000/01/13 20:31:46 clasen Exp $
 dnl @author Luc Maisonobe
 dnl
-AC_DEFUN(AC_CXX_NAMESPACES,
+AC_DEFUN([AC_CXX_NAMESPACES],
 [AC_CACHE_CHECK(whether the compiler implements namespaces,
 ac_cv_cxx_namespaces,
 [AC_LANG_SAVE
@@ -182,7 +182,7 @@
 dnl @version $Id: acinclude.m4,v 1.6 2000/01/13 20:31:46 clasen Exp $
 dnl @author Luc Maisonobe
 dnl
-AC_DEFUN(AC_CXX_BOOL,
+AC_DEFUN([AC_CXX_BOOL],
 [AC_CACHE_CHECK(whether the compiler recognizes bool as a built-in type,
 ac_cv_cxx_bool,
 [AC_LANG_SAVE
@@ -200,14 +200,14 @@
 fi
 ])
 
-AC_DEFUN(AC_DEFINE_DIR, [
+AC_DEFUN([AC_DEFINE_DIR], [
   ac_expanded=`(
     test "x$prefix" = xNONE && prefix="$ac_default_prefix"
     test "x$exec_prefix" = xNONE && exec_prefix="${prefix}"
     eval echo \""[$]$2"\"
   )`
   ifelse($3, ,
-    AC_DEFINE_UNQUOTED($1, "$ac_expanded"),
+dnl    AC_DEFINE_UNQUOTED($1, "$ac_expanded"),
     AC_DEFINE_UNQUOTED($1, "$ac_expanded", $3))
 ])
 
@@ -220,7 +220,7 @@
 dnl @version $Id: acinclude.m4,v 1.6 2000/01/13 20:31:46 clasen Exp $
 dnl @author Luc Maisonobe
 dnl
-AC_DEFUN(AC_CXX_MUTABLE,
+AC_DEFUN([AC_CXX_MUTABLE],
 [AC_CACHE_CHECK(whether the compiler supports the mutable keyword,
 ac_cv_cxx_mutable,
 [AC_LANG_SAVE
@@ -238,3 +238,16 @@
   AC_DEFINE(HAVE_MUTABLE,,[define if the compiler supports the mutable keyword])
 fi
 ])
+
+dnl In the intl/Makefile.in we have a special dependency which makes
+dnl sense only for gettext.  We comment this out for non-gettext
+dnl packages.
+if test "$PACKAGE" = "gettext"; then
+  GT_NO="#NO#"
+  GT_YES=
+else
+  GT_NO=
+  GT_YES="#YES#"
+fi
+AC_SUBST(GT_NO)
+AC_SUBST(GT_YES)
--- openjade-1.4devel1.orig/configure.in
+++ openjade-1.4devel1/configure.in
@@ -1,4 +1,4 @@
-AC_REVISION([$Id: configure.in,v 1.21 2000/03/28 16:10:47 clasen Exp $])
+AC_REVISION([$Id: configure.in,v 1.25 2001/07/20 06:19:24 adicarlo Exp $])
 dnl
 dnl  Process this file with autoconf to produce a configure script.
 dnl
@@ -11,10 +11,13 @@
 dnl
 
 dnl Initialization
-AC_INIT(dsssl)
-AM_INIT_AUTOMAKE(OpenJade, 1.4devel, no-define)
-AM_CONFIG_HEADER(config.h)
+AC_INIT([OpenJade], [1.4devel], [], [OpenJade])
+AC_CONFIG_SRCDIR(dsssl)
+AM_INIT_AUTOMAKE([foreign])
+AM_CONFIG_HEADER([config.h])
 AM_SANITY_CHECK
+AM_MAINTAINER_MODE
+AC_USE_SYSTEM_EXTENSIONS
 
 dnl Use different names than usually to avoid conflicts.
 AC_DEFINE_UNQUOTED(OPENJADE_PACKAGE, "$PACKAGE", [Package name])
@@ -27,30 +30,31 @@
 AC_PROG_CXXCPP
 AC_PROG_INSTALL
 AC_PROG_LN_S
-AC_PROG_RANLIB
+dnl AC_PROG_RANLIB
 AC_PROG_MAKE_SET
 AC_PATH_PROGS(PERL, perl, perl)
 AM_PROG_LIBTOOL
 
 dnl Checks for libraries.
 AC_CHECK_LIB(pthread,pthread_create,,AC_CHECK_LIB(threads,cthread_fork))
-ALL_LINGUAS="de sv"
 AM_GNU_GETTEXT
-AC_CHECK_HEADERS(locale.h)
+AM_GNU_GETTEXT_VERSION([0.19.2])
+AC_CHECK_HEADERS([locale.h])
 AC_DEFINE_DIR(OPENJADE_LOCALE_DIR, datadir/locale, [location of message catalogs])
 OPENJADE_MESSAGE_DOMAIN=jade
 AC_DEFINE_UNQUOTED(OPENJADE_MESSAGE_DOMAIN, "$OPENJADE_MESSAGE_DOMAIN", [message domain])
 AC_SUBST(OPENJADE_MESSAGE_DOMAIN)
+AC_CHECK_LIB(w,wcscoll)
 
 dnl Checks for header files.
 AC_HEADER_STDC
-AC_CHECK_HEADERS(limits.h)
-AC_LANG_CPLUSPLUS 
+AC_CHECK_HEADERS([limits.h])
+AC_LANG([C++]) 
 AC_CHECK_HEADERS(new cassert)
 
 dnl Checks for typedefs, structures and compiler characteristics.
 AC_TYPE_SIZE_T
-AC_STRUCT_ST_BLKSIZE
+AC_CHECK_MEMBERS([struct stat.st_blksize])
 AC_CACHE_CHECK(for sig_atomic_t in signal.h,
     ac_cv_have_sig_atomic_t,
     AC_TRY_LINK([#include <signal.h>],sig_atomic_t x;,
@@ -149,7 +153,7 @@
               [define this if your system misses new.h])
     AC_CACHE_CHECK(whether to declare set_new_handler extern "C",
                     ac_cv_cxx_new_handler_extern_c,
-                    [AC_TRY_COMPILE([
+                    [AC_TRY_LINK([
 typedef void (*new_handler)();
 new_handler set_new_handler(new_handler);],[
 set_new_handler(0);],
@@ -183,8 +187,8 @@
 dnl Checks for system services.
 
 dnl Package options.
-AC_ARG_PROGRAM
-AC_DEFINE_UNQUOTED(DEFAULT_SCHEME_BUILTINS,"$prefix/share/$PACKAGE/builtins.dsl",
+dnl AC_ARG_PROGRAM dnl complains about multiple invocations, though this is only explicit one
+AC_DEFINE_UNQUOTED(DEFAULT_SCHEME_BUILTINS,"$prefix/share/sgml/$PACKAGE/builtins.dsl",
                    [set this to the location of builtins.dsl])
 AC_DEFINE(SP_MULTI_BYTE,1,
           [define this to build a multi-byte version])
@@ -232,9 +236,8 @@
             [define this to build the html backend])
   AC_MSG_RESULT(yes))
 
-AC_SUBST(LIBOBJS)
-AC_OUTPUT([${PACKAGE}-${VERSION}.spec:spec.in Makefile msggen.pl style/Makefile grove/Makefile spgrove/Makefile
-	jade/Makefile dsssl/Makefile jadedoc/Makefile 
-	jadedoc/images/Makefile intl/Makefile po/Makefile.in],
-	[echo creating po/Makefile
-	sed -e "/POTFILES =/r po/POTFILES" po/Makefile.in > po/Makefile])
+dnl AC_SUBST(LIBOBJS)
+AC_OUTPUT([${PACKAGE}-${VERSION}.spec:spec.in Makefile msggen.pl style/Makefile
+	grove/Makefile spgrove/Makefile jade/Makefile dsssl/Makefile
+	jadedoc/Makefile jadedoc/images/Makefile intl/Makefile contrib/Makefile
+	unicode/Makefile po/Makefile.in])
--- openjade-1.4devel1.orig/contrib/Makefile.am
+++ openjade-1.4devel1/contrib/Makefile.am
@@ -0,0 +1,9 @@
+## Process this file with automake to produce Makefile.in
+
+pkgdatadir = $(datadir)/@PACKAGE@/contrib
+
+pkgdata_DATA = transform.dsl
+
+EXTRA_DIST = transform.dsl
+
+MAINTAINERCLEANFILES = Makefile.in
--- openjade-1.4devel1.orig/contrib/README
+++ openjade-1.4devel1/contrib/README
@@ -0,0 +1,33 @@
+README for the OpenJade contrib directory
+-----------------------------------------
+
+This directory contains software and documentation that are not an
+integral part of OpenJade -- that is, they are not part of a DSSSL
+implementation. They may or may not be useful. Your pointage may 
+vary.
+
+Here's a list of what's in this directory:
+
+rtf2doc.pl - a Perl script which will take .rtf files generated by 
+    Jade and convert them to Word .doc format. In the process, 
+    referenced graphic files will be embedded into the documents,
+    and page numbers references will be resolved. Requires MS Word
+    97.d
+
+psgml-jade.el - an addition to psgml (a powerful SGML mode for Emacs)
+    which makes it easy to apply a DSSSL style sheet to an SGML document 
+    from within the editor. It also contains a framework to enable
+    menu-driven customization of DSSSL style sheets. Requires 
+    psgml-dsssl.el and customize.dtd.
+
+psgml-dsssl.el - creates a skeleton DSSSL style sheet for an SGML document.
+
+customize.dtd - a dtd derived from the DSSSL architecture which includes
+    information about user-settable variables and characteristics. This
+    allows menu-driven customization.
+
+jadetex - the JadeTeX macros needed to process the output of the TeX 
+    backend used to be included here.  However, they were removed;
+    just get them from upstream:
+    <URL:http://www.tug.org/applications/jadetex/>
+
--- openjade-1.4devel1.orig/contrib/catalog
+++ openjade-1.4devel1/contrib/catalog
@@ -0,0 +1,3 @@
+-- Copyright (C) 1999 Avi Kivity --
+CATALOG "../dsssl/catalog"
+-- ENTITY "transform.dsl" "transform.dsl" --
--- openjade-1.4devel1.orig/contrib/customize.dtd
+++ openjade-1.4devel1/contrib/customize.dtd
@@ -0,0 +1,150 @@
+<!-- A DTD for customizable DSSSL Style Sheets. Second version 97/07/11 -->
+
+<!-- An customization application should create a style sheet containing
+     a style-specification using the customizable style-specification as an 
+     external-specification. The generated style-specification should contain
+     a line 
+
+     (define identifier expression) 
+
+     with the customized value expression for each <variable name=identifier> 
+     element and a line  
+   
+     (declare-initial-value identifier expression) 
+
+     for each <characteristic name=identifier> element in the customizable 
+     style-specification.  -->
+
+<!element customizable-style-sheet o o (style-specification,
+			   (external-specification|style-specification)*)>
+<!element style-specification o o (customize?,style-specification-body)>
+<!attlist style-specification
+  id id #implied
+  use idrefs #implied
+>
+<!element style-specification-body o o (#pcdata)>
+<!attlist style-specification-body
+  content entity #conref
+>
+<!element external-specification - o empty>
+<!attlist external-specification
+  id id #required
+  document entity #required
+  specid name #implied
+>
+
+<!element customize - - ((section|variable|characteristic)*) 
+  -- The description of the customizable part of a style-specification. 
+     It can be hierarchically structured to make menu-based customization 
+     dialogs possible. -->
+ 
+<!attlist customize
+  languages cdata #implied -- A list of languages for which descriptions 
+	                      are given. A customization tool should give the 
+                              user a possibility to choose the preferred
+                              language among thses. This language should be
+                              used for selecting appropriate <description>s. 
+                              If a particular <section>, <variable> or <value>
+                              doesn't have a <description> in the preferred 
+                              language, the tool should display a description
+                              without an explicit language, if there is one.
+                              Otherwise the tool might choose to use another
+                              language or provide a default description. It is
+                              not acceptible to simply omit the <section>,
+                              <variable> or <value> in question. -->
+
+<!element section - - (description*,(section|variable|characteristic)*) >
+
+<!element characteristic - - (description*,value*) 
+  -- Infomation about a single inherited characteristic. -->
+  
+<!attlist characteristic
+  name cdata #required   -- The name of the characteristic. --
+  ignored (ignored) #conref  -- Style sheet authors can mark characteristics
+                                as ignored. If a characteristic is marked as 
+                                ignored, the customization application shall 
+                                not offer it for customization. 
+                                Typical reasons for ignoring characteristics
+                                are that the style sheet does not use flow
+                                object classes which have this characteristic
+                                or that the style sheet relies on a the
+                                characteristic to have a fixed value or
+                                that the characteristic is overridden by 
+                                an expression. Eg, paper-height and paper-width
+                                could be ignored, if there is a variable for
+                                selecting the paper format. 
+
+                                The customization application is free to 
+                                offer customization for any characteristics 
+                                which have not been explicitly mentioned in
+                                the customize info in the style sheet. It 
+                                could base the decision about which
+                                characteristics to offer on knowledge about
+                                supported flow object classes in the DSSSL 
+                                engine. --
+  initial cdata #implied -- The initial value of the characteristic. This 
+                            shall be an allowed value. -->
+
+<!element variable - - (description*,value*) 
+  -- Infomation about a single variable. -->
+ 
+<!attlist variable
+  name cdata #required   -- The name of the variable. --
+  default cdata #implied -- The default value of the variable, if any. This 
+                            shall be an allowed value. -->
+
+<!element value - o (description*,(content|type)) 
+  -- This element describes the allowed values for a variable. The
+     values can be explicitly specified using the <content> element or 
+     a whole type of elements can be included using the <type> element.
+     The set of all allowed values is the union of the sets of allowed
+     values of all <content> and <type> subelements. Typical constellations 
+     are: 1) only <content> subelements
+          2) a single <type> element -->
+ 
+<!element type - o empty >
+
+<!attlist type class (boolean|char|string|number|length|area|expression) #required 
+ -- All values of the type specified in this attribute are acceptable values. -->
+ 
+<!element content - - (#pcdata) -- A single possible value. end tag ommission
+                                   is not allowed, since a closing newline is
+                                   almost never wanted in a value, but would
+                                   creep in inevitably. -->
+
+<!element description - o (short,long?) -- A description can be part of a 
+   <section>, a <variable> or a <value>. It always has a <short> part, which
+   should contain a short descriptive string, suitable as a menu entry. The
+   optional long part can contain a longer description, suitable a a help text
+   explaining the <section>, <variable> or <value> in question. -->
+  
+<!attlist description
+   language cdata #implied -- Identifies the language used in the
+                              description. If no language is specified, the
+                              description is used whenever there is no
+                              description in the users preferred language. -->
+
+<!element short o o (#pcdata) -- A short description suitable as a menu entry. -->
+  
+<!element long - o (#pcdata) -- A longer description, suitable as 
+                                an explanatory help text. -->
+
+<?ArcBase DSSSL>
+<!NOTATION DSSSL   PUBLIC "ISO/IEC 10179:1996//NOTATION
+                   DSSSL Architecture Definition Document//EN"
+                -- A document architecture conforming to the
+                   Architectural Form Definition Requirements of
+                   ISO/IEC 10744.     --
+>
+
+<!ATTLIST #NOTATION DSSSL
+                            -- Support attributes for all architectures --
+  ArcQuant CDATA #FIXED "NAMELEN 64"
+  ArcDTD CDATA #FIXED "%DSSSLDTD"
+  ArcDocF NAME #FIXED dsssl-specification
+  ArcDataF NAME #FIXED dsssl-specification
+>
+
+<!ENTITY % DSSSLDTD PUBLIC
+ "ISO/IEC 10179:1996//DTD DSSSL Architecture//EN"
+>
--- openjade-1.4devel1.orig/contrib/psgml-dsssl.el
+++ openjade-1.4devel1/contrib/psgml-dsssl.el
@@ -0,0 +1,139 @@
+;; psgml-dsssl.el --- create a skeleton DSSSL spec for an SGML document.
+;; $Id: psgml-dsssl.el,v 1.1 1999/08/28 20:01:31 clasen Exp $
+;; Copyright (C) 1996 David Megginson.  Free redistribution permitted.
+;; USE AT YOUR OWN RISK!
+;;
+;; Author: David Megginson (dmeggins@microstar.com)
+
+
+;;; Commentary:
+
+;; Installation:
+;;
+;; This file requires Gnu Emacs 19.* or XEmacs, together with Lennart
+;; Staflin's PSGML mode (tested with version 1a12).
+;;
+;; Install this file somewhere on your load path, byte-compile it, and
+;; include the following in your .emacs or site-start.el file:
+;;
+;;   (autoload 'sgml-dsssl-make-spec "psgml-dsssl" nil t)
+;;
+;; Now, whenever you are editing an SGML document with PSGML, you can
+;; type
+;;
+;;    M-x sgml-dsssl-make-spec
+;;
+;; to create a skeleton DSSSL style spec in a temporary buffer
+;; "**DSSSL**" (overwriting any existing spec).  You may save the
+;; buffer to a file and edit it as you wish.
+;;
+;;
+;; Operation:
+;;
+;; This package will generate an element construction rule for every
+;; element type which could appear in the SGML document, whether it
+;; actually appears or not -- it does so by starting with the element
+;; type of the document's root element, then performing a depth-first
+;; traversal of the DTD tree.  Any element types which are not
+;; reachable from the root will be excluded.
+;;
+;; The first instance of each element class in the DTD tree will
+;; determine its context, and thus, its default flow-object class.
+;; The contexts are as follow:
+;;
+;; 1) The root element of the document (default: simple-page-sequence).
+;; 2) The element appears in mixed content or contains PCDATA content
+;;    (default: sequence).
+;; 3) The element contains mixed content and appears in element content
+;;    (default: paragraph).
+;; 4) The element contains only element content
+;;    (default: display-group).
+;; 5) The element is EMPTY (default: sequence).
+;;
+;; These will work well with some DTDs, but the assumptions will fall
+;; apart quickly for others, especially HTML (which allows mixed
+;; content almost everywhere).  You can change the default flow-object
+;; classes for each of these using configuration variables, as you can
+;; change the default document-type declaration at the top of the
+;; specification.
+;;
+
+
+;;; Code:
+
+(require 'psgml-parse)
+(autoload 'sgml-map-element-types "psgml-info" nil t)
+(autoload 'sgml-eltype-refrenced-elements "psgml-info" nil t)
+
+;;
+;; Global configuration variables -- change as appropriate.
+;;
+
+					; Default to the style-sheet
+					; DTD from the jade distribution.
+(defvar sgml-dsssl-prolog
+  "<!DOCTYPE style-sheet PUBLIC \"-//James Clark//DTD DSSSL Style Sheet//EN\">\n\n"
+  "Prolog for generated DSSSL scripts.")
+
+(defvar sgml-dsssl-root-foc "simple-page-sequence"
+  "The default flow-object class for the root element type.")
+
+(defvar sgml-dsssl-mixed-foc "paragraph"
+  "The default flow-object class for an element type with mixed content.")
+
+(defvar sgml-dsssl-element-foc "display-group"
+  "The default flow-object class for an element type with element content.")
+
+(defvar sgml-dsssl-data-foc "sequence"
+  "The default flow-object class for an element type with data content.")
+
+(defvar sgml-dsssl-empty-foc "sequence"
+  "The default flow-object class for an element type with EMPTY content.")
+
+;;;
+;;; Generate a skeleton DSSSL spec.
+;;;
+(defun sgml-dsssl-make-spec ()
+  "Generate a skeleton DSSSL style spec for the SGML document in a buffer.
+The output will always go into a buffer named \"**DSSSL**\"."
+
+  (interactive)
+  (sgml-need-dtd)
+  (let ((root (symbol-name (sgml-element-name (sgml-top-element))))
+	(max-lisp-eval-depth 10000)
+	(elements-seen ()))
+    (with-output-to-temp-buffer "**DSSSL**"
+      (princ sgml-dsssl-prolog)
+      (sgml-dsssl-make-rule (sgml-lookup-eltype root)))))
+
+(defun sgml-dsssl-make-rule (eltype &optional parent-mixed)
+  "Generate an element-construction rule, then recurse to any children."
+
+  (let ((name (sgml-eltype-name eltype))
+	(foc
+	 (cond ((equal elements-seen ())
+		sgml-dsssl-root-foc)
+	       ((or (equal (sgml-eltype-refrenced-elements eltype)
+			   (list (intern "#PCDATA")))
+		    parent-mixed)
+		sgml-dsssl-data-foc)
+;	       ((sgml-eltype-mixed eltype)
+;		sgml-dsssl-mixed-foc)
+	       ((equal (sgml-eltype-refrenced-elements eltype) ())
+		sgml-dsssl-empty-foc)
+	       (t sgml-dsssl-element-foc))))
+
+    (push name elements-seen)
+    
+;    (princ ";; Contents: ")
+;    (mapc (function (lambda (child) (princ child) (princ " ")))
+;	  (sgml-eltype-refrenced-elements eltype))
+;    (princ "\n")
+    (princ (format "(element %s\n  (make %s\n    (process-children)))\n\n"
+		   (upcase name) foc)))
+  (mapcar (function
+	   (lambda (el)
+	     (if (and (not (memq (sgml-eltype-name el) elements-seen))
+		      (not (string= (sgml-eltype-name el) "#PCDATA")))
+		 (sgml-dsssl-make-rule el (sgml-eltype-mixed eltype)))))
+	  (sgml-eltype-refrenced-elements eltype)))
--- openjade-1.4devel1.orig/contrib/psgml-jade.el
+++ openjade-1.4devel1/contrib/psgml-jade.el
@@ -0,0 +1,1103 @@
+;	$Id: psgml-jade.el,v 1.2 2001/01/31 23:37:56 adicarlo Exp $	
+;; psgml-jade.el --- add jade, jadetex and customize support to psgml.
+;; Copyright (C) 1997 Matthias Clasen.  Free redistribution permitted.
+;; USE AT YOUR OWN RISK!
+;;
+;; Author: Matthias Clasen (mclasen@sun2.mathematik.uni-freiburg.de)
+
+
+;;; Commentary:
+
+;; Thanks:
+;;
+;; The code is heavily borrowed from AUCTeX 9.5. 
+;;
+;;
+;; Installation:
+;;
+;; This file requires Gnu Emacs 19.* or XEmacs, together with Lennart
+;; Staflin's PSGML mode (tested with version 1.0.1) and David Megginson's 
+;; DSSSL extensions (psgml-dsssl.el). 
+;;
+;; Install this file somewhere on your load path, byte-compile it, and
+;; include the following in your .emacs or site-start.ed file:
+;;
+;;  (add-hook 'sgml-mode-hook '(lambda () (require 'psgml-jade)))
+;;
+;; Make the file `customize.dtd' accessible to jade and psgml. This
+;; typically means adding a catalog entry for this file.
+;;
+;; Now, whenever you are editing an SGML document with PSGML, you will
+;; see an additional menu with title `DSSSL'. It contains entries 
+
+;;  `Jade'       calls jade with sensible command line parameters
+;;  `JadeTeX'    calls jadetex with sensible command line parameters
+;;  `View dvi'   calls `xdvi' by default
+;;  `Kill Job'   kills a job started with one of the above entries
+;;  `Recenter Output Buffer'    displays the output of a job started 
+;;               with one of the above entries.
+;;  `File Options >'    opens a submenu that allows you to select the 
+;;               DSSSL style sheet and the backend to use with jade.
+;;  `Make new style sheet'    executes David Megginson's `sgml-dsssl-make-spec'
+;;               for this you need the file `psgml-dsssl.el'.
+;;  `Edit style sheet'    brings up a buffer with the selected style sheet.
+;;  `Customize style sheet'   If the style sheet is following the DTD
+;;               `customize.dtd' distributed with this file, this contains
+;;               a submenu for changing variable settings in the style sheet.   
+;;  `Save customizations'     Asks you for the name of a file to save the
+;;               customized values to. The generated file is a fully valid
+;;               DSSSL style sheet. You may reload your customizations from 
+;;               this file by selecting it as style sheet. 
+;;
+;; The menu entries (except `File Options >') are also reachable by commands:
+;; `M-x sgml-command' prompts you for the command to execute. You can use 
+;;    completion to select one of the menu entries for the external commands.
+;; `M-x sgml-recenter-output-buffer'
+;; `M-x sgml-kill-job' 
+;; `M-x sgml-dsssl-make-spec'
+;; `M-x sgml-dsssl-edit-spec'
+;;
+;; For details how to add commands to the menu, see the documentation of
+;; the variables below. 
+
+
+;;; Code:
+
+;;;; Variables to be customized.
+
+(defvar
+  sgml-command-list 
+  (list 
+; this is how `Validate' could be done here; note that this is better than
+; the solution in the `SGML' menu, since it automatically includes the catalogs.
+;   (list "Validate" 
+;	 "cd %dir; nsgmls -s -m%catalogs %file" 'sgml-run-command t 
+;	 '((":\\(.+\\):\\([0-9]+\\):\\([0-9]+\\):[EX]: " 1 2 3)
+;	   ("\\(error\\|warning\\) at \\([^,]+\\), line \\([0-9]+\\)" 2 3)
+;	   ("\n[a-zA-Z]?:?[^0-9 \n\t:]+:[ \t]*\\([^ \n\t:]+\\):\
+;\\([0-9]+\\):\\(\\([0-9]+\\)[: \t]\\)?" 1 2 4)))
+   (list "Jade" "cd %dir; openjade -c%catalogs -t%backend -d%stylesheet %file" 
+	 'sgml-run-command nil
+	 '(("openjade:\\(.*\\):\\(.*\\):\\(.*\\):E:" 1 2 3)))
+   (list "JadeTeX" "cd %dir; jadetex '\\nonstopmode\\input %tex'" 
+         'sgml-run-command nil)
+   (list "View dvi" "cd %dir; xdvi %dvi" 
+         'sgml-run-background t))
+  "*List of commands. 
+
+The first entry is the string appearing in the `DSSSL' menu. 
+The second entry is the command to run after expansion with `sgml-command-expand'. 
+The third one is the hook used to run the command. A hook should be a function of
+four arguments: the name (first entry), the command to run (the expanded second 
+entry), the file name and an error regexp (the fifth entry).
+The fourth entry is set to t to enforce confirmation in the minibuffer.
+The (optional) fifth entry is an error regexp to be used by `compile-internal'.")
+
+(defvar sgml-sgml-file-extension "sgml"
+  "*Extension used for the expansion of %sgml in `sgml-command-expand'.")
+
+(defvar sgml-dsssl-file-extension "dsl"
+  "*Extension used for the expansion of %dsssl in `sgml-command-expand'
+and for the default file name when saving the `**DSSSL**' buffer.")
+
+
+(defvar sgml-expand-list 
+  (list 
+   (list "%file" 'file nil)                         ; the current file as is
+   (list "%sgml" 'file sgml-sgml-file-extension)    ;   with given extension
+   (list "%tex" 'file "tex")                        ;   dito 
+   (list "%dvi" 'file "dvi")                        ;   dito
+   (list "%dsssl" 'file sgml-dsssl-file-extension)  ;   dito
+   (list "%dir" 'file nil t)                        ; the directory part  
+   (list "%stylesheet" 'sgml-dsssl-spec)            ; the specified style sheet
+   (list "%backend" 'sgml-jade-backend)             ; the selected backend
+   (list "%catalogs" 'sgml-dsssl-catalogs 'sgml-catalog-files 'sgml-local-catalogs)
+        ; the catalogs listed in sgml-catalog-files and sgml-local-catalogs.
+   )
+  "*List of matched patterns in commands.
+
+The first entry is the placeholder in the command string. 
+The second entry is a function which is evaluated to produce a string 
+replacing the placeholder.
+
+The function should accept all remaining list entries as arguments plus a 
+first argument which is a string holding a possible flag preceding the 
+placeholder in the command string or the empty string if there is no flag.
+
+If the replacement is more than one item (like for catalogs), the function 
+would normally repeat the flag for each item.")
+
+(defvar sgml-jade-backends 
+  '(("TeX" . tex)
+    ("RTF" . rtf)
+    ("FOT" . fot)
+    ("SGML" . sgml)
+    ("XML" . xml))
+  "*List of supported backends for jade. 
+
+Each backend is specified as a cons cell containing a string to appear in the 
+`Jade backend' menu and a symbol whose name is used as replacement for %backend."  
+)
+
+(defvar sgml-show-compilation nil
+  "*If non-nil, show output of compilation in other window.")
+
+;;;; Internal variables.
+
+;; This variable is shared with `compile.el'.
+(defvar compilation-in-progress nil 
+  "List of compilation processes now running.")
+
+(or (assq 'compilation-in-progress minor-mode-alist)
+    (setq minor-mode-alist (cons '(compilation-in-progress " Compiling")
+				 minor-mode-alist)))
+
+(defvar sgml-jade-backend 'tex 
+  "*Symbol whose name is used as replacement for %backend in `sgml-command-expand'. 
+
+Possible values are given in `sgml-jade-backends'.")
+(make-variable-buffer-local 'sgml-jade-backend)
+(put 'sgml-jade-backend 'sgml-type sgml-jade-backends)
+(put 'sgml-jade-backend 'sgml-desc "Jade backend")
+
+(defvar sgml-dsssl-spec nil 
+  "*String used as file name part in the replacement for %stylesheet 
+in `sgml-command-expand'.
+
+The value should be a file name or nil.")
+(make-variable-buffer-local 'sgml-dsssl-spec)
+(put 'sgml-dsssl-spec 'sgml-type 'file-or-nil)
+(put 'sgml-dsssl-spec 'sgml-desc "DSSSL style sheet")
+
+(defvar sgml-dsssl-subspec nil
+  "*String used as style-specification part in the replacement for
+%stylesheet in `sgml-command-expand'.
+
+The value should be the ID of a style-specification in 
+`sgml-dsssl-spec' or nil.")
+(make-variable-buffer-local 'sgml-dsssl-subspec)
+(put 'sgml-dsssl-subspec 'sgml-type 'string-or-nil)
+(put 'sgml-dsssl-subspec 'sgml-desc "DSSSL style specification")
+
+(defvar sgml-dsssl-customize-spec nil 
+  "*String used as file name when saving customizations.
+
+The value should be a file name or nil.")
+(make-variable-buffer-local 'sgml-dsssl-customize-spec)
+(put 'sgml-dsssl-customize-spec 'sgml-type 'file-or-nil)
+(put 'sgml-dsssl-customize-spec 'sgml-desc "Customizations go to")
+
+(defvar sgml-dsssl-language "DE"
+  "*String identifying the language preferred for customization info.")
+(put 'sgml-dsssl-language 'sgml-type 'string-or-nil)
+(put 'sgml-dsssl-language 'sgml-desc "Language")
+
+(defvar sgml-dsssl-customize nil 
+  "*An alist holding customized values of style sheet variables
+and characteristics.")
+(make-variable-buffer-local 'sgml-dsssl-customize)
+(put 'sgml-dsssl-customize 'sgml-type 'list)
+(put 'sgml-dsssl-customize 'sgml-desc "Customize value alist")
+
+(defvar sgml-dsssl-customize-info nil 
+  "*An alist holding customization info about style sheet variables 
+and characteristics.")
+(make-variable-buffer-local 'sgml-dsssl-customize-info)
+(put 'sgml-dsssl-customize-info 'sgml-type 'list)
+(put 'sgml-dsssl-customize-info 'sgml-desc "Customize info alist")
+
+(defvar sgml-dsssl-added-characteristics nil
+  "*The name of a customizable style sheet containing a description
+of DSSSL characteristics which should be offered for customization.")
+(put 'sgml-dsssl-added-characteristics 'sgml-type 'file-or-nil)
+(put 'sgml-dsssl-added-characteristics 'sgml-desc "Additional characteristics")
+
+(defconst sgml-dsssl-customize-identifier 
+  "<!-- This file has been automatically generated by psgml. -->"
+"A string inserted at the beginning of customization files.")
+
+(defconst sgml-dsssl-file-options
+  '(
+    sgml-jade-backend
+    sgml-dsssl-spec
+    sgml-dsssl-subspec
+    sgml-dsssl-language
+    )
+  "Options for the current file, can be saved or set from menu."
+  )
+
+(defvar sgml-confirm-command-history nil
+    "The minibuffer history list for `sgml-command-execute''s COMMAND argument.")
+
+(defvar sgml-read-command-history nil
+    "The minibuffer history list for `sgml-read-command-name'.")
+
+;;;; Command expansion   
+
+(defun sgml-jade-backend (flag) 
+  "Used in `sgml-command-expand' to produce the replacement text for %backend."
+  (concat (when sgml-jade-backend flag) (symbol-name sgml-jade-backend)))
+
+(defun sgml-dsssl-spec (flag) 
+  "Used in `sgml-command-expand' to produce the replacement text for %stylesheet.
+
+If the style sheet has customization info, this has the side effect of creating
+a temporary style sheet."
+  (cond 
+   ((null sgml-dsssl-spec) "") ; no style sheet
+   ((null sgml-dsssl-customize)  ; a style sheet without customize info
+    (concat flag 
+	    sgml-dsssl-spec 
+	    (when sgml-dsssl-subspec "#") sgml-dsssl-subspec)) ; might have subspec
+   (t (let ( (the-spec (make-temp-name (concat "/tmp/" "psgml"))) ) 
+	(sgml-dsssl-write-customize the-spec)
+	(concat flag the-spec)))))
+
+(defun sgml-dsssl-write-customize (&optional filename)
+  (interactive 
+   (list (setq sgml-dsssl-customize-spec 
+	       (read-from-minibuffer "Filename: " sgml-dsssl-customize-spec))))
+  (let ( (the-spec sgml-dsssl-spec)
+	 (the-subspec sgml-dsssl-subspec)
+	 (the-cust sgml-dsssl-customize) 
+	 (the-info sgml-dsssl-customize-info) )
+    (when (and the-spec the-cust filename)
+      (save-excursion 
+	(set-buffer (find-file-noselect filename))
+	(erase-buffer)
+	(insert sgml-dsssl-customize-identifier "\n")
+	(insert "<!doctype style-sheet "
+		"PUBLIC \"-//James Clark//DTD DSSSL Style Sheet//EN\" [\n")
+	(insert "<!entity base system \"" 
+		the-spec 
+		"\" cdata dsssl>\n")
+	(insert "]>\n")
+	(insert "<style-specification use=x>\n")
+	(let ( (val nil) 
+	       (info nil) )
+	  (while the-cust
+	    (setq desc (car the-cust))
+	    (setq info (cdr (assoc (car desc) the-info))) 
+	    (when (cdr desc) ; write out only customized values
+	      (cond 
+	       ((equal 'characteristic (aref info 4))
+		(insert "(declare-initial-value " (car desc) " " (cdr desc) ")\n"))
+	       ((equal 'variable (aref info 4))
+		(insert "(define " (car desc) " " (cdr desc) ")\n"))))
+	    (setq the-cust (cdr the-cust))))
+	(insert "</style-specification>\n")
+	(insert "<external-specification id=x document=base") 	
+	(when the-subspec (insert " specid=" the-subspec))
+	(insert ">\n")
+	(save-buffer)))))
+
+(defun sgml-dsssl-catalogs (flag &rest lists)
+  "Used in `sgml-command-expand' to produce the replacement text for %catalogs."
+  (mapconcat 
+   (lambda (cats) 
+     (mapconcat (lambda (cat) (concat flag cat)) (eval cats) " "))
+   lists " ")
+)
+
+; should this somehow deal with `sgml-parent-document' ?
+(defun sgml-file (&optional extension dir) 
+  "If DIR is non-nil, return the directory part of the current file,
+else the current file without directory part. Replace the extension 
+by EXTENSION, if non-nil."
+  (if dir 
+      (file-name-directory (buffer-file-name))
+    (if extension
+	(concat (sgml-strip-extension 
+		 (file-name-nondirectory (buffer-file-name))) "." extension)
+      (file-name-nondirectory (buffer-file-name))
+      )
+    )
+  )
+
+(defun sgml-command-expand (command file)
+  "Expand COMMAND for FILE as described by `sgml-expand-list'."
+  (let ( (list sgml-expand-list) )
+  (while list
+    (let ( (case-fold-search nil)                 ; Do not ignore case.
+	   (string (car (car list)))	          ; First element
+	   (expansion (car (cdr (car list))))     ; Second element
+	   (arguments (cdr (cdr (car list)))) )   ; Remaining elements
+      (while (string-match (concat " \\(-.*\\|\\)" string) command)
+	(let ( (prefix (substring command 0 (match-beginning 1)))
+	       (flag (substring command (match-beginning 1) (match-end 1)))
+	       (postfix (substring command (match-end 0))) )
+	  (setq command 
+		(concat prefix
+			(cond ((sgml-function-p expansion)
+			       (apply expansion flag arguments))
+			      ((boundp expansion)
+			       (concat flag (apply (eval expansion) arguments)))
+			      (t
+			       (error "Nonexpansion %s" expansion)))
+			postfix)))))
+    (setq list (cdr list)))
+  command))
+
+;;;; Hooks for `sgml-command-list'
+
+(defun sgml-run-background (name command file error-regexp)
+  "Start process with second argument, show output when and if it arrives."
+  (save-excursion
+    (set-buffer (get-buffer-create "*SGML background*"))
+    (erase-buffer)
+  (let ((process (start-process (concat name " background")
+				nil "/bin/sh" "-c" command)))
+    (process-kill-without-query process))))
+  
+(defun sgml-run-command (name command file error-regexp)
+  "Hook for `sgml-command-list'."
+  (let ( (buffer (sgml-process-buffer-name file)) 
+	 (fname (file-name-nondirectory file))
+	 (dir (file-name-directory file)) )
+    (sgml-process-check file)
+    (get-buffer-create buffer)
+    (set-buffer buffer)
+    (erase-buffer)
+    (insert "Running `" name "' on `" file "' with ``" command "''\n")
+    (compilation-minor-mode)
+    (setq compilation-error-regexp-alist error-regexp)
+    (setq compilation-error-message "No more errors")
+    (setq mode-name name)	
+    (if sgml-show-compilation 
+	(display-buffer buffer)
+      (message "Type `%s' to display results of compilation." 
+	       (substitute-command-keys "\\[sgml-recenter-output-buffer]")))
+    (let ((process (start-process name buffer "/bin/sh" "-c" command)))
+      (set-marker (process-mark process) (point-max))
+      (setq compilation-in-progress (cons process compilation-in-progress))
+      process)
+    )
+  )
+
+(defun sgml-recenter-output-buffer (line)
+  "Redisplay buffer of job output so that most recent output can be seen.
+The last line of the buffer is displayed on line LINE of the window, or
+at bottom if LINE is nil." 
+  (interactive "P")
+  (let ( (buffer (sgml-process-buffer (sgml-file))) )
+    (if buffer
+	(let ((old-buffer (current-buffer)))
+	  (pop-to-buffer buffer t)
+	  (bury-buffer buffer)
+	  (goto-char (point-max))
+	  (recenter (if line
+			(prefix-numeric-value line)
+		      (/ (window-height) 2)))
+	  (pop-to-buffer old-buffer))
+      (message "No process for this document."))))
+
+;;;; Command execution
+
+(defun sgml-command-execute (name file)
+  "Run the command NAME from `sgml-command-list' on FILE.
+
+This function relies on NAME being a valid element of `sgml-command-list'
+and on FILE being function returning a file name. For interactive calls, 
+use `sgml-command'."
+  (let* ( (entry (assoc name sgml-command-list))
+	  (command (sgml-command-expand (nth 1 entry) file))
+	  (hook (nth 2 entry))
+	  (confirm (nth 3 entry)) 
+	  (error-regexp (nth 4 entry)) )
+    (if confirm
+	(setq command
+	      (read-from-minibuffer (concat name " command: ") command
+				    nil nil 'sgml-confirm-command-history)))
+    (if sgml-offer-save
+	(save-some-buffers nil nil))
+    (apply hook name command (apply file nil) error-regexp nil)))
+
+(defun sgml-command (name)
+  "Execute command NAME from `sgml-command-list' from a menu or interactively."
+  (interactive (list 
+		(completing-read "Run command: " sgml-command-list nil t nil
+				 'sgml-read-command-history)))
+  (setq name (car-safe (sgml-assoc name sgml-command-list)))
+  (when name (sgml-command-execute name 'sgml-file))
+  )
+
+(defun sgml-kill-job ()
+  (interactive)
+  (let ( (process (sgml-process (sgml-file))) )
+    (if process
+	(kill-process process)
+      (error "No process to kill"))))
+
+;;;; Process handling 
+
+(defun sgml-process-buffer-name (name)
+  (concat "*" (abbreviate-file-name (expand-file-name name)) " output*"))
+
+(defun sgml-process-buffer (name)
+  (get-buffer (sgml-process-buffer-name name)))
+
+(defun sgml-process (name)
+  (get-buffer-process (sgml-process-buffer name)))
+
+(defun sgml-process-check (name)
+  "Check if a process for the document NAME already exists. If so, 
+give the user the choice of aborting the process or the current command."
+  (let ((process (sgml-process name)))
+    (cond ((null process))
+	  ((not (eq (process-status process) 'run)))
+	  ((yes-or-no-p (concat "Process `"
+				(process-name process)
+				"' for document `"
+				name
+				"' running, kill it? "))
+	   (delete-process process))
+	  (t
+	   (error "Cannot have two processes for the same document")))))
+
+;;;; The menu
+ 
+(defun sgml-command-menu-entry (entry)
+  "Return `sgml-command-list' entry ENTRY as a menu item."
+  (let ( (name (car entry)) )
+    (vector name (list 'sgml-command name) t)))
+
+(defun sgml-dsssl-file-options-menu (&optional event)
+  "If `sgml-dsssl-spec' is changed, update `sgml-dsssl-customize' and the 
+   customize menu."
+  (interactive "e")
+  (let ( (old-spec sgml-dsssl-spec) 
+	 (old-subspec sgml-dsssl-subspec)
+	 (old-lang sgml-dsssl-language) ) 
+    (sgml-options-menu event sgml-dsssl-file-options)
+    (unless (equal old-spec sgml-dsssl-spec)
+      (setq sgml-dsssl-subspec nil))
+    (unless (and (equal old-spec sgml-dsssl-spec)
+		 (equal old-subspec sgml-dsssl-subspec)
+		 (equal old-lang sgml-dsssl-language))
+      (sgml-dsssl-check-customize))))
+
+(easy-menu-define sgml-command-menu sgml-mode-map "DSSSL menu"
+ (append '("DSSSL")
+	 (let ( (file 'buffer-file-name) )
+	   (mapcar 'sgml-command-menu-entry sgml-command-list))
+	 '("--"
+	   ["Kill job" sgml-kill-job (sgml-process (sgml-file))]
+	   ["Recenter output buffer" sgml-recenter-output-buffer 
+	    (sgml-process-buffer (sgml-file))]
+           "--"
+	   ["File Options >" sgml-dsssl-file-options-menu 't]
+	   ["Create new style sheet" sgml-dsssl-new-spec 't]  
+	   ["Edit style sheet" sgml-dsssl-edit-spec sgml-dsssl-spec]
+	   ["Customize style sheet" t 'nil]
+	   ["Save customizations" sgml-dsssl-write-customize sgml-dsssl-customize])))
+
+
+;;;; Auxiliary functions
+
+; You might want to find David Love's new scheme.el which implements dsssl-mode. 
+(if (not (fboundp 'dsssl-mode)) (fset 'dsssl-mode 'scheme-mode))
+
+(defun sgml-function-p (arg)
+  "Return non-nil if ARG is callable as a function."
+  (or (and (fboundp 'byte-code-function-p)
+	   (byte-code-function-p arg))
+      (and (listp arg)
+	   (eq (car arg) 'lambda))
+      (and (symbolp arg)
+	   (fboundp arg))))
+
+(defun sgml-member (elt list how)
+  "Returns the member ELT in LIST.  Comparison done with HOW.
+
+Return nil if ELT is not a member of LIST."
+  (while (and list (not (funcall how elt (car list))))
+    (setq list (cdr list)))
+  (car-safe list))
+
+(defun sgml-assoc (elem list)
+  "Like assoc, except case incentive."
+  (let ((case-fold-search t))
+    (sgml-member elem list
+		(function (lambda (a b)
+		  (string-match (concat "^" (regexp-quote a) "$")
+				(car b)))))))
+
+(defun sgml-strip-extension (name)
+  "Return NAME with final `.*' stripped."
+  (string-match "^\\(.*\\)[.][^.]*$" name)
+  (substring name (match-beginning 1) (match-end 1))
+  )
+
+
+;;; Integration of psgml-dsssl.el with psgml-jade.el
+
+(defun sgml-dsssl-ask-for-spec ()
+  (let ( (dsssl (buffer-file-name)) )
+    (save-excursion 
+      (set-buffer sgml-current-sgml-buffer)
+      (when (and
+	     (not (equal sgml-dsssl-spec dsssl))
+	     (y-or-n-p "Select style sheet ")
+	     (setq sgml-dsssl-spec dsssl)
+	     (sgml-dsssl-check-customize))))))
+
+(defun sgml-dsssl-write ()
+  (if (equal (buffer-name) "**DSSSL**") 
+      (progn 
+       (setq buffer-file-name 
+	     (expand-file-name (read-file-name 
+	     "File to save in: " (file-name-directory buffer-file-name) 
+	     buffer-file-name nil (file-name-nondirectory buffer-file-name))))
+       (rename-buffer (file-name-nondirectory buffer-file-name))))
+  nil)
+
+(defun sgml-dsssl-edit-spec ()
+  (interactive)
+  (when (or (null sgml-dsssl-customize) 
+	    (y-or-n-p "Editing the style sheet will destroy 
+your customizations. Continue? "))
+    (display-buffer (find-file-noselect sgml-dsssl-spec))
+    (setq sgml-current-sgml-buffer (current-buffer))
+    (select-window (get-buffer-window (get-file-buffer sgml-dsssl-spec)))
+    (dsssl-mode)
+    (font-lock-mode)
+    (goto-char (point-min))
+    (setq buffer-offer-save t)
+    (add-hook 'after-save-hook 'sgml-dsssl-check-customize)))
+
+(defun sgml-dsssl-new-spec ()
+  (interactive)
+  (sgml-dsssl-make-spec)
+  (setq sgml-current-sgml-buffer (current-buffer))
+  (let* ( (name (sgml-file sgml-dsssl-file-extension))
+	  (buffer (get-buffer "**DSSSL**")) )
+    (select-window (get-buffer-window buffer))
+    (dsssl-mode)
+    (font-lock-mode)
+    (goto-char (point-min))
+    (setq buffer-offer-save t)
+    (setq buffer-file-name name)
+    (make-local-variable 'after-save-hook)
+    (add-hook 'after-save-hook 'sgml-dsssl-ask-for-spec)
+    (add-hook 'local-write-file-hooks 'sgml-dsssl-write)))
+
+;;; Customization of style sheets
+
+(defun sgml-dsssl-read-desc (elt) 
+  (let ( (sub-elt (sgml-element-content elt))
+	 (retval nil) )
+    (while sub-elt
+      (setq retval (cons (buffer-substring-no-properties 
+			  (sgml-element-stag-end sub-elt)
+			  (sgml-element-etag-start sub-elt)) retval))
+      (setq sub-elt (sgml-element-next sub-elt)))
+    (reverse retval))) 
+
+(defun sgml-dsssl-read-var-or-char (elt) 
+  (let* ( (sub-elt (sgml-element-content elt))
+	  (desc nil)
+	  (default-desc (list (sgml-element-attval elt "name")))
+	  (values nil) 
+	  (types nil) )
+    (while sub-elt
+      (let ( (elname (symbol-name (sgml-element-name sub-elt))) )
+	(cond
+	 ((equal "description" elname)
+	  (let ( (lang (sgml-element-attval sub-elt "language")) )
+	    (cond 
+	     ((equal lang sgml-dsssl-language)
+	      (setq desc (sgml-dsssl-read-desc sub-elt)))
+	     ((null lang)
+	      (setq default-desc (sgml-dsssl-read-desc sub-elt))))))
+	 ((equal "value" elname)
+	  (let ( (value-desc nil)
+		 (sub-sub-elt (sgml-element-content sub-elt)) )
+	    (while sub-sub-elt
+	      (let ( (sub-elname (symbol-name (sgml-element-name sub-sub-elt))) )
+		(cond 
+		 ((equal "type" sub-elname) 
+		  (setq newval (sgml-element-attval sub-sub-elt "class"))
+		  (when (null value-desc) 
+		    (setq value-desc (list newval "")))
+		  (setq types (cons (cons (nth 0 value-desc) (list newval)) types)) 
+		  (setq sub-sub-elt nil))
+		 ((equal "content" sub-elname) 
+		  (setq newval (buffer-substring-no-properties
+				(sgml-element-stag-end sub-sub-elt)
+				(sgml-element-etag-start sub-sub-elt)))
+		  (when (null value-desc)
+		    (setq value-desc (list newval "")))
+		  (setq values (cons (cons (nth 0 value-desc) newval) values)) 
+		  (setq sub-sub-elt nil))
+		 ((equal "description" sub-elname) 
+		  (let ( (lang (sgml-element-attval sub-sub-elt "language")) )
+		    (cond 
+		     ((equal lang sgml-dsssl-language)
+		      (setq value-desc (sgml-dsssl-read-desc sub-sub-elt)))
+		     ((and (null lang) (null value-desc))
+		      (setq value-desc (sgml-dsssl-read-desc sub-sub-elt)))))
+		  (setq sub-sub-elt (sgml-element-next sub-sub-elt)))
+		 ((setq sub-sub-elt (sgml-element-next sub-sub-elt)))))))))
+	(setq sub-elt (sgml-element-next sub-elt))))
+    (let* ( (is-variable (equal "variable" (symbol-name (sgml-element-name elt))))
+	    (name (sgml-element-attval elt "name"))
+	    (default (if is-variable 
+			 (sgml-element-attval elt "default")
+		       (sgml-element-attval elt "initial"))) )
+      (when (null desc) (setq desc default-desc))
+      (setq types (reverse types))
+      (setq values (reverse values))
+
+      ; build up the alists of per-variable information.
+      (setq new-cust (cons (cons name default) new-cust))
+      (setq new-cust-info 
+	    (cons (cons name 
+			(vector desc default types values
+				(if is-variable 'variable 'characteristic)))
+		  new-cust-info))
+
+      (vector (nth 0 desc)  
+	      `(sgml-dsssl-var-menu (quote ,name) 't)
+	      't))))
+
+(defun sgml-dsssl-read-section (elt &optional start)
+  (let* ( (sub-elt (sgml-element-content elt))
+	  (desc nil)
+	  (default-desc (list (cond (start) ("???"))))
+	  (retval (list nil)) ) 
+    (while sub-elt
+      (let ( (elname (symbol-name (sgml-element-name sub-elt))) ) 
+	(cond
+	 ((equal "description" elname)
+	  (let ( (lang (sgml-element-attval sub-elt "language")) )
+	    (cond
+	     ((equal lang sgml-dsssl-language)
+	      (setq desc (sgml-dsssl-read-desc sub-elt)))
+	     ((null lang)
+	      (setq default-desc (sgml-dsssl-read-desc sub-elt))))))
+	 ((equal "section" elname)
+	  (setq retval (append retval (list (sgml-dsssl-read-section sub-elt)))))
+	 ((equal "variable" elname) 
+	  (unless (assoc (sgml-element-attval sub-elt "name") new-cust)
+	    (setq retval 
+		  (append retval (list (sgml-dsssl-read-var-or-char sub-elt))))))
+	 ((equal "characteristic" elname)
+	  (when (equal "ignored" (sgml-element-attval sub-elt "ignored"))
+	    (setq ignored-chars 
+		  (cons (sgml-element-attval sub-elt "name") ignored-chars)))
+	  (unless (or (member (sgml-element-attval sub-elt "name") ignored-chars) 
+		      (assoc (sgml-element-attval sub-elt "name") new-cust)) 
+	    (setq retval 
+		  (append retval (list (sgml-dsssl-read-var-or-char sub-elt))))))
+	 (t (error "Confusion in `read-section'")))
+	(setq sub-elt (sgml-element-next sub-elt))))
+    (when (null desc) (setq desc default-desc))
+    (if (equal (length retval) 1) 
+	'() ;  empty section; do not add to menu 
+      (cons (nth 0 desc) (cdr retval)))))
+
+(defun sgml-dsssl-check-customize ()
+  (interactive)
+  (easy-menu-change 
+   nil "DSSSL" 
+   (append (let ( (file 'buffer-file-name) )
+	     (mapcar 'sgml-command-menu-entry sgml-command-list))
+	   (list "--"
+		 ["Kill job" sgml-kill-job (sgml-process (sgml-file))]
+		 ["Recenter output buffer" sgml-recenter-output-buffer 
+		  (sgml-process-buffer (sgml-file))]
+		 "--"
+		 ["File Options >" sgml-dsssl-file-options-menu 't]
+		 ["Create new style sheet" sgml-dsssl-new-spec 't]  
+		 ["Edit style sheet" sgml-dsssl-edit-spec sgml-dsssl-spec])
+	   (list (sgml-dsssl-analyze-spec)
+		 ["Save customizations" sgml-dsssl-write-customize 
+		  sgml-dsssl-customize])))) 
+
+(defun sgml-dsssl-check-auto-generated ()
+  (let* ( (true-spec nil) 
+	  (true-subspec nil) )
+    (save-excursion 
+      (set-buffer (find-file-noselect sgml-dsssl-spec))
+      
+      ; check for psgml-generated customization file
+      (goto-char (point-min))
+      (when (and
+	     (search-forward-regexp "<!--.*-->" (save-excursion 
+						  (goto-line 2) (point)) t) 
+	     (equal (buffer-substring-no-properties 
+		     (match-beginning 0) (match-end 0))
+		    sgml-dsssl-customize-identifier))
+          ; (message "Its my baby!")
+
+	  ; find the style sheet which is customized here
+	(search-forward-regexp "<!entity base system \"\\(.*\\)\" cdata dsssl>"
+			       nil t)
+	(setq true-spec (buffer-substring-no-properties 
+			 (match-beginning 1) (match-end 1)))
+	
+	  ; find a possible style-specification
+	(when (search-forward-regexp 
+	       "<external-specification id=x document=base specid=\\(.*\\)>" 
+	       nil t)
+	  (setq true-subspec (buffer-substring-no-properties 
+			      (match-beginning 1) (match-end 1))))
+	  
+	  ; find the customized values.
+	(goto-char (point-min))
+	  ; we match to the end of line, since the value might 
+	  ; be an arbitrary DSSSL expression containing parens 
+	(while (search-forward-regexp 
+		"^[ ]*(declare-initial-value \\([^ ]*\\) \\(.*\\))[ ]*$" nil t)
+	  (setq saved-variables
+		(cons (cons (buffer-substring-no-properties
+			     (match-beginning 1) (match-end 1))
+			    (buffer-substring-no-properties
+			     (match-beginning 2) (match-end 2))) 
+		      saved-variables)))
+	  ; find the customized values.
+	(goto-char (point-min))
+	  ; we match to the end of line, since the value might 
+	  ; be an arbitrary DSSSL expression containing parens 
+	(while (search-forward-regexp 
+		"^[ ]*(define \\([^ ]*\\) \\(.*\\))[ ]*$" nil t)
+	  (setq saved-variables
+		(cons (cons (buffer-substring-no-properties
+			     (match-beginning 1) (match-end 1))
+			    (buffer-substring-no-properties
+			     (match-beginning 2) (match-end 2))) 
+		      saved-variables))))) ; end of excursion
+    (when true-spec 
+      (setq sgml-dsssl-customize-spec sgml-dsssl-spec)
+      (setq sgml-dsssl-spec true-spec) 
+      (setq sgml-dsssl-subspec true-subspec))))
+
+; cut string into a list of strings at whitespace
+(defun explode-string (s)
+  (let ( (i 0) 
+	 (retval nil) )
+    (while (< i (length s)) 
+      (string-match "[ ]*\\([^ ]+\\)[ ]*" s i) 
+      (setq retval (cons (substring s (match-beginning 1) (match-end 1)) retval))
+      (setq i (match-end 0)))
+    (reverse retval)))
+  
+(defun sgml-dsssl-analyze-spec ()
+  "Return menu tree from spec, also setting `sgml-dsssl-customize'."
+  ; reset stuff depending on sgml-dsssl-spec.
+  (setq sgml-dsssl-customize nil)
+  (setq sgml-dsssl-customize-info nil)
+  (put 'sgml-dsssl-language 'sgml-type 'string-or-nil)
+  (put 'sgml-dsssl-subspec 'sgml-type 'string-or-nil)
+
+  ; analyze sgml-dsssl-spec, rebuilding all dependent stuff.
+  (if (null sgml-dsssl-spec)
+      ["Customize style sheet" 't 'nil]
+    (let ( (new-cust nil) 
+	   (new-cust-info nil)
+	   (ignored-chars nil)
+	   (lang-list (list nil))
+	   (id-list (list nil))
+	   (use-list nil)
+	   (menu-so-far (list "Customize style sheet")) 
+	   (local-catalogs sgml-local-catalogs) 
+	   (saved-variables nil) )
+      (sgml-dsssl-check-auto-generated) 
+      (setq use-list (list sgml-dsssl-subspec))
+
+      ; if we had a psgml-generated file, we now switch to the style sheet.
+      (save-excursion 
+	(set-buffer (find-file-noselect sgml-dsssl-spec))
+	
+	; treat an non-psgml-generated style sheet
+	(sgml-mode)
+	(setq sgml-local-catalogs local-catalogs)
+	(sgml-need-dtd)
+	(sgml-parse-to (point-max))
+        
+	; find all available style-specifications
+	(when (sgml-top-element)
+	  (let* ( (style-spec (sgml-element-content (sgml-top-element))) 
+		  (id nil) 
+		  (i 0) )
+	    (while style-spec
+            ; might need to check for partial attribute here 
+	    (when (equal "style-specification" 
+			 (symbol-name (sgml-element-name style-spec)))
+	      (setq i (+ 1 i))
+	      (setq id (sgml-element-attval style-spec "id"))
+	      (when id (setq id-list (append id-list (list id)))))
+	    (setq style-spec (sgml-element-next style-spec)))
+	    (message (format "%d style-specification(s) found." i)))
+
+	  ; analyze the customize
+	  (let* ( (style-spec (sgml-element-content (sgml-top-element)))  
+		  (count 0) )
+	    (while (and style-spec use-list (< count 1000)) 
+	      (when (or (null (car use-list)) ; special case for first spec 
+			(equal (sgml-element-attval style-spec "id") 
+			       (car use-list))) 
+
+	        ; update use-list
+		(setq use-list 
+		      (append use-list
+			      (explode-string 
+			       (sgml-element-attval style-spec "use"))))
+		(setq use-list (remove-duplicates (cdr use-list)))
+		
+		(let ( (cust (sgml-element-content style-spec)) )
+                  ; this silently drops external-specification's
+		  (when (and cust
+			     (equal "customize" 
+				    (symbol-name (sgml-element-name cust))))
+		  
+                    ; append languages
+		    (setq lang-list 
+			  (append lang-list 
+				  (explode-string 
+				   (sgml-element-attval cust "languages"))))
+
+                    ; append the customize info
+		    (setq menu-so-far 
+			  (append menu-so-far (list "---")
+				  (cdr (sgml-dsssl-read-section cust)))))))
+	      
+	      ; continue loop over style-spec
+	      (setq count (+ 1 count))
+	      (setq style-spec (sgml-element-next style-spec))
+	      (when (null style-spec) ; loop from the beginning
+		(setq style-spec (sgml-element-content (sgml-top-element))))))))
+                ; end of excursion
+
+      (when sgml-dsssl-added-characteristics
+	(save-excursion 
+	  (set-buffer (find-file-noselect sgml-dsssl-added-characteristics))
+	  
+	  (sgml-mode)
+	  (setq sgml-local-catalogs local-catalogs)
+	  (sgml-need-dtd)
+	  (sgml-parse-to (point-max))
+	  
+	  (when (sgml-top-element)
+	    (let* ( (cust (sgml-element-content 
+			   (sgml-element-content 
+			    (sgml-top-element)))) )
+	      (when (and cust
+			 (equal "customize" 
+				(symbol-name (sgml-element-name cust))))
+		  
+		; append the customize info
+		(setq menu-so-far 
+		      (append menu-so-far (list "---")
+			      (cdr (sgml-dsssl-read-section cust)))))))))
+
+      ; check if we found any customize info
+      (when (equal 1 (length menu-so-far)) 
+	  (setq menu-so-far [ "Customize style sheet" 't 'nil]))
+      
+      ; set the buffer-local variables to their new values
+      (put 'sgml-dsssl-language 'sgml-type 
+	   (or (remove-duplicates (cdr lang-list)) 'string-or-nil))
+      (put 'sgml-dsssl-subspec 'sgml-type 
+	   (or (remove-duplicates (cdr id-list)) 'string-or-nil))
+
+      ; if we had a psgml-generated file, we use the values from 
+      ; there instead of the default ones
+      ;(setq sgml-dsssl-customize (or saved-variables new-cust))
+      (while saved-variables
+	(setcdr (assoc (car (car saved-variables)) new-cust) 
+		(cdr (car saved-variables)))
+	(setq saved-variables (cdr saved-variables)))
+      (setq sgml-dsssl-customize new-cust)
+      (setq sgml-dsssl-customize-info new-cust-info)
+      menu-so-far)))
+
+(defun sgml-dsssl-var-menu (var event)
+ (let* ( (info (cdr (assoc var sgml-dsssl-customize-info)))
+	 (desc (aref info 0))
+	 (types (copy-alist (aref info 2)))
+	 (values (copy-alist (aref info 3))) ) 
+   ; treat boolean variables as having two explicit values
+   (let ( (bool (rassoc '("boolean") types)) )
+     (when bool 
+       (setq types (delete bool types))
+       (setq values (append (list (cons "#t" "#t") (cons "#f" "#f")) values))))
+  
+   (let* ( (pair (assoc var sgml-dsssl-customize))
+	   (current (cdr pair))
+	   (choice nil) )
+
+     ; treat variables with just one type without popup-menu
+     (if (and (null values) (equal 1 (length types)))
+	 (setq choice (cdr (nth 0 types)))
+
+       ; create a popup-menu 
+       (progn
+	 ; mark the current value
+	 (when current 
+	   (let ( (curval (rassoc current values)) )
+	     (if curval 
+		 (setcar curval (concat (car curval) " *")) 
+	       (setq values 
+		     (append values 
+			     (list (cons (concat current " *") current)))))))
+	 (setq choice (sgml-popup-menu event (nth 0 desc) (append values types)))))
+
+     ; now choice is the value we have to analyze
+     (cond
+      ((stringp choice) 
+       (sgml-dsssl-set-variable var choice))
+      ((and choice (listp choice))
+       (sgml-dsssl-set-variable var nil (car choice))))))) 
+
+(defun sgml-dsssl-set-variable (&optional var val type)
+  (interactive)
+  (unless var
+    (setq var (completing-read "Variable/Characteristic: " 
+			       sgml-dsssl-customize nil t)))
+  (let ( (pair (assoc var sgml-dsssl-customize)) )
+    (unless val
+      (let* ( (info (cdr (assoc var sgml-dsssl-customize-info)))
+	      (desc (aref info 0))
+	      (current (cdr pair))
+	      (types (aref info 2))
+	      (values (aref info 3)) 
+	      (l nil) )
+	(when (and (null type)
+		   (equal 1 (length types)))
+	  (setq type (nth 0 (cdr (nth 0 types)))))
+	(with-output-to-temp-buffer "*Help*"
+	  (cond
+	   (type (princ (concat "Please enter a new value of type " type 
+				"\n(or a DSSSL expression of that type) ")))
+         ; in this case we know that types is of length > 1.
+	   (types (princ "Please enter a new value of type ")
+		  (setq l types)
+		  (while l 
+		    (princ (nth 0 (cdr (car l))))
+		    (setq l (cdr l))
+		    (when l (princ " or ")))
+		  (princ "\n(or a DSSSL expression of one of that types) "))
+	   (t (princ "Please choose a new value among ")
+	      (setq l values)
+	      (while l 
+		(princ (cdr (nth 0 l)))
+		(setq l (cdr l))
+		(when l (princ ", ")))))
+	  (if (equal 'variable (aref info 4))  
+	      (princ (concat "\nfor the variable `" var "' (" (nth 0 desc) ").\n"))
+	    (princ (concat "\nfor the characteristic `" var "' (" 
+			   (nth 0 desc) ").\n")))
+	  (princ (concat "The current value of `" var "' is " 
+			 (or current "unspecified") ".\n\n"))
+	  (when (nth 1 desc) (princ (nth 1 desc))))
+	(setq val (completing-read "Value: " (unless type values) 
+				   nil (null types) current))))
+    (setcdr pair val)))
+
+;;; my ideas for additions to psgml-edit.el
+
+(defun sgml-entity-under-point ()
+  "Return the entity found whose name is under point or nil. If there is an 
+entity, leave point after ERO, else don't move point."
+  (sgml-with-parser-syntax  
+   (let ( (pnt (point))
+	  (entity) )
+     (when (or (sgml-parse-delim "ERO")
+	       (progn (search-backward-regexp "[&>;]")
+		      (sgml-parse-delim "ERO")))
+	   (setq pnt (point))
+	   (setq sgml-markup-start (- (point) (length "&")))
+	   (setq entity (sgml-lookup-entity 
+			 (sgml-parse-name t)
+			 (sgml-dtd-entities (sgml-pstate-dtd
+					     sgml-buffer-parse-state)))))
+     
+     (goto-char pnt)
+     entity
+     )
+   )
+  )
+
+(defun sgml-edit-external-entity ()
+  "Open	a new window and display the external entity at the point."
+  (interactive)
+  (sgml-need-dtd)
+  (save-excursion                     
+    (sgml-with-parser-syntax  
+     (setq sgml-markup-start (point))
+     (unless (sgml-parse-delim "ERO")
+       (search-backward-regexp "[&>;]")
+       (setq sgml-markup-start (point))
+       (sgml-check-delim "ERO"))
+     (sgml-parse-to-here)		; get an up-to-date parse tree
+     (let* ( (parent (buffer-file-name)) ; used to be (sgml-file)
+	     (ename (sgml-check-name t))
+	     (entity (sgml-lookup-entity ename       
+					 (sgml-dtd-entities
+					  (sgml-pstate-dtd
+					   sgml-buffer-parse-state))))
+	     (buffer nil)
+	     (ppos nil))
+       (unless entity
+	 (error "Undefined entity %s" ename))
+       (unless (and (eq (sgml-entity-type entity) 'text)               
+		    (not (stringp (sgml-entity-text entity))))
+	 (error "The entity %s is not an external text entity" ename))
+
+       ;; here I try to construct a useful value for
+       ;; `sgml-parent-element'.
+
+       ;; find sensible values for the HAS-SEEN-ELEMENT part
+       (let ((seen nil)
+	     (child (sgml-tree-content sgml-current-tree)))
+	 (while (and child
+		     (sgml-tree-etag-epos child)
+		     (<= (sgml-tree-end child) (point)))
+	   (push (sgml-element-gi child) seen)
+	   (setq child (sgml-tree-next child)))
+	 (push (nreverse seen) ppos))
+       
+       ;; find ancestors
+       (let ((rover sgml-current-tree))
+	 (while (not (eq rover sgml-top-tree))
+	   (push (sgml-element-gi rover) ppos)
+	   (setq rover (sgml-tree-parent rover))))
+
+       (find-file-other-window
+	(sgml-external-file (sgml-entity-text entity)
+			    (sgml-entity-type entity)
+			    (sgml-entity-name entity)))
+       (goto-char (point-min))
+       (sgml-mode)
+       (setq sgml-parent-document (cons parent ppos))
+       ;; update the live element indicator of the new window
+       (sgml-parse-to-here)))))
+
+(defun sgml-edit-external-entity-mouse (event)
+  (interactive "e")
+  (mouse-set-point event)
+  (sgml-edit-external-entity)
+)
+
+(defun sgml-expand-entity-reference-mouse (event)
+  (interactive "e")
+  (mouse-set-point event)
+  (sgml-expand-entity-reference)
+)
+
+(define-key sgml-mode-map [S-mouse-1] 'sgml-edit-external-entity-mouse)
+(define-key sgml-mode-map [S-double-mouse-1] 'sgml-expand-entity-reference-mouse)
+
+;;;; Autoload
+
+(autoload 'sgml-dsssl-make-spec "psgml-dsssl" nil t)
+(autoload 'sgml-options-menu "psgml-edit" nil t)
+(autoload 'sgml-with-parser-syntax "psgml-parse" nil t)
+
+;;;; Provide
+
+(provide 'psgml-jade)
+
+;;; psgml-jade.el ends here
+
--- openjade-1.4devel1.orig/contrib/rtf2doc.pl
+++ openjade-1.4devel1/contrib/rtf2doc.pl
@@ -0,0 +1,49 @@
+#! /usr/bin/perl -w 
+# Copyright (C) 1999 Avi Kivity
+
+sub usage
+{
+    print <<__USAGE__;
+Usage: rtf2doc.pl FILE...
+  Converts one or more MS .rtf FILEs to MS Word .doc files.
+  Requires MS Word 97 or above, plus correct phase of moon.
+__USAGE__
+}
+
+usage(), exit 0 
+    if ($#ARGV < 0) || ($ARGV[0] =~ /^((-h)|(--help))$/);
+
+use Cwd;
+use Win32::OLE;
+use Win32::OLE::Const 'Microsoft Word';
+
+$cwd = cwd();
+
+@storytypes = ( 4, 3, 8, 6, 11, 10, 2, 1, 9, 7, 5 );
+my $Word = Win32::OLE->new('Word.Application', 'Quit');
+die "Cannot open MS Word\n" unless $Word;
+
+foreach (@ARGV) {
+    my $src = $_;
+    $src = "$cwd\\$src"
+        unless $src =~ /^(.:\\)/;
+    my $tgt = "$src.doc";
+    my $Doc = $Word->Documents->Open($src);
+    die "Cannot open $src\n" unless $Doc;
+    $Doc->Repaginate();
+    $Stories = $Doc->StoryRanges;
+    for $s (@storytypes) {
+        eval {            
+            local $SIG{__WARN__} = {};    
+            $Story = $Stories->Item($s);
+            if ($Story) {
+                $Story->Fields->Update();
+                $Story->Fields->Unlink();
+            }
+        };
+    }
+    $Doc->SaveAs($tgt, 0);
+    $Doc->Close();
+}
+
+$Word->Quit();
--- openjade-1.4devel1.orig/contrib/transform.dsl
+++ openjade-1.4devel1/contrib/transform.dsl
@@ -0,0 +1,73 @@
+<!doctype style-sheet PUBLIC "-//James Clark//DTD DSSSL Style Sheet//EN">
+<!-- Copyright (C) 1999 Avi Kivity -->
+
+<!--
+   
+This stylesheet provides procedures for handling sgml transformations
+using OpenJade's sgml backend. All procedures assume that osnl refers
+to a node of class element.
+
+  (empty-element? osnl)
+  Returns #f if the element has a declared content model of EMPTY.
+
+  (element-attributes osnl)
+  Returns a list of the non-implied attributes of osnl, in the same
+  foramt accepted by the attributes: characteristic of the element
+  flow object.
+  
+  (copy-element osnl)
+  Returns a sosofo that is the identity transformation of osnl. Bug:
+  Defaulted attributes are made explicit. Fix with prlgabs1?
+
+-->
+
+
+<style-specification id=transform>
+
+(declare-flow-object-class element
+    "UNREGISTERED::James Clark//Flow Object Class::element")
+(declare-flow-object-class empty-element
+    "UNREGISTERED::James Clark//Flow Object Class::empty-element")
+(declare-flow-object-class document-type
+    "UNREGISTERED::James Clark//Flow Object Class::document-type")
+(declare-flow-object-class entity
+    "UNREGISTERED::James Clark//Flow Object Class::entity")
+(declare-flow-object-class entity-ref
+    "UNREGISTERED::James Clark//Flow Object Class::entity-ref")
+(declare-flow-object-class formatting-instruction
+    "UNREGISTERED::James Clark//Flow Object Class::formatting-instruction")
+(declare-characteristic preserve-sdata?
+    "UNREGISTERED::James Clark//Characteristic::preserve-sdata?" #f)
+
+(define (empty-element? #!optional (nd (current-node)))
+    (node-property 'must-omit-end-tag? nd)
+)
+
+(define (element-attributes #!optional (nd (current-node)))
+    (let loop ((atts (named-node-list-names (attributes nd))))
+        (if (null? atts)
+            '()
+            (let*
+                (
+                    (name (car atts))
+                    (value (attribute-string name nd))
+                )
+                (if value
+                    (cons (list name value) (loop (cdr atts)))
+                    (loop (cdr atts))
+                )
+            )
+        )
+    )
+)
+
+(define (copy-element #!optional (node (current-node)))
+    (if (empty-element? node)
+        (make empty-element  attributes: (element-attributes node))
+        (make element        attributes: (element-attributes node))
+    )
+)
+
+(mode identity-transform
+    (default (copy-element))        
+)
--- openjade-1.4devel1.orig/debian/README.Debian
+++ openjade-1.4devel1/debian/README.Debian
@@ -0,0 +1,23 @@
+openjade for Debian
+------------------------------
+
+This document covers the Debian version of OpenJade.
+
+For information on using these packages, see the included HTML
+documentation.  It also includes links to other sites, for more
+information about SGML or DSSSL.  Also see:
+
+  <URL:http://www.jclark.com/jade/>        Jade home page (OpenJade's parent)
+  <URL:http://www.oasis-open.org/cover/>   Robin Cover's SGML/XML/DSSSL pages
+  <URL:http://www.mulberrytech.com/dsssl/> Mulberry DSSSL docs and cookbook
+  <URL:http://trisome.com/auto_faq/jade-Dsssl/>
+                                           An auto-FAQ for Jade and DSSSL
+  <URL:http://www.w3.org/>                 W3O, a standards body
+                                           Discussion of the HTML backend
+
+
+See the task-sgml and task-sgml-dev packages for other useful Debian 
+SGML packages.
+
+.....Adam Di Carlo....adam@onShore.com.....<URL:http://www.onShore.com/>
+
--- openjade-1.4devel1.orig/debian/changelog
+++ openjade-1.4devel1/debian/changelog
@@ -0,0 +1,298 @@
+openjade (1.4devel1-21.3) unstable; urgency=low
+
+  * Non-maintainer upload.
+  * Pass -fno-lifetime-dse to GCC to work around invalid assumptions about
+    object lifetimes (closes: #823419). Thanks to Daniel Schepler for the bug
+    report.
+
+ -- Jakub Wilk <jwilk@debian.org>  Sat, 01 Oct 2016 17:01:25 +0200
+
+openjade (1.4devel1-21.2) unstable; urgency=medium
+
+  * Non-maintainer upload.
+  * Move to debhelper compat level 9. (Closes: #817606)
+    - Don't use brace expansion in debian/libostyle-dev.install.
+
+ -- Chris Lamb <lamby@debian.org>  Sun, 25 Sep 2016 14:09:33 +0200
+
+openjade (1.4devel1-21.1) unstable; urgency=medium
+
+  [ Wookey ]
+  * Add acinclude.m4 macro to find correct intlh header whether or
+    not gettext is present (Closes: #748626, #759100)
+  * Update rules file to use dh-autoreconf rather than manual commands
+    and update configure.in enough for autoreconf to work
+
+  [ Andreas Barth ]
+  * Non-maintainer upload.
+  * Update configure.in to set PACKAGE_TARNAME to mixed case.
+  * Create po/Makevars with copyright hint to individual pot files
+    and DOMAIN=jade.
+
+ -- Andreas Barth <aba@ayous.org>  Sun, 24 Aug 2014 12:47:55 +0000
+
+openjade (1.4devel1-21) unstable; urgency=low
+
+  * Added dependency on libperl4-corelibs-perl for getopts.pl. (Closes:
+    #724728).
+  * Added explicit dependency on libostyle1c2 to libostyle-dev to ensure
+    there are no broken symlinks when installed. (Closes: #715098).
+  * Added man page to update-alternatives. (Closes: #662887).
+
+ -- Neil Roeth <neil@debian.org>  Sat, 12 Oct 2013 21:09:50 -0400
+
+openjade (1.4devel1-20.1) unstable; urgency=low
+
+  * Non-maintainer upload.
+  * Fix "FTBFS: make[1]: *** No targets specified and no makefile found.
+    Stop.": fix target dependencies in debian/rules.
+    (Closes: #666346)
+
+ -- gregor herrmann <gregoa@debian.org>  Tue, 01 May 2012 17:27:19 +0200
+
+openjade (1.4devel1-20) unstable; urgency=low
+
+  * Resolved lintian warnings:
+  - about shlibs
+  - added debian/source/format
+  - added build-arch and build-indep target to debian/rules
+  * Updated to policy 3.9.2.0:
+  - Removed obsolete -D_REENTRANT option.
+  * Removed unnecessary lintian override.
+  
+ -- Neil Roeth <neil@debian.org>  Sat, 06 Aug 2011 10:43:48 -0400
+
+openjade (1.4devel1-19.1) unstable; urgency=low
+
+  * Non-maintainer upload.
+  * Build with -fpermissive to fix build failure with GCC 4.6
+    (Closes: #624872).
+  * Don't ship .la files.
+
+ -- Luk Claes <luk@debian.org>  Fri, 01 Jul 2011 19:39:11 +0200
+
+
+openjade (1.4devel1-19) unstable; urgency=low
+
+  * Ensure it builds with g++ 4.3
+
+ -- Neil Roeth <neil@debian.org>  Thu, 24 Jul 2008 07:46:05 -0400
+
+openjade (1.4devel1-18) unstable; urgency=low
+
+  * debian/rules: COPYING inadvertently was changed to GPL, which applies
+    to debian/ dir, not whole package.  Reverted back to COPYING from
+    upstream, which appears to be BSD-derived. Does away with cmp that
+    caused FTBFS in prior Debian version.
+
+ -- Neil Roeth <neil@debian.org>  Thu, 31 Aug 2006 21:33:06 -0400
+
+openjade (1.4devel1-17) unstable; urgency=low
+
+  * debian/rules: Fix FTBFS, thanks to Julien Danjou (closes: #383772)
+
+ -- Neil Roeth <neil@debian.org>  Sat, 19 Aug 2006 13:18:11 -0400
+
+openjade (1.4devel1-16) unstable; urgency=low
+
+  * Fixed "openjade: FTBFS: bashisms in debian/rules", thanks to Julien
+    Danjou (closes: #376481)
+
+ -- Neil Roeth <neil@debian.org>  Mon,  3 Jul 2006 22:20:33 -0400
+
+openjade (1.4devel1-15) unstable; urgency=low
+
+  * Compiled against new libosp5.
+
+ -- Neil Roeth <neil@debian.org>  Sun,  8 Jan 2006 07:59:04 -0500
+
+openjade (1.4devel1-14) unstable; urgency=low
+
+  * Added dh-buildinfo.
+  * Updated FSF location in COPYING. (closes: #314414)
+  * Update for g++ 4.0 transition - depend on libosp4c2. (closes: #321543)
+  * debian/rules: Backed optimization down from -O3 to -O2 to avoid ICE in
+    g++ while compiling GroveBuilder.
+  * Change "it's" to "its" in Description. (closes: #268534, #277258)
+
+ -- Neil Roeth <neil@debian.org>  Mon,  8 Aug 2005 21:57:08 -0400
+
+openjade (1.4devel1-13) unstable; urgency=low
+
+  * Compiled against new libosp4.
+  * Moved debhelper compatibility level from debian/rules to debian/compat.
+  * Revamped debian/rules - used debhelper to simplify it greatly.
+  * Moved include files from openjade package to libostyle-dev package.
+    Added Conflicts: openjade (<< 1.4devel1-13) to libostyle-dev.
+  * Updated to Standards-Version: 3.6.1 (no changes).
+  * Depend on debhelper >= 4.1.75 to pick up bug fixes for dh_installcatalogs.
+
+ -- Neil Roeth <neil@debian.org>  Thu, 23 Oct 2003 22:50:37 -0400
+
+openjade (1.4devel1-12) unstable; urgency=low
+
+  * Cleaned up debian/rules:
+  - Set DH_COMPAT=4, debhelper version to (>=4).
+  - Used libtool 1.5 for autotools generated files, so C++ gets used for
+    linking, ensuring that libs get linked with libstdc++, and removed
+    gruesome sed hacks that were necessary to do this with libtool 1.4.
+  - Fixed copyright file: was a copy of GPL plus some text that referenced
+    /usr/share/common-licenses/GPL, now it is the actual copyright notice,
+    the reference, and the Debian copyright info.
+  - Let debhelper tools do shlibs and substvars generation instead of
+    explicitly doing it in rules.
+  - Added openjade-1.4devel1 man page (closes: #191738)
+  * Updated to Standards-Version: 3.6.0.
+  * Removed libtool from Build-Depends.
+
+ -- Neil Roeth <neil@debian.org>  Thu,  7 Aug 2003 08:23:59 -0400
+
+openjade (1.4devel1-11) unstable; urgency=low
+
+  * Recognize 'noopt' instead of 'debug' in DEB_BUILD_OPTIONS.
+  * Changed section of libostyle-dev to libdevel.
+  * Remove use of autotools from regular package build.
+  * Added unicode/Makefile.am to replace Debian specific rules.
+  * Added contrib/Makefile.am in order to get transform.dsl into openjade
+    package.  I find it useful, I suppose others might, too.
+  * Added *.gmo to files removed in clean target of makefile in subdir po.
+    They get built if not there, and were causing a binary file difference
+    error when building the package.
+  * Fixed improperly defined 'attribute' function in builtins.dsl; changed
+    parameter name from 'string' to 'name'. (closes: #145242)
+  * Incorporated patch to fix quoting of '&' in XML backend.  Will push
+    upstream. (closes: #147073)
+  * Thanks to Toby Speight for the patches that closed the two bugs.
+
+ -- Neil Roeth <neil@debian.org>  Sun, 27 Jul 2003 21:51:16 -0400
+
+openjade (1.4devel1-10) unstable; urgency=low
+
+  * Make new maintainer effective by actually changing Maintainer field in
+    control file. (closes: #171072)
+
+ -- Neil Roeth <neil@debian.org>  Sun, 25 May 2003 12:20:13 -0400
+
+openjade (1.4devel1-9) unstable; urgency=low
+
+  * New maintainer (closes: #171072)
+  * Add/remove central catalog to/from super catalog. (closes: #191060)
+  * Removed unnecessary token pasting operator in Node.cxx so that it
+    compiles with g++ 3.3. (closes: #193219)
+  * Removed install-docs calls from postinst and prerm; they are already
+    handled by dh_installdocs.
+
+ -- Neil Roeth <neil@debian.org>  Sun, 25 May 2003 10:02:51 -0400
+
+openjade (1.4devel1-8.3) unstable; urgency=low
+
+  * NMU
+  * Fix libostyle1.shlibs.  Closes: #187543.
+  * Fix libostyle-dev dependencies.
+
+ -- Daniel Schepler <schepler@debian.org>  Fri,  4 Apr 2003 16:32:11 -0800
+
+openjade (1.4devel1-8.2) unstable; urgency=low
+
+  * NMU
+  * Remove manpage slave from openjade alternative, since it was now
+    creating a dangling symlink.
+
+ -- Daniel Schepler <schepler@debian.org>  Wed, 19 Mar 2003 04:31:57 -0800
+
+openjade (1.4devel1-8.1) unstable; urgency=low
+
+  * NMU
+  * Use updated msggen.pl from upstream CVS to allow compilation with
+    newer opensp versions.  Closes: #159140.
+    (Upstream also changed the soname version with this patch, so I'm
+    doing the same.)
+  * Remove obsolete po/Makefile code from configure.in.
+  * g++-3.2 transition.  Closes: #179709.
+
+ -- Daniel Schepler <schepler@debian.org>  Sun, 16 Mar 2003 18:34:24 -0800
+
+openjade (1.4devel1-8) unstable; urgency=low
+
+  * Added build-flag for hppa.  Thanks to Lamont Jones.  (closes: Bug#126852)
+  * Added patch (closes: Bug#108414) to fix some aspect of table creation.
+
+ -- Chad Miller <cmiller@debian.org>  Thu, 21 Feb 2002 16:19:45 +0000
+
+openjade (1.4devel1-7) unstable; urgency=low
+
+  * Made openjade binary use alternatives system.
+  * Corrected registration of unicode catalog.  Clobber any other version
+    at preinst.
+
+ -- Chad Miller <cmiller@debian.org>  Mon, 17 Dec 2001 02:53:27 +0000
+
+openjade (1.4devel1-6) unstable; urgency=low
+
+  * Maintainer change.  (closes: Bug#110802)
+  * Register and deregister catalog using update-catalog.  (closes: Bug#108360)
+  * Changed to debhelper v3.
+  * Fixed control file var-subst on nonexistent package version.
+  * Named openjade's postinst and prerm to names that get included in the package.
+    (the real source of Bug#108360)
+
+ -- Chad Miller <cmiller@debian.org>  Sun, 16 Dec 2001 16:41:00 +0000
+
+openjade (1.4devel1-5) unstable; urgency=low
+
+  * debian/control: fix override disparities in libostyle0 and
+    libostyle-dev
+  * debian/control: build-depends on gettext
+    closes: #105181
+  * problem fixed a while ago where we weren't shipping the HTML
+    documentation
+    closes: #71093
+  * Japanese translation added upstream
+  * debian/rules: make maintainer-clean upstream is incredibly fragile,
+    so tolerate errors there until that gets fixed
+  * debian/rules: during build, run libtoolize --force to replace this
+    libtoolize stuff, which is needed for arches which diverge from the
+    libtool stuff OpenSP ships with
+  * debian/rules, control: use dh_shlibdeps, remove some hand-rolled stuff
+    here which was unnecessary and in fact adding two libosp deps on the
+    opensp package, not to mention that it stopped working
+
+ -- Adam Di Carlo <aph@debian.org>  Fri, 20 Jul 2001 11:08:45 -0400
+
+openjade (1.4devel1-4) unstable; urgency=low
+
+  * upstream changes from CVS, see NEWS
+  * debian/rules: compile with -O3 instead of -O2 to try to get this thing
+    faster; CXXFLAGS propogates to the library stuff properly now; remove
+    an extra licensing file (thanks, lintian); some improvements in clean
+    and cvs-build (snapshot building); run aclocal and autoheader, I think
+    this is proper -- it certainly inhibits some warnings
+  * debian/control: update standards to 3.5.0 (no changes required)
+
+ -- Adam Di Carlo <aph@debian.org>  Fri,  2 Feb 2001 21:44:24 -0500
+
+openjade (1.4devel1-3) unstable; urgency=low
+
+  * upstream changes from CVS, see NEWS
+  * debian/rules: cope with DEB_BUILD_OPTIONS; stop building with -g by
+    default; fix setting of pkgdocdir when doing 'make install'
+  * debian/control: Policy compliant with 3.2.1
+
+ -- Adam Di Carlo <aph@debian.org>  Sat, 27 Jan 2001 15:03:29 -0500
+
+openjade (1.4devel1-2) unstable; urgency=low
+
+  * some upstream changes from cvs since the last release
+  * debian/rules: stop renaming unicode.sd to unicode.decl, based on a
+    related problem in jade; build with -g
+
+ -- Adam Di Carlo <aph@debian.org>  Wed, 18 Oct 2000 00:13:25 -0400
+
+openjade (1.4devel1-1) unstable; urgency=low
+
+  * new package; upstream fork from James Clark's Jade package
+    (closes: Bug#41697)
+
+ -- Adam Di Carlo <aph@debian.org>  Sat, 20 May 2000 12:55:44 -0400
+
+
--- openjade-1.4devel1.orig/debian/compat
+++ openjade-1.4devel1/debian/compat
@@ -0,0 +1 @@
+9
--- openjade-1.4devel1.orig/debian/control
+++ openjade-1.4devel1/debian/control
@@ -0,0 +1,49 @@
+Source: openjade
+Section: text
+Priority: optional
+Maintainer: Neil Roeth <neil@debian.org>
+Homepage: http://openjade.sourceforge.net/
+Standards-Version: 3.9.2.0
+Build-Depends: libosp-dev (>= 1.5.1.0-2.1), debhelper (>= 9), dh-autoreconf, gettext, dh-buildinfo, libperl4-corelibs-perl
+
+Package: openjade
+Architecture: any
+Depends: ${shlibs:Depends}, ${misc:Depends}
+Conflicts: libostyle-dev (<< 1.4devel1-14)
+Suggests: doc-base, sgml-data
+Description: Implementation of the DSSSL language
+ OpenJade is an implementation of the ISO/IEC 10179:1996 standard
+ DSSSL language.  It is based on James Clark's Jade software.
+ .
+ The OpenJade processor, in conjunction with a DSSSL style sheet, is
+ capable of translating SGML documents into other formats.  Output
+ formats currently supported are RTF, HTML, MIF, JadeTeX, or an XML
+ representation of the flow object tree.  Using its own non-standard
+ system, it is also capable of transforming one SGML or XML DTD to
+ another.
+ .
+ Author:   The OpenJade Team <jade-devel@infomansol.com>
+
+Package: libostyle1c2
+Architecture: any
+Section: libs
+Depends: ${shlibs:Depends}, ${misc:Depends}
+Replaces: libostyle1
+Conflicts: libostyle1
+Description: Runtime libraries for OpenJade
+ OpenJade's shared libraries, runtime support.  Includes libogrove,
+ providing an abstract interface to groves; libospgrove, an interface
+ to groves on top of the OpenSP suite; and libostyle, the actual DSSSL
+ style engine.
+ .
+ This shared library is used by the openjade package.
+
+Package: libostyle-dev
+Architecture: any
+Section: libdevel
+Depends: libostyle1c2(= ${binary:Version}), ${misc:Depends}
+Conflicts: openjade (<< 1.4devel1-14)
+Description: OpenJade libraries, developer support
+ Contains include files and the static library for libogrove,
+ libospgrove, and libostyle.  This is useful for those developing on
+ top of the OpenJade grove or DSSSL engine.
--- openjade-1.4devel1.orig/debian/copyright.Debian
+++ openjade-1.4devel1/debian/copyright.Debian
@@ -0,0 +1,22 @@
+
+-----
+
+The distribution license for OpenJade is the GNU General Public License (GPL)
+version 2.  You can find a copy of the GPL version 2 in
+/usr/share/common-licenses/GPL-2.
+
+-----
+
+This package has borrowed heavily from the 'jade' package.  It was originally
+made into a Debian package by Adam Di Carlo <aph@debian.org> and is now
+maintained by Neil Roeth <neil@debian.org>.
+
+The original source was downloaded from
+<URL:ftp://openjade.sourceforge.net/pub/openjade/> and/or the CVS area at
+cvs.openjade.sourceforge.net:/cvsroot/openjade .
+
+All materials under the 'debian' subdirectory are licensed under the GNU
+General Public License (GPL) version 2 or later.  You can find a copy of the
+GPL in /usr/share/common-licenses/GPL on Debian systems.  Any changes made
+*not* under the 'debian' subdirectory are under the same license as the
+software itself.
--- openjade-1.4devel1.orig/debian/libostyle-dev.dirs
+++ openjade-1.4devel1/debian/libostyle-dev.dirs
@@ -0,0 +1,3 @@
+usr/lib
+usr/include/OpenJade
+usr/share/doc/libostyle-dev
--- openjade-1.4devel1.orig/debian/libostyle-dev.install
+++ openjade-1.4devel1/debian/libostyle-dev.install
@@ -0,0 +1,3 @@
+debian/tmp/usr/include/OpenJade usr/include
+debian/tmp/usr/lib/lib*.a usr/lib
+debian/tmp/usr/lib/lib*.so usr/lib
--- openjade-1.4devel1.orig/debian/libostyle1c2.dirs
+++ openjade-1.4devel1/debian/libostyle1c2.dirs
@@ -0,0 +1,2 @@
+usr/lib
+usr/share/doc/libostyle1c2
--- openjade-1.4devel1.orig/debian/libostyle1c2.install
+++ openjade-1.4devel1/debian/libostyle1c2.install
@@ -0,0 +1,2 @@
+debian/tmp/usr/lib/lib*.so.[0-9].[0-9].[0-0] usr/lib
+debian/tmp/usr/lib/lib*.so.[0-9] usr/lib
--- openjade-1.4devel1.orig/debian/libostyle1c2.postinst
+++ openjade-1.4devel1/debian/libostyle1c2.postinst
@@ -0,0 +1,11 @@
+#!/bin/sh
+
+set -e
+
+if [ "$1" = "configure" ]; then
+	ldconfig
+fi
+
+#DEBHELPER#
+
+exit 0
--- openjade-1.4devel1.orig/debian/license.Debian
+++ openjade-1.4devel1/debian/license.Debian
@@ -0,0 +1,7 @@
+
+-----
+
+The distribution license for OpenJade is the GNU General Public License (GPL)
+version 2.  You can find a copy of the GPL version 2 in
+/usr/share/common-licenses/GPL-2.
+
--- openjade-1.4devel1.orig/debian/openjade.1
+++ openjade-1.4devel1/debian/openjade.1
@@ -0,0 +1,399 @@
+.\"Generated by db2man.xsl. Don't modify this, modify the source.
+.de Sh \" Subsection
+.br
+.if t .Sp
+.ne 5
+.PP
+\fB\\$1\fR
+.PP
+..
+.de Sp \" Vertical space (when we can't use .PP)
+.if t .sp .5v
+.if n .sp
+..
+.de Ip \" List item
+.br
+.ie \\n(.$>=3 .ne \\$3
+.el .ne 3
+.IP "\\$1" \\$2
+..
+.TH "OPENJADE" 1 "January 2002" "OpenJade" ""
+.SH NAME
+openjade \- apply a DSSSL stylesheet to an SGML or XML document
+.SH "SYNOPSIS"
+.ad l
+.hy 0
+.HP 9
+\fBopenjade\fR [\fB\-vCegG2s\fR] [\fB\-b\ \fIencoding\fR\fR] [\fB\-f\ \fIerror_file\fR\fR] [\fB\-c\ \fIcatalog_sysid\fR\fR] [\fB\-D\ \fIdir\fR\fR] [\fB\-a\ \fIlink_type\fR\fR] [\fB\-A\ \fIarch\fR\fR] [\fB\-E\ \fImax_errors\fR\fR] [\fB\-i\ \fIentity\fR\fR] [\fB\-w\ \fIwarning_type\fR\fR] [\fB\-d\ \fIdsssl_spec\fR\fR] [\fB\-V\ \fIvariable[=\fIvalue\fR]\fR\fR] [\fB\-t\ \fIoutput_type\fR\fR] [\fB\-o\ \fIoutput_file\fR\fR] [\fB\fIsysid\fR\fR...]
+.ad
+.hy
+
+.SH "DESCRIPTION"
+
+.PP
+ \fBopenjade\fR is an implementation of the ISO/IEC 10179:1996 standard DSSSL language. The DSSSL engine receives as input an SGML or XML document and transforms it into formats like:
+
+.PP
+* XML representation of the flow object tree.
+
+.PP
+* RTF format that can be rendered and printed with Microsoft's free Word Viewer 97
+
+.PP
+* TeX format
+
+.PP
+* MIF format that can be rendered and printed with Framemaker
+
+.PP
+* SGML or XML format. This is used in conjunction with non\-standard flow object classes to generate SGML, thus allowing \fBopenjade\fR to be used for SGML/XML transformations.
+
+.PP
+The system identifier of the document to be processed is specified as an argument to \fBopenjade\fR. If this is omitted, standard input will be read.
+
+.PP
+\fBopenjade\fR determines the system identifier for the DSSSL specification as follows:
+
+.PP
+1. If the \-d option is specified, it will use the argument as the system identifier.
+
+.PP
+2. Otherwise, it will look for processing instructions in the prolog of the document. Two kinds of processing instruction are recognized:
+
+.PP
+<?stylesheet href="sysid" type="text/dsssl">
+
+.PP
+The system data of the processing instruction is parsed like an SGML start\-tag. It will be parsed using the reference concrete syntax whatever the actual concrete syntax of the document. The name that starts the processing instruction can be either stylesheet, xml\-stylesheet or xml:stylesheet. The processing instruction will be ignored unless the value of the type attribute is one of text/dsssl, text/x\-dsssl, application/dsssl, or application/x\-dsssl. The value of href attribute is the system identifier of the DSSSL specification.
+
+.PP
+<?dsssl sysid>
+
+.PP
+The system identifier is the portion of the system data of the processing instruction following the initial name and any whitespace.
+
+.PP
+Although the processing instruction is only recognized in the prolog, it need not occur in the document entity. For example, it could occur in a DTD. The system identifier will be interpreted relative to where the the processing instruction occurs.
+
+.PP
+3. Otherwise, it will use the system identifier of the document with any extension changed to .dsl.
+
+.PP
+A DSSSL specification document can contain more than one style\-specification. If the system identifier of the DSSSL specification is followed by #id, then \fBopenjade\fR will use the style\-specification whose unique identifier is id. This is allowed both with the \fB\-d\fR option and with the processing instructions.
+
+.PP
+The DSSSL specification must be an SGML document conforming to the DSSSL architecture. For an example, see \fIdsssl/demo.dsl\fR.
+
+.PP
+\fBopenjade\fR supports the following options in addition to the normal OpenSP (see \fBonsgmls(1)\fR) options (note that all options are case\-sensitive, ie \fB\-g\fR and \fB\-G\fR are different options):
+
+.TP
+\fB\-d \fIdsssl_spec\fR\fR
+This specifies that dsssl_spec is the system identifier of the DSSSL specification to be used.
+
+.TP
+\fB\-G\fR
+Debug mode. When an error occurs in the evaluation of an expression, \fBopenjade\fR will display a stack trace. Note that this disables tail\-call optimization.
+
+.TP
+\fB\-c \fIfilename\fR\fR
+The filename arguments specify catalog files rather than the document entity. The document entity is specified by the first DOCUMENT entry in the catalog files.
+
+.TP
+\fB\-s\fR
+Strict compliance mode. Currently the only effect is that jade doesn't use any predefined character names, sdata\-entity mappings or name\-characters. This is useful for checking that your stylesheet is portable to other DSSSL implementations and that it is strictly compliant to the DSSSL specifications.
+
+.TP
+\fB\-t \fIoutput_type\fR\fR
+\fIoutput_type\fR specifies the type of output as follows:
+
+\fBfot \fR An XML representation of the flow object tree
+
+\fBrtf\fR \fBrtf\-95 \fR RTF (used for SGML/XML to RTF transformations) Microsoft's Rich Text Format. rtf\-95 produces output optimized for Word 95 rather than Word 97.
+
+\fBtex\fR TeX (used for SGML/XML to TeX transformations)
+
+\fBsgml\fR \fBsgml\-raw\fR SGML (used for SGML/XML to SGML transformations). sgml\-raw doesn't emit linebreaks in tags.
+
+\fBxml\fR \fBxml\-raw\fR XML (used for SGML/XML to XML transformations). xml\-raw doesn't emit linebreaks in tags.
+
+\fBhtml \fR HTML (used for SGML/XML to HTML transformations)
+
+\fBmif\fR MIF (used for SGML/XML to MIF transformations)
+
+.TP
+\fB\-o \fIoutput_file\fR\fR
+Write output to \fIoutput_file\fR instead of the default. The default filename is the name of the last input file with its extension replaced by the name of the type of output. If there is no input filename, then the extension is added onto jade\-out.
+
+.TP
+\fB\-V \fIvariable\fR\fR
+This is equivalent to doing (define variable #t) except that this definition will take priority over any definition of variable in a style\-sheet.
+
+.TP
+\fB\-V \fIvariable=value\fR\fR
+This is equivalent to doing (define \fIvariable\fR "\fIvalue\fR") except that this definition will take priority over any definition of variable in a style\-sheet.
+
+.TP
+\fB\-V (define \fIvariable\fR \fIvalue\fR)\fR
+This is equivalent to doing (define variable value) except that this definition will take priority over any definition of variable in a style\-sheet. Note that you will probably have to use some escaping mechanism for the spaces to get the entire scheme expression parsed as one cmdline argument.
+
+.TP
+\fB\-w\fItype\fR\fR
+Control warnings and errors. Multiple \fB\-w\fR options are allowed. The following values of type enable warnings:
+
+\fBxml\fR Warn about constructs that are not allowed by XML.
+
+\fBmixed\fR Warn about mixed content models that do not allow #pcdata anywhere.
+
+\fBsgmldecl\fR Warn about various dubious constructions in the SGML declaration.
+
+\fBshould\fR Warn about various recommendations made in ISO 8879 that the document does not comply with. (Recommendations are expressed with ``should'', as distinct from requirements which are usually expressed with ``shall''.)
+
+\fBdefault\fR Warn about defaulted references.
+
+\fBduplicate\fR Warn about duplicate entity declarations.
+
+\fBundefined\fR Warn about undefined elements: elements used in the DTD but not defined.
+
+\fBunclosed\fR Warn about unclosed start and end\-tags.
+
+\fBempty\fR Warn about empty start and end\-tags.
+
+\fBnet\fR Warn about net\-enabling start\-tags and null end\-tags.
+
+\fBmin\-tag\fR Warn about minimized start and end\-tags. Equivalent to combination of unclosed, empty and net warnings.
+
+\fBunused\-map\fR Warn about unused short reference maps: maps that are declared with a short reference mapping declaration but never used in a short reference use declaration in the DTD.
+
+\fBunused\-param\fR Warn about parameter entities that are defined but not used in a DTD. Unused internal parameter entities whose text is INCLUDE or IGNORE won't get the warning.
+
+\fBnotation\-sysid\fR Warn about notations for which no system identifier could be generated.
+
+\fBall\fR Warn about conditions that should usually be avoided (in the opinion of the author). Equivalent to: mixed, should, default, undefined, sgmldecl, unused\-map, unused\-param, empty and unclosed.
+
+A warning can be disabled by using its name prefixed with no\-. Thus \fB\-wall\fR \fB\-wno\-duplicate\fR will enable all warnings except those about duplicate entity declarations.
+
+The following values for \fIwarning_type\fR disable errors:
+
+\fBno\-idref\fR Do not give an error for an ID reference value which no element has as its ID. The effect will be as if each attribute declared as an ID reference value had been declared as a name.
+
+\fBno\-significant\fR Do not give an error when a character that is not a significant character in the reference concrete syntax occurs in a literal in the SGML declaration. This may be useful in conjunction with certain buggy test suites.
+
+\fBno\-valid\fR Do not require the document to be type\-valid. This has the effect of changing the SGML declaration to specify VALIDITY NOASSERT and IMPLYDEF ATTLIST YES ELEMENT YES. An option of \fB\-wvalid\fR has the effect of changing the SGML declaration to specify VALIDITY TYPE and IMPLYDEF ATTLIST NO ELEMENT NO. If neither \fB\-wvalid\fR nor \fB\-wno\-valid\fR are specified, then the VALIDITY and IMPLYDEF specified in the SGML declaration will be used.
+
+.SH "ENVIRONMENT"
+
+.PP
+OpenJade ignores the SP_CHARSET_FIXED and SP_SYSTEM_CHARSET environment variables and always uses Unicode as its internal character set, as if SP_CHARSET_FIXED was 1 and SP_SYSTEM_CHARSET was unset. Thus only the SP_ENCODING environment variable is relevant to OpenJade's handling of character sets.
+
+.SH "OPENJADE EXTENSIONS"
+
+.PP
+The following external procedures are available. These external procedures are defined by a prototype in the same manner as in the standard. To use one of these external procedures, you must make use of the standard external\-procedure procedure, using a public identifier of "UNREGISTERED::James Clark//Procedure::name" where name is the name given here, typically by including the following in the DSSSL specification:
+
+.PP
+(define name (external\-procedure "UNREGISTERED::James Clark//Procedure::name"))
+
+.PP
+Note that external\-procedure returns #f if it doesn't know about the specified public identifier. You can use this to enable your DSSSL specifications to work gracefully with other implementations which do not support these extensions.
+
+.PP
+For external procedures added by the OpenJade team, use a public identifier of the form "UNREGISTERED::OpenJade//Procedure::name".
+
+.PP
+An easy way to get access to all external procedures is to use the style specification dsssl/extensions.dsl#procedures. The file dsssl/extensions.dsl also contains style specifications which make the nonstandard flow object classes and inherited characteristics supported by the backends available in a convenient way.
+
+.PP
+\fBDebugging\fR
+
+.PP
+(debug obj)
+
+.PP
+Generates a message including the value of obj and then returns obj.
+
+.PP
+\fBSimple\-page\-sequence header/footer control\fR
+
+.PP
+(if\-first\-page sosofo1 sosofo2)
+
+.PP
+This can be used only in the specification of the value of one of the header/footer characteristics of simple\-page\-sequence. It returns a sosofo that will display as sosofo1 if the page is the first page of the simple\-page\-sequence and as sosofo2 otherwise.
+
+.PP
+(if\-front\-page sosofo1 sosofo2)
+
+.PP
+This can be used only in the specification of the value of one of the header/footer characteristics of simple\-page\-sequence. It returns a sosofo that will display as sosofo1 if the page is a front (ie recto, odd\-numbered) page and as sosofo2 if it is a back (ie verso, even\-numbered) page.
+
+.PP
+\fBNumbering\fR
+
+.PP
+(all\-element\-number)
+
+.PP
+(all\-element\-number osnl)
+
+.PP
+This is the same as element\-number except it counts elements with any generic identifier. If osnl is not an element returns #f, otherwise returns 1 plus the number of elements that started before osnl. This provides an efficient way of creating a unique identifier for any element in a document.
+
+.PP
+\fBExternal entity access\fR
+
+.PP
+(read\-entity string)
+
+.PP
+This returns a string containing the contents of the external entity with system identifier string. This should be used only for textual entities (CDATA and SDATA), and not for binary entities (NDATA).
+
+.PP
+\fBPOSIX locale access\fR
+
+.PP
+(language lang country)
+
+.PP
+This procedure returns an object of type language, if the system supports the specified language. lang is a string or symbol giving the two letter language code. country is a string or symbol giving the two letter country code.
+
+.PP
+This procedure uses POSIX locales. It is an OpenJade addition. It is not supported on all operating systems.
+
+.PP
+\fBExtended standard procedures\fR
+
+.PP
+(sgml\-parse sysid #!key active: parent: architecture:)
+
+.PP
+This allows you to specify an SGML architecture with respect to which the document should be parsed. It is an OpenJade addition.
+
+.PP
+(expt q k)
+
+.PP
+This allows you to raise a quantity to an integral power. It is an OpenJade addition.
+
+.SH "LIMITATIONS"
+
+.PP
+This section describes the limitations of the front\-end (the general\-purpose DSSSL engine); each backend also has its own limitations.
+
+.PP
+\fBopenjade\fR doesn't allow internal definitions at the beginning of bodies and the (test => recipient) variant of cond clauses.
+
+.PP
+\fBopenjade\fR supports only a single, fixed grove plan which comprises the following modules:
+
+.PP
+* baseabs
+
+.PP
+* prlgabs0
+
+.PP
+* prlgabs1
+
+.PP
+* instabs
+
+.PP
+* basesds0
+
+.PP
+* instsds0
+
+.PP
+* subdcabs
+
+.PP
+It doesn't implement the following parts of SDQL: HyTime support, auxiliary parsing, node regular expressions.
+
+.PP
+Query rules, sosofo synchronization, indirect sosofos, reference values, decoration areas and font properties are not supported.
+
+.PP
+Note that only inherited characteristics that are applicable to some supported flow object can be specified.
+
+.PP
+\fBCharacter/glyph handling\fR
+
+.PP
+It only supports a single pre\-defined character repertoire. A character name of the form U\-XXXX where XXXX are four upper\-case hexadecimal digits, is recognized as referring to the Unicode character with that code. For many characters, it is also possible to use the ISO/IEC 10646 name in lower\-case with words separated by hyphens.
+
+.PP
+Some common SDATA entity names from the ISO entity sets are recognized and mapped to characters. In addition an SDATA entity name of the form U\-XXXX, where XXXX are four upper\-case hexadecimal digits, is mapped to the Unicode character with that code.
+
+.PP
+OpenJade now supports the standard\-chars, map\-sdata\-entity, add\-name\-chars, add\-separator\-chars and char\-repertoire declaration element forms, allowing a style\-sheet to define additional character names, sdata entity mappings, name characters (i.e. characters allowed in identifiers) and separator characters. Currently the only recognized character repertoire is the built\-in repertoire. It has the public identifier "UNREGISTERED::OpenJade//Character Repertoire::OpenJade".
+
+.PP
+\fBValidation\fR
+
+.PP
+Several things that it would be desirable to have checked aren't checked:
+
+.PP
+* When the allowed value of an inherited characteristic is a symbol, OpenJade checks only that the value is a symbol that is allowed as the value of some characteristic; #t and #f are treated as a special kind of symbol in this case.
+
+.PP
+* OpenJade doesn't check whether a flow object is occurring in a context where it is allowed.
+
+.PP
+* OpenJade does not prevent flow objects being attached to the principal port of a flow object when the flow object shouldn't have a principal port.
+
+.PP
+* Most type\-checking is done at run\-time not compile\-time.
+
+.PP
+* OpenJade does not check for non\-inherited characteristics that are required to be specified.
+
+.PP
+* It doesn't check that optional features that have been used were declared in the features form.
+
+.PP
+\fBOther limitations\fR
+
+.PP
+The following primitives are just stubs:
+
+.PP
+\fBchar\-script\-case\fR Always returns last argument.
+
+.PP
+\fBaddress\-visited?\fR Always returns #f.
+
+.SH "EXAMPLES"
+
+.PP
+Given an SGML file \fBfile.sgml\fR, use the stylesheet \fBfile.dsl\fR and publish as an rtf file.
+
+.PP
+openjade \-t rtf file.sgml
+
+.PP
+Using a different stylesheet:
+
+.PP
+openjade \-t rtf \-d docbook.dsl file.sgml
+
+.PP
+Using the \fBprint\fR style specification contained within the stylesheet
+
+.PP
+openjade \-t rtf \-d docbook.dsl#print file.sgml
+
+.PP
+And use the html specification within the style sheet to convert to html
+
+.PP
+openjade \-t sgml \-i html \-d docbook.dsl#html file.sgml
+
+.SH "SEE ALSO"
+
+.PP
+\fBonsgmls(1)\fR
+
+.SH AUTHORS
+James Clark, Ian Castle <ian.castle@looksystems.co.uk>.
--- openjade-1.4devel1.orig/debian/openjade.dirs
+++ openjade-1.4devel1/debian/openjade.dirs
@@ -0,0 +1,11 @@
+usr/bin
+usr/share/man/man1
+usr/share/doc/openjade
+usr/share/doc/openjade/images
+usr/share/sgml/OpenJade
+usr/share/sgml/OpenJade/contrib
+usr/share/sgml/OpenJade/unicode
+usr/share/locale/de/LC_MESSAGES
+usr/share/locale/ja/LC_MESSAGES
+usr/share/locale/sv/LC_MESSAGES
+usr/share/doc-base
--- openjade-1.4devel1.orig/debian/openjade.doc-base
+++ openjade-1.4devel1/debian/openjade.doc-base
@@ -0,0 +1,13 @@
+Document: openjade
+Title: OpenJade Users Manual
+Author: James Clark <jjc@jclark.com>, Open Jade Development Group
+Abstract: Users manual and documentation for OpenJade.
+ OpenJade is an implementation of the DSSSL style language.
+ This allows you to flexibly format SGML and XML data to
+ media-specific back-ends, including TeX, RTF, MIF, HTML, 
+ and other XML or SGML files.
+Section: Text
+
+Format: HTML
+Index: /usr/share/doc/openjade/index.htm
+Files: /usr/share/doc/openjade/*.htm
--- openjade-1.4devel1.orig/debian/openjade.docs
+++ openjade-1.4devel1/debian/openjade.docs
@@ -0,0 +1,7 @@
+debian/README.Debian
+debian/tmp/usr/share/doc/OpenJade/AUTHORS
+debian/tmp/usr/share/doc/OpenJade/README
+debian/tmp/usr/share/doc/OpenJade/NEWS
+debian/tmp/usr/share/doc/OpenJade/images
+debian/tmp/usr/share/doc/OpenJade/doc/*.htm
+debian/tmp/usr/share/doc/OpenJade/demo.*
--- openjade-1.4devel1.orig/debian/openjade.install
+++ openjade-1.4devel1/debian/openjade.install
@@ -0,0 +1,3 @@
+debian/tmp/usr/bin/openjade-1.4devel usr/bin
+debian/tmp/usr/share/OpenJade usr/share/sgml
+debian/tmp/usr/share/locale usr/share
--- openjade-1.4devel1.orig/debian/openjade.manpages
+++ openjade-1.4devel1/debian/openjade.manpages
@@ -0,0 +1 @@
+debian/tmp/usr/share/man/man1/openjade-1.4devel.1
--- openjade-1.4devel1.orig/debian/openjade.postinst
+++ openjade-1.4devel1/debian/openjade.postinst
@@ -0,0 +1,16 @@
+#!/bin/sh
+
+set -e
+
+case "$1" in
+    configure)
+	## alternatives
+	update-alternatives --quiet --install \
+	    /usr/bin/openjade openjade /usr/bin/openjade-1.4devel 20 \
+	    --slave /usr/share/man/man1/openjade.1.gz openjade.1.gz /usr/share/man/man1/openjade-1.4devel.1.gz
+	;;
+esac
+
+#DEBHELPER#
+
+exit 0
--- openjade-1.4devel1.orig/debian/openjade.prerm
+++ openjade-1.4devel1/debian/openjade.prerm
@@ -0,0 +1,16 @@
+#!/bin/sh
+
+set -e
+
+case "$1" in
+    remove|deconfigure|upgrade)
+	## alternatives system
+	update-alternatives --quiet --remove \
+	    openjade /usr/bin/openjade-1.4devel
+    ;;
+
+esac
+
+#DEBHELPER#
+
+exit 0
--- openjade-1.4devel1.orig/debian/openjade.sgmlcatalogs
+++ openjade-1.4devel1/debian/openjade.sgmlcatalogs
@@ -0,0 +1 @@
+debian/tmp/usr/share/OpenJade/catalog /usr/share/sgml/OpenJade/catalog
--- openjade-1.4devel1.orig/debian/rules
+++ openjade-1.4devel1/debian/rules
@@ -0,0 +1,180 @@
+#!/usr/bin/make -f
+
+export DH_VERBOSE=1
+
+pkg			:= openjade
+pkg-openjade		:= $(pkg)
+pkg-libostyle		:= libostyle1c2
+pkg-libostyle-dev	:= libostyle-dev
+
+# build tool abstraction
+install_	:= install -o root -g root -p
+install_file	:= install -o root -g root -m 644 -p
+install_script	:= install -o root -g root -m 755 -p
+install_program	:= install -o root -g root -m 755 -p
+ifeq (,$(findstring nostrip,$(DEB_BUILD_OPTIONS)))
+  install_program += --strip
+endif
+make_directory	:= install -d -o root -g root -m 755
+compress	:= gzip -9f
+
+CFLAGS		:= -g --pipe
+CXXFLAGS	:= -g --pipe -fpermissive
+ifeq (,$(findstring noopt,$(DEB_BUILD_OPTIONS)))
+  CFLAGS += -O2
+  CXXFLAGS += -O2
+else
+  CFLAGS += -O0
+  CXXFLAGS += -O0
+endif
+ifneq (,$(findstring hppa,$(DEB_BUILD_ARCH)))
+  CFLAGS += -ffunction-sections
+  CXXFLAGS += -ffunction-sections
+endif
+CXXFLAGS += -fno-lifetime-dse  # https://gcc.gnu.org/bugzilla/show_bug.cgi?id=69534
+export CFLAGS
+export CXXFLAGS
+
+# flags to get automake to use the above
+inst_flags	:= INSTALL='$(install_)'
+inst_flags	+= INSTALL_PROGRAM='$(install_program)'
+inst_flags	+= INSTALL_SCRIPT='$(install_script)'
+inst_flags	+= INSTALL_DATA='$(install_file)'
+
+# first version of package providing the right shlibs
+SHLIBS_PKGVER	:= 1.4devel1-11
+
+# # extra docs we don't want
+# DOCS_TOO_MUCH	:= ABOUT-NLS COPYING copying.txt ChangeLog
+
+# determine our version numbers
+SRC_VERSION	:= $(shell LC_ALL=C dpkg-parsechangelog | grep ^Version: | sed 's/^Version: *//')
+UPSTREAM_VERSION:= $(shell echo $(SRC_VERSION) | sed -e 's/^\(.*\)-[^-]*$$/\1/')
+# stuff for snapshot/cvs building
+root_cmd		:= sudo
+deb_build		:= dpkg-buildpackage -pgpg -r$(root_cmd) -b
+cvs_build_dir		:= $(HOME)/debian/$(pkg-openjade)
+cvs_ver_build_dir	:= $(cvs_build_dir)/$(pkg-openjade)-$(UPSTREAM_VERSION)
+cvs_pure_src_dir	:= ..
+cvs_pure_src		:= $(pkg-openjade)
+
+# cvs snapshot building
+cvs-build:	clean
+	[ -d $(cvs_pure_src_dir)/$(cvs_pure_src)/CVS ] || exit 1
+	$(root_cmd) rm -rf $(cvs_ver_build_dir)
+#	rm -f $(cvs_build_dir)/$(pkg-openjade)_$(UPSTREAM_VERSION).orig.tar.gz
+#	 don't do cvs up or make the changelog
+	install -d -m 755 $(cvs_ver_build_dir)
+#	GZIP=-9 tar czf $(cvs_build_dir)/$(pkg-openjade)_$(UPSTREAM_VERSION).orig.tar.gz -C $(cvs_pure_src_dir) --exclude CVS $(cvs_pure_src)
+	tar cf - --exclude CVS . | tar xf - -C $(cvs_ver_build_dir)
+	[ -f ChangeLog ] || cvs2cl -r -t -b
+	cp ChangeLog $(cvs_ver_build_dir)/
+	cd $(cvs_ver_build_dir) && $(deb_build)
+
+ChangeLog:
+	[ ! -e OpenJade-$(UPSTREAM_VERSION) ]
+	[ -f $(cvs_pure_src_dir)/$(pkg-openjade)_$(UPSTREAM_VERSION).orig.tar.gz ]
+	tar -xzvf $(cvs_pure_src_dir)/$(pkg-openjade)_$(UPSTREAM_VERSION).orig.tar.gz OpenJade-1.4devel/ChangeLog
+	mv OpenJade-1.4devel/ChangeLog .
+	rm -r OpenJade-1.4devel
+
+clean:
+	dh_testdir
+	rm -f debian/buildinfo
+	[ ! -f Makefile ] || $(MAKE) distclean || true
+	rm -f po/*.gmo
+	find . -type l | xargs rm -f
+	dh_clean configure-stamp build-stamp install-stamp debian/copyright
+	# The build process doesn't handle this properly, force a rebuild
+	-rm -f style/InterpreterMessages.cxx style/InterpreterMessages.h \
+	    style/DssslAppMessages.h jade/JadeMessages.h \
+	    jade/RtfMessages.h jade/HtmlMessages.h jade/TeXMessages.h \
+	    jade/MifMessages.h
+	dh_autoreconf_clean
+	rm -f debian/*.debhelper.log
+
+configure: configure-stamp
+configure-stamp:
+	dh_autoreconf
+	dh_buildinfo generate cat
+	./configure --prefix=/usr --enable-http --enable-shared --enable-static
+	touch $@
+
+
+build: build-arch build-indep
+build-arch: build-stamp
+build-indep: build-stamp
+build-stamp: configure-stamp
+	dh_testdir jade
+	$(MAKE) SUBDIRS="grove spgrove style"
+	$(MAKE)
+	touch $@
+
+
+# Upstream copyright notice only appears in README; for Debian, it must be in
+# copyright file.  COPYING is the license, which appears to be BSD derived
+# (similar wording, with "Regents" changed to "James Clark"). Create
+# debian/copyright with all the right information.
+debian/copyright: README debian/license.Debian debian/copyright.Debian
+	cat $^ > $@
+
+# Install into DESTDIR, then move everything later. CURDIR is set by make.
+DESTDIR = $(CURDIR)/debian/tmp
+export DESTDIR
+install: build install-stamp
+install-stamp:
+	dh_testdir
+	dh_testroot
+	dh_clean -k
+	$(MAKE) install $(inst_flags)
+	touch $@
+
+clean-install:
+	rm -fr debian/tmp
+	rm install-stamp
+
+binary-indep: install
+# There are no architecture-independent binary packages generated from this
+# source package.
+
+binary-arch: install debian/copyright debian/README.Debian 
+	dh_testdir
+	dh_testroot
+	rm -f debian/*.debhelper
+	dh_clean -X tmp -d
+
+	dh_installdirs
+	dh_installdocs
+	dh_installchangelogs -A ChangeLog
+
+	mkdir -p $(DESTDIR)/usr/share/man/man1 && \
+	cp -p debian/openjade.1 \
+		$(DESTDIR)/usr/share/man/man1/openjade-1.4devel.1
+	dh_installman -p openjade
+
+	cp -p $(DESTDIR)/usr/bin/openjade $(DESTDIR)/usr/bin/openjade-1.4devel
+	dh_install
+
+	dh_installcatalogs
+
+	dh_strip -a
+	dh_compress -a
+	dh_fixperms -a
+	dh_makeshlibs
+	dh_shlibdeps -L $(pkg-libostyle) -l debian/$(pkg-libostyle)/usr/lib
+
+	dh_buildinfo install
+
+	dh_installdeb
+	dh_gencontrol
+	dh_md5sums
+	dh_builddeb
+
+binary: binary-indep binary-arch
+
+.PHONY: clean build install binary-indep binary-arch binary
+
+# vim: set syntax=makefile:
+# Local variables:
+# compile-command: "cd .. && fakeroot dpkg-buildpackage -uc -us"
+# End:
--- openjade-1.4devel1.orig/debian/source/format
+++ openjade-1.4devel1/debian/source/format
@@ -0,0 +1 @@
+1.0
--- openjade-1.4devel1.orig/develdoc/DEVELOPERS
+++ openjade-1.4devel1/develdoc/DEVELOPERS
@@ -0,0 +1,158 @@
+			Notes for Developers                         -*-text-*-
+			--------------------
+
+Note: these notes apply only if you are working on some flavor of Unix.
+
+You will need to install several GNU tools to be able to use the cvs
+sources.  If you do not have these tools available, build from the tar
+file distribution instead, available from peano.mathematik.uni-freiburg.de
+
+To build from the CVS sources, you will need:
+  * GNU gcc (version >= 2.95) 
+  * GNU make
+  * autoconf (version >= 2.13)
+  * automake (version >= 1.4)
+
+
+After the *initial* checkout of the sources, (see cvs.html) you will
+need to execute the following commands from the top of the source
+tree.
+
+    automake --add-missing
+    autoreconf
+        ^^
+Be careful!  The second command is autoREconf, not simply autoconf.
+
+There will be some warnings, which are ignorable as long as you get a
+working configure script: the configure script will fix all those
+problems.
+
+Now, configure and build as per INSTALL.  If configure fails, please 
+look through `config.log' for clues.
+
+
+Development Rules of the Road
+-----------------------------
+
+ 1) _Every_ change must be properly ChangeLogged.  Since we create the
+    ChangeLog automatically from the cvs commit logs, you can do this 
+    by giving meaningful logs when cvs commits asks for them.
+
+ 2) If you make a user-visible change please add a blurb about it to the
+    NEWS file.  A couple sentences is fine; don't repeat the
+    documentation but give folks enough of an idea so they can decide if
+    they want to learn more.  Bug fixes (unless they're _really_ user
+    visible) shouldn't be noted in the NEWS file.
+
+ 3) If you add a new user-visible feature, don't forget to update the
+    appropriate documentation at the same time!
+
+ 4) Bug fixes may be committed at any time (unless we're in code freeze
+    for a release), usually without much review (unless you want someone
+    else to look at it).  All our code freeze, etc. is merely
+    procedural, not enforced, so it's important you read jade-devel
+    and keep up-to-date with the current state of the tree.
+
+ 5) New features should be discussed on the list to ensure everyone
+    thinks they're "appropriate". 
+
+ 6) If the new feature is large enough, unstable enough, or not
+    targeted at the next release, it should go on a private branch.
+    Otherwise, consensus will probably have it installed on the main
+    branch.
+
+
+        ** Of course, compile and test before committing! **
+
+
+Dealing with CVS
+----------------
+
+I will fill in some details sometime.
+
+
+Changing a Makefile
+-------------------
+
+First of all, NEVER edit anything named Makefile or Makefile.in.  These
+are both derived from the corresponding Makefile.am.  The most common
+reason for editing is to change the list of sources.
+
+Steps: 1. edit foo/blah/Makefile.am
+       2. re-run "make" from the top of the build directory
+
+Step 2 will take care of rebuilding the Makefile.in and Makefile from your
+changed Makefile.am.
+
+Makefile.am has a simple format, basically:
+
+        bin_PROGRAMS = openjade
+
+        fvmw2_SOURCES = blah.cxx blah.h foo.cxx foo.h ...
+
+Notice that you have to add all files, C++-code *and* headers, to the
+_SOURCES line.  This is vital, because this is the list of files that are
+packed into the distribution.  If you leave one out, nobody will be able
+to build the distributed tar file!
+
+
+Changing configure.in
+---------------------
+
+The most common reason to do this is to change the version string.  If
+you're editing it for any other reason, I will assume you know what you're
+doing.
+
+Steps: 1. edit configure.in, and find the line containing
+          AM_INIT_AUTOMAKE(OpenJade, x.y.z) at the top of the file
+       2. change x.y.z to the new version string
+       3. re-run "make" from the top of the build directory
+
+Step 3 will take care of rebuilding the configure script, and usually all
+the other Makefiles.
+
+
+Building a distribution
+-----------------------
+
+By this, I mean the file "OpenJade-x.y.z.tar.gz".
+
+Steps: 1. ./configure
+       2. make clean
+       3. double check that you get no warnings during the build (the
+          options for compilers other than gcc may be different):
+          make CFLAGS="-g -O2 -Wall -Werror"
+       4. make distcheck
+       5. ensure that you see the message
+          "OpenJade-x.y.z.tar.gz ready for distribution"
+
+Note that you need to have actually build everything before packing
+the distribution, thus if we ever have files which are compiled only
+conditionally, you'll have to add the necessary options 1. to make 
+sure everything is built.  Among other things, this generates
+the proper dependency information for insertion into Makefile.in's
+generated in step 4.
+
+Step 4 will create the tar file, then unpack it and attempt a build &
+install (to a scratch directory, not /usr/local).  This makes sure
+that you really DID include all the files necessary to build the
+package into the tar file. It may be hard to appreciate how useful
+this is, until it has reminded you that you forgot file "foo.h" in
+some _SOURCES line.  But trust me, it will save your bacon in this way
+some day!
+
+
+If this is to be an "official", labeled release, then do also the
+following:
+
+       6. tag the CVS tree:
+          cvs tag openjade_x_y_z
+       7. increase the version number in configure.in (see above)
+          and `cvs commit' this change
+       8. put the file up for ftp somewhere 
+       9. add a link to the download.html page, which is in the
+          cvs module named www.  Committing the new version to the
+          repository will bring it online shortly after.
+
+Be sure to do steps 6 and 7 in that order, so you get the label on the
+right version of configure.in.
--- openjade-1.4devel1.orig/develdoc/NOTES
+++ openjade-1.4devel1/develdoc/NOTES
@@ -0,0 +1,195 @@
+Some temporary notes:
+
+==============================================================================
+
+For reference, here is how some of this can be hacked in jadetex using 
+sgml-parse:
+
+cat >>jadetex.cfg <<EOF
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% page-number and category-page-number support
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+%
+% We need a counter totalpages which truly counts the pages 
+% shipped out so far (unlike page, which counts something 
+% like the DSSSL category-page-number).  
+%
+\newcounter{totalpages}
+\setcounter{totalpages}{1}
+
+% Wow, changing the LaTeX output routine !
+\let\@@outputpage\@outputpage
+\def\@outputpage{\@@outputpage\stepcounter{totalpages}}
+
+% Produce an SGML file which can be read by sgml-parse
+\newwrite\@dssslindexfile
+\immediate\openout\@dssslindexfile=\jobname.index
+\begingroup
+  \catcode`\#=12
+  \immediate\write\@dssslindexfile
+  {<!doctype pagelist [^^J %
+<!element pagelist - - (node+) >^^J 
+<!element node - - (firstarea,node*,lastarea) >^^J 
+<!attlist node id ID #IMPLIED >^^J 
+<!element (firstarea,lastarea) - - EMPTY >^^J 
+<!attlist (firstarea,lastarea)^^J   
+page NUMBER #REQUIRED^^J   
+category NUMBER #REQUIRED >^^J%
+]>^^J%
+<pagelist>}
+\endgroup
+\typeout{Writing DSSSL page number information to \jobname.index.}
+
+\newcounter{elno}
+\let\@@Node\Node
+\def\Node#1{%
+  \@@Node{#1}%
+  \DEBUG{Label \Label}%
+  \DEBUG{Element \Element}%
+  \def\pgid{}%
+  \ifx\Label\@empty
+    \ifx\Element\@empty\else
+     \setcounter{elno}{\Element}%
+     \addtocounter{elno}{1}%
+     \edef\pgid{ELNO\arabic{elno}}%
+    \fi
+  \else
+    \let\pgid\Label
+  \fi
+    \immediate\write\@dssslindexfile
+    {<node\ifx\pgid\@empty\else\space id="\pgid"\fi>^^J
+       <firstarea page="\arabic{totalpages}" 
+                  category="\arabic{page}">}}
+\let\@@endNode\endNode
+\def\endNode#1{%
+  \DEBUG{endNode: \Label, \Element}%
+    \immediate\write\@dssslindexfile
+    { <lastarea page="\arabic{totalpages}"
+                category="\arabic{page}">^^J</node>}%
+  \@@endNode{#1}}
+\let\@@endFOT\endFOT
+\def\endFOT{%
+ \immediate\write\@dssslindexfile{</pagelist>}%
+ \immediate\closeout\@dssslindexfile
+ \@@endFOT}
+
+EOF
+
+Explanation for the TeXagnostics: What this does is write an SGML file
+xyz.index (assuming you started with xyz.sgml from which jade -ttex produced 
+xyz.tex) with the following DTD
+
+<!element pagelist - - (node+) >
+<!element node - - (firstarea,node*,lastarea) >
+<!attlist node id ID #IMPLIED >
+<!element (firstarea,lastarea) - - EMPTY >
+<!attlist (firstarea,lastarea)
+	page NUMBER #REQUIRED
+	category NUMBER #REQUIRED >
+ 
+jadetex emits a node element for each node in the FOT (in reality there
+are no nodes in the FOT, but the TeXFOTBuilder emits enough information
+for jadetex to know which node was current when a FO was created).
+
+The page and category attributes of the firstarea and lastarea elements 
+contain the values we want to get via 
+
+(page-number first-area-of-node: nd)
+(page-number last-area-of-node: nd)
+(category-page-number first-area-of-node: nd)
+(category-page-number last-area-of-node: nd)
+
+if nd is the node in question.
+
+Here is how to define page-number and category-page-number using sgml-parse.
+The ugly thing is that the name of the index file is hardcoded. This 
+could be improved using the -V extensions of OpenJade.
+
+cat >>page-numbers.dsl <<EOF
+
+(define index-sysid "xyz.index")
+(define index-page-grove (sgml-parse index-sysid))
+
+(define (page-number #!key first-area-of-node last-area-of-node) 
+  (wrap-generated-object
+  (if (and first-area-of-node last-area-of-node)
+     (error "page-number accepts at most one key argument")
+     (let* ((snl (or first-area-of-node last-area-of-node (current-node))) 
+            (area (if last-area-of-node "LASTAREA" "FIRSTAREA"))
+	    (tid (or (id snl) (string-append "ELNO" 
+					     (format-number
+					      (all-element-number snl) "1")))))
+       (if tid
+	   (string->number 
+	    (or (attribute-string 
+		 "PAGE" (select-elements 
+			 (children (element-with-id tid index-page-grove))
+			 area))
+		"0"))
+	   (error "page-number currently works only on elements 
+and nodes with id"))))))
+	   
+(define (category-page-number #!key first-area-of-node last-area-of-node) 
+  (wrap-generated-object
+  (if (and first-area-of-node last-area-of-node)
+     (error "category-page-number accepts at most one key argument")
+     (let* ((snl (or first-area-of-node last-area-of-node (current-node))) 
+            (area (if last-area-of-node "LASTAREA" "FIRSTAREA"))
+	    (tid (or (id snl) (string-append "ELNO" 
+					     (format-number
+					      (all-element-number snl) "1")))))
+       (if tid
+	   (string->number 
+	    (or (attribute-string 
+		 "CATEGORY" (select-elements 
+			 (children (element-with-id tid index-page-grove))
+			 area))
+		"0"))
+	   (error "category-page-number currently works only on elements 
+and nodes with id"))))))
+
+
+;; I used wrap-generated-object to fake a new type for generated objects.
+
+(define (wrap-generated-object x) (cons 'generated-object x))
+
+(define (generated-object? x) 
+  (and (pair? x) (equal? (car x) 'generated-object)))
+
+(define (unwrap-generated-object x) 
+  (if (generated-object? x) 
+      (cdr x)
+      (error "generated object required")))
+
+
+;; Of course we also need some of the DSSSL functions dealing with
+;; generated objects.
+
+; This is a *very* partial implementation of general-indirect-sosofo.
+(define (general-indirect-sosofo fun #!rest li) 
+  (fun (map unwrap-generated-object li)))
+
+(define (number-indirect-sosofo x #!key (format "1") (add 0) (multiple 1))
+  (let ((y (unwrap-generated-object x)))
+    (if (not (number? y))
+	(error "number-indirect-sosofo: kernel of generated object 
+not a number")
+	(let ((n (+ add y))) 
+	  (if (= 0 (remainder n multiple))
+	      (literal (format-number n format))
+	      (literal ""))))))
+
+(define (asis-indirect-sosofo x)
+  (let ((y (unwrap-generated-object x)))
+    (if (not (sosofo? y))
+	(error "asis-indirect-sosofo: kernel of generated object 
+not a sosofo")
+	y)))
+
+EOF
+
+==============================================================================
--- openjade-1.4devel1.orig/develdoc/TODO
+++ openjade-1.4devel1/develdoc/TODO
@@ -0,0 +1,197 @@
+* Add some optimizations to the query stuff: add query rules to the per-gi
+  rule lists only if they actually contain at least on element node with that
+  gi, add a seperate list of char rules and a findCharRule function to use
+  for char nodes (or combine the various find...Rule functions into one
+  which gets the list to look in as a parameter). Then hasCharRules_ can 
+  be replaced by charRules_[0].size() > 0 || charRules_[1].size() > 0.
+x
+* Redo the modules stuff. Move it from Interpreter to grove/. Ideally, the
+  style engine shouldn't need any hardwired knowledge about the limitations
+  of the grove implementation, but should query it.
+
+* Redo the features stuff to make it cleaner.  
+
+* Remove the SdataMapper hack from the grove interface. Rename SdataMapper
+  to something like GroveConstructionParameters and pass it to the grove
+  construction process. Eventually we want to add the standard-chars,
+  combine-char and other stuff to the GroveConstructionParameters.
+
+* Make the in-memory representation for char chunks more compact. Right
+  now we store a flat array of 32bit chars, which is wasteful. If we use
+  a different representation, DataNode::charChunk will involve a making
+  a copy and thus be much more expensive than currently. Thus we should
+  make sure it is not called unnecessarily often (eg its called twice
+  in ProcessContext::processNode). 
+
+* Add more error messages to the SchemeParser. Currently, many parser
+  functions just return 0 to the caller; they should also issue a message.
+  Add sth like AllowedTokensMessageArg and use that in 
+  SchemeParser::tokenRecover to give information about the expected tokens.
+
+* Free Expressions when they are no longer needed. Later, maybe replace the
+  allocation mechanism with a simpler one that does not actually free
+  individual objects.
+
+* Wrap lines in help message. (Add wrapping OutputCharStream.)
+  Then fold the info<n> messages into a single message
+
+* The empty delimEnd message has been removed from ParserMessages.msg.
+  If translators need to do something different than just put a string
+  before the actual delimiter, we should support simple insertions in
+  message fragments and use
+  +delim++delimiter %
+  instead.
+
+Things which are missing and need a lot of work
+===============================================
+
+* Redesign the App class hierarchy to prepare for breaking OpenJade in
+  exchangeable components.
+
+* Check the win32 port of OpenJade (OpenSP works).
+
+* Support i18n on win32. As a first step, write a perl script to translate
+  the .rc files using the translations from the <lang>.po files. Be careful,
+  the quoting in .rc seems to be different from the quoting in .po. 
+  This will give us compile-time language-choice on win32, ie one could
+  decide to run this script for de.po before the compilation to get the
+  German translations compiled in. I still have no idea how install-time
+  language-selection would be handled. 
+
+* SGML backend: Change the document-type FO to be non-atomic, to allow an
+  internal DTD subset. ADD FOs for DTD declarations.
+
+* query: leads to current-node not being an element node.
+
+* char-script-case: this should be handled by the backends.
+
+* baseset-encoding, literal-described-char, other-chars: 
+  must abandon SP_CHARSET_FIXED to do this, since otherwise
+  SP does unwanted conversions on numeric char refs. On the
+  other hand, we do want SP_CHARSET_FIXED, if we are using
+  jades builtin repertoire (ie Unicode). This could be done
+  by scanning the cmdline args for "-s"/"--strict" before
+  constructing the JadeApp instance.  
+
+  We have to map other-chars in the Unicode/UCS private area somewhere and
+  tell the user/backend about it. 
+ 
+* combine-char: If we do this, we can't do character translation
+  as a map char --> char any longer, but instead have to deal
+  with string --> string.
+
+* Annex K #ALL/#IMLICIT content tokens. Implementation idea: At the 
+  begin of the instance and after seeing a new implicit element type 
+  in the instance, go over all definitions and recompile the model 
+  groups. Also adjust the inclusions/exclusions. Optimization: recompile 
+  only those which actually use #ALL/#IMPLICIT.
+
+<<<<<<< TODO
+* Annex K #IMPLIED doctype name.
+
+=======
+* Annex K DTD data entities: add a DTD notation framework. Applications
+  should have a way to register DTD notation handlers which would then
+  be called for DTD data entities with the corresponding notation. They
+  would get a pointer to the entity and to the current Dtd and would
+  add the element and entity declarations they extract from the entity
+  to the Dtd.
+
+>>>>>>> 1.12.2.6
+* check table-auto-width and multi-process features.
+
+* A caching mechanism for DTDs, dsssl specs, ...
+  This is complicated, since the result of parsing a DTD does depend not
+  only on the sysid, but also on cmdline options which could define parameter
+  entities and on the catalogs used to search for entities. 
+
+* An XSLFO backend ? Would try to approximate the DSSSL FOT into an XSLFO
+  document. Then we could take advantage of existing XSL formatters. We could
+  also drop JadeTeX in favor of PassiveTeX (when it gets ready) then.
+
+* TeXFOTBuilder: Only output Start/EndNode pairs for nodes actually referred to
+  (see RtfFOTBuilder).
+
+* Do page feature in the front-end.
+
+* TeX backend: Implement general indirect FOs by outputting relevant info from
+  a TeX run and reading that info in the next OJ run.
+
+
+
+Simple things
+=============
+
+* install ports, ICs, etc only in SL Interpreters.
+
+* Perhaps split InterpreterMessages into InterpreterMessages and 
+  SchemeParserMessages (and more...). 
+
+<<<<<<< TODO
+* Remove FOTBuilder::characters(const Vector<CharacterNIC> &) and instead add
+  a procedure that lets the backend query character properties for a Char
+  array. Makes storing parts of the FOT more efficient (otherwise,
+  SaveFOTBuilder will have to store the NIC Vectors, for example.)
+  Should be done before next release.
+
+* A way for backends to declare/access extension character properties.
+  (Not needed until we have a backend that actually would do this.)
+
+* Validation of extension flow objects. (Not very important, since the backends
+  can handle these special cases without major effort.) Instead we could add a
+  FOTBuilder::FOMessage() non-virtual, so that backends may produce consistent
+  error messages without knowing about ProcessContext internals.
+=======
+* Set up framework for I18N: generating .po from .msg, po/OpenXYZ.pot from ../*.po,
+  generate and install .mo files. This has been done for OpenSP,
+  still to do for OpenJade. 
+  
+  If you add a new .msg file, you now have to remember to add it 
+  to po/POTFILES.in.
+
+  Adding support for a new language is done by:
+  1) cp po/OpenSP.pot <lang>.po	
+  2) Add translations in po/<lang>.po
+  3) cvs add po/<lang>.po 
+  4) Add <lang> to ALL_LINGUAS in configure.in
+  5) cvs commit configure.in po/<lang>.po
+  Here <lang> stands for the proper 2-letter language code 
+  (is that ISO 639 ?)
+
+  Still to do: figure out how to create translated .rc files from
+  the translations in <lang>.po. This will need some perl magic
+  to read in <lang>.po, then go over the .rc file and for each string,
+  look up the translation. Then write out a translated .rc file 
+  containing the proper language identification (ask Didier about this). 
+>>>>>>> 1.12.2.6
+
+* Support uri-ref addresses in more backends.
+
+Things which have to be added to the jade internals documentation
+=================================================================
+
+*  writing backends.
+
+*  scheme primitives: special meaning of partIndex == unsigned(-1),
+   (define internal: ...), (define feature: foo ...).
+
+*  language stuff.
+
+*  feature checking.
+
+*  grove plan checking.
+
+*  color spaces.
+
+*  char repertoire stuff.
+
+* messages: module stuff, message numbers 
+  I18n handling.
+
+Reorganization
+==============
+
+* clean up the mess of SP_ defines
+ 
+* replace many SP_ defines by their more `standard' automake
+  names (see the bottom of acconfig.h)
--- openjade-1.4devel1.orig/develdoc/jadedoc.sgml
+++ openjade-1.4devel1/develdoc/jadedoc.sgml
@@ -0,0 +1,1243 @@
+<!doctype article public "-//Davenport//DTD DocBook V3.0//EN">
+<article>
+  <artheader>
+    <title>OpenJade and OpenSP internals</title>
+    <author>
+      <firstname>Matthias</firstname>
+      <surname>Clasen</surname>
+      <affiliation>
+	<address format="linespecific">
+	  <email>clasen@mathematik.uni-freiburg.de</email>
+	</address>
+      </affiliation>
+    </author>
+    <date>19.11.99</date>
+  </artheader>
+  <abstract>
+    <para>This document describes the OpenJade DSSSL engine
+      and the OpenSP SGML system upon which it is based 
+      from the programmers point of view. It was written to
+      help people who want to extend OpenJade or OpenSP.</para>
+  </abstract>
+  <sect1>
+    <title>OpenSP Package organization</title>
+    <sect2>
+      <title>Directory contents</title>
+      <para>The follwing directories contain files needed during the
+      build:</para> 
+      <variablelist>
+	<varlistentry>
+	  <term><filename>all/</filename></term>
+	  <listitem><para>Visual C++ build process</para></listitem>
+	</varlistentry>
+      </variablelist>
+      <para>The following directories contain documentation:</para>
+      <variablelist>
+	<varlistentry>
+	  <term><filename>doc/</filename></term>
+	  <listitem><para>OpenSP documentation</para></listitem>
+	</varlistentry>
+      </variablelist>
+      <para>The following directories contain
+      <acronym>SGML</acronym> text files:</para>
+      <variablelist>
+	<varlistentry>
+	  <term><filename>pubtext/</filename></term>
+	  <listitem><para>various DTDs and catalogs</para></listitem>
+	</varlistentry>
+	<varlistentry>
+	  <term><filename>unicode/</filename></term>
+	  <listitem><para><acronym>SGML</acronym> declaration and catalog for
+	  dealing with Unicode</para></listitem>
+	</varlistentry>
+      </variablelist>
+      <para>The following directories contain the sources of the 
+      library:</para> 
+      <variablelist>
+	<varlistentry>
+	  <term><filename>include/</filename></term>
+	  <term><filename>generic</filename></term>
+	  <listitem><para>the headers defining the API of the OpenSP
+	    library</para></listitem>
+	</varlistentry>
+	<varlistentry>
+	  <term><filename>lib/</filename></term>
+	  <listitem><para>the source of the OpenSP library</para></listitem> 
+	</varlistentry>
+      </variablelist>
+      <para>Applications:</para>
+      <variablelist>
+	<varlistentry>
+	  <term><filename>nsgmls/</filename></term>
+	  <listitem><para>an <acronym>SGML</acronym> parser</para></listitem>
+	</varlistentry>
+	<varlistentry>
+	  <term><filename>sgmlnorm/</filename></term>
+	  <listitem><para>an <acronym>SGML</acronym> normalizer</para>
+	  </listitem>
+	</varlistentry>
+	<varlistentry>
+	  <term><filename>spam/</filename></term>
+	  <listitem><para>a markup stream editor</para></listitem>
+	</varlistentry>
+	<varlistentry>
+	  <term><filename>spent/</filename></term>
+	  <listitem><para>a frontend to the OpenSP entity manager</para>
+	  </listitem>
+	</varlistentry>
+	<varlistentry>
+	  <term><filename>sx/</filename></term>
+	  <listitem><para>a simple <acronym>SGML</acronym> to
+	      <acronym>XML</acronym> converter</para></listitem>
+	</varlistentry>
+	<varlistentry>
+	  <term><filename>spcat/</filename></term>
+	  <listitem><para>a frontend to the OpenSP catalog 
+	      manager</para></listitem>
+	</varlistentry>
+      </variablelist>
+    </sect2>
+    <sect2>
+      <title>The build system</title>
+      <para>OpenSP uses the GNU build system based on autoconf, automake
+	and libtool. If you are working from a <filename>.tar.gz</filename>
+        snapshot or release of OpenSP, all you need to do is
+<cmd>./configure; make</cmd>. If you are working from CVS, you have to
+  	run <cmd>autoconf --add-missing; autoheader; aclocal; autoconf</cmd>
+	initially.</para>
+    </sect2>
+  </sect1>
+  <sect1>
+    <title>OpenJade Package organization</title>
+    <sect2>
+      <title>Directory contents</title>
+      <para>The follwing directories contain files needed during the
+      build:</para> 
+      <variablelist>
+	<varlistentry>
+	  <term><filename>jadedist/</filename></term>
+	  <listitem><para>creating a distribution</para></listitem>
+	</varlistentry>
+	<varlistentry>
+	  <term><filename>testsuite/</filename></term>
+	  <listitem><para>a collection of DSSSL tests</para></listitem>
+	</varlistentry>
+	<varlistentry>
+	  <term><filename>debian/</filename></term>
+	  <listitem><para>files necessary to build a Debian package</para></listitem>
+	</varlistentry>
+      </variablelist>
+      <para>The following directories contain documentation:</para>
+      <variablelist>
+	<varlistentry>
+	  <term><filename>jadedoc/</filename></term>
+	  <listitem><para>OpenJade documentation</para></listitem>
+	</varlistentry>
+	<varlistentry>
+	  <term><filename>develdoc/</filename></term>
+	  <listitem><para>documentation for developers</para></listitem>
+	</varlistentry>
+      </variablelist>
+      <para>The following directories contain
+      <acronym>DSSSL</acronym> text files:</para>
+      <variablelist>
+	<varlistentry>
+	  <term><filename>dsssl/</filename></term>
+	  <listitem><para>DTDs for style sheets and FOT output; jadetex;
+	      examples</para></listitem>
+	</varlistentry>
+      </variablelist>
+      <para>The following directories contain the sources of the various
+      libraries:</para> 
+      <variablelist>
+	<varlistentry>
+	  <term><filename>style/</filename></term>
+	  <listitem><para>the <acronym>DSSSL</acronym> style
+	      engine</para></listitem>
+	</varlistentry>
+	<varlistentry>
+	  <term><filename>grove/</filename></term>
+	  <listitem><para>an abstract interface to groves</para></listitem>
+	</varlistentry>
+	<varlistentry>
+	  <term><filename>spgrove/</filename></term>
+	  <listitem><para>an implementation of the grove
+	      interface on top of OpenSP</para></listitem> 
+	</varlistentry>
+	<varlistentry>
+	  <term><filename>groveoa/</filename></term>
+	  <listitem><para>an <acronym>OLE</acronym>-enabled version of the
+	      grove builder, Windows-only</para></listitem>  
+	</varlistentry>
+      </variablelist>
+      <para>Applications:</para>
+      <variablelist>
+	<varlistentry>
+	  <term><filename>jade/</filename></term>
+	  <listitem><para>the source of the OpenJade application and its 
+              various backends</para></listitem>
+	</varlistentry>
+      </variablelist>
+    </sect2>
+    <sect2>
+      <title>The build system</title>
+	<para>OpenJade also uses the GNU build system. Look at the
+	  description of the OpenSP build system for more details.</para> 
+    </sect2>
+  </sect1>
+  <sect1>
+    <title>Coding conventions</title>
+    <sect2>
+      <title>Formatting</title>
+      <para>The following list gives some hints on the coding conventions
+	used throughout the source.</para>
+      <itemizedlist>
+	<listitem>
+	  <para>Whitespace.</para>
+	  <itemizedlist>
+	    <listitem>
+	      <para>Statement keywords have one space after them, and no space
+		between the parentheses and the enclosed expression:</para>
+	      <programlisting>
+if (foo)  /* good */
+if( foo ) /* bad */
+	      </programlisting>
+	    </listitem>
+	    <listitem>
+	      <para>In general there is never a space after an open
+		parenthesis or before a close parenthesis:</para>
+	      <programlisting>   
+foo(arg)    /* good */
+foo( arg ) /* bad */
+	      </programlisting>
+	    </listitem> 
+	    <listitem>
+	      <para>The * or & in pointer or reference declarations stick to
+		the identifier, not to the type:</para>
+	      <programlisting>
+void foo(int *p, int &amp;r) /* good */
+void foo(int* p, int& r) /* bad */
+	      </programlisting>	    
+	    </listitem>
+	    <listitem>
+	      <para>Put whitespace on either side of operators:</para>
+	      <programlisting>   
+x = y + z; /* good */
+x=y+z;     /* bad */
+	      </programlisting>
+	    </listitem> 
+	    <listitem>
+	      <para>Indent by 2 characters.</para>
+	    </listitem>
+	    <listitem>
+	      <para>Tabs are set every 8 characters.</para>
+	    </listitem>
+	  </itemizedlist>
+	</listitem>
+	<listitem>
+	  <para>Line breaks.</para>
+	  <itemizedlist>
+	    <listitem>
+	      <para>Expressions broken over more than one line are aligned
+		LISP style:</para> 
+	      <programlisting>   
+if ((a
+      && b)
+       || (c
+           && d)) 
+	      </programlisting>
+	    </listitem> 
+	    <listitem>
+	      <para>else is on a separate line from the preceding brace:</para>
+	      <programlisting>
+if (foo) {
+}
+else if (bar) {
+}
+else {
+}
+	      </programlisting>
+	    </listitem>
+	    <listitem>
+	      <para>Long function headers should not be broken before the
+		parenthesis that starts the argument list.</para>
+	    </listitem>
+	  </itemizedlist>	
+	</listitem>	
+	<listitem>
+	  <para>Identifiers.</para>
+	  <itemizedlist>
+	    <listitem>
+	      <para>Use camelCase. Class names and type names start
+		with an upper-case letter. Function names start with a
+		lower-case letter.</para>
+	    </listitem>
+	    <listitem>
+	      <para>Names of private date members end with an
+		underscore.</para> 
+	    </listitem>
+	  </itemizedlist>
+	</listitem>
+	<listitem>
+	  <para>Declarations.</para>
+	  <itemizedlist>
+	    <listitem>
+	      <para>Use public: before private: in class declarations.</para>
+	    </listitem>
+	    <listitem>
+	      <para>Use const wherever applicable.  Declare member functions
+		const if they don't alter the object.  Declare reference
+		arguments const if the function doesn't change them
+		etc.</para> 
+	    </listitem>
+	    <listitem>
+	      <para>Don't declare inline member functions in the body; declare
+		them separately in the header file.</para>
+	    </listitem>
+	    <listitem>
+	      <para>Never have public data members in a class.</para>
+	      <para>However is OK to have a struct which is just a bundle of
+		data.  In this case use struct not class.  All members are
+		public and names don't end with an underscore.  There are no
+		member functions (the only exception is that there may be a
+	      constructor).</para>	     
+	    </listitem>
+	  </itemizedlist>
+	</listitem>
+	<listitem>
+	  <para>Other rules.</para>
+	  <itemizedlist>
+	    <listitem>
+	      <para>case clauses without a break always have a
+		"fall through" comment where the break would occur:</para>
+	      <programlisting format="linespecific">
+switch (foo)
+case x:
+/* do something here */
+// fall through
+case y:
+}
+	      </programlisting>
+	    </listitem> 
+	    <listitem>
+	      <para>A statement governed by if or else that is longer than a
+		single line always is surrounded by {}. The following is
+		unacceptable:</para>
+	      <programlisting> 
+else
+if (foo)
+    ;
+else
+    ;
+	      </programlisting>
+	    </listitem>
+	    <listitem>
+	      <para>On the other hand, never use braces around single
+		statements:</para>
+	      <programlisting>
+if (foo)   /* good */
+  bar();  
+if (foo) { /* bad */
+  bar();
+}
+	      </programlisting>
+	    </listitem> 
+	    <listitem>
+	      <para>Avoid global functions.  All functions should be members
+		of some class.</para>
+	    </listitem>
+	    <listitem>
+	      <para>Try to avoid calling delete except in low-level library
+		classes. For example, don't do:
+		<programlisting>
+void foo() {
+  Obj *p = new Obj;
+
+  ...
+  delete p;
+}
+		</programlisting>
+		Instead do:
+		<programlisting>
+void foo() {
+  Owner&lt;Obj> p(new Obj);
+  ...
+}
+		</programlisting>
+	      </para>
+	    </listitem>
+	    <listitem>
+	      <para>If a the default copy constructor and assignment operator
+		will not work for a class, you must do one of two things:
+		Either provide a copy constructor and assigment operator that
+		will work or declare but do not implement a private copy
+		constructor and assignment operator.</para>
+	    </listitem>
+	    <listitem>
+	      <para>Avoid C++ exceptions.</para>
+	    </listitem>
+	    <listitem>
+	      <para>You can assume new will never return NULL (either it will
+		throw an exception on systems where that works or it will
+		print a fatal error and exit).</para>
+	    </listitem>
+	  </itemizedlist>
+	</listitem>
+      </itemizedlist>
+    </sect2>
+    <sect2>
+      <title>Headers</title>
+      <para>Every header file should be surrounded by an <code>#ifndef</code>. 
+        Here is a skeleton for a header file named 
+	<filename>filename.h</filename>:</para>
+      <programlisting format="linespecific">
+/* copyright notice goes here */
+
+#ifndef filename_INCLUDED
+#define filename_INCLUDED 1
+
+/* contents go here */
+
+#endif /* not filename_INCLUDED */
+      </programlisting>
+      <para>The first header included by a source file must be 
+	<filename>splib.h</filename> for files in
+        <filename>lib/</filename>, <filename>config.h</filename>
+        for files in <filename>grove/</filename>, <filename>spgrove/</filename>
+	or an application directory, <filename>stylelib.h</filename> 
+        for files in <filename>style/</filename>.</para>
+    </sect2>
+    <sect2>
+      <title>Namespaces</title>
+      <para>Every file should be surrounded by a namespace. Namespaces are
+	never used directly in order to support compilers which don't
+	understand namespaces. The general skeleton for a
+      <filename>.cxx</filename> file in the namespace NAMESPACE is:</para>
+	<programlisting format="linespecific">
+/* includes go here */
+
+#ifdef NAMESPACE
+namespace NAMESPACE {
+#endif
+
+/* content goes here */
+
+#ifdef NAMESPACE
+}
+#endif
+</programlisting>
+      <para>Files in the <filename>lib/</filename>,
+	<filename>nsgmls/</filename>, <filename>sgmlnorm/</filename>,
+	<filename>spam/</filename>, <filename>spent/</filename>,  
+	<filename>spgrove/</filename> and <filename>sx/</filename>
+	directories use the namespace SP_NAMESPACE. Files in
+	<filename>grove/</filename> use the namespace GROVE_NAMESPACE.
+	Files in <filename>style/</filename> and
+	<filename>jade/</filename> use DSSSL_NAMESPACE.</para>
+      
+      <para>DSSSL_NAMESPACE imports everything from SP_NAMESPACE and
+	GROVE_NAMESPACE (see <filename>style/dsssl_ns.h</filename>).</para>
+
+      <para>VC 5 and 6 have bugs in the namespace management, which mean that
+	all these 3 need to be defined to be the same.</para>
+
+      <para>The conditional stuff is to deal with compilers that don't support
+	namespaces.</para>
+    </sect2>
+    <sect2>
+      <title>Templates</title>
+      <para>To cope with different compilers capabilities with respect to
+      templates, all template instantiations are collected in files with names
+	ending in <filename>_inst.cxx</filename>. These are generated from
+	<filename>_inst.m4</filename> files.</para> 
+      
+      <para>To add a new template instantiation, add a macro call of the
+	form
+<programlisting>
+__instantiate(/* your template instatiation */)
+</programlisting>
+	to the appropriate <filename>.m4</filename> file.</para>
+    </sect2>
+    <sect2>
+      <title>API definitions</title>
+      <para>
+	When building <acronym>DLL</acronym>s on Windows, every class or
+	function which should be exported by the <acronym>DLL</acronym>
+	has to be prefixed with 
+<programlisting format="linespecific">
+__declspec(dllexport)
+</programlisting>
+	when building the <acronym>DLL</acronym> and with
+<programlisting format="linespecific">
+__declspec(dllimport)
+</programlisting>
+	when using it outside the <acronym>DLL</acronym>.</para>
+
+      <para>This is hidden behind the _API macros which get defined
+      appropriately. Every declaration of a class of function which is part of
+      the public interface of its library should be prefixed with the proper
+      _API macro. Files in <filename>include/</filename> use SP_API,  
+	files in <filename>grove/</filename> use GROVE_API,
+	files in <filename>spgrove/</filename> use SPGROVE_API,
+	files in <filename>style/</filename> use STYLE_API.
+      </para>
+    </sect2>
+    <sect2>
+      <title>Messages</title>
+      <para>Messages for the main classes are collected in separate classes.
+	Eg there is a class <classname>InterpreterMessages</classname> for all
+	messages of the class <classname>Interpreter</classname>.</para>
+      
+      <para>The sources (<filename>.h</filename> and <filename>.cxx</filename>
+	files and, on Windows, <filename>.rc</filename> files) for the
+	<classname><replaceable>&lt;class></replaceable>Messages</classname>
+	classes are generated from <filename>.msg</filename> files by
+	the <filename>msggen.pl</filename> Perl script.
+      </para>
+
+	<para>Adding a new message amounts to adding one line to the correct
+	<filename>.msg</filename> file. The lines in these files have the
+	following format:</para> 
+
+      <para><replaceable>&lt;message type></replaceable><replaceable>&lt;args></replaceable>+<replaceable>&lt;identifier></replaceable>+<replaceable>&lt;relevant clauses></replaceable>+<replaceable>&lt;message text></replaceable></para>
+	 
+      <para><replaceable>&lt;message type></replaceable> must be one of the
+	I, W, Q, X or E. These stand for info, warning, quantity error, idref
+	error and error, respectively.</para>
+
+      <para><replaceable>&lt;args></replaceable> is the number of placeholders
+	of the form %n in the <replaceable>&lt;message
+	text></replaceable>.</para>  
+
+      <para><replaceable>&lt;identifier></replaceable> is the C++-identifier
+	used to refer to the message.</para> 
+
+      <para><replaceable>&lt;relevant clauses></replaceable> may be used to
+        give an exact reference to the relevant ISO standard for
+	each error message. In OpenJade error messages, this field is 
+        usually left empty. The information in this field is currently 
+        ignored by all OpenSP and OpenJade applications. 
+        The format for this field is a space-separated
+        list of clauses, where each clause is a dot-separated list of
+        numbers. A clause may optionally contain a paragraph specification,
+        which is a suffix of the form `p&lt;number>'. </para> 
+
+      <para><replaceable>&lt;message text></replaceable> is the text of the
+   message. It can contain placeholders of the form %n where n is a number
+   between 0 and <replaceable>&lt;args></replaceable> - 1. These placeholders
+   will be replaced by suitable arguments if the message is issued.</para>
+ 
+      <para>Besides normal message lines, <filename>.msg</filename> files
+        may contain a few other lines: a line starting with `!cxx' causes
+        the generation of a <filename>.cxx</filename> file (this is necessary
+        if the generated header file is included in multiple source files,
+        a line of the form `= &lt;number>' can be used to set the number
+        for the following message, a line starting with `-' is a deleted
+        message (ie it is ignored, but still increases the message number),
+        a line with `#' or `$' as the first non-whitespace character is  
+        a comment (ie it is ignored). Finally, if a message line omits 
+        the &lt;message type> and &lt;args> fields and starts with the `+'
+        before the &lt;identifier> field, it specifies a message fragment.
+        Message fragments are used in building up messages.</para>
+
+      <para>Message numbers should be unique across all 
+        <filename>.msg</filename> files in a single library or 
+        application.</para>
+
+      <para>Message arguments come from classes derived from
+	<classname>MessageArg</classname>.
+	<classname>StringMessageArg</classname> is a string, 
+	<classname>NumberMessageArg</classname> is an unsigned long.</para> 
+
+      <para>There is a special form of message which also gives a location for
+	the error which can be defined by adding one more field of the form
+	+<replaceable>&lt;aux text></replaceable> at the end of message
+	definition. <replaceable>&lt;aux text></replaceable> will usually be
+	an explanation of the location like "first definition was here" (for a
+	duplicate definition error). This form of message is only implemented
+	for <replaceable>&lt;args></replaceable>&le;1.</para> 
+
+      <para>Issuing a message is done by a call of the form
+	<function>message(<replaceable>&lt;class></replaceable>Messages::<replaceable>&lt;identifier></replaceable>, ...)</function>
+	
+	where <replaceable>&lt;class></replaceable> is the class to which the
+	message belongs and <replaceable>&lt;identifier></replaceable> is the
+	identifier used in the message definition. The remaining arguments to
+	the <function>message()</function> call must match the %n placeholders
+	in the message. For messages which give location information, the last
+	argument must be an object of type
+	<classname>Location</classname>.</para>  
+    </sect2>
+  </sect1>
+  <sect1>
+    <title>General overview</title>
+    <sect2>
+      <title>Program structure</title>
+
+      <para>Most of OpenSP and OpenJade is user-interface independent: 
+       it doesn't know
+	whether it's being run from the command line or from a GUI. The 
+	code is organized in several layers.</para>
+      <orderedlist>
+	<listitem><para>The lowest layer is a general purpose class library (mostly
+	  template based), which is independent of
+	  <acronym>SGML</acronym>/<acronym>XML</acronym>.
+	</para></listitem>
+	<listitem><para>The next layer is a general concept of an entity
+	  manager, which is basically an interface to set of services to an
+	  <acronym>SGML</acronym> parser; basically it's everything that the
+	  <acronym>SGML</acronym> standard leaves undefined or makes 
+	  system-dependent for an <acronym>SGML</acronym> parser.  This layer
+	  includes the message reporting API
+	  (<classname>MessageReporter</classname>,
+	  <classname>Message</classname>), catalog API 
+	  (<classname>EntityCatalog</classname>), 
+	  character set API (<classname>CharsetInfo</classname>), and the
+	  entity manager proper
+	  (<classname>EntityManager</classname>). Template instantations for
+	  this are in <filename>entmgr_inst.m4</filename>.
+	</para></listitem>
+	<listitem><para>Dependent on the first two layers is the core
+	  <acronym>SGML</acronym> parser.  This only implements the behaviour
+	  defined in the <acronym>SGML</acronym> standard.  Main public  
+	  classes are <classname>SgmlParser</classname> and
+	  <classname>Event</classname>. Template instantations for this are in 
+	  <filename>parser_inst.m4</filename>.
+	</para>
+	</listitem>
+	<listitem><para>The architectural forms engine. It depends on the
+	  <acronym>SGML</acronym> parser. Main class is
+	  <classname>ArcEngine</classname>. 
+	  Template instantiations are in
+	  <filename>arc_inst.m4</filename>.</para>
+	</listitem>
+	<listitem><para>An implementation of the entity manager interface. This
+	  doesn't depend on the <acronym>SGML</acronym> parser or achitectural
+	  forms engine. Main class is
+	  <classname>ExtendEntityManager</classname>. This for example 
+	  determines what the syntax of a system identifier is. Template
+	  instantiations for this are in
+	  <filename>xentmgr_inst.m4</filename>.</para>
+	</listitem>
+	<listitem><para>A generic interface to groves; in
+	  <filename>grove/Node.h</filename>.  This doesn't depend 
+	  on any of the previous layers.</para>
+	</listitem>
+	<listitem><para>An implementation of the grove interface using OpenSP;
+	  this is in the <filename>spgrove/</filename> directory. Main class
+	  is <classname>GroveBuilder</classname>. This doesn't depend on the
+	  implementation of the entity manager interface.</para>
+	</listitem>
+	<listitem><para>An implementation of the <acronym>DSSSL</acronym> style
+	  language (the tree construction part, not the formatting part). 
+	  This is in the <filename>style/</filename> directory.  There
+	  are really two sub parts:</para>
+	  <orderedlist>
+	    <listitem><para>Packaging of the <acronym>DSSSL</acronym>
+		stylesheet as an <acronym>SGML</acronym> document using
+		architectural forms. Main classes are
+		<classname>DssslSpecEventHandler</classname> and  
+		<classname>StyleEngine</classname>. This doesn't depend on
+		the implemenation of the entity manager and grove
+		interfaces.</para>
+	    </listitem>
+	    <listitem><para>Processing of the contents of the elements in
+		the <acronym>DSSSL</acronym> stylesheet; this depends only
+		on the entity manager and grove interfaces.
+		The main interface here is <classname>FOTBuilder</classname>
+		which is the interface between the tree construction process
+		and the formatter.</para>
+	    </listitem>
+	  </orderedlist>
+	</listitem>
+	<listitem><para>Multiple implementations of the
+	    <classname>FOTBuilder</classname> interface (the backends).</para> 
+	</listitem>
+      </orderedlist>
+      <para>Parallel to the hierarchy of layers is a hierarchy of convenience
+	classes that collect together various pieces in a convenient way for
+	command line apps.</para>
+      <orderedlist>
+	<listitem><para><classname>CmdLineApp</classname> is the lowest level
+	  and depends only on the general purpose class library.</para></listitem>
+	<listitem><para><classname>EntityApp</classname> additionally depends on 
+	  the entity manager interface and implementation; it's a convenience
+	  class for accessing the functionality of the entity manager with a
+	  command line program.</para></listitem> 
+	<listitem><para><classname>ParserApp</classname> additionally depends on the
+	  <acronym>SGML</acronym> parser; it packages the parser together with
+	  the entity manager for use in a command line program.</para></listitem>
+	<listitem><para><classname>GroveApp</classname> additionally depends on the
+	  grove interface and implementation; this packages the functionality
+	  of the grove builder in a convenient way for command line
+	  apps.</para></listitem>  
+	<listitem><para><classname>DssslApp</classname> additionally depends on 
+	  <acronym>DSSSL</acronym> style language implementation, tieing it to
+	  the grove implementation; it is packaging up the functionality of
+	  the <acronym>DSSSL</acronym> tree construction in a way suitable for
+	  command line apps.</para></listitem> 
+	<listitem><para><classname>JadeApp</classname> additionally depends on the
+	  backends.</para></listitem>
+      </orderedlist>
+    </sect2>
+    <sect2>
+      <title>Other important classes</title>
+      <para>Short descriptions of several central classes in the
+      <acronym>DSSSL</acronym> style language implementation, some of which
+	have not yet been mentioned.</para>
+      <variablelist>
+	<varlistentry>
+	  <term><classname>StyleEngine</classname></term>
+	  <listitem>
+	    <para>main class of the style
+	      library. <classname>DssslApp</classname> 
+	      uses an instance of this class to process the grove.</para>
+	  </listitem>
+	</varlistentry>
+	<varlistentry>
+	  <term><classname>Interpreter</classname></term>
+	  <listitem>
+	    <para>contains all the stylesheet-related state:
+	      there are no global
+	      variables. <classname>StyleEngine</classname> owns an instance
+	      of this class.</para>
+	  </listitem>
+	</varlistentry>
+	<varlistentry>
+	  <term><classname>SchemeParser</classname></term>
+	  <listitem>
+	    <para>parses a part of a <acronym>DSSSL</acronym> spec, creating
+	      expression language objects and binding variables using a given
+	      <classname>Interpreter</classname>.
+	      <classname>StyleEngine</classname> uses instances of this class 
+	      to parse the parts of its spec.</para>
+	  </listitem>
+	</varlistentry>
+	<varlistentry>
+	  <term><classname>ProcessContext</classname></term>
+	  <listitem>
+	    <para>holds the current state of the processing of a grove.</para>
+	  </listitem>
+	</varlistentry>
+	<varlistentry>
+	  <term><classname>VM</classname></term>
+	  <listitem>
+	    <para>represents the state of the virtual machine that
+	      implements the expression language.</para>
+	  </listitem>
+	</varlistentry>
+	<varlistentry>
+	  <term><classname>Expression</classname></term>
+	  <listitem>
+	    <para><classname>Expression</classname>s are the result of parsing
+	      expression language constructs. They are compiled to
+	      <classname>Insn</classname>s.</para> 
+	  </listitem>
+	</varlistentry>
+	<varlistentry>
+	  <term><classname>Insn</classname></term>
+	  <listitem>
+	    <para>an instruction for the virtual machine.</para>
+	    <para>When an instruction is executed it modifies the state of the
+	      virtual machine (usually) and then returns the next instruction
+	      to be executed. Returning a null <classname>Insn</classname>
+	    terminates execution.  Thus the inner loop of the expression
+	      evaluator is in a member function of <classname>VM</classname>
+	    and looks like:  
+	    </para>
+	    <programlisting>  
+while (insn)
+    insn = insn->execute(*this);
+</programlisting>
+	  </listitem>
+	</varlistentry>
+	<varlistentry>
+	  <term><classname>ELObj</classname></term>
+	  <listitem>
+	    <para>the abstract base class for all expression language
+	    types.</para> 
+	  </listitem>
+	</varlistentry>
+      </variablelist>
+    </sect2>
+    <sect2 id="GC">
+      <title>Garbage collection</title>
+
+      <para>
+	For further information on the garbage collection technique used in
+	Jade, look at <ulink url="ftp://ftp.cs.utexas.edu/pub/garbage/bigsurv.ps">ftp://ftp.cs.utexas.edu/pub/garbage/bigsurv.ps</ulink> and
+	<ulink
+	       url="ftp://ftp.netcom.com/pub/hb/hbaker/NoMotionGC.html">ftp://ftp.netcom.com/pub/hb/hbaker/NoMotionGC.html</ulink>.</para>
+
+      <para>Basically it works like a copying collector, but the copying is
+	logical rather than physical.  There are two doubly-linked lists one
+	for each of the two spaces of a copying collector.  Every object is
+	one of these two lists.  There's also a bit (the "color") which says
+	which space it is in. To "copy" an object from one space to another,
+	it is unlinked from one list, linked into the other, and its color is
+	flipped.  A key point is that unlike normal copying collectors, this
+	collector never changes the address of a GC object.
+      </para>
+      <para>This is a simplification. It is optimized so that there is one big 
+	circular list of all objects. A pointer into the list separates the 
+	allocated from the free list.  Allocating just moves the pointer along 
+	the list.
+      </para>
+      <para>Garbage collection starts with a set of root objects (more on this 
+	later). It finds all objects reachable from this set of root objects. 
+	All objects not reachable are considered garbage and are put on the
+	free list where they can be reused.  If garbage collection doesn't
+	free up enough objects, then more memory is allocated from the system.
+      </para>
+      <para>There are a couple of twists beyond what's described in the Wilson
+	paper:
+      </para>
+      <orderedlist>
+	<listitem><para>It supports finalization (the ability to call an GC object's
+	  destructor when the object is GCed).  All finalizable objects occur
+	  before non-finalizable objects in the allocated list.  The garbage
+	  collection arranges so that immediately after completing the copy
+	  part of a garbage collection, the objects needing finalization are
+	  at the head of the free list, thus allowing the collector to
+	  efficiently perform finalization.
+	</para></listitem>
+	<listitem><para>Objects which are created during the parsing of the
+	  stylesheet, which can never become garbage during the processing of
+	  the source document, are separated off into a separate area (these
+	  are called "permanent").  All objects reachable from a permanent
+	  object must themselves be permanent.
+	</para></listitem>
+	<listitem><para>It has the concept of an object being read-only: it can mark
+	  an object and all objects reachable from that object as being
+	  read-only (needed for OpenJade extensions which allow limited mutation
+	  of objects). 
+	</para></listitem>
+	<listitem><para>It always allocates a fixed amount of space for a GC object;
+	  so the <function>sizeof()</function> any object derived from
+	  <classname>ELObj</classname> must be &le; this space. How big 
+	  is it? On a 32-bit machine there is space for 16 bytes (eg 4
+	  pointers, or a double+int+pointer) beyond what is used by the
+	  <classname>ELObj</classname> itself.  On a 64-bit machine it will be
+	  about twice that; <function>maxObjSize()</function> in
+	  <filename>style/Interpreter.cxx</filename> figures it out at
+	  runtime, so to be safe add any new  types of
+	  <classname>ELObj</classname> to the table in
+	  <function>maxObjSize()</function>.  But make 
+	  sure you don't use more than 16 bytes on a 32-bit machine, otherwise
+	  you will significantly increase Jade's memory consumption.  If you
+	  need more space than this, then the <classname>ELObj</classname>
+	  should have a pointer to dynamically allocated memory; in this case
+	  you must deallocate the memory in the destructor.  In this case and
+	  any other case where an <classname>ELObj</classname> has a  
+	  destructor that must be called, you must declare an operator
+	  <function>new()</function>:
+<programlisting>	  
+void *operator new(size_t, Collector &amp;c) 
+{
+  return c.allocateObject(1);
+}
+</programlisting>
+This tells the garbage collector that the object has a destructor that
+must be called when the object becomes garbage.
+</para></listitem>
+</orderedlist>
+
+      <para>A key aspect of correct use of the garbage collector is to ensure
+	that the collector always has a sufficient set of roots.  Any time
+	that C++ code does anything that may allocate a GC object, any GC
+	object that is not reachable from a root object may get recycled by
+	the system.  The way to create a root is to use an auto variable of
+	type <classname>ELObjDynamicRoot</classname>.  An
+	<classname>ELObjDynamicRoot</classname> adds a single
+	<classname>ELObj</classname> as a root for the
+	<classname>Collector</classname> for as long as the
+	<classname>ELObjDynamicRoot</classname> is in scope.  The first
+	argument of the <classname>ELObjDynamicRoot</classname> constructor
+	specifies the collector. The second argument specifies the
+	<classname>ELObj</classname> that is to be made a root. The
+	<classname>ELObj</classname> that the
+	<classname>ELObjDynamicRoot</classname> causes to be a 
+	root can be changed by assiging an <classname>ELObj</classname> to the
+	<classname>ELObjDynamicRoot</classname>.  There's also a  
+	conversion from <classname>ELObjDynamicRoot</classname> to
+	<classname>ELObj</classname> *.</para>
+      <example>
+	<title>The <function>reverse()</function> function</title>
+      <programlisting>
+DEFPRIMITIVE(Reverse, argc, argv, context, interp, loc)
+{
+  ELObjDynamicRoot protect(interp, interp.makeNil());
+  ELObj *p = argv[0];
+  while (!p->isNil()) {
+    PairObj *tem = p->asPair();
+    if (!tem)
+      return argError(interp, loc,
+		      InterpreterMessages::notAList, 0, argv[0]);
+    protect = new (interp) PairObj(tem->car(), protect);
+    p = tem->cdr();
+  }
+  return protect;
+}
+</programlisting>
+	<para>protect is a dynamic root that contains the currently created
+	  part of the reversed node list.  Making this a root ensures that all
+	  the newly created <classname>PairObj</classname>s are reachable from
+	  a root.</para>
+      </example>
+      <example>
+	<title>The <function>NodeListRef()</function> function</title>
+      <para>The <function>NodeListRef()</function> function gives an example of
+	the sort of bug that can creep in if you're not very careful. This
+	used to end like this:
+	<programlisting>
+return new (interp) 
+    NodePtrNodeListObj(nl->nodeListRef(k, context, interp));
+	</programlisting>
+	  The <function>nodeListRef()</function> function sometimes
+	allocatesthat it takes an <classname>Interpreter</classname> argument
+	is a good clue).  So what could happen is:</para>
+	<orderedlist>
+	  <listitem><para>operator <function>new()</function> gets called to
+	    allocate a new object</para></listitem> 
+	  <listitem><para><function>nodeListRef()</function> gets called in a
+	    way that causes an allocation</para></listitem> 
+	  <listitem><para>the free list happens to be empty, so the garbage
+	    collector gets run; the newly allocated object is not reachable
+	    from a root, so it gets GCed and recycled</para></listitem>
+	  <listitem><para>the constructor gets called with a GC object that
+	    the garbage collector thinks is free</para></listitem>
+	</orderedlist>
+      <para>
+	The fix was to rewrite it as:
+	<programlisting>  
+NodePtr nd(nl->nodeListRef(k, context, interp));
+return new (interp) NodePtrNodeListObj(nd);
+	</programlisting>	
+      </para>
+      </example>
+      <para>Another key aspect of correct use of the garbage collector is to 
+        ensure that objects with garbage-collected subobjects inform the 
+        collector of the references to the subobjects they hold. To do so, 
+        they must override 
+        <code>Collector::Object::traceSubObjects(Collector &)</code>
+        to call <code>Collector::trace(const Object *)</code> for each 
+	subobject.</para>
+    </sect2>
+  </sect1>
+  <sect1>
+    <title>How to add a new application</title>
+    <para>Create a subclass of one of the <classname>App</classname> classes;
+      use the macro SP_DEFINE_APP.</para>
+    <para>TODO: This needs more detail. Perhaps 
+      use <command>spcat</command> as example.</para>
+  </sect1>
+  <sect1>
+    <title>Extending OpenJade</title>
+    <sect2>
+      <title>Utility classes</title>
+      <para>TODO: Explain Char, String, Vector, StringC, Ptr, Owner</para>
+      <para>TODO: Maybe move this to the "General overview".</para>
+    </sect2>
+    <sect2>
+      <title>Primitives</title>
+      <para>Primitives of the expression language, the SDQL and the style
+	language are implemented as subclasses of
+      <classname>PrimitiveObj</classname> 
+	(<filename>style/Insn.h</filename>,
+      <filename>style/Insn.cxx</filename>). All primitives are defined in the
+	files <filename>style/primitive.h</filename> and
+      <filename>style/primitive.cxx</filename>. Adding a new primitive is done
+      by adding a macro call of the form
+	<programlisting format="linespecific">
+PRIMITIVE(<replaceable>&lt;class name prefix></replaceable>,
+	  "<replaceable>&lt;primitive name></replaceable>", 
+          <replaceable>&lt;req. args></replaceable>, <replaceable>&lt;opt. args></replaceable>, <replaceable>&lt;rest arg></replaceable>,
+	  <replaceable>&lt;feature></replaceable>)
+	</programlisting>
+	to <filename>style/primitive.h</filename> and a macro call of the form
+	<programlisting format="linespecific">
+DEFPRIMITIVE(<replaceable>&lt;class name prefix></replaceable>, argc, argv,
+	     context, interp, loc)
+	</programlisting>
+	to <filename>style/primitive.cxx</filename>, followed by the body of
+	the function 
+	<function>PrimitiveObj::primitiveCall()</function> as needed for the
+	function you want to add.</para>
+
+      <para>For procedures that are specific to the style language,
+	use SPRIMITIVE instead of PRIMITIVE. Likewise, procedures that
+	are specific to the experimental so-called DSSSL-2 option, are
+	declared with the PRIMITIVE2 macro.</para>
+
+      <para>External procedures found in Jade 1.2.1 use XPRIMITIVE instead of PRIMITIVE.
+	These procedures are accessed using a public identifier of the form:</para>
+      <para>"UNREGISTERED::James Clark//Procedure::<replaceable>&lt;primitive name></replaceable>".</para>    
+      <para>External procedures added to OpenJade should be declared
+	using XXPRIMITIVE and are accessed using a public identifier
+	of the form:</para>
+      <para>"UNREGISTERED::OpenJade//Procedure::<replaceable>&lt;primitive name></replaceable>"</para>
+      <example>
+	<title>The <function>sin</function> function</title>
+	<para>We can add the <function>sin</function> defined in clause
+	  8.5.7.18 of the <acronym>DSSSL</acronym> standard by appending
+	  <programlisting>
+PRIMITIVE(Sin, "sin", 1, 0, 0)
+	  </programlisting>      
+	  to <filename>style/primitive.h</filename> and 
+	  <programlisting>
+DEFPRIMITIVE(Sin, argc, argv, context, interp, loc)
+{
+  double d;
+  if (!argv[0]->realValue(d)) 
+  return argError(interp, loc,
+		    InterpreterMessages::notANumber, 0, argv[0]);
+  return new (interp) RealObj(sin(d));
+}
+	  </programlisting>      
+	  to <filename>style/primitive.cxx</filename>.</para>
+      </example>
+    </sect2>
+    <sect2>
+      <title>Expression language types</title>
+      <para>Relevant classes:</para>
+      <variablelist>
+	<varlistentry>
+	  <term><classname>ELObj</classname></term> 
+	  <listitem>
+	    <para>Adding a new expression language type
+	      is done by adding a new subclass of
+	      <classname>ELObj</classname>. Make sure to follow the advise
+	      in the section on garbage collection with respect to the size of
+	      the subclass.</para>
+	  </listitem> 
+	</varlistentry>
+	<varlistentry>
+	  <term>SchemeParser</term>
+	  <listitem>
+	    <para>You will have to add a method for generating
+	      objects of the new type. This will generally involve a line like 
+	      <programlisting>
+result = new (*interp_) <replaceable>&lt;your class></replaceable>(...)
+	      </programlisting>    
+       The <code>*interp_</code> argument to new is important to make
+       the newly generated object properly garbage collected.</para>
+	  </listitem>
+	</varlistentry>
+      </variablelist>
+      <para>TODO: is this all ? add an example!</para>
+    </sect2>
+    <sect2>
+      <title>Backends</title>
+      <para>In order to create a completely new backend, you first
+	need to create a new subclass of
+	<classname>FOTBuilder</classname> or
+	<classname>SerialFOTBuilder</classname> implementing the output 
+	format you are interested in. It is probably a good idea to
+	take an existing backend as a skeleton.</para>
+      <para>TODO: More detail needed.</para>
+
+      <para>To make the new backend available to OpenJade, you have to
+	add new values for your backend to 
+	<type>JadeApp::OutputType</type> and
+	<type>JadeApp::outputTypeNames</type> and add a new 
+	case to the switch statement in 
+	<function>JadeApp::makeFOTBuilder()</function> 
+	returning an instance of your <classname>FOTBuilder</classname>
+	subclass.</para>  
+    </sect2>
+    <sect2>
+      <title>Flow objects</title>
+      <para>For a standard flow object, you must create
+	a new subclass of <classname>FlowObj</classname> (atomic)
+	or <classname>CompoundFlowObj</classname> (nonatomic).
+	Do not forget to add a FLOW_OBJ macro call for the new class
+	in the <function>Interpreter::installFlowObjs()</function> function
+	in <filename>style/FlowObj.cxx</filename>.</para>
+      
+      <para>The FlowObj class has two members: one pointer and one
+	<classname>Owner</classname> (which takes up the same space as
+	a pointer). So, on a 32-bit machine for example, there is 8
+	bytes (two pointers) left for data members. The
+	<classname>CompoundFlowObj</classname> class adds one more data
+	member (a pointer), so you may have at most one pointer in a
+	subclass of that class. (See <xref linkend="gc"> for more
+	information.)
+      </para>
+
+      <para>The <function>processInner()</function> of the new class
+	is responsible for calling the <classname>FOTBuilder</classname>
+	function (or pair of functions for nonatomic flow objects) associated
+	with the flow object in question. You may have to add these
+	functions to the interface of the <classname>FOTBuilder</classname>
+	class and provide default definitions there. These have to
+	be overridden by the backends (<classname>FOTBuilder</classname>
+	subclass) in order to implement the flow object in question.</para>
+
+      <para>For a compound flow object, this function also has to tell the
+	<classname>ProcessContext</classname> what ports this flow
+	object has and what content these prots accept. This is done
+	by calling
+	<function><classname>ProcessContext</classname>>::pushPorts()</function>
+	and
+	<function><classname>ProcessContext</classname>::popPorts()</function>
+	if the flow object has any named ports, or
+	<function><classname>ProcessContext</classname>::pushPrincipalPort()</function>
+	and
+	<function><classname>ProcessContext</classname>::popPrincipalPort()</function>
+	if the flow object has a single principal port. You also have
+	to provide subclasses of
+	<classname>ProcessContext::Validator</classname> for each port.</para>
+
+      <para>The <function>acceptFlags()</function>
+	<classname>FlowObj</classname> member function should return
+	flags describing the flow object (i.e. if it is inline or
+	display, for example). This information is used by the
+	validation mechanism.</para>
+
+      <para>TODO: explain extension flow objects</para>
+    </sect2>
+    <sect2>
+      <title>Command line switches</title>
+      <para>If you are adding a new OpenJade-specific option, add it to 
+	<classname>JadeApp</classname>. If the option you are adding
+	influences the behaviour of the style engine, add it to
+      <classname>DssslApp</classname>.</para> 
+
+      <para>Adding an option amount to registering it in the constructor 
+	with <function>registerOption()</function> and handling it in
+	<function>processOption()</function>. 
+      </para>
+      
+      <para>The <classname>CmdLineApp</classname> supports only single-letter options. You should
+	make sure that you don't choose a letter that is already taken:
+      </para>
+      <variablelist>
+	<varlistentry>
+	  <term>b, f, v</term>
+	    <listitem><para>registered by
+		<classname>CmdLineApp</classname></para></listitem> 
+	</varlistentry>
+	<varlistentry>
+	  <term>c, C, D</term>
+	    <listitem><para>registered by
+		<classname>EntityApp</classname></para></listitem> 
+	</varlistentry>
+	<varlistentry>
+	  <term>a, A, e, E, g, i, w</term>
+	    <listitem><para>registered by
+		<classname>ParserApp</classname></para></listitem> 
+	</varlistentry>
+	<varlistentry>
+	  <term>G, 2, d, V, s</term>
+	    <listitem><para>registered by
+		<classname>DssslApp</classname></para></listitem>
+	</varlistentry>
+	<varlistentry>
+	  <term>t, o</term>
+	    <listitem><para>registered by
+		<classname>JadeApp</classname></para></listitem>
+	</varlistentry>
+      </variablelist>    
+      <example>
+	<title>A -s flag for <classname>DssslApp</classname></title>
+	<para>Lets assume you have changed the
+	  <classname>StyleEngine</classname> constructor to accept one
+	  more bool parameter strict_, which you want to be set depending
+	  on the -s command line flag.</para>
+
+	<para>We add a new private member strict_ to
+	  <classname>DssslApp</classname> to hold the value until we pass
+	  it to the <classname>StyleEngine</classname> constructor. Thus we
+	  insert
+	<programlisting format="linespecific">
+bool strict_;	  
+	</programlisting>
+	  at the very end of the <classname>DssslApp</classname> class
+	  declaration in <filename>style/DssslApp.h</filename>.</para>
+	<para>Now we change the constructor to
+	  <programlisting>
+DssslApp::DssslApp(int unitsPerInch)
+: GroveApp("unicode"), unitsPerInch_(unitsPerInch),
+  dssslSpecOption_(0), debugMode_(0), dsssl2_(0),
+  strict_(0)  // this line is new
+{
+  registerOption('G');
+  registerOption('2');
+  registerOption('d', SP_T("dsssl_spec"));
+  registerOption('V', SP_T("variable"));
+  registerOption('s'); // this line is new
+}
+	  </programlisting> 
+	  and the function <function>processOption()</function> to
+	  <programlisting format="linespecific">
+void DssslApp::processOption(AppChar opt, const AppChar *arg)
+{
+  switch (opt) {
+  case 's':  // new case        
+    strict_ = 1;
+    break;
+  /* other cases stay the same */
+    }
+}
+	  </programlisting>
+	  Finally, we change the call of the
+	  <classname>StyleEngine</classname> constructor in
+	  <function>processGrove()</function> to
+	  <programlisting format="linespecific">
+StyleEngine se(*this, *this, unitsPerInch_, debugMode_, 
+               dsssl2_, strict_, extensions);
+	  </programlisting>
+	  </para>
+      </example>
+    </sect2>
+    <sect2>
+      <title>Supporting a larger grove plan</title>
+      <para>TODO: how is this done ?</para>
+    </sect2>
+    <sect2>
+      <title>Translating messages</title>
+      <para>I can explain this only for the <function>gettext()</function>
+        support.</para>
+	<step performance="required">
+          <para>Make sure <function>gettext()</function> is supported on
+            your system.</para>
+	<step performance="required">
+          <para>Modify <filename>msggen.pl</filename> by changing the
+            line 
+<programlisting>
+$gen_po = 0;
+</programlisting>
+to
+<programlisting>
+$gen_po = 1; 
+</programlisting>
+</para>
+	<step performance="required">
+	  <para>Build everything.</para>
+	</step>
+	<step performance="required">
+	  <para>Collect the various <filename>.po</filename> files in one big 
+            one:</para>
+	  <programlisting format="linespecific">
+for i in */*.po; do cat $i >> messages.po; done
+	  </programlisting>
+	</step>
+	<step performance="required">
+	  <para>Make a copy of <filename>messages.po</filename> for
+	    the language you are interested in and add the translations.</para>
+	</step>
+	<step performance="required">
+	  <para>Compile the translated file and install the resulting
+	    <filename>.mo</filename> file under the name
+	    <filename>sp.mo</filename> in the appropriate directory:</para> 
+	  <programlisting format="linespecific">
+msgfmt -o de.mo de.po
+cp de.mo /usr/local/share/locale/de/LC_MESSAGES/sp.mo
+	  </programlisting>
+	</step>
+      </procedure>
+    </sect2>
+  </sect1>
+</article>
+
+
--- openjade-1.4devel1.orig/develdoc/missing
+++ openjade-1.4devel1/develdoc/missing
@@ -0,0 +1,240 @@
+This collects stuff from the DSSSL standard which is 
+not implemented (yet) in OpenJade. A '+' at the end of 
+a line indicates that there is a patch implementing it.
+A '*' indicates it is already in CVS.
+
+
+missing DSSSL architectural element forms
+=========================================
+
+7.1.1	features                * 
+7.1.2	sgml-grove-plan         * 
+7.1.3	char-repertoire		* 
+7.1.5	other-chars             +
+7.1.6	baseset-encoding        + (the patch is only semi-functional)
+7.1.7	literal-described-char  + (the patch is only semi-functional)
+7.1.9	add-separator-chars	*
+7.1.10	add-name-chars		*
+7.1.11	combine-char            + (the patch is only semi-functional)
+
+
+missing expression language primitives
+======================================
+
+8.5.8.1		declare-char-property *
+		add-char-properties   *
+8.5.8.2		language?	 *
+		current-language *
+		with-language	 *
+8.5.8.2.1	define-language	 *
+8.5.8.4		char<?		 *
+		char>?		 *
+		char<=?		 * 
+		char>=?		 *
+8.5.8.5		char-ci<?	 *
+		char-ci>?	 *
+		char-ci<=?	 *
+		char-ci>=?	 *
+8.5.8.6		char-upcase	 *
+		char-downcase	 *
+8.5.8.7		char-property	 * 
+8.5.9.5		string-ci=?	 *
+		string-equiv?	 *
+8.5.9.6		string<?	 *
+		string>?	 *
+		string<=?	 *
+		string>=?	 *
+		string-ci<?	 *
+		string-ci>?	 *
+		string-ci<=?	 *
+		string-ci>=?	 *
+
+
+missing property set modules
+============================
+
+basesds1
+sdclabs
+sdclsds
+prlgabs1			* 
+prlgsds
+instsds1
+dtgabs
+rankabs				*
+srabs
+srsds
+linkabs
+linksds
+subdcsds
+fpiabs				*
+
+
+missing SDQL primitives
+=======================
+
+10.1.1	current-root         *
+10.2.1	value-proploc
+	list-proploc
+	node-list-proploc
+	listloc
+	nameloc
+	groveloc
+	treeloc
+	pathloc
+	relloc-any
+	relloc-esib
+	relloc-ysib
+	relloc-des
+	datatok
+	make-grove
+	literal-match
+	hylex-match
+	compare
+	ordered-may-overlap?
+	ordered-no-overlap?
+	span
+10.2.2	node-list-reduce                *
+	node-list-contains?		*
+	node-list-remove-duplicates	*
+	node-list-union			*
+	node-list-intersection		*
+	node-list-difference		*
+	node-list-symmetric-difference	*
+	node-list-map			*
+	node-list-union-map		*
+	node-list-some?			*
+	node-list-every?		*
+	node-list-filter		*
+	node-list->list			*
+	node-list-tail			*
+	node-list-head			*
+	node-list-sublist		*
+	node-list-count			*
+	node-list-last			*
+	there-exist?                    *
+	for-all?                        *
+	select-each                     *
+	union-for-each                  *
+10.2.3	node-list-property		*
+	origin				*
+	origin-to-subnode-rel		*
+	tree-root			*
+	grove-root			*
+	source				*
+	subtree				*
+	subgrove			*
+	ancestors			*
+	grove-root-path			*
+	rsiblings			*
+	ipreced				*
+	ifollow				*
+	grove-before?			*
+	sort-in-tree-order		*
+	tree-before?			*
+	tree-before			*
+	property-lookup			*
+	select-by-property		*
+	select-by-null-property		*
+	select-by-missing-property	*
+10.2.5	attribute			*
+	referent			*
+	q-element			*
+	q-class				*
+	q-sdata				*
+10.3.1 	word-parse
+	select-tokens
+10.3.2	regexp?
+10.3.3	regexp-node
+	regexp-seq
+	regexp-or
+	regexp-and
+	regexp-rep
+	regexp-plus
+	regexp-opt
+	regexp-range
+	string->regexp
+10.3.4	regexp-search
+	regexp-search-disjoint
+
+
+Transformation language
+=======================
+
+
+Style language
+==============
+
+12.4.1   query					*
+12.4.6	 char-script-case
+	 declare-char-characteristic+property	*
+12.4.7	 sync
+	 side-sync
+12.5.1	 generated-object?
+12.5.1.1 general-indirect-sosofo
+	 asis-indirect-sosofo
+	 number-indirect-sosofo
+12.5.1.2 page-number
+	 category-page-number
+	 page-number-in-node
+	 total-node-page-numbers
+	 column-number
+	 footnote-number
+	 line-number
+12.5.1.3 declare-reference-value-type
+	 first-area-reference-value	 
+	 last-area-reference-value	 
+	 last-preceding-area-reference-value	 
+	 all-area-reference-value	 
+12.5.3	 decoration-area
+	 decorated-area-width
+	 decorated-area-height
+12.5.7	 font-property
+
+
+Missing color spaces
+====================
+
+ISO/IEC 10179:1996//Color-Space Family::Device Gray     *
+ISO/IEC 10179:1996//Color-Space Family::Device CMYK     *
+ISO/IEC 10179:1996//Color-Space Family::Device KX       *
+ISO/IEC 10179:1996//Color-Space Family::CIE LAB         *
+ISO/IEC 10179:1996//Color-Space Family::CIE LUV         *
+ISO/IEC 10179:1996//Color-Space Family::CIE Based ABC   *
+ISO/IEC 10179:1996//Color-Space Family::CIE Based A     *
+
+
+Missing flow object classes
+===========================
+
+page-sequence       (and related expression language primitives and types) 
+column-set-sequence (and related expression language primitives and types) 
+anchor
+embedded-text
+included-container-area
+side-by-side                    * (only some backends)
+side-by-side-item               * (only some backends)
+glyph-annotation
+aligned-column
+multi-line-inline-note
+emphasizing-mark
+
+
+Ignored inherited characteristics
+=================================
+
+force!c                         *
+inline-space-space              *
+line-miter-limit
+alignment-point-offset
+hyphenation-char
+asis-truncate-char
+asis-wrap-char
+first-line-align
+hyphenation-exceptions
+box-corner-rounded
+table-corner-rounded
+line-dash
+allowed-ligatures
+line-number
+line-spacing-priority
+char-map			* 
--- openjade-1.4devel1.orig/dsssl/Makefile.am
+++ openjade-1.4devel1/dsssl/Makefile.am
@@ -3,10 +3,12 @@
 pkgdata_DATA = builtins.dsl catalog dsssl.dtd \
 	style-sheet.dtd spec.dtd fot.dtd extensions.dsl 
 
-docdir = $(prefix)/doc
+docdir = $(datadir)/doc
 pkgdocdir = $(docdir)/@PACKAGE@
 
 pkgdoc_DATA = demo.dsl demo.sgm 
 
 EXTRA_DIST = builtins.dsl catalog demo.dsl demo.sgm dsssl.dtd \
 	extensions.dsl fot.dtd spec.dtd style-sheet.dtd
+
+MAINTAINERCLEANFILES = Makefile.in
--- openjade-1.4devel1.orig/dsssl/builtins.dsl
+++ openjade-1.4devel1/dsssl/builtins.dsl
@@ -342,7 +342,7 @@
 		    nl))
 
 ;; clause 10.2.5
-(define (attribute string nl)
+(define (attribute name nl)
   (node-list-map (lambda (snl)
 		   (named-node name (attributes snl)))
 		 nl))
--- openjade-1.4devel1.orig/dsssl/extensions.dsl
+++ openjade-1.4devel1/dsssl/extensions.dsl
@@ -135,6 +135,10 @@
   "UNREGISTERED::James Clark//Characteristic::page-balance-columns?"
   #f)
 
+(declare-characteristic page-two-side?
+  "UNREGISTERED::OpenJade//Characteristic::page-two-side?"
+  #f)
+
 (declare-characteristic superscript-height
   "UNREGISTERED::James Clark//Characteristic::superscript-height"
   0pt)
--- openjade-1.4devel1.orig/grove/Makefile.am
+++ openjade-1.4devel1/grove/Makefile.am
@@ -2,7 +2,7 @@
 
 lib_LTLIBRARIES = libogrove.la
 
-libogrove_la_LDFLAGS = -version-info 0:0:0
+libogrove_la_LDFLAGS = -version-info 1:0:0
 
 libogrove_la_SOURCES = Node.h Node.cxx LocNode.h LocNode.cxx
 
@@ -10,3 +10,5 @@
 pkginclude_HEADERS = Node.h
 
 EXTRA_DIST = grove.dsp
+
+MAINTAINERCLEANFILES = Makefile.in
--- openjade-1.4devel1.orig/grove/Node.cxx
+++ openjade-1.4devel1/grove/Node.cxx
@@ -547,7 +547,7 @@
       ret = getEntityType(type);
       if (ret == accessOK) {
 	switch (type) {
-#define ENUM(e, E) case EntityType::##e: value.set(ComponentName::id##E); break;
+#define ENUM(e, E) case EntityType::e: value.set(ComponentName::id##E); break;
 	  ENUM(text, Text)
 	  ENUM(cdata, Cdata)
 	  ENUM(sdata, Sdata)
@@ -567,7 +567,7 @@
       ret = getDeclValueType(type);
       if (ret == accessOK) {
 	switch (type) {
-#define ENUM(e, E) case DeclValueType::##e: value.set(ComponentName::id##E); break;
+#define ENUM(e, E) case DeclValueType::e: value.set(ComponentName::id##E); break;
 	ENUM(cdata, Cdata)
         ENUM(entity, Entity)
         ENUM(entities, Entities)
@@ -597,7 +597,7 @@
       ret = getDefaultValueType(type);
       if (ret == accessOK) {
 	switch (type) {
-#define ENUM(e, E) case DefaultValueType::##e: value.set(ComponentName::id##E); break;
+#define ENUM(e, E) case DefaultValueType::e: value.set(ComponentName::id##E); break;
         ENUM(value, Value)
         ENUM(fixed, Fixed)
         ENUM(required, Required)
@@ -617,7 +617,7 @@
       ret = getContentType(type);
       if (ret == accessOK) {
 	switch (type) {
-#define ENUM(e, E) case ContentType::##e: value.set(ComponentName::id##E); break;
+#define ENUM(e, E) case ContentType::e: value.set(ComponentName::id##E); break;
         ENUM(cdata, Cdata)
         ENUM(rcdata, Rcdata)
         ENUM(empty, Empty)
@@ -636,7 +636,7 @@
       ret = getConnector(type);
       if (ret == accessOK) {
 	switch (type) {
-#define ENUM(e, E) case Connector::##e: value.set(ComponentName::id##E); break;
+#define ENUM(e, E) case Connector::e: value.set(ComponentName::id##E); break;
         ENUM(and_, And)
         ENUM(or_, Or)
         ENUM(seq, Seq)
@@ -653,7 +653,7 @@
       ret = getOwnerType(type);
       if (ret == accessOK) {
         switch (type) {
-#define ENUM(e, E) case OwnerType::##e: value.set(ComponentName::id##E); break;
+#define ENUM(e, E) case OwnerType::e: value.set(ComponentName::id##E); break;
         ENUM(iso, Iso)
         ENUM(registered, Registered)
         ENUM(unregistered, Unregistered)
@@ -670,7 +670,7 @@
       ret = getTextClass(tclass);
       if (ret == accessOK) {
         switch (tclass) {
-#define ENUM(e, E) case TextClass::##e: value.set(ComponentName::id##E); break;
+#define ENUM(e, E) case TextClass::e: value.set(ComponentName::id##E); break;
         ENUM(capacity, Capacity)
         ENUM(charset, Charset)
         ENUM(document, Document)
--- openjade-1.4devel1.orig/groveoa/CGroveBuilder.cxx
+++ openjade-1.4devel1/groveoa/CGroveBuilder.cxx
@@ -0,0 +1,377 @@
+// CGroveBuilder.cpp : Implementation of CGroveBuilder
+
+#include "stdafx.h"
+#include "groveoa.h"
+#include "CGroveBuilder.h"
+#include "GroveBuilder.h"
+#include "ErrorCountEventHandler.h"
+#include "GroveNode.h"
+#include "MessageTable.h"
+#include "ArcEngine.h"
+#include <new>
+#include <signal.h>
+#include <process.h>
+#define STRICT
+#include <windows.h>
+
+using SP_NAMESPACE::StringC;
+
+#ifdef SP_NO_STD_NAMESPACE
+#define std /* as nothing */
+#endif
+
+#define TRY try {
+#define CATCH  } catch (std::bad_alloc) { return E_OUTOFMEMORY; }
+
+/* We need to keep a reference to the entity manager, because
+StoragePos can use storage managers that are owned by the entity
+manager. */
+
+class SpParserThread :
+	public ParserThread,
+	public SP_NAMESPACE::Messenger,
+	public SP_NAMESPACE::MessageFormatter {
+public:
+  SpParserThread() : cancel_(0) { }
+  ~SpParserThread();
+  void run();
+  void dispatchMessage(const SP_NAMESPACE::Message &);
+  SP_NAMESPACE::Boolean getMessageText(const SP_NAMESPACE::MessageFragment &, SP_NAMESPACE::StringC &);
+
+  SP_NAMESPACE::Owner<SP_NAMESPACE::EventHandler> eh;
+  SP_NAMESPACE::SgmlParser parser;
+  SP_NAMESPACE::Ptr<SP_NAMESPACE::EntityManager> em;
+  SP_NAMESPACE::Vector<SP_NAMESPACE::StringC> archNames;
+  static unsigned __stdcall start(void *p);
+private:
+  sig_atomic_t cancel_;
+  HANDLE thread_;
+};
+
+void convertBSTR(BSTR str, StringC &result)
+{
+  if (str)
+    result.assign(str, ::SysStringLen(str));
+  else
+    result.resize(0);
+}
+
+STDMETHODIMP CGroveBuilder::parse(BSTR sysid, SgmlDocumentNode **retval)
+{
+  return archParse( sysid, 0, retval );
+}
+
+STDMETHODIMP CGroveBuilder::archParse
+ (BSTR sysid, BSTR archNames, SgmlDocumentNode **retval)
+{
+  TRY
+  SpParserThread *parserThread = new SpParserThread;
+  SP_NAMESPACE::Owner<ParserThread> tem(parserThread);
+ 
+  if( archNames != 0 ) {
+    StringC archNames_;
+    convertBSTR(archNames, archNames_);
+    StringC archName;
+    for( short i = 0; i < archNames_.size(); i++ )
+      if( archNames_[i] != ' ' )
+        archName += archNames_[i];
+      else if( archName.size() != 0 ) {
+        parserThread->archNames.push_back( archName );
+        archName.resize( 0 );
+      }
+    if( archName.size() != 0 )
+      parserThread->archNames.push_back( archName );
+  }
+
+  GROVE_NAMESPACE::NodePtr root;
+  parserThread->eh
+    = SP_NAMESPACE::GroveBuilder::make(0, parserThread, parserThread, validateOnly_ != 0, root);
+  StringC str(sysid, sysid ? ::SysStringLen(sysid) : 0);
+  app_.initParser(str, parserThread->parser, parserThread->em);
+  parserThread->run();
+  return makeRootNode(root, tem, retval);
+  CATCH
+}
+
+static
+HRESULT makeBSTR(const StringC &str, BSTR *retval)
+{
+  if (str.size() == 0)
+    *retval = 0;
+  else {
+    *retval = ::SysAllocStringLen(str.data(), str.size());
+    if (!*retval)
+      return E_OUTOFMEMORY;
+  }
+  return NOERROR;
+}
+
+STDMETHODIMP CGroveBuilder::get_ExtraCatalogs(BSTR *retval)
+{
+  return makeBSTR(app_.extraCatalogs(), retval);
+}
+
+STDMETHODIMP CGroveBuilder::put_ExtraCatalogs(BSTR str)
+{
+  TRY
+  StringC tem;
+  convertBSTR(str, tem);
+  app_.setExtraCatalogs(tem);
+  return NOERROR;
+  CATCH
+}
+
+STDMETHODIMP CGroveBuilder::get_DefaultCatalogs(BSTR *retval)
+{
+  return makeBSTR(app_.defaultCatalogs(), retval);
+}
+
+STDMETHODIMP CGroveBuilder::put_DefaultCatalogs(BSTR str)
+{
+  TRY
+  StringC tem;
+  convertBSTR(str, tem);
+  app_.setDefaultCatalogs(tem);
+  return NOERROR;
+  CATCH
+}
+
+STDMETHODIMP CGroveBuilder::get_ExtraDirectories(BSTR *retval)
+{
+  return makeBSTR(app_.extraDirectories(), retval);
+}
+
+STDMETHODIMP CGroveBuilder::put_ExtraDirectories(BSTR str)
+{
+  TRY
+  StringC tem;
+  convertBSTR(str, tem);
+  app_.setExtraDirectories(tem);
+  return NOERROR;
+  CATCH
+}
+
+STDMETHODIMP CGroveBuilder::get_DefaultDirectories(BSTR *retval)
+{
+  return makeBSTR(app_.defaultDirectories(), retval);
+}
+
+STDMETHODIMP CGroveBuilder::put_DefaultDirectories(BSTR str)
+{
+  TRY
+  StringC tem;
+  convertBSTR(str, tem);
+  app_.setDefaultDirectories(tem);
+  return NOERROR;
+  CATCH
+}
+
+STDMETHODIMP CGroveBuilder::get_Encoding(BSTR *retval)
+{
+  return makeBSTR(app_.encoding(), retval);
+}
+
+STDMETHODIMP CGroveBuilder::put_Encoding(BSTR str)
+{
+  TRY
+  StringC tem;
+  convertBSTR(str, tem);
+  app_.setEncoding(tem);
+  // FIXME give an error for a illegal encoding
+  return NOERROR;
+  CATCH
+}
+
+STDMETHODIMP CGroveBuilder::get_DefaultEncoding(BSTR *retval)
+{
+  return makeBSTR(app_.defaultEncoding(), retval);
+}
+
+STDMETHODIMP CGroveBuilder::put_DefaultEncoding(BSTR str)
+{
+  TRY
+  StringC tem;
+  convertBSTR(str, tem);
+  app_.setDefaultEncoding(tem);
+  return NOERROR;
+  CATCH
+}
+
+STDMETHODIMP CGroveBuilder::get_Includes(BSTR *retval)
+{
+  TRY
+  SP_NAMESPACE::StringC tem;
+  for (size_t i = 0; i < app_.options.includes.size(); i++) {
+    if (i)
+      tem += ',';
+    tem += app_.options.includes[i];
+  }
+  return makeBSTR(tem, retval);
+  CATCH
+}
+
+STDMETHODIMP CGroveBuilder::put_Includes(BSTR str)
+{
+  TRY
+  SP_NAMESPACE::Vector<SP_NAMESPACE::StringC> &v = app_.options.includes;
+  v.resize(0);
+  if (str) {
+    SP_NAMESPACE::Boolean started = 0;
+    for (; *str; str++) {
+      if (*str == ',')
+	started = 0;
+      else {
+	if (!started) {
+	  v.resize(v.size() + 1);
+	  started = 1;
+	}
+	v.back() += *str;
+      }
+    }
+  }
+  return NOERROR;
+  CATCH
+}
+
+STDMETHODIMP CGroveBuilder::get_Warning(WarningType type, VARIANT_BOOL *retval)
+{
+  *retval = 0;
+  SP_NAMESPACE::PackedBoolean *p = lookupWarningType(type);
+  if (!p)
+    return E_INVALIDARG;
+  *retval = *p ? -1 : 0;
+  return NOERROR;
+}
+
+STDMETHODIMP CGroveBuilder::put_Warning(WarningType type, VARIANT_BOOL b)
+{
+  SP_NAMESPACE::PackedBoolean *p = lookupWarningType(type);
+  if (!p)
+    return E_INVALIDARG;
+  *p = b ? 1 : 0;
+  return NOERROR;
+}
+
+SP_NAMESPACE::PackedBoolean *CGroveBuilder::lookupWarningType(WarningType type)
+{
+  switch (type) {
+#define ENTRY(w) case warning##w: return &app_.options.warn##w;
+  ENTRY(SgmlDecl)
+  ENTRY(DuplicateEntity)
+  ENTRY(Should)
+  ENTRY(UndefinedElement)
+  ENTRY(DefaultEntityReference)
+  ENTRY(MixedContent)
+  ENTRY(EmptyTag)
+  ENTRY(UnusedMap)
+  ENTRY(UnusedParam)
+  ENTRY(NotationSystemId)
+#undef ENTRY
+  case warningUnclosedTag:
+    return &app_.options.noUnclosedTag;
+  case warningNet:
+    return &app_.options.noNet;
+  }
+  return 0;
+}
+
+STDMETHODIMP CGroveBuilder::get_Error(ErrorType type, VARIANT_BOOL *retval)
+{
+  *retval = 0;
+  if (type == errorValid) {
+    *retval = (app_.options.typeValid == 0 ? 0 : -1);
+    return NOERROR;
+  }
+  SP_NAMESPACE::PackedBoolean *p = lookupErrorType(type);
+  if (!p)
+    return E_INVALIDARG;
+  *retval = *p ? -1 : 0;
+  return NOERROR;
+}
+
+STDMETHODIMP CGroveBuilder::put_Error(ErrorType type, VARIANT_BOOL b)
+{
+  if (type == errorValid) {
+    app_.options.typeValid = (b ? SP_NAMESPACE::ParserOptions::sgmlDeclTypeValid : 0);
+    return NOERROR;
+  }
+  SP_NAMESPACE::PackedBoolean *p = lookupErrorType(type);
+  if (!p)
+    return E_INVALIDARG;
+  *p = b ? 1 : 0;
+  return NOERROR;
+}
+
+SP_NAMESPACE::PackedBoolean *CGroveBuilder::lookupErrorType(ErrorType type)
+{
+  switch (type) {
+#define ENTRY(e) case error##e: return &app_.options.error##e;
+  ENTRY(Idref)
+  ENTRY(Significant)
+  ENTRY(Afdr)
+#undef ENTRY
+  case errorLpdNotation:
+    return &errorLpdNotation_;
+  }
+  return 0;
+}
+
+STDMETHODIMP CGroveBuilder::get_ValidateOnly(VARIANT_BOOL *retval)
+{
+  *retval = validateOnly_;
+  return NOERROR;
+}
+
+STDMETHODIMP CGroveBuilder::put_ValidateOnly(VARIANT_BOOL b)
+{
+  validateOnly_ = b;
+  return NOERROR;
+}
+
+SpParserThread::~SpParserThread()
+{
+  cancel_ = 1;
+  ::WaitForSingleObject(thread_, INFINITE);
+  ::CloseHandle(thread_);
+}
+
+unsigned __stdcall SpParserThread::start(void *p)
+{
+  SpParserThread *arg = (SpParserThread *)p;
+  try {
+    if (arg->archNames.size() > 0) {
+      SP_NAMESPACE::SelectOneArcDirector director(arg->archNames, *arg->eh);
+      SP_NAMESPACE::ArcEngine::parseAll(arg->parser, director, director, &arg->cancel_);
+    } else
+      arg->parser.parseAll(*arg->eh, &arg->cancel_);
+  }
+  catch (std::bad_alloc) {
+    // FIXME how to report this?
+  }
+  arg->eh.clear();
+  // Release the parser
+  SP_NAMESPACE::SgmlParser tem;
+  tem.swap(arg->parser);
+  return 0;
+}
+
+void SpParserThread::run()
+{
+  unsigned id;
+  thread_ = HANDLE(_beginthreadex(NULL, 0, start, this, 0, &id));
+}
+
+void SpParserThread::dispatchMessage(const SP_NAMESPACE::Message &)
+{
+}
+
+SP_NAMESPACE::Boolean
+SpParserThread::getMessageText(const SP_NAMESPACE::MessageFragment &frag,
+			       StringC &text)
+{
+  SP_NAMESPACE::String<SP_NAMESPACE::SP_TCHAR> str;
+  if (!SP_NAMESPACE::MessageTable::instance()->getText(frag, str))
+    return 0;
+  text.assign((const SP_NAMESPACE::Char *)str.data(), str.size());
+  return 1;
+}
--- openjade-1.4devel1.orig/groveoa/CGroveBuilder.h
+++ openjade-1.4devel1/groveoa/CGroveBuilder.h
@@ -0,0 +1,61 @@
+// CGroveBuilder.h : Declaration of the CGroveBuilder
+
+#ifndef __GROVEBUILDER_H_
+#define __GROVEBUILDER_H_
+
+#include "resource.h"       // main symbols
+#include "config.h"
+#include "WinApp.h"
+#include "Message.h"
+#include "MessageFormatter.h"
+
+/////////////////////////////////////////////////////////////////////////////
+// CGroveBuilder
+class ATL_NO_VTABLE CGroveBuilder : 
+	public CComObjectRoot,
+	public CComCoClass<CGroveBuilder, &CLSID_GroveBuilder>,
+	public IDispatchImpl<_GroveBuilder, &IID__GroveBuilder, &LIBID_GROVE>
+{
+public:
+	CGroveBuilder() : validateOnly_(0), errorLpdNotation_(0) { }
+
+DECLARE_REGISTRY_RESOURCEID(IDR_GROVEBUILDER)
+
+BEGIN_COM_MAP(CGroveBuilder)
+	COM_INTERFACE_ENTRY(_GroveBuilder)
+	COM_INTERFACE_ENTRY(IDispatch)
+END_COM_MAP()
+// IGroveBuilder
+public:
+	STDMETHOD(parse)(BSTR sysid, SgmlDocumentNode **root);
+	STDMETHOD(archParse)(BSTR sysid, BSTR archNames, SgmlDocumentNode **root);
+	STDMETHOD(get_ExtraCatalogs)(BSTR *);
+	STDMETHOD(put_ExtraCatalogs)(BSTR);
+	STDMETHOD(get_DefaultCatalogs)(BSTR *);
+	STDMETHOD(put_DefaultCatalogs)(BSTR);
+	STDMETHOD(get_ExtraDirectories)(BSTR *);
+	STDMETHOD(put_ExtraDirectories)(BSTR);
+	STDMETHOD(get_DefaultDirectories)(BSTR *);
+	STDMETHOD(put_DefaultDirectories)(BSTR);
+	STDMETHOD(get_Encoding)(BSTR *);
+	STDMETHOD(put_Encoding)(BSTR);
+	STDMETHOD(get_DefaultEncoding)(BSTR *);
+	STDMETHOD(put_DefaultEncoding)(BSTR);
+	STDMETHOD(get_Includes)(BSTR *);
+	STDMETHOD(put_Includes)(BSTR);
+	STDMETHOD(get_Warning)(WarningType, VARIANT_BOOL *);
+	STDMETHOD(put_Warning)(WarningType, VARIANT_BOOL);
+	STDMETHOD(get_Error)(ErrorType, VARIANT_BOOL *);
+	STDMETHOD(put_Error)(ErrorType, VARIANT_BOOL);
+	STDMETHOD(get_ValidateOnly)(VARIANT_BOOL *);
+	STDMETHOD(put_ValidateOnly)(VARIANT_BOOL);
+private:
+        SP_NAMESPACE::PackedBoolean *lookupWarningType(WarningType type);
+	SP_NAMESPACE::PackedBoolean *lookupErrorType(ErrorType type);
+	SP_NAMESPACE::WinApp app_;
+	VARIANT_BOOL validateOnly_;
+	// This is just for binary compatibility.
+	SP_NAMESPACE::PackedBoolean errorLpdNotation_;
+};
+
+#endif //__GROVEBUILDER_H_
--- openjade-1.4devel1.orig/groveoa/GroveBuilder.rgs
+++ openjade-1.4devel1/groveoa/GroveBuilder.rgs
@@ -0,0 +1,25 @@
+HKCR
+{
+	SP.GroveBuilder.1 = s 'GroveBuilder Class'
+	{
+		CLSID = s '{557CE382-9EBD-11D0-9083-0020AF41CFC2}'
+	}
+	SP.GroveBuilder = s 'GroveBuilder Class'
+	{
+		CLSID = s '{557CE382-9EBD-11D0-9083-0020AF41CFC2}'
+		CurVer = s 'SP.GroveBuilder.1'
+	}
+	NoRemove CLSID
+	{
+		ForceRemove {557CE382-9EBD-11D0-9083-0020AF41CFC2} = s 'GroveBuilder Class'
+		{
+			ProgID = s 'SP.GroveBuilder.1'
+			VersionIndependentProgID = s 'SP.GroveBuilder'
+			ForceRemove 'Programmable'
+			InprocServer32 = s '%MODULE%'
+			{
+				val ThreadingModel = s 'Apartment'
+			}
+		}
+	}
+}
--- openjade-1.4devel1.orig/groveoa/GroveNode.cxx
+++ openjade-1.4devel1/groveoa/GroveNode.cxx
@@ -0,0 +1,1483 @@
+// GroveNode.cxx
+
+#include "stdafx.h"
+#include "groveoa.h"
+#include "config.h"
+#include "GroveNode.h"
+#include "Boolean.h"
+#include "Node.h"
+#include "LocNode.h"
+#include "PointerTable.h"
+#include "NamedResource.h"
+#include "Ptr.h"
+#include "Owner.h"
+#include "ExtendEntityManager.h"
+#include "StorageManager.h"
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <new>
+
+#ifdef SP_NO_STD_NAMESPACE
+#define std /* as nothing */
+#endif
+
+#define TRY try {
+#define CATCH  } catch (std::bad_alloc) { return E_OUTOFMEMORY; }
+
+// A NULL BSTR is supposed to be equivalent to an empty BSTR
+// but not everybody gets this right (perl build 306, for example)
+
+inline
+BSTR makeEmptyBSTR()
+{
+  return ::SysAllocStringLen(0, 0);
+}
+
+using GROVE_NAMESPACE::NodePtr;
+using GROVE_NAMESPACE::NodeListPtr;
+using GROVE_NAMESPACE::NamedNodeListPtr;
+using GROVE_NAMESPACE::GroveString;
+using GROVE_NAMESPACE::GroveStringList;
+using GROVE_NAMESPACE::GroveStringListPtr;
+using GROVE_NAMESPACE::ConstGroveStringListIter;
+using GROVE_NAMESPACE::GroveChar;
+using GROVE_NAMESPACE::accessOK;
+using GROVE_NAMESPACE::accessNull;
+using GROVE_NAMESPACE::accessNotInClass;
+using GROVE_NAMESPACE::SdataMapper;
+
+class NodeTable;
+typedef SP_NAMESPACE::Ptr<NodeTable> NodeTablePtr;
+
+class ATL_NO_VTABLE CStringList :
+	public CComObjectRoot,
+	public IDispatchImpl<StringList, &IID_StringList, &LIBID_GROVE> {
+public:
+    CStringList() { }
+BEGIN_COM_MAP(CStringList)
+   COM_INTERFACE_ENTRY(IDispatch)
+   COM_INTERFACE_ENTRY(StringList)
+END_COM_MAP()
+    STDMETHOD(get_Count)(long *);
+    STDMETHOD(get_Item)(long, BSTR *retval);
+    STDMETHOD(First)(BSTR *retval);
+    STDMETHOD(Rest)(StringList **);
+    static HRESULT make(const GroveStringListPtr &, StringList **);
+private:
+  GroveStringListPtr sl_;    
+};
+
+class CNodeBase {
+public:
+    virtual ~CNodeBase();
+    void init(const NodePtr &nd, const NodeTablePtr &);
+    static HRESULT make(const NodePtr &, const NodeTablePtr &, Node **);
+    static BSTR makeBSTR(const GroveString &);
+    static const GROVE_NAMESPACE::Node &key(const CNodeBase &obj) {
+      return *obj.nd_;
+    }
+    static unsigned long hash(const GROVE_NAMESPACE::Node &nd) {
+      return nd.hash();
+    }
+    virtual Node *asNode() = 0;
+    HRESULT internalGetStoragePos(StoragePos **);
+protected:
+    CNodeBase() { }
+    NodePtr nd_;
+    NodeTablePtr table_;
+};
+
+class NodeTable
+: public SP_NAMESPACE::Resource,
+  public SP_NAMESPACE::PointerTable<CNodeBase *, GROVE_NAMESPACE::Node, CNodeBase, CNodeBase> {
+public:
+  NodeTable(SP_NAMESPACE::Owner<ParserThread> &thd) {
+    thd.swap(thread_);
+  }
+private:
+  SP_NAMESPACE::Owner<ParserThread> thread_;
+};
+
+class ATL_NO_VTABLE CNodeList :
+	public CComObjectRoot,
+	public IDispatchImpl<NodeList, &IID_NodeList, &LIBID_GROVE> {
+public:
+    CNodeList() { }
+BEGIN_COM_MAP(CNodeList)
+   COM_INTERFACE_ENTRY(IDispatch)
+   COM_INTERFACE_ENTRY(NodeList)
+END_COM_MAP()
+    STDMETHOD(get_Count)(long *);
+    STDMETHOD(get_Item)(long, Node **);
+    STDMETHOD(get__NewEnum)(IUnknown **);
+    STDMETHOD(First)(Node **);
+    STDMETHOD(Rest)(NodeList **);
+    static HRESULT make(const NodeListPtr &, const NodeTablePtr &, NodeList **);
+private:
+    NodeListPtr nl_;
+    NodeTablePtr table_;
+};
+
+class ATL_NO_VTABLE CChunkNodeList :
+        public CComObjectRoot,
+	public IDispatchImpl<NodeList, &IID_NodeList, &LIBID_GROVE> {
+public:
+  CChunkNodeList() { }
+BEGIN_COM_MAP(CChunkNodeList)
+   COM_INTERFACE_ENTRY(IDispatch)
+   COM_INTERFACE_ENTRY(NodeList)
+END_COM_MAP()
+  STDMETHOD(get_Count)(long *);
+  STDMETHOD(get_Item)(long, Node **);
+  STDMETHOD(get__NewEnum)(IUnknown **);
+  STDMETHOD(First)(Node **);
+  STDMETHOD(Rest)(NodeList **);
+  static HRESULT make(const NodeListPtr &, const NodeTablePtr &, NodeList **);
+private:
+    NodeListPtr nl_;
+    NodeTablePtr table_;
+};
+
+class ATL_NO_VTABLE CNamedNodeList :
+	public CComObjectRoot,
+	public IDispatchImpl<NamedNodeList, &IID_NamedNodeList, &LIBID_GROVE> {
+public:
+    CNamedNodeList() { }
+BEGIN_COM_MAP(CNamedNodeList)
+   COM_INTERFACE_ENTRY(IDispatch)
+   COM_INTERFACE_ENTRY(NamedNodeList)
+END_COM_MAP()
+    STDMETHOD(get_Count)(long *);
+    STDMETHOD(get_Item)(BSTR, Node **);
+    STDMETHOD(get__NewEnum)(IUnknown **);
+    STDMETHOD(get_NodeList)(NodeList **);
+    STDMETHOD(Normalize)(BSTR, BSTR *);
+    STDMETHOD(NodeName)(Node *, BSTR *);
+    static HRESULT make(const NamedNodeListPtr &, const NodeTablePtr &, NamedNodeList **);
+private:
+    NamedNodeListPtr nnl_;
+    NodeTablePtr table_;
+};
+
+class ATL_NO_VTABLE CStoragePos :
+  public CComObjectRoot,
+  public IDispatchImpl<StoragePos, &IID_StoragePos, &LIBID_GROVE> {
+public:
+  CStoragePos() { }
+  BEGIN_COM_MAP(CStoragePos)
+    COM_INTERFACE_ENTRY(IDispatch)
+    COM_INTERFACE_ENTRY(StoragePos)
+  END_COM_MAP()
+  STDMETHOD(get_StorageManagerName)(BSTR *retval) {
+    const char *s = loc_.storageObjectSpec->storageManager->type();
+    BSTR tem = ::SysAllocStringLen(0, strlen(s));
+    *retval = tem;
+    if (!tem)
+      return E_OUTOFMEMORY;
+    while (*s)
+      *tem++ = *s++;
+    return NOERROR;
+  }
+  STDMETHOD(get_StorageObjectId)(BSTR *retval) {
+    const SP_NAMESPACE::StringC &id = loc_.actualStorageId;
+    CComBSTR tem(id.size(), id.data());
+    *retval = tem.Detach();
+    return *retval ? NOERROR : E_OUTOFMEMORY;
+  }
+  STDMETHOD(get_LineNumber)(long *retval) {
+    *retval = loc_.lineNumber;
+    if (*retval < 0)
+      *retval = 0;
+    return NOERROR;
+  }
+  STDMETHOD(get_ColumnNumber)(long *retval) {
+    *retval = loc_.columnNumber;
+    if (*retval < 0)
+      *retval = 0;
+    return NOERROR;
+  }
+  STDMETHOD(get_ByteIndex)(long *retval) {
+    *retval = loc_.byteIndex + 1;
+    return NOERROR;
+  }
+  STDMETHOD(get_CharacterIndex)(long *retval) {
+    *retval = loc_.storageObjectOffset + 1;
+    return NOERROR;
+  }
+  static HRESULT make(const SP_NAMESPACE::ExternalInfo *,
+		      SP_NAMESPACE::Offset,
+		      const NodePtr &,
+		      StoragePos **);
+private:
+  SP_NAMESPACE::StorageObjectLocation loc_;
+  NodePtr nd_;
+};
+
+#define NODE_PROP2(xfunc, ifunc) \
+    STDMETHOD(xfunc)(Node **retval) { \
+      TRY \
+      *retval = 0; \
+      NodePtr nd; \
+      if (nd_->ifunc(nd) == accessOK) \
+	return make(nd, table_, retval); \
+      return NOERROR; \
+      CATCH \
+    }
+#define NODE_PROP(Name) NODE_PROP2(get_##Name, get##Name)
+
+#define DERIVED_NODE_PROP2(xfunc, ifunc, cls) \
+    STDMETHOD(xfunc)(cls##Node **retval) { \
+      TRY \
+      *retval = 0; \
+      NodePtr nd; \
+      if (nd_->ifunc(nd) == accessOK) { \
+        Node *base; \
+	HRESULT hres = make(nd, table_, &base); \
+	*retval = (cls##Node *)base; \
+	return hres; \
+      } \
+      return NOERROR; \
+      CATCH \
+    }
+#define DERIVED_NODE_PROP(Name, cls) DERIVED_NODE_PROP2(get_##Name, get##Name, cls)
+
+
+#define NODE_LIST_PROP2(xfunc, ifunc) \
+    STDMETHOD(xfunc)(NodeList **retval) { \
+      TRY \
+      *retval = 0; \
+      NodeListPtr nl; \
+      if (nd_->ifunc(nl) == accessOK) \
+	return CNodeList::make(nl, table_, retval); \
+      return NOERROR; \
+      CATCH \
+    }
+#define NODE_LIST_PROP(Name) NODE_LIST_PROP2(get_##Name, get##Name)
+
+#define STRING_LIST_PROP2(xfunc, ifunc) \
+    STDMETHOD(xfunc)(StringList **retval) { \
+      TRY \
+      *retval = 0; \
+      GroveStringListPtr sl; \
+      if (nd_->ifunc(sl) == accessOK) \
+	return CStringList::make(sl, retval); \
+      return NOERROR; \
+      CATCH \
+    }
+#define STRING_LIST_PROP(Name) STRING_LIST_PROP2(get_##Name, get##Name)
+
+#define CHUNK_NODE_LIST_PROP2(xfunc, ifunc) \
+    STDMETHOD(xfunc)(NodeList **retval) { \
+      TRY \
+      *retval = 0; \
+      NodeListPtr nl; \
+      if (nd_->ifunc(nl) == accessOK) \
+	return CChunkNodeList::make(nl, table_, retval); \
+      return NOERROR; \
+      CATCH \
+    }
+
+#define NAMED_NODE_LIST_PROP2(xfunc, ifunc) \
+    STDMETHOD(xfunc)(NamedNodeList **retval) { \
+      TRY \
+      *retval = 0; \
+      NamedNodeListPtr nnl; \
+      if (nd_->ifunc(nnl) == accessOK) \
+	return CNamedNodeList::make(nnl, table_, retval); \
+      return NOERROR; \
+      CATCH \
+    }
+#define NAMED_NODE_LIST_PROP(Name) \
+ NAMED_NODE_LIST_PROP2(get_##Name, get##Name)
+
+#define BOOL_PROP2(xfunc, ifunc) \
+    STDMETHOD(xfunc)(VARIANT_BOOL *retval) { \
+      TRY \
+      bool b; \
+      if (nd_->ifunc(b) == accessOK) \
+        *retval = b ? -1 : 0; \
+      else \
+	*retval = 0; \
+      return NOERROR; \
+      CATCH \
+    }
+#define BOOL_PROP(Name) BOOL_PROP2(get_##Name, get##Name)
+
+#define INTEGER_PROP2(xfunc, ifunc) \
+    STDMETHOD(xfunc)(long *retval) { \
+      TRY \
+      long l; \
+      if (nd_->ifunc(l) == accessOK) \
+        *retval = l; \
+      else \
+	*retval = 0; \
+      return NOERROR; \
+      CATCH \
+    }
+#define INTEGER_PROP(Name) INTEGER_PROP2(get_##Name, get##Name)
+
+#define STRING_PROP2(xfunc, ifunc) \
+    STDMETHOD(xfunc)(BSTR *retval) { \
+      TRY \
+      *retval = 0; \
+      GroveString str; \
+      if (nd_->ifunc(str) == accessOK) \
+	*retval = makeBSTR(str); \
+      else \
+        *retval = makeEmptyBSTR(); \
+      return NOERROR; \
+      CATCH \
+    }
+#define STRING_PROP(Name) STRING_PROP2(get_##Name, get##Name)
+
+#define ENUM_PROP2(enumClass, xfunc, ifunc) \
+  STDMETHOD(xfunc)(enumClass *retval) { \
+    GROVE_NAMESPACE::Node::##enumClass##::Enum type; \
+    if (nd_->ifunc(type) == accessOK) \
+      *retval = enumClass##(type); \
+    return NOERROR; \
+  }
+#define ENUM_PROP(Name) ENUM_PROP2(Name, get_##Name, get##Name)
+
+#define NULL_STRING_PROP(Name) \
+    STRING_PROP(Name) \
+    STDMETHOD(get_##Name##Null)(VARIANT_BOOL *retval) { \
+      TRY \
+      *retval = 0; \
+      GroveString str; \
+      if (nd_->get##Name(str) == accessNull) \
+	*retval = -1; \
+      return NOERROR; \
+      CATCH \
+    }
+
+
+template <class T, const IID *piid, const GUID *plibid, NodeClass nodeClass>
+class INodeImpl : public IDispatchImpl<T, piid, plibid>, public CNodeBase {
+public:
+    NODE_PROP(Parent)
+    NODE_PROP(Origin)
+    NODE_PROP(GroveRoot)
+    NODE_PROP(TreeRoot)
+    NODE_LIST_PROP2(get_Children, children)
+    CHUNK_NODE_LIST_PROP2(get_ChunkChildren, children)
+    NODE_PROP2(FirstChild, firstChild)
+    NODE_PROP2(NextSibling, nextSibling)
+    NODE_PROP2(NextChunkSibling, nextChunkSibling)
+    STDMETHOD(get_Class)(NodeClass *retval) {
+      TRY
+      *retval = nodeClass;
+      return NOERROR;
+      CATCH
+    }
+    STDMETHOD(get_SiblingIndex)(long *retval) {
+      TRY
+      unsigned long n;
+      if (nd_->siblingsIndex(n) == accessOK)
+	*retval = n + 1;
+      else
+	*retval = 0;
+      return NOERROR;
+      CATCH
+    }
+    Node *asNode() { return this; }
+    STDMETHOD(get_StoragePos)(StoragePos **retval) {
+      return internalGetStoragePos(retval);
+    }
+};
+
+class ATL_NO_VTABLE CElementNode :
+	public CComObjectRoot,
+	public INodeImpl<ElementNode, &IID_ElementNode, &LIBID_GROVE, nodeClassElement> {
+public:
+    CElementNode() { }
+BEGIN_COM_MAP(CElementNode)
+   COM_INTERFACE_ENTRY(IDispatch)
+   COM_INTERFACE_ENTRY(ElementNode)
+   COM_INTERFACE_ENTRY(Node)
+END_COM_MAP()
+   STRING_PROP(Gi)
+   NAMED_NODE_LIST_PROP(Attributes)
+   STRING_PROP(Id)
+   NODE_LIST_PROP(Content)
+   CHUNK_NODE_LIST_PROP2(get_ChunkContent, getContent)
+   BOOL_PROP(Included)
+   BOOL_PROP(MustOmitEndTag) 
+   DERIVED_NODE_PROP(ElementType, ElementType)
+};
+
+class ATL_NO_VTABLE CAttributeAssignmentNode :
+	public CComObjectRoot,
+	public INodeImpl<AttributeAssignmentNode, &IID_AttributeAssignmentNode, &LIBID_GROVE, nodeClassAttributeAssignment> {
+public:
+    CAttributeAssignmentNode() { }
+BEGIN_COM_MAP(CAttributeAssignmentNode)
+   COM_INTERFACE_ENTRY(IDispatch)
+   COM_INTERFACE_ENTRY(AttributeAssignmentNode)
+   COM_INTERFACE_ENTRY(Node)
+END_COM_MAP()
+   STRING_PROP(Name)
+   BOOL_PROP(Implied)
+   NODE_LIST_PROP(Value)
+   CHUNK_NODE_LIST_PROP2(get_ChunkValue, getValue)
+   STDMETHOD(get_TokenSep)(long *retval) {
+     TRY
+     GroveChar ch;
+     if (nd_->getTokenSep(ch) == accessOK)
+       *retval = ch;
+     else
+       *retval = -1;
+     return NOERROR;
+     CATCH
+   }
+   STDMETHOD(get_StringValue)(BSTR *retval) {
+     TRY
+     *retval = 0;
+     bool implied;
+     if (nd_->getImplied(implied) == accessOK && implied) {
+       *retval = makeEmptyBSTR();
+       return NOERROR;
+     }
+     GroveString tokens;
+     if (nd_->tokens(tokens) == accessOK) {
+       *retval = makeBSTR(tokens);
+       return NOERROR;
+     }
+     NodePtr first;
+     if (nd_->firstChild(first) == accessOK) {
+       size_t len = 0;
+       NodePtr tem(first);
+       do {
+	 GroveString chunk;
+	 if (tem->charChunk(SdataMapper(), chunk) == accessOK)
+	   len += chunk.size();
+       } while (tem.assignNextChunkSibling() == accessOK);
+       GroveChar *p = ::SysAllocStringLen(0, len);
+       if (!p)
+	 return E_OUTOFMEMORY;
+       *retval = p;
+       tem = first;
+       do {
+	 GroveString chunk;
+	 if (tem->charChunk(SdataMapper(), chunk) == accessOK) {
+	   memcpy(p, chunk.data(), chunk.size()*sizeof(*p));
+	   p += chunk.size();
+	 } 
+       } while (tem.assignNextChunkSibling() == accessOK);
+     }
+     return NOERROR;
+     CATCH
+   }
+   DERIVED_NODE_PROP(AttributeDef, AttributeDef)
+ };
+
+class ATL_NO_VTABLE CAttributeValueTokenNode :
+	public CComObjectRoot,
+	public INodeImpl<AttributeValueTokenNode, &IID_AttributeValueTokenNode, &LIBID_GROVE, nodeClassAttributeValueToken> {
+public:
+    CAttributeValueTokenNode() { }
+BEGIN_COM_MAP(CAttributeValueTokenNode)
+   COM_INTERFACE_ENTRY(IDispatch)
+   COM_INTERFACE_ENTRY(AttributeValueTokenNode)
+   COM_INTERFACE_ENTRY(Node)
+END_COM_MAP()
+   STRING_PROP(Token)
+   DERIVED_NODE_PROP(Referent, Element)
+   DERIVED_NODE_PROP(Entity, Entity)
+   DERIVED_NODE_PROP(Notation, Notation)
+};
+
+class ATL_NO_VTABLE CSgmlDocumentNode :
+	public CComObjectRoot,
+	public INodeImpl<SgmlDocumentNode, &IID_SgmlDocumentNode, &LIBID_GROVE, nodeClassSgmlDocument> {
+public:
+    CSgmlDocumentNode() { }
+BEGIN_COM_MAP(CSgmlDocumentNode)
+    COM_INTERFACE_ENTRY(IDispatch)
+    COM_INTERFACE_ENTRY(SgmlDocumentNode)
+    COM_INTERFACE_ENTRY(Node)
+END_COM_MAP()
+    DERIVED_NODE_PROP(DocumentElement, Element)
+    DERIVED_NODE_PROP(SgmlConstants, SgmlConstants)
+    NULL_STRING_PROP(ApplicationInfo)
+    NODE_LIST_PROP(Prolog)
+    NODE_LIST_PROP(Epilog)
+    NAMED_NODE_LIST_PROP(Elements)
+    NAMED_NODE_LIST_PROP(Entities)
+    NAMED_NODE_LIST_PROP(DefaultedEntities)
+    NAMED_NODE_LIST_PROP(DoctypesAndLinktypes)
+    DERIVED_NODE_PROP(GoverningDoctype, DocumentType)
+    NODE_LIST_PROP(Messages)
+};
+
+class ATL_NO_VTABLE CDataCharNode :
+	public CComObjectRoot,
+	public INodeImpl<DataCharNode, &IID_DataCharNode, &LIBID_GROVE, nodeClassDataChar> {
+public:
+    CDataCharNode() { }
+BEGIN_COM_MAP(CDataCharNode)
+   COM_INTERFACE_ENTRY(IDispatch)
+   COM_INTERFACE_ENTRY(DataCharNode)
+   COM_INTERFACE_ENTRY(Node)
+END_COM_MAP()
+    STDMETHOD(get_Char)(long *);
+    STDMETHOD(get_NonSgml)(long *);
+    STDMETHOD(get_CharChunk)(BSTR *);
+};
+
+class ATL_NO_VTABLE CSgmlConstantsNode :
+    public CComObjectRoot,
+    public INodeImpl<SgmlConstantsNode, &IID_SgmlConstantsNode, &LIBID_GROVE, nodeClassSgmlConstants> {
+public:
+      CSgmlConstantsNode() { }
+BEGIN_COM_MAP(CSgmlConstantsNode)
+  COM_INTERFACE_ENTRY(IDispatch)
+  COM_INTERFACE_ENTRY(SgmlConstantsNode)
+  COM_INTERFACE_ENTRY(Node)
+END_COM_MAP()
+};
+
+class ATL_NO_VTABLE CPiNode :
+    public CComObjectRoot,
+    public INodeImpl<PiNode, &IID_PiNode, &LIBID_GROVE, nodeClassPi> {
+public:
+      CPiNode() { }
+BEGIN_COM_MAP(CPiNode)
+  COM_INTERFACE_ENTRY(IDispatch)
+  COM_INTERFACE_ENTRY(PiNode)
+  COM_INTERFACE_ENTRY(Node)
+END_COM_MAP()
+  STRING_PROP(SystemData)
+  DERIVED_NODE_PROP(Entity, Entity)
+  STRING_PROP(EntityName)
+};
+
+class ATL_NO_VTABLE CSdataNode :
+    public CComObjectRoot,
+    public INodeImpl<SdataNode, &IID_SdataNode, &LIBID_GROVE, nodeClassSdata> {
+public:
+      CSdataNode() { }
+BEGIN_COM_MAP(CSdataNode)
+  COM_INTERFACE_ENTRY(IDispatch)
+  COM_INTERFACE_ENTRY(SdataNode)
+  COM_INTERFACE_ENTRY(Node)
+END_COM_MAP()
+  STRING_PROP(SystemData)
+  DERIVED_NODE_PROP(Entity, Entity)
+  STRING_PROP(EntityName)
+};
+
+class ATL_NO_VTABLE CDocumentTypeNode :
+    public CComObjectRoot,
+    public INodeImpl<DocumentTypeNode, &IID_DocumentTypeNode, &LIBID_GROVE, nodeClassDocumentType> {
+public:
+      CDocumentTypeNode() { }
+BEGIN_COM_MAP(CDocumentTypeNode)
+  COM_INTERFACE_ENTRY(IDispatch)
+  COM_INTERFACE_ENTRY(DocumentTypeNode)
+  COM_INTERFACE_ENTRY(Node)
+END_COM_MAP()
+  STRING_PROP(Name)
+  BOOL_PROP(Governing)
+  NAMED_NODE_LIST_PROP(GeneralEntities)
+  NAMED_NODE_LIST_PROP(Notations)
+  NAMED_NODE_LIST_PROP(ElementTypes)
+  NAMED_NODE_LIST_PROP(ParameterEntities)
+  DERIVED_NODE_PROP(DefaultEntity, DefaultEntity)
+};
+
+class ATL_NO_VTABLE CEntityNode :
+    public CComObjectRoot,
+    public INodeImpl<EntityNode, &IID_EntityNode, &LIBID_GROVE, nodeClassEntity> {
+public:
+      CEntityNode() { }
+BEGIN_COM_MAP(CEntityNode)
+  COM_INTERFACE_ENTRY(IDispatch)
+  COM_INTERFACE_ENTRY(EntityNode)
+  COM_INTERFACE_ENTRY(Node)
+END_COM_MAP()
+  STRING_PROP(Name)
+  NULL_STRING_PROP(Text)
+  DERIVED_NODE_PROP(Notation, Notation)
+  STRING_PROP(NotationName)
+  BOOL_PROP(Defaulted)
+  NAMED_NODE_LIST_PROP(Attributes)
+  DERIVED_NODE_PROP(ExternalId, ExternalId)
+  ENUM_PROP(EntityType)
+};
+
+class ATL_NO_VTABLE CDefaultEntityNode :
+    public CComObjectRoot,
+    public INodeImpl<DefaultEntityNode, &IID_DefaultEntityNode, &LIBID_GROVE, nodeClassDefaultEntity> {
+public:
+      CDefaultEntityNode() { }
+BEGIN_COM_MAP(CDefaultEntityNode)
+  COM_INTERFACE_ENTRY(IDispatch)
+  COM_INTERFACE_ENTRY(DefaultEntityNode)
+  COM_INTERFACE_ENTRY(Node)
+END_COM_MAP()
+  STRING_PROP(Name)
+  NULL_STRING_PROP(Text)
+  DERIVED_NODE_PROP(Notation, Notation)
+  STRING_PROP(NotationName)
+  NAMED_NODE_LIST_PROP(Attributes)
+  DERIVED_NODE_PROP(ExternalId, ExternalId)
+  ENUM_PROP(EntityType)
+};
+
+
+class ATL_NO_VTABLE CNotationNode :
+    public CComObjectRoot,
+    public INodeImpl<NotationNode, &IID_NotationNode, &LIBID_GROVE, nodeClassNotation> {
+public:
+      CNotationNode() { }
+BEGIN_COM_MAP(CNotationNode)
+  COM_INTERFACE_ENTRY(IDispatch)
+  COM_INTERFACE_ENTRY(NotationNode)
+  COM_INTERFACE_ENTRY(Node)
+END_COM_MAP()
+  STRING_PROP(Name)
+  DERIVED_NODE_PROP(ExternalId, ExternalId)
+  NAMED_NODE_LIST_PROP(AttributeDefs)
+};
+
+class ATL_NO_VTABLE CExternalIdNode :
+    public CComObjectRoot,
+    public INodeImpl<ExternalIdNode, &IID_ExternalIdNode, &LIBID_GROVE, nodeClassExternalId> {
+public:
+      CExternalIdNode() { }
+BEGIN_COM_MAP(CExternalIdNode)
+  COM_INTERFACE_ENTRY(IDispatch)
+  COM_INTERFACE_ENTRY(ExternalIdNode)
+  COM_INTERFACE_ENTRY(Node)
+END_COM_MAP()
+  NULL_STRING_PROP(PublicId)
+  NULL_STRING_PROP(SystemId)
+  STRING_PROP(GeneratedSystemId)
+};
+
+class ATL_NO_VTABLE CExternalDataNode :
+    public CComObjectRoot,
+    public INodeImpl<ExternalDataNode, &IID_ExternalDataNode, &LIBID_GROVE, nodeClassExternalData> {
+public:
+      CExternalDataNode() { }
+BEGIN_COM_MAP(CExternalDataNode)
+  COM_INTERFACE_ENTRY(IDispatch)
+  COM_INTERFACE_ENTRY(ExternalDataNode)
+  COM_INTERFACE_ENTRY(Node)
+END_COM_MAP()
+  DERIVED_NODE_PROP(Entity, Entity)
+  STRING_PROP(EntityName)
+};
+
+class ATL_NO_VTABLE CSubdocNode :
+    public CComObjectRoot,
+    public INodeImpl<SubdocNode, &IID_SubdocNode, &LIBID_GROVE, nodeClassSubdoc> {
+public:
+      CSubdocNode() { }
+BEGIN_COM_MAP(CSubdocNode)
+  COM_INTERFACE_ENTRY(IDispatch)
+  COM_INTERFACE_ENTRY(SubdocNode)
+  COM_INTERFACE_ENTRY(Node)
+END_COM_MAP()
+  DERIVED_NODE_PROP(Entity, Entity)
+  STRING_PROP(EntityName)
+};
+
+class ATL_NO_VTABLE CElementTypeNode :
+    public CComObjectRoot,
+    public INodeImpl<ElementTypeNode, &IID_ElementTypeNode, &LIBID_GROVE, nodeClassElementType> {
+public:
+      CElementTypeNode() { }
+BEGIN_COM_MAP(CElementTypeNode)
+  COM_INTERFACE_ENTRY(IDispatch)
+  COM_INTERFACE_ENTRY(ElementTypeNode)
+  COM_INTERFACE_ENTRY(Node)
+END_COM_MAP()
+  STRING_PROP(Gi)
+  NAMED_NODE_LIST_PROP(AttributeDefs)
+  ENUM_PROP(ContentType)
+  STRING_LIST_PROP(Exclusions)
+  STRING_LIST_PROP(Inclusions)
+  DERIVED_NODE_PROP(ModelGroup, ModelGroup)
+  BOOL_PROP(OmitEndTag)
+  BOOL_PROP(OmitStartTag)
+};
+
+class ATL_NO_VTABLE CAttributeDefNode :
+    public CComObjectRoot,
+    public INodeImpl<AttributeDefNode, &IID_AttributeDefNode, &LIBID_GROVE, nodeClassAttributeDef> {
+public:
+      CAttributeDefNode() { }
+BEGIN_COM_MAP(CElementTypeNode)
+  COM_INTERFACE_ENTRY(IDispatch)
+  COM_INTERFACE_ENTRY(ElementTypeNode)
+  COM_INTERFACE_ENTRY(Node)
+END_COM_MAP()
+  STRING_PROP(Name)
+  ENUM_PROP(DeclValueType)
+  ENUM_PROP(DefaultValueType)
+  STRING_LIST_PROP(Tokens)
+  INTEGER_PROP(CurrentAttributeIndex)
+  NODE_LIST_PROP(CurrentGroup)
+  NODE_LIST_PROP(DefaultValue)
+};
+
+class ATL_NO_VTABLE CModelGroupNode :
+    public CComObjectRoot,
+    public INodeImpl<ModelGroupNode, &IID_ModelGroupNode, &LIBID_GROVE, nodeClassModelGroup> {
+public:
+      CModelGroupNode() { }
+BEGIN_COM_MAP(CModelGroupNode)
+  COM_INTERFACE_ENTRY(IDispatch)
+  COM_INTERFACE_ENTRY(ModelGroupNode)
+  COM_INTERFACE_ENTRY(Node)
+END_COM_MAP()
+  ENUM_PROP(Connector)
+  ENUM_PROP(OccurIndicator)
+  NODE_LIST_PROP(ContentTokens)
+};
+
+class ATL_NO_VTABLE CElementTokenNode :
+    public CComObjectRoot,
+    public INodeImpl<ElementTokenNode, &IID_ElementTokenNode, &LIBID_GROVE, nodeClassElementToken> {
+public:
+      CElementTokenNode() { }
+BEGIN_COM_MAP(CElementTokenNode)
+  COM_INTERFACE_ENTRY(IDispatch)
+  COM_INTERFACE_ENTRY(ElementTokenNode)
+  COM_INTERFACE_ENTRY(Node)
+END_COM_MAP()
+  STRING_PROP(Gi)
+  ENUM_PROP(OccurIndicator)
+};
+
+class ATL_NO_VTABLE CPcdataTokenNode :
+    public CComObjectRoot,
+    public INodeImpl<PcdataTokenNode, &IID_PcdataTokenNode, &LIBID_GROVE, nodeClassPcdataToken> {
+public:
+      CPcdataTokenNode() { }
+BEGIN_COM_MAP(CPcdataTokenNode)
+  COM_INTERFACE_ENTRY(IDispatch)
+  COM_INTERFACE_ENTRY(PcdataTokenNode)
+  COM_INTERFACE_ENTRY(Node)
+END_COM_MAP()
+};
+
+class ATL_NO_VTABLE CMessageNode :
+    public CComObjectRoot,
+    public INodeImpl<MessageNode, &IID_MessageNode, &LIBID_GROVE, nodeClassMessage> {
+public:
+  CMessageNode() { }
+BEGIN_COM_MAP(CMessageNode)
+  COM_INTERFACE_ENTRY(IDispatch)
+  COM_INTERFACE_ENTRY(MessageNode)
+  COM_INTERFACE_ENTRY(Node)
+END_COM_MAP()
+  STRING_PROP(Text)
+  STDMETHOD(get_Severity)(Severity *retval) {
+    TRY
+    GROVE_NAMESPACE::Node::Severity type;
+    if (nd_->getSeverity(type) == accessOK)
+      *retval = Severity(type);
+    return NOERROR;
+    CATCH
+  }
+};
+
+class ATL_NO_VTABLE CEnumNodeList :
+	public CComObjectRoot,
+	public IEnumVARIANT {
+public:
+    CEnumNodeList() { }
+BEGIN_COM_MAP(CEnumNodeList)
+   COM_INTERFACE_ENTRY(IEnumVARIANT)
+END_COM_MAP()
+  // IEnumVARIANT
+  STDMETHOD(Next)(ULONG celt, VARIANT *rgVar, ULONG *pCeltFetched);
+  STDMETHOD(Skip)(ULONG celt);
+  STDMETHOD(Reset)();
+  STDMETHOD(Clone)(IEnumVARIANT **ppEnum);
+  static HRESULT make(const NodeListPtr &, const NodeTablePtr &table, IUnknown **);
+private:
+  NodeListPtr nl_;
+  NodeListPtr cur_;
+  NodeTablePtr table_;
+};
+
+class ATL_NO_VTABLE CEnumChunkNodeList :
+	public CComObjectRoot,
+	public IEnumVARIANT {
+public:
+    CEnumChunkNodeList() { }
+BEGIN_COM_MAP(CEnumChunkNodeList)
+   COM_INTERFACE_ENTRY(IEnumVARIANT)
+END_COM_MAP()
+  // IEnumVARIANT
+  STDMETHOD(Next)(ULONG celt, VARIANT *rgVar, ULONG *pCeltFetched);
+  STDMETHOD(Skip)(ULONG celt);
+  STDMETHOD(Reset)();
+  STDMETHOD(Clone)(IEnumVARIANT **ppEnum);
+  static HRESULT make(const NodeListPtr &, const NodeTablePtr &table, IUnknown **);
+private:
+  NodeListPtr nl_;
+  NodeListPtr cur_;
+  NodeTablePtr table_;
+};
+
+struct BuildVisitor :  public GROVE_NAMESPACE::NodeVisitor {
+public:
+  BuildVisitor(const NodePtr &n, const NodeTablePtr &t)
+    : nd(n), table(t), retval(0), hRes(NOERROR) { }
+#define BUILD(mem, Cls) \
+  void mem(GROVE_NAMESPACE::Node &) { \
+    CComObject<Cls> *p; \
+    hRes = CComObject<Cls>::CreateInstance(&p); \
+    if (!FAILED(hRes)) { \
+      p->init(nd, table); \
+      retval = p; \
+      (retval)->AddRef(); \
+    } \
+  }
+  BUILD(element, CElementNode)
+  BUILD(attributeAssignment, CAttributeAssignmentNode)
+  BUILD(attributeValueToken, CAttributeValueTokenNode)
+  BUILD(sgmlDocument, CSgmlDocumentNode)
+  BUILD(dataChar, CDataCharNode)
+  BUILD(sgmlConstants, CSgmlConstantsNode)
+  BUILD(pi, CPiNode)
+  BUILD(sdata, CSdataNode)
+  BUILD(documentType, CDocumentTypeNode)
+  BUILD(entity, CEntityNode)
+  BUILD(notation, CNotationNode)
+  BUILD(externalId, CExternalIdNode)
+  BUILD(externalData, CExternalDataNode)
+  BUILD(subdocument, CSubdocNode)
+  BUILD(message, CMessageNode)
+  BUILD(elementType, CElementTypeNode)
+  BUILD(modelGroup, CModelGroupNode)
+  BUILD(elementToken, CElementTokenNode)
+  BUILD(pcdataToken, CPcdataTokenNode)
+  BUILD(defaultEntity, CDefaultEntityNode)
+  BUILD(attributeDef, CAttributeDefNode)
+#undef BUILD
+  NodePtr nd;
+  HRESULT hRes;
+  Node *retval;
+  NodeTablePtr table;
+};
+
+HRESULT CNodeBase::make(const NodePtr &nd, const NodeTablePtr &table, Node **retval)
+{
+  CNodeBase *nb = table->lookup(*nd);
+  if (nb) {
+    *retval = nb->asNode();
+    (*retval)->AddRef();
+    return NOERROR;
+  }
+  else {
+    BuildVisitor visitor(nd, table);
+    nd->accept(visitor);
+    *retval = visitor.retval;
+    return visitor.hRes;
+  }
+}
+
+CNodeBase::~CNodeBase()
+{
+  CNodeBase *tem = table_->remove(*nd_);
+  if (tem != this)
+    abort();
+}
+
+void CNodeBase::init(const NodePtr &nd, const NodeTablePtr &table)
+{
+  table_ = table;
+  nd_ = nd;
+  table_->insert(this);
+}
+
+BSTR CNodeBase::makeBSTR(const GroveString &str)
+{
+  CComBSTR bstr(str.size(), str.data());
+  return bstr.Detach();
+}
+
+HRESULT CNodeBase::internalGetStoragePos(StoragePos **retval)
+{
+  TRY
+  const SP_NAMESPACE::LocNode *lp = SP_NAMESPACE::LocNode::convert(nd_);
+  if (lp) {
+    SP_NAMESPACE::Location loc;
+    if (lp->getLocation(loc) == accessOK) {
+      const SP_NAMESPACE::Origin *origin = loc.origin().pointer();
+      SP_NAMESPACE::Index index = loc.index();
+      while (origin) {
+	const SP_NAMESPACE::ExternalInfo *info
+	  = origin->externalInfo();
+	if (info)
+	  return CStoragePos::make(info, origin->startOffset(index), nd_, retval);
+	const SP_NAMESPACE::Location &loc = origin->parent();
+	index = loc.index();
+	origin = loc.origin().pointer();
+      }
+    }
+  }
+  *retval = 0;
+  return NOERROR;
+  CATCH
+}
+
+STDMETHODIMP CDataCharNode::get_CharChunk(BSTR *retval)
+{
+  TRY
+  *retval = 0;
+  GroveString str;
+  if (nd_->charChunk(SdataMapper(), str) == accessOK)
+    *retval = makeBSTR(str);
+  else
+    *retval = makeEmptyBSTR();
+  return NOERROR;
+  CATCH
+}
+
+STDMETHODIMP CDataCharNode::get_Char(long *retval)
+{
+  TRY
+  GroveChar ch;
+  if (nd_->getChar(SdataMapper(), ch) == accessOK)
+    *retval = ch;
+  else
+    *retval = -1;
+  return NOERROR;
+  CATCH
+}
+
+STDMETHODIMP CDataCharNode::get_NonSgml(long *retval)
+{
+  TRY
+  unsigned long n;
+  if (nd_->getNonSgml(n) == accessOK)
+    *retval = n;
+  else
+    *retval = -1;
+  return NOERROR;
+  CATCH
+}
+// ----------
+
+HRESULT CStringList::make(const GroveStringListPtr &sl, StringList **retval)
+{
+  CComObject<CStringList> *p;
+  HRESULT hRes = CComObject<CStringList>::CreateInstance(&p);
+  if (FAILED(hRes))
+    return hRes;
+  CStringList *np = p;
+  np->sl_ = sl;
+  *retval = p;
+  (*retval)->AddRef();
+  return NOERROR;
+}
+
+STDMETHODIMP CStringList::First(BSTR *retval)
+{
+  TRY
+  *retval = 0;
+  GroveString str;
+  if (sl_->first(str) == accessOK) {
+    *retval = CNodeBase::makeBSTR(str);
+  }
+  return NOERROR;
+  CATCH
+}
+
+STDMETHODIMP CStringList::Rest(StringList **retval)
+{
+  TRY
+  *retval = 0;
+  GroveStringListPtr sl;
+  if (sl_->rest(sl) == accessOK)
+    return CStringList::make(sl, retval);
+  return NOERROR;
+  CATCH
+}
+
+STDMETHODIMP CStringList::get_Count(long *retval)
+{
+  TRY
+  long n = 0;
+  for (ConstGroveStringListIter iter(sl_->iter()); !iter.done(); iter.next())
+    n++;
+  *retval = n;
+  return NOERROR;
+  CATCH
+}
+
+STDMETHODIMP CStringList::get_Item(long i, BSTR *retval)
+{
+  TRY
+  *retval = 0;
+  if (i <= 0)
+    return E_INVALIDARG;
+  ConstGroveStringListIter iter(*sl_);
+  for (long n = 1; n < i && !iter.done(); n++)
+    iter.next();
+  if (iter.done())
+    return E_INVALIDARG;
+  GroveString str;
+  str = iter.cur();
+  *retval = CNodeBase::makeBSTR(str);
+  return NOERROR;
+  CATCH
+}
+// -----------
+
+HRESULT CNodeList::make(const NodeListPtr &nl, const NodeTablePtr &table, NodeList **retval)
+{
+  CComObject<CNodeList> *p;
+  HRESULT hRes = CComObject<CNodeList>::CreateInstance(&p);
+  if (FAILED(hRes))
+    return hRes;
+  CNodeList *np = p;
+  np->nl_ = nl;
+  np->table_ = table;
+  *retval = p;
+  (*retval)->AddRef();
+  return NOERROR;
+}
+
+STDMETHODIMP CNodeList::First(Node **retval)
+{
+  TRY
+  *retval = 0;
+  NodePtr nd;
+  if (nl_->first(nd) == accessOK)
+    return CNodeBase::make(nd, table_, retval);
+  return NOERROR;
+  CATCH
+}
+
+STDMETHODIMP CNodeList::Rest(NodeList **retval)
+{
+  TRY
+  *retval = 0;
+  NodeListPtr nl;
+  if (nl_->rest(nl) == accessOK)
+    return CNodeList::make(nl, table_, retval);
+  return NOERROR;
+  CATCH
+}
+
+STDMETHODIMP CNodeList::get_Count(long *retval)
+{
+  TRY
+  long n = 0;
+  NodeListPtr nl;
+  if (nl_->rest(nl) == accessOK) {
+    n++;
+    while (nl.assignRest() == accessOK)
+      n++;
+  }
+  *retval = n;
+  return NOERROR;
+  CATCH
+}
+
+STDMETHODIMP CNodeList::get_Item(long i, Node **retval)
+{
+  TRY
+  *retval = 0;
+  NodePtr nd;
+  if (i <= 0)
+    return E_INVALIDARG;
+  if (nl_->ref(i - 1, nd) != accessOK)
+    return E_INVALIDARG;
+  return CNodeBase::make(nd, table_, retval);
+  CATCH
+}
+
+STDMETHODIMP CNodeList::get__NewEnum(IUnknown **retval)
+{
+  TRY
+  return CEnumNodeList::make(nl_, table_, retval);
+  CATCH
+}
+
+HRESULT CChunkNodeList::make(const NodeListPtr &nl, const NodeTablePtr &table, NodeList **retval)
+{
+  CComObject<CChunkNodeList> *p;
+  HRESULT hRes = CComObject<CChunkNodeList>::CreateInstance(&p);
+  if (FAILED(hRes))
+    return hRes;
+  CChunkNodeList *np = p;
+  np->nl_ = nl;
+  np->table_ = table;
+  *retval = p;
+  (*retval)->AddRef();
+  return NOERROR;
+}
+
+STDMETHODIMP CChunkNodeList::First(Node **retval)
+{
+  TRY
+  *retval = 0;
+  NodePtr nd;
+  if (nl_->first(nd) == accessOK)
+    return CNodeBase::make(nd, table_, retval);
+  return NOERROR;
+  CATCH
+}
+
+STDMETHODIMP CChunkNodeList::Rest(NodeList **retval)
+{
+  TRY
+  *retval = 0;
+  NodeListPtr nl;
+  if (nl_->chunkRest(nl) == accessOK)
+    return CNodeList::make(nl, table_, retval);
+  return NOERROR;
+  CATCH
+}
+
+STDMETHODIMP CChunkNodeList::get__NewEnum(IUnknown **retval)
+{
+  TRY
+  return CEnumChunkNodeList::make(nl_, table_, retval);
+  CATCH
+}
+
+STDMETHODIMP CChunkNodeList::get_Count(long *retval)
+{
+  TRY
+  long n = 0;
+  NodeListPtr nl;
+  if (nl_->chunkRest(nl) == accessOK) {
+    n++;
+    while (nl.assignChunkRest() == accessOK)
+      n++;
+  }
+  *retval = n;
+  return NOERROR;
+  CATCH
+}
+
+STDMETHODIMP CChunkNodeList::get_Item(long i, Node **retval)
+{
+  TRY
+  *retval = 0;
+  if (i <= 0)
+    return E_INVALIDARG;
+  if (i == 1)
+    return First(retval);
+  NodeListPtr nl(nl_);
+  do {
+    if (nl.assignChunkRest() != accessOK)
+      return E_INVALIDARG;
+  } while (--i > 1);
+  NodePtr nd;
+  if (nl->first(nd) != accessOK)
+    return E_INVALIDARG;
+  return CNodeBase::make(nd, table_, retval);
+  CATCH
+}
+
+STDMETHODIMP CNamedNodeList::get_Count(long *retval)
+{
+  TRY
+  NodeListPtr nl(nnl_->nodeListNoOrder());
+  long n = 0;
+  while (nl.assignRest() == accessOK)
+    n++;
+  *retval = n;
+  return NOERROR;
+  CATCH
+}
+
+STDMETHODIMP CNamedNodeList::get_Item(BSTR name, Node **retval)
+{
+  TRY
+  *retval = 0;
+  if (!name)
+    return E_INVALIDARG;
+  GroveString tem(name, ::SysStringLen(name));
+  NodePtr nd;
+  if (nnl_->namedNode(tem, nd) != accessOK)
+    return E_INVALIDARG;
+  return CNodeBase::make(nd, table_, retval);
+  CATCH
+}
+
+STDMETHODIMP CNamedNodeList::get_NodeList(NodeList **retval)
+{
+  TRY
+  return CNodeList::make(nnl_->nodeList(), table_, retval);
+  CATCH
+}
+
+STDMETHODIMP CNamedNodeList::get__NewEnum(IUnknown **retval)
+{
+  TRY
+  return CEnumNodeList::make(nnl_->nodeListNoOrder(), table_, retval);
+  CATCH
+}
+
+STDMETHODIMP CNamedNodeList::Normalize(BSTR name, BSTR *retval)
+{
+  TRY
+  *retval = 0;
+  if (name) {
+    size_t len = ::SysStringLen(name);
+    BSTR tem = ::SysAllocStringLen(name, len);
+    size_t newLen = nnl_->normalize(tem, len);
+    if (newLen != len && !::SysReAllocStringLen(&tem, tem, newLen)) {
+      ::SysFreeString(tem);
+      return E_OUTOFMEMORY;
+    }
+    *retval = tem;
+  }
+  else
+    *retval = makeEmptyBSTR();
+  return NOERROR;
+  CATCH
+}
+
+STDMETHODIMP CNamedNodeList::NodeName(Node *nd, BSTR *retval)
+{
+  TRY
+  *retval = 0;
+  switch (nnl_->type()) {
+#define CASE(T, I, P) \
+  case GROVE_NAMESPACE::NamedNodeList::T: \
+    { \
+      I *tem; \
+      if (SUCCEEDED(nd->QueryInterface(IID_##I, (void **)&tem))) { \
+	HRESULT hRes = tem->get_##P(retval); \
+	tem->Release(); \
+	return hRes; \
+      } \
+      return NOERROR; \
+    }
+    CASE(elements,ElementNode,Id)
+    CASE(entities,EntityNode,Name)
+    CASE(notations,NotationNode,Name)
+    CASE(attributes,AttributeAssignmentNode,Name)
+    CASE(doctypesAndLinktypes,DocumentTypeNode,Name)
+    CASE(elementTypes,ElementTypeNode,Gi)
+    CASE(attributeDefs,AttributeDefNode,Name)
+  }
+  return NOERROR;
+  CATCH
+}
+
+HRESULT CNamedNodeList::make(const NamedNodeListPtr &nnl,
+			     const NodeTablePtr &table,
+			     NamedNodeList **retval)
+{
+  CComObject<CNamedNodeList> *p;
+  HRESULT hRes = CComObject<CNamedNodeList>::CreateInstance(&p);
+  if (FAILED(hRes))
+    return hRes;
+  CNamedNodeList *np = p;
+  np->nnl_ = nnl;
+  np->table_ = table;
+  *retval = p;
+  (*retval)->AddRef();
+  return NOERROR;
+}
+
+HRESULT CEnumNodeList::make(const NodeListPtr &nl, const NodeTablePtr &table,
+			    IUnknown **retval)
+{
+  CComObject<CEnumNodeList> *p;
+  HRESULT hRes = CComObject<CEnumNodeList>::CreateInstance(&p);
+  if (FAILED(hRes))
+    return hRes;
+  CEnumNodeList *np = p;
+  np->nl_ = nl;
+  np->cur_ = nl;
+  np->table_ = table;
+  return p->QueryInterface(IID_IUnknown, (void **)retval);
+}
+
+STDMETHODIMP CEnumNodeList::Next(ULONG celt, VARIANT *rgVar, ULONG *pCeltFetched)
+{
+  TRY
+  ULONG n = 0;
+  for (; celt > 0; celt--, rgVar++, n++) {
+    NodePtr nd;
+    if (cur_->first(nd) != accessOK)
+      break;
+    if (cur_.assignRest() != accessOK)
+      goto error;
+    Node *ip;
+    if (FAILED(CNodeBase::make(nd, table_, &ip)))
+      goto error;
+    rgVar->vt = VT_DISPATCH;
+    rgVar->pdispVal = ip;
+  }
+  if (pCeltFetched)
+    *pCeltFetched = n;
+  return celt ? S_FALSE : NOERROR;
+error:
+  while (n > 0) {
+    --n ;
+    --rgVar;
+    VariantClear(rgVar);
+  }
+  if (pCeltFetched)
+    *pCeltFetched = 0;
+  return S_FALSE;
+  CATCH
+}
+
+STDMETHODIMP CEnumNodeList::Skip(ULONG celt)
+{
+  TRY
+  for (; celt > 0; celt--) {
+    if (cur_.assignRest() != accessOK)
+      return S_FALSE;
+  }
+  return NOERROR;
+  CATCH
+}
+
+STDMETHODIMP CEnumNodeList::Reset()
+{
+  TRY
+  cur_ = nl_;
+  return NOERROR;
+  CATCH
+}
+
+STDMETHODIMP CEnumNodeList::Clone(IEnumVARIANT **ppEnum)
+{
+  TRY
+  CComObject<CEnumNodeList> *p;
+  HRESULT hRes = CComObject<CEnumNodeList>::CreateInstance(&p);
+  if (FAILED(hRes))
+    return hRes;
+  CEnumNodeList *np = p;
+  np->nl_ = nl_;
+  np->cur_ = cur_;
+  np->table_ = table_;
+  *ppEnum = p;
+  (*ppEnum)->AddRef();
+  return NOERROR;
+  CATCH
+}
+
+HRESULT CEnumChunkNodeList::make(const NodeListPtr &nl, const NodeTablePtr &table,
+			    IUnknown **retval)
+{
+  CComObject<CEnumChunkNodeList> *p;
+  HRESULT hRes = CComObject<CEnumChunkNodeList>::CreateInstance(&p);
+  if (FAILED(hRes))
+    return hRes;
+  CEnumChunkNodeList *np = p;
+  np->nl_ = nl;
+  np->cur_ = nl;
+  np->table_ = table;
+  return p->QueryInterface(IID_IUnknown, (void **)retval);
+}
+
+STDMETHODIMP CEnumChunkNodeList::Next(ULONG celt, VARIANT *rgVar, ULONG *pCeltFetched)
+{
+  TRY
+  ULONG n = 0;
+  for (; celt > 0; celt--, rgVar++, n++) {
+    NodePtr nd;
+    if (cur_->first(nd) != accessOK)
+      break;
+    if (cur_.assignChunkRest() != accessOK)
+      goto error;
+    Node *ip;
+    if (FAILED(CNodeBase::make(nd, table_, &ip)))
+      goto error;
+    rgVar->vt = VT_DISPATCH;
+    rgVar->pdispVal = ip;
+  }
+  if (pCeltFetched)
+    *pCeltFetched = n;
+  return celt ? S_FALSE : NOERROR;
+error:
+  while (n > 0) {
+    --n ;
+    --rgVar;
+    VariantClear(rgVar);
+  }
+  if (pCeltFetched)
+    *pCeltFetched = 0;
+  return S_FALSE;
+  CATCH
+}
+
+STDMETHODIMP CEnumChunkNodeList::Skip(ULONG celt)
+{
+  TRY
+  for (; celt > 0; celt--) {
+    if (cur_.assignChunkRest() != accessOK)
+      return S_FALSE;
+  }
+  return NOERROR;
+  CATCH
+}
+
+STDMETHODIMP CEnumChunkNodeList::Reset()
+{
+  TRY
+  cur_ = nl_;
+  return NOERROR;
+  CATCH
+}
+
+STDMETHODIMP CEnumChunkNodeList::Clone(IEnumVARIANT **ppEnum)
+{
+  TRY
+  CComObject<CEnumChunkNodeList> *p;
+  HRESULT hRes = CComObject<CEnumChunkNodeList>::CreateInstance(&p);
+  if (FAILED(hRes))
+    return hRes;
+  CEnumChunkNodeList *np = p;
+  np->nl_ = nl_;
+  np->cur_ = cur_;
+  np->table_ = table_;
+  *ppEnum = p;
+  (*ppEnum)->AddRef();
+  return NOERROR;
+  CATCH
+}
+
+HRESULT CStoragePos::make(const SP_NAMESPACE::ExternalInfo *info,
+			  SP_NAMESPACE::Offset offset,
+			  const NodePtr &nd,
+			  StoragePos **retval)
+{
+  *retval = 0;
+  CComObject<CStoragePos> *p;
+  HRESULT hRes = CComObject<CStoragePos>::CreateInstance(&p);
+  if (FAILED(hRes))
+    return hRes;
+  CStoragePos *tem = p;
+  if (!SP_NAMESPACE::ExtendEntityManager::externalize(info, offset, tem->loc_)) {
+    delete p;
+    return NOERROR;
+  }
+  tem->nd_ = nd;
+  *retval = p;
+  (*retval)->AddRef();
+  return NOERROR;
+}
+
+HRESULT makeRootNode(const GROVE_NAMESPACE::NodePtr &root,
+		     SP_NAMESPACE::Owner<ParserThread> &parser,
+		     SgmlDocumentNode **retval)
+{
+  TRY
+  NodeTablePtr table(new NodeTable(parser));
+  Node *tem;
+  HRESULT hRes = CNodeBase::make(root, table, &tem);
+  *retval = (SgmlDocumentNode *)tem;
+  return hRes;
+  CATCH
+}
--- openjade-1.4devel1.orig/groveoa/GroveNode.h
+++ openjade-1.4devel1/groveoa/GroveNode.h
@@ -0,0 +1,16 @@
+#ifndef GroveNode_INCLUDED
+#define GroveNode_INCLUDED 1
+
+#include "Owner.h"
+#include "Boolean.h"
+#include "Node.h"
+
+struct ParserThread {
+  virtual ~ParserThread() { }
+};
+
+HRESULT makeRootNode(const GROVE_NAMESPACE::NodePtr &,
+		     SP_NAMESPACE::Owner<ParserThread> &,
+		     SgmlDocumentNode **);
+
+#endif /* not GroveNode_INCLUDED */
--- openjade-1.4devel1.orig/groveoa/Makefile.am
+++ openjade-1.4devel1/groveoa/Makefile.am
@@ -0,0 +1,5 @@
+## Process this file with automake to produce Makefile.in
+
+EXTRA_DIST = CGroveBuilder.cxx CGroveBuilder.h GroveBuilder.rgs \
+	GroveNode.cxx GroveNode.h StdAfx.cxx StdAfx.h groveoa.cxx \
+	groveoa.def groveoa.dsp groveoa.idl groveoa.rc resource.h
--- openjade-1.4devel1.orig/groveoa/StdAfx.cxx
+++ openjade-1.4devel1/groveoa/StdAfx.cxx
@@ -0,0 +1,12 @@
+// stdafx.cpp : source file that includes just the standard includes
+//  stdafx.pch will be the pre-compiled header
+//  stdafx.obj will contain the pre-compiled type information
+
+#include "stdafx.h"
+
+#ifdef _ATL_STATIC_REGISTRY
+#include <statreg.h>
+#include <statreg.cpp>
+#endif
+
+#include <atlimpl.cpp>
--- openjade-1.4devel1.orig/groveoa/StdAfx.h
+++ openjade-1.4devel1/groveoa/StdAfx.h
@@ -0,0 +1,14 @@
+// stdafx.h : include file for standard system include files,
+//      or project specific include files that are used frequently,
+//      but are changed infrequently
+
+#define STRICT
+
+// #define _WIN32_WINNT 0x0400
+#define _ATL_APARTMENT_THREADED
+
+#include <atlbase.h>
+//You may derive a class from CComModule and use it if you want to override
+//something, but do not change the name of _Module
+extern CComModule _Module;
+#include <atlcom.h>
--- openjade-1.4devel1.orig/groveoa/groveoa.cxx
+++ openjade-1.4devel1/groveoa/groveoa.cxx
@@ -0,0 +1,92 @@
+// groveoa.cxx : Implementation of DLL Exports.
+
+// You will need VC 4.2 and the full 4.2b patch (http://msvc/vc42b/vc42b.htm) in 
+// order to build this project.  This patch includes the final NT 4.0 SDK.
+// You will also need MIDL 3.00.75, which is included with ATL 2.0.
+
+// Note: Proxy/Stub Information
+//		To merge the proxy/stub code into the object DLL, add the file 
+//		dlldatax.c to the project.  Make sure precompiled headers 
+//		are turned off for this file, and add _MERGE_PROXYSTUB to the 
+//		defines for the project.  
+//
+//		If you are not running MIDL with /Oicf (the default), you will need
+//		to remove the following defines from the top of dlldatax.c.
+//		#define _WIN32_WINNT 0x0400
+//		#define USE_STUBLESS_PROXY
+//
+//		Modify the custom build rule for groveoa.idl by adding the following 
+//		files to the Outputs.
+//			groveoa_p.c
+//			dlldata.c
+//		To build a separate proxy/stub DLL, 
+//		run nmake -f groveoaps.mk in the project directory.
+
+#include "stdafx.h"
+#include "resource.h"
+#include "groveoa.h"
+
+#include "groveoa_i.c"
+#include "CGroveBuilder.h"
+
+CComModule _Module;
+
+BEGIN_OBJECT_MAP(ObjectMap)
+	OBJECT_ENTRY(CLSID_GroveBuilder, CGroveBuilder)
+END_OBJECT_MAP()
+
+/////////////////////////////////////////////////////////////////////////////
+// DLL Entry Point
+
+extern "C"
+BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
+{
+	lpReserved;
+	if (dwReason == DLL_PROCESS_ATTACH)
+	{
+		_Module.Init(ObjectMap, hInstance);
+		DisableThreadLibraryCalls(hInstance);
+	}
+	else if (dwReason == DLL_PROCESS_DETACH)
+		_Module.Term();
+	return TRUE;    // ok
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Used to determine whether the DLL can be unloaded by OLE
+
+STDAPI DllCanUnloadNow(void)
+{
+	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Returns a class factory to create an object of the requested type
+
+STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
+{
+	return _Module.GetClassObject(rclsid, riid, ppv);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// DllRegisterServer - Adds entries to the system registry
+
+STDAPI DllRegisterServer(void)
+{
+	// registers object, typelib and all interfaces in typelib
+	return _Module.RegisterServer(TRUE);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// DllUnregisterServer - Removes entries from the system registry
+
+STDAPI DllUnregisterServer(void)
+{
+	_Module.UnregisterServer();
+#if _WIN32_WINNT >= 0x0400
+	UnRegisterTypeLib(LIBID_GROVE, 1, 0, LOCALE_USER_DEFAULT, SYS_WIN32);
+#endif
+	return S_OK;
+}
+
+
--- openjade-1.4devel1.orig/groveoa/groveoa.def
+++ openjade-1.4devel1/groveoa/groveoa.def
@@ -0,0 +1,9 @@
+; groveoa.def : Declares the module parameters.
+
+LIBRARY      "ogroveoa.DLL"
+
+EXPORTS
+	DllCanUnloadNow     @1 PRIVATE
+	DllGetClassObject   @2 PRIVATE
+	DllRegisterServer   @3 PRIVATE
+	DllUnregisterServer	@4 PRIVATE
--- openjade-1.4devel1.orig/groveoa/groveoa.dsp
+++ openjade-1.4devel1/groveoa/groveoa.dsp
@@ -0,0 +1,163 @@
+# Microsoft Developer Studio Project File - Name="groveoa" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Dynamic-Link Library" 0x0102
+
+CFG=groveoa - Win32 Release
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "groveoa.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "groveoa.mak" CFG="groveoa - Win32 Release"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "groveoa - Win32 Release" (based on "Win32 (x86) Dynamic-Link Library")
+!MESSAGE "groveoa - Win32 Debug" (based on "Win32 (x86) Dynamic-Link Library")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+MTL=midl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "groveoa - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir ".\Release"
+# PROP BASE Intermediate_Dir ".\Release"
+# PROP BASE Target_Dir "."
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir ".\Release"
+# PROP Intermediate_Dir ".\Release"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir "."
+# ADD BASE CPP /nologo /MT /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /YX /c
+# ADD CPP /nologo /MD /W3 /GX /O2 /I "..\include" /I "..\grove" /I "..\spgrove" /D "_MBCS" /D "_ATL_STATIC_REGISTRY" /D "_WINDLL" /D "NDEBUG" /D "_WINDOWS" /D "WIN32" /D SP_NAMESPACE=James_Clark_SP /D GROVE_NAMESPACE=James_Clark_GROVE /D "SP_MULTI_BYTE" /YX /FD /c
+# ADD BASE MTL /nologo /D "NDEBUG" /win32
+# ADD MTL /nologo /D "NDEBUG" /mktyplib203 /win32
+# ADD BASE RSC /l 0x809 /d "NDEBUG"
+# ADD RSC /l 0x809 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /machine:I386
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /machine:I386 /out:"..\bin\ogroveoa.dll" /base:0x25000000
+# Begin Special Build Tool
+TargetPath=\users\Avi\jadetest\jade\bin\ogroveoa.dll
+SOURCE="$(InputPath)"
+PostBuild_Cmds=regsvr32 /s /c "$(TargetPath)"
+# End Special Build Tool
+
+!ELSEIF  "$(CFG)" == "groveoa - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir ".\Debug"
+# PROP BASE Intermediate_Dir ".\Debug"
+# PROP BASE Target_Dir "."
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir ".\Debug"
+# PROP Intermediate_Dir ".\Debug"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir "."
+# ADD BASE CPP /nologo /MTd /W3 /Gm /GX /Zi /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /YX /c
+# ADD CPP /nologo /MDd /W3 /Gm /GX /ZI /Od /I "..\include" /I "..\grove" /I "..\spgrove" /D "_MBCS" /D "_ATL_STATIC_REGISTRY" /D "_WINDLL" /D "_DEBUG" /D "_WINDOWS" /D "WIN32" /D SP_NAMESPACE=James_Clark_SP /D GROVE_NAMESPACE=James_Clark_GROVE /D "SP_MULTI_BYTE" /YX /FD /c
+# ADD BASE MTL /nologo /D "_DEBUG" /win32
+# ADD MTL /nologo /D "_DEBUG" /mktyplib203 /win32
+# ADD BASE RSC /l 0x809 /d "_DEBUG"
+# ADD RSC /l 0x809 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /debug /machine:I386
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /debug /machine:I386 /out:"..\dbgbin\ogroveoa.dll" /base:0x25000000
+# SUBTRACT LINK32 /incremental:no
+
+!ENDIF 
+
+# Begin Target
+
+# Name "groveoa - Win32 Release"
+# Name "groveoa - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat;for;f90"
+# Begin Source File
+
+SOURCE=.\CGroveBuilder.cxx
+# ADD CPP /Yu"stdafx.h"
+# End Source File
+# Begin Source File
+
+SOURCE=.\GroveNode.cxx
+# ADD CPP /Yu"stdafx.h"
+# End Source File
+# Begin Source File
+
+SOURCE=.\groveoa.cxx
+# ADD CPP /Yu"stdafx.h"
+# End Source File
+# Begin Source File
+
+SOURCE=.\groveoa.def
+# End Source File
+# Begin Source File
+
+SOURCE=.\groveoa.idl
+# ADD MTL /tlb "groveoa.tlb" /h "groveoa.h" /iid "groveoa_i.c" /Oicf
+# SUBTRACT MTL /mktyplib203
+# End Source File
+# Begin Source File
+
+SOURCE=.\StdAfx.cxx
+# ADD CPP /Yc"stdafx.h"
+# End Source File
+# End Group
+# Begin Group "Header Files"
+
+# PROP Default_Filter "h;hpp;hxx;hm;inl;fi;fd"
+# Begin Source File
+
+SOURCE=.\CGroveBuilder.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\GroveNode.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\resource.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\StdAfx.h
+# End Source File
+# End Group
+# Begin Group "Resource Files"
+
+# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;cnt;rtf;gif;jpg;jpeg;jpe"
+# Begin Source File
+
+SOURCE=.\groveoa.rc
+# End Source File
+# End Group
+# Begin Source File
+
+SOURCE=.\GroveBuilder.rgs
+# End Source File
+# End Target
+# End Project
--- openjade-1.4devel1.orig/groveoa/groveoa.idl
+++ openjade-1.4devel1/groveoa/groveoa.idl
@@ -0,0 +1,773 @@
+// groveoa.idl : IDL source for groveoa.dll
+
+// This file will be processed by the MIDL tool to
+// produce the type library (groveoa.tlb) and marshalling code.
+
+import "oaidl.idl";
+
+interface Node;
+interface NodeList;
+interface NamedNodeList;
+interface StringList;
+
+interface ElementNode;
+interface AttributeAssignmentNode;
+interface AttributeValueTokenNode;
+interface DataCharNode;
+interface SgmlDocumentNode;
+interface SgmlConstantsNode;
+interface PiNode;
+interface SdataNode;
+interface DocumentTypeNode;
+interface EntityNode;
+interface NotationNode;
+interface ExternalIdNode;
+interface ExternalDataNode;
+interface SubdocNode;
+interface MessageNode;
+interface StoragePos;
+interface ElementTypeNode;
+interface AttributeDefNode;
+interface ModelGroupNode;
+interface ElementTokenNode;
+interface PcdataTokenNode;
+interface DefaultEntityNode;
+
+enum NodeClass {
+	nodeClassElement,
+	nodeClassAttributeAssignment,
+	nodeClassAttributeValueToken,
+	nodeClassDataChar,
+	nodeClassSgmlDocument,
+	nodeClassSgmlConstants,
+	nodeClassPi,
+	nodeClassSdata,
+	nodeClassDocumentType,
+	nodeClassEntity,
+	nodeClassNotation,
+	nodeClassExternalId,
+	nodeClassExternalData,
+	nodeClassSubdoc,
+	nodeClassMessage,
+	nodeClassElementType,
+	nodeClassAttributeDef,
+	nodeClassElementToken,
+	nodeClassPcdataToken,
+	nodeClassDefaultEntity,
+	nodeClassModelGroup
+};
+
+enum EntityType {
+	entityTypeText,
+	entityTypeCdata,
+	entityTypeSdata,
+	entityTypeNdata,
+	entityTypeSubdocument,
+	entityTypePi
+};
+
+enum ContentType {
+	contentTypeCdata,
+	contentTypeRcdata,
+	contentTypeEmpty,
+	contentTypeAny,
+	contentTypeModelGroup
+};
+
+enum DeclValueType {
+	declValueTypeCdata,
+	declValueTypeEntity,
+	declValueTypeEntities,
+	declValueTypeId,
+	declValueTypeIdref,
+	declValueTypeIdrefs,
+	declValueTypeName,
+	declValueTypeNames,
+	declValueTypeNmtoken,
+    declValueTypeNmtokens,
+	declValueTypeNumber,
+	declValueTypeNumbers,
+	declValueTypeNutoken,
+	declValueTypeNutokens,
+	declValueTypeNotation,
+	declValueTypeNmtkgrp
+};
+
+enum DefaultValueType {
+	defaultValueTypeValue,
+	defaultValueTypeFixed,
+	defaultValueTypeRequired,
+	defaultValueTypeCurrent,
+	defaultValueTypeConref,
+	defaultValueTypeImplied
+};
+
+enum Connector {
+	connectorAnd,
+	connectorOr,
+	connectorSeq
+};
+
+enum OccurIndicator {
+	occurIndicatorOpt,
+	occurIndicatorPlus,
+	occurIndicatorRep
+};
+
+enum Severity {
+	severityInfo,
+	severityWarning,
+	severityError
+};
+
+[
+	object,
+	uuid(B3BE8C20-BA4A-11d0-9083-0020AF41CFC2),
+	dual,
+	pointer_default(unique)
+]
+interface Node : IDispatch
+{
+	[propget]
+	HRESULT Parent([out, retval] Node **);
+	[propget]
+	HRESULT Origin([out, retval] Node **);
+	/* Using SgmlDocumentNode as the return type doesn't work. */
+	[propget]
+	HRESULT GroveRoot([out, retval] Node **);
+	[propget]
+	HRESULT TreeRoot([out, retval] Node **);
+	[propget]
+	HRESULT Children([out, retval] NodeList **);
+	[propget]
+	HRESULT ChunkChildren([out, retval] NodeList **);
+	[propget]
+	HRESULT Class([out, retval] enum NodeClass *);
+	[propget]
+	HRESULT StoragePos([out, retval] StoragePos **);
+	[propget]
+	HRESULT SiblingIndex([out, retval] long *);
+
+	HRESULT FirstChild([out, retval] Node **);
+	HRESULT NextSibling([out, retval] Node **);
+	HRESULT NextChunkSibling([out, retval] Node **);
+}
+
+[
+	object,
+    uuid(D8334201-9FD6-11d0-9083-0020AF41CFC2),
+	dual,
+	pointer_default(unique)
+]
+interface SgmlDocumentNode : Node
+{
+	[propget]
+	HRESULT DocumentElement([out, retval] ElementNode **);
+	[propget]
+	HRESULT SgmlConstants([out, retval] SgmlConstantsNode **);
+	[propget]
+	HRESULT ApplicationInfo([out, retval] BSTR *);
+	[propget]
+	HRESULT ApplicationInfoNull([out, retval] VARIANT_BOOL *);
+	[propget]
+	HRESULT Prolog([out, retval] NodeList **);
+	[propget]
+	HRESULT Epilog([out, retval] NodeList **);
+	[propget]
+	HRESULT Elements([out, retval] NamedNodeList **);
+	[propget]
+	HRESULT Entities([out, retval] NamedNodeList **);
+	[propget]
+	HRESULT DefaultedEntities([out, retval] NamedNodeList **);
+	[propget]
+	HRESULT GoverningDoctype([out, retval] DocumentTypeNode **);
+	[propget]
+	HRESULT DoctypesAndLinktypes([out, retval] NamedNodeList **);
+	[propget]
+	HRESULT Messages([out, retval] NodeList **);
+}
+
+[
+	object,
+	uuid(D8334202-9FD6-11d0-9083-0020AF41CFC2),
+	dual,
+	pointer_default(unique)
+]
+interface ElementNode : Node
+{
+	[propget]
+	HRESULT Gi([out, retval] BSTR *);
+	[propget]
+	HRESULT Attributes([out, retval] NamedNodeList **);
+	[propget]
+	HRESULT Id([out, retval] BSTR *);
+	[propget]
+	HRESULT Content([out, retval] NodeList **);
+	[propget]
+	HRESULT ChunkContent([out, retval] NodeList **);
+	[propget]
+	HRESULT Included([out, retval] VARIANT_BOOL *);
+	[propget]
+	HRESULT MustOmitEndTag([out, retval] VARIANT_BOOL *);
+	[propget]
+	HRESULT ElementType([out, retval] ElementTypeNode **);
+}
+
+[
+	object,
+	uuid(D8334203-9FD6-11d0-9083-0020AF41CFC2),
+	dual,
+	pointer_default(unique)
+]
+interface DataCharNode : Node
+{
+	[propget]
+	HRESULT Char([out, retval] long *);
+	[propget]
+	HRESULT NonSgml([out, retval] long *);
+	[propget]
+	HRESULT CharChunk([out, retval] BSTR *);
+}
+
+[
+	object,
+	uuid(D8334204-9FD6-11d0-9083-0020AF41CFC2),
+	dual,
+	pointer_default(unique)
+]
+interface AttributeAssignmentNode : Node
+{
+	[propget]
+	HRESULT Name([out, retval] BSTR *);
+	[propget]
+	HRESULT Implied([out, retval] VARIANT_BOOL *);
+	[propget]
+	HRESULT Value([out, retval] NodeList **);
+	[propget]
+	HRESULT ChunkValue([out, retval] NodeList **);
+	[propget]
+	HRESULT TokenSep([out, retval] long *);
+	[propget, id(DISPID_VALUE)]
+	HRESULT StringValue([out, retval] BSTR *);
+	[propget]
+	HRESULT AttributeDef([out, retval] AttributeDefNode **);
+}
+
+[
+	object,
+	uuid(D8334205-9FD6-11d0-9083-0020AF41CFC2),
+	dual,
+	pointer_default(unique)
+]
+interface AttributeValueTokenNode : Node
+{
+	[propget, id(DISPID_VALUE)]
+	HRESULT Token([out, retval] BSTR *);
+	[propget]
+	HRESULT Referent([out, retval] ElementNode **);
+	[propget]
+	HRESULT Entity([out, retval] EntityNode **);
+	[propget]
+	HRESULT Notation([out, retval] NotationNode **);
+}
+
+[
+	object,
+	uuid(D8334206-9FD6-11d0-9083-0020AF41CFC2),
+	dual,
+	pointer_default(unique)
+]
+interface SgmlConstantsNode : Node
+{
+}
+
+[
+	object,
+	uuid(D8334207-9FD6-11d0-9083-0020AF41CFC2),
+	dual,
+	pointer_default(unique)
+]
+interface PiNode : Node
+{
+	[propget]
+	HRESULT SystemData([out, retval] BSTR *);
+	[propget]
+	HRESULT Entity([out, retval] EntityNode **);
+	[propget]
+	HRESULT EntityName([out, retval] BSTR *);
+}
+
+[
+	object,
+	uuid(D8334208-9FD6-11d0-9083-0020AF41CFC2),
+	dual,
+	pointer_default(unique)
+]
+interface SdataNode : Node
+{
+	[propget]
+	HRESULT SystemData([out, retval] BSTR *);
+	[propget]
+	HRESULT Entity([out, retval] EntityNode **);
+	[propget]
+	HRESULT EntityName([out, retval] BSTR *);
+}
+
+[
+	object,
+	uuid(D8334209-9FD6-11d0-9083-0020AF41CFC2),
+	dual,
+	pointer_default(unique)
+]
+interface DocumentTypeNode : Node
+{
+	[propget]
+	HRESULT Name([out, retval] BSTR *);
+	[propget]
+	HRESULT Governing([out, retval] VARIANT_BOOL *);
+	[propget]
+	HRESULT GeneralEntities([out, retval] NamedNodeList **);
+	[propget]
+	HRESULT Notations([out, retval] NamedNodeList **);
+	[propget]
+	HRESULT ElementTypes([out, retval] NamedNodeList **);
+	[propget]
+	HRESULT ParameterEntities([out, retval] NamedNodeList **);
+	[propget]
+	HRESULT DefaultEntity([out, retval] DefaultEntityNode **);
+}
+
+[
+	object,
+	uuid(D833420A-9FD6-11d0-9083-0020AF41CFC2),
+	dual,
+	pointer_default(unique)
+]
+interface EntityNode : Node
+{
+	[propget]
+	HRESULT Name([out, retval] BSTR *);
+	[propget]
+	HRESULT Text([out, retval] BSTR *);
+	[propget]
+	HRESULT TextNull([out, retval] VARIANT_BOOL *);
+	[propget]
+	HRESULT Notation([out, retval] NotationNode **);
+	[propget]
+	HRESULT NotationName([out, retval] BSTR *);
+	[propget]
+	HRESULT EntityType([out, retval] enum EntityType *);
+	[propget]
+	HRESULT Defaulted([out, retval] VARIANT_BOOL *);
+	[propget]
+	HRESULT Attributes([out, retval] NamedNodeList **);
+	[propget]
+	HRESULT ExternalId([out, retval] ExternalIdNode **);
+}
+
+[
+	object,
+	uuid(D833420B-9FD6-11d0-9083-0020AF41CFC2),
+	dual,
+	pointer_default(unique)
+]
+interface NotationNode : Node
+{
+	[propget]
+	HRESULT Name([out, retval] BSTR *);
+	[propget]
+	HRESULT ExternalId([out, retval] ExternalIdNode **);
+	[propget]
+	HRESULT AttributeDefs([out, retval] NamedNodeList **);
+}
+
+[
+	object,
+	uuid(D833420C-9FD6-11d0-9083-0020AF41CFC2),
+	dual,
+	pointer_default(unique)
+]
+interface ExternalIdNode : Node
+{
+	[propget]
+	HRESULT PublicId([out, retval] BSTR *);
+	[propget]
+	HRESULT PublicIdNull([out, retval] VARIANT_BOOL *);
+	[propget]
+	HRESULT SystemId([out, retval] BSTR *);
+	[propget]
+	HRESULT SystemIdNull([out, retval] VARIANT_BOOL *);
+	[propget]
+	HRESULT GeneratedSystemId([out, retval] BSTR *);
+}
+
+[
+	object,
+	uuid(D833420D-9FD6-11d0-9083-0020AF41CFC2),
+	dual,
+	pointer_default(unique)
+]
+interface ExternalDataNode : Node
+{
+	[propget]
+	HRESULT Entity([out, retval] EntityNode **);
+	[propget]
+	HRESULT EntityName([out, retval] BSTR *);
+}
+
+[
+	object,
+	uuid(D833420E-9FD6-11d0-9083-0020AF41CFC2),
+	dual,
+	pointer_default(unique)
+]
+interface SubdocNode : Node
+{
+	[propget]
+	HRESULT Entity([out, retval] EntityNode **);
+	[propget]
+	HRESULT EntityName([out, retval] BSTR *);
+}
+
+[
+	object,
+	uuid(D833420F-9FD6-11d0-9083-0020AF41CFC2),
+	dual,
+	pointer_default(unique)
+]
+interface ElementTypeNode : Node
+{
+	[propget]
+	HRESULT Gi([out, retval] BSTR *);
+	[propget]
+	HRESULT AttributeDefs([out, retval] NamedNodeList **);
+	[propget]
+	HRESULT ContentType([out, retval] enum ContentType *);
+	[propget]
+	HRESULT Exclusions([out, retval] StringList **);
+	[propget]
+	HRESULT Inclusions([out, retval] StringList **);
+	[propget]
+	HRESULT ModelGroup([out, retval] ModelGroupNode **);
+	[propget]
+	HRESULT OmitEndTag([out, retval] VARIANT_BOOL *);
+	[propget]
+	HRESULT OmitStartTag([out, retval] VARIANT_BOOL *);
+}
+
+[
+	object,
+	uuid(D8334210-9FD6-11d0-9083-0020AF41CFC2),
+	dual,
+	pointer_default(unique)
+]
+interface AttributeDefNode : Node
+{
+	[propget]
+	HRESULT Name([out, retval] BSTR *);
+	[propget]
+	HRESULT DeclValueType([out, retval] enum DeclValueType *);
+	[propget]
+	HRESULT DefaultValueType([out, retval] enum DefaultValueType *);
+	[propget]
+	HRESULT Tokens([out, retval] StringList **);
+	[propget]
+	HRESULT CurrentAttributeIndex([out, retval] long *);
+	[propget]
+	HRESULT CurrentGroup([out, retval] NodeList **);
+	[propget]
+	HRESULT DefaultValue([out, retval] NodeList **);
+}
+
+[
+	object,
+	uuid(D8334211-9FD6-11d0-9083-0020AF41CFC2),
+	dual,
+	pointer_default(unique)
+]
+interface ModelGroupNode : Node
+{
+	[propget]
+	HRESULT Connector([out, retval] enum Connector *);
+	[propget]
+	HRESULT OccurIndicator([out, retval] enum OccurIndicator *);
+	[propget]
+	HRESULT ContentTokens([out, retval] NodeList **);
+}
+
+[
+	object,
+	uuid(D8334212-9FD6-11d0-9083-0020AF41CFC2),
+	dual,
+	pointer_default(unique)
+]
+interface ElementTokenNode : Node
+{
+	[propget]
+	HRESULT Gi([out, retval] BSTR *);
+	[propget]
+	HRESULT OccurIndicator([out, retval] enum OccurIndicator *);
+}
+
+[
+	object,
+	uuid(D8334213-9FD6-11d0-9083-0020AF41CFC2),
+	dual,
+	pointer_default(unique)
+]
+interface PcdataTokenNode : Node
+{
+}
+
+[
+	object,
+	uuid(D8334214-9FD6-11d0-9083-0020AF41CFC2),
+	dual,
+	pointer_default(unique)
+]
+interface DefaultEntityNode : Node
+{
+	[propget]
+	HRESULT Name([out, retval] BSTR *);
+	[propget]
+	HRESULT Text([out, retval] BSTR *);
+	[propget]
+	HRESULT TextNull([out, retval] VARIANT_BOOL *);
+	[propget]
+	HRESULT Notation([out, retval] NotationNode **);
+	[propget]
+	HRESULT NotationName([out, retval] BSTR *);
+	[propget]
+	HRESULT EntityType([out, retval] enum EntityType *);
+	[propget]
+	HRESULT Attributes([out, retval] NamedNodeList **);
+	[propget]
+	HRESULT ExternalId([out, retval] ExternalIdNode **);
+}
+
+[
+	object,
+	uuid(8E5A3821-A213-11d0-9083-0020AF41CFC2),
+	dual,
+	pointer_default(unique)
+]
+interface MessageNode : Node
+{
+	[propget]
+	HRESULT Text([out, retval] BSTR *);
+	[propget]
+	HRESULT Severity([out, retval] enum Severity *);
+}
+
+[
+	object,
+	uuid(BA7A21C0-9FA9-11d0-9083-0020AF41CFC2),
+	dual,
+	pointer_default(unique)
+]
+interface NamedNodeList : IDispatch
+{
+	[propget, helpstring("Returns number of nodes.")]
+	HRESULT Count([out, retval] long *retval);
+
+	[propget, id(DISPID_VALUE), helpstring("Given a name, return the node.")]
+	/* if you use "name" for the parameter name, MIDL outputs a TLB file
+	   that uses "name" instead of "Name" for "Name" properties */
+	HRESULT Item([in] BSTR nodeName, [out, retval] Node **retval);
+	[propget, restricted, id(DISPID_NEWENUM)]
+	HRESULT _NewEnum([out, retval] IUnknown **retval);
+
+    [propget]
+	HRESULT NodeList([out, retval] NodeList **retval);
+
+	HRESULT Normalize([in] BSTR nodeName, [out, retval] BSTR *);
+	HRESULT NodeName([in] Node *, [out, retval] BSTR *);
+}
+
+[
+	object,
+	uuid(BA7A21C1-9FA9-11d0-9083-0020AF41CFC2),
+	dual
+]
+interface NodeList : IDispatch
+{
+	HRESULT First([out, retval] Node **);
+	HRESULT Rest([out, retval] NodeList **);
+
+	[propget, helpstring("Returns number of nodes.")]
+	HRESULT Count([out, retval] long *retval);
+
+	[propget, id(DISPID_VALUE),
+	 helpstring("Given an index, return the node.  First node has index 1.")]
+	HRESULT Item([in] long index, [out, retval] Node **retval);
+
+	[propget, restricted, id(DISPID_NEWENUM)]
+	HRESULT _NewEnum([out, retval] IUnknown **retval);	
+}
+
+[
+	object,
+	uuid(BA7A21C2-9FA9-11d0-9083-0020AF41CFC2),
+	dual
+]
+interface StringList : IDispatch
+{
+	HRESULT First([out, retval] BSTR *);
+	HRESULT Rest([out, retval] StringList **);
+
+	[propget, helpstring("Returns number of strings.")]
+	HRESULT Count([out, retval] long *retval);
+
+	[propget, id(DISPID_VALUE),
+	 helpstring("Given an index, return the string.  First string has index 1.")]
+	HRESULT Item([in] long index, [out, retval] BSTR *retval);
+}
+
+[
+	object,
+	uuid(18E670A0-AE01-11D0-9083-0020AF41CFC2),
+	dual,
+	pointer_default(unique)
+]
+interface StoragePos : IDispatch
+{
+	[propget]
+	HRESULT StorageManagerName([out, retval] BSTR *);
+	[propget]
+	HRESULT StorageObjectId([out, retval] BSTR *);
+	[propget]
+	HRESULT LineNumber([out, retval] long *);
+	[propget]
+	HRESULT ColumnNumber([out, retval] long *);
+	[propget]
+	HRESULT ByteIndex([out, retval] long *);
+	[propget]
+	HRESULT CharacterIndex([out, retval] long *);
+}
+
+enum ErrorType {
+  errorIdref,
+  errorSignificant,
+  errorAfdr,
+  errorLpdNotation,
+  errorValid
+};
+
+enum WarningType {
+  warningSgmlDecl,
+  warningDuplicateEntity,
+  warningShould,
+  warningUndefinedElement,
+  warningDefaultEntityReference,
+  warningMixedContent,
+  warningUnclosedTag,
+  warningNet,
+  warningEmptyTag,
+  warningUnusedMap,
+  warningUnusedParam,
+  warningNotationSystemId
+};
+
+[
+	object,
+	uuid(557CE381-9EBD-11D0-9083-0020AF41CFC2),
+	dual,
+	hidden,
+	pointer_default(unique)
+]
+interface _GroveBuilder : IDispatch
+{
+	[propget]
+	HRESULT ExtraCatalogs([out, retval] BSTR *);
+	[propput]
+	HRESULT ExtraCatalogs([in] BSTR catalogs);
+	[propget]
+	HRESULT DefaultCatalogs([out, retval] BSTR *);
+	[propput]
+	HRESULT DefaultCatalogs([in] BSTR catalogs);
+	[propget]
+	HRESULT ExtraDirectories([out, retval] BSTR *);
+	[propput]
+	HRESULT ExtraDirectories([in] BSTR dirs);
+	[propget]
+	HRESULT DefaultDirectories([out, retval] BSTR *);
+	[propput]
+	HRESULT DefaultDirectories([in] BSTR dirs);
+	[propget]
+	HRESULT Encoding([out, retval] BSTR *);
+	[propput]
+	HRESULT Encoding([in] BSTR name);
+	[propget]
+	HRESULT DefaultEncoding([out, retval] BSTR *);
+	[propput]
+	HRESULT DefaultEncoding([in] BSTR name);
+	[propget]
+	HRESULT Includes([out, retval] BSTR *);
+	[propput]
+	HRESULT Includes([in] BSTR entityNames);
+    [propget]
+	HRESULT Warning([in] enum WarningType type, [out, retval] VARIANT_BOOL *);
+    [propput]
+	HRESULT Warning([in] enum WarningType type, [in] VARIANT_BOOL);
+    [propget]
+	HRESULT Error([in] enum ErrorType type, [out, retval] VARIANT_BOOL *);
+    [propput]
+	HRESULT Error([in] enum ErrorType type, [in] VARIANT_BOOL);
+    [propget]
+	HRESULT ValidateOnly([out, retval] VARIANT_BOOL *);
+    [propput]
+	HRESULT ValidateOnly([in] VARIANT_BOOL);
+
+	HRESULT parse([in] BSTR systemId, [out, retval] SgmlDocumentNode **);
+
+	HRESULT archParse([in] BSTR systemId,
+					  [in] BSTR archNames,
+					  [out, retval] SgmlDocumentNode **);
+}
+
+[
+	uuid(8E1C3D40-9EBC-11D0-9083-0020AF41CFC2),
+	version(1.0),
+	helpstring("SP Grove 1.0 Type Library")
+]
+library GROVE
+{
+	importlib("stdole32.tlb");
+	importlib("stdole2.tlb");
+
+	interface Node;
+	interface NodeList;
+	interface NamedNodeList;
+	interface StringList;
+
+	interface ElementNode;
+	interface AttributeAssignmentNode;
+	interface AttributeValueTokenNode;
+	interface DataCharNode;
+	interface SgmlDocumentNode;
+	interface SgmlConstantsNode;
+	interface PiNode;
+	interface SdataNode;
+	interface DocumentTypeNode;
+	interface EntityNode;
+	interface NotationNode;
+	interface ExternalIdNode;
+	interface ExternalDataNode;
+	interface SubdocNode;
+	interface MessageNode;
+	interface StoragePos;
+	interface ElementTypeNode;
+	interface AttributeDefNode;
+	interface ModelGroupNode;
+	interface ElementTokenNode;
+	interface PcdataTokenNode;
+	interface DefaultEntityNode;
+	
+	[
+		uuid(557CE382-9EBD-11D0-9083-0020AF41CFC2)
+	]
+	coclass GroveBuilder
+	{
+		[default] interface _GroveBuilder;
+	}
+}
--- openjade-1.4devel1.orig/groveoa/groveoa.rc
+++ openjade-1.4devel1/groveoa/groveoa.rc
@@ -0,0 +1,136 @@
+//Microsoft Developer Studio generated resource script.
+//
+#include "resource.h"
+
+#define APSTUDIO_READONLY_SYMBOLS
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 2 resource.
+//
+#include "winres.h"
+
+/////////////////////////////////////////////////////////////////////////////
+#undef APSTUDIO_READONLY_SYMBOLS
+
+/////////////////////////////////////////////////////////////////////////////
+// English (U.S.) resources
+
+#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
+#ifdef _WIN32
+LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
+#pragma code_page(1252)
+#endif //_WIN32
+
+#ifdef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// TEXTINCLUDE
+//
+
+1 TEXTINCLUDE DISCARDABLE 
+BEGIN
+    "resource.h\0"
+END
+
+2 TEXTINCLUDE DISCARDABLE 
+BEGIN
+    "#include ""winres.h""\r\n"
+    "\0"
+END
+
+3 TEXTINCLUDE DISCARDABLE 
+BEGIN
+    "1 TYPELIB ""groveoa.tlb""\r\n"
+    "\0"
+END
+
+#endif    // APSTUDIO_INVOKED
+
+
+#ifndef _MAC
+/////////////////////////////////////////////////////////////////////////////
+//
+// Version
+//
+
+VS_VERSION_INFO VERSIONINFO
+ FILEVERSION 1,0,0,1
+ PRODUCTVERSION 1,0,0,1
+ FILEFLAGSMASK 0x3fL
+#ifdef _DEBUG
+ FILEFLAGS 0x1L
+#else
+ FILEFLAGS 0x0L
+#endif
+ FILEOS 0x4L
+ FILETYPE 0x2L
+ FILESUBTYPE 0x0L
+BEGIN
+    BLOCK "StringFileInfo"
+    BEGIN
+        BLOCK "040904B0"
+        BEGIN
+            VALUE "CompanyName", "\0"
+            VALUE "FileDescription", "groveoa Module\0"
+            VALUE "FileVersion", "1, 0, 0, 1\0"
+            VALUE "InternalName", "GROVEOA\0"
+            VALUE "LegalCopyright", "Copyright  1995\0"
+            VALUE "OriginalFilename", "GROVEOA.DLL\0"
+            VALUE "ProductName", "groveoa Module\0"
+            VALUE "ProductVersion", "1, 0, 0, 1\0"
+            VALUE "OLESelfRegister", "\0"
+        END
+    END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x409, 1200
+    END
+END
+
+#endif    // !_MAC
+
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// String Table
+//
+
+STRINGTABLE DISCARDABLE 
+BEGIN
+    IDS_PROJNAME            "Groveoa"
+END
+
+#endif    // English (U.S.) resources
+/////////////////////////////////////////////////////////////////////////////
+
+
+/////////////////////////////////////////////////////////////////////////////
+// English (U.K.) resources
+
+#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENG)
+#ifdef _WIN32
+LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_UK
+#pragma code_page(1252)
+#endif //_WIN32
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// REGISTRY
+//
+
+IDR_GROVEBUILDER        REGISTRY DISCARDABLE    "GroveBuilder.rgs"
+#endif    // English (U.K.) resources
+/////////////////////////////////////////////////////////////////////////////
+
+
+
+#ifndef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 3 resource.
+//
+1 TYPELIB "groveoa.tlb"
+
+/////////////////////////////////////////////////////////////////////////////
+#endif    // not APSTUDIO_INVOKED
+
--- openjade-1.4devel1.orig/groveoa/resource.h
+++ openjade-1.4devel1/groveoa/resource.h
@@ -0,0 +1,17 @@
+//{{NO_DEPENDENCIES}}
+// Microsoft Developer Studio generated include file.
+// Used by groveoa.rc
+//
+#define IDS_PROJNAME                    100
+#define IDR_GROVEBUILDER                101
+
+// Next default values for new objects
+// 
+#ifdef APSTUDIO_INVOKED
+#ifndef APSTUDIO_READONLY_SYMBOLS
+#define _APS_NEXT_RESOURCE_VALUE        201
+#define _APS_NEXT_COMMAND_VALUE         32768
+#define _APS_NEXT_CONTROL_VALUE         201
+#define _APS_NEXT_SYMED_VALUE           102
+#endif
+#endif
--- openjade-1.4devel1.orig/intl/ChangeLog
+++ openjade-1.4devel1/intl/ChangeLog
@@ -0,0 +1,1086 @@
+1998-04-29  Ulrich Drepper  <drepper@cygnus.com>
+
+	* intl/localealias.c (read_alias_file): Use unsigned char for
+	local variables.  Remove unused variable tp.
+	* intl/l10nflist.c (_nl_normalize_codeset): Use unsigned char *
+	for type of codeset.  For loosing Solaris systems.
+	* intl/loadinfo.h: Adapt prototype of _nl_normalize_codeset.
+	* intl/bindtextdom.c (BINDTEXTDOMAIN): Don't define local variable
+	len if not needed.
+	Patches by Jim Meyering.
+
+1998-04-28  Ulrich Drepper  <drepper@cygnus.com>
+
+	* loadmsgcat.c (_nl_load_domain): Don't assign the element use_mmap if
+	mmap is not supported.
+
+	* hash-string.h: Don't include <values.h>.
+
+1998-04-27  Ulrich Drepper  <drepper@cygnus.com>
+
+	* textdomain.c: Use strdup is available.
+
+	* localealias.c: Define HAVE_MEMPCPY so that we can use this
+	function.  Define and use semapahores to protect modfication of
+	global objects when compiling for glibc.  Add code to allow
+	freeing alias table.
+
+	* l10nflist.c: Don't assume stpcpy not being a macro.
+
+	* gettextP.h: Define internal_function macri if not already done.
+	Use glibc byte-swap macros instead of defining SWAP when compiled
+	for glibc.
+	(struct loaded_domain): Add elements to allow unloading.
+
+	* Makefile.in (distclean): Don't remove libintl.h here.
+
+	* bindtextdomain.c: Carry over changes from glibc.  Use strdup if
+	available.
+
+	* dcgettext.c: Don't assume stpcpy not being a macro.  Mark internal
+	functions.  Add memory freeing code for glibc.
+
+	* dgettext.c: Update copyright.
+
+	* explodename.c: Include stdlib.h and string.h only if they exist.
+	Use strings.h eventually.
+
+	* finddomain.c: Mark internal functions.  Use strdup if available.
+	Add memory freeing code for glibc.
+
+1997-10-10 20:00  Ulrich Drepper  <drepper@cygnus.com>
+
+	* libgettext.h: Fix dummy textdomain and bindtextdomain macros.
+	They should return reasonable values.
+	Reported by Tom Tromey <tromey@cygnus.com>.
+
+1997-09-16 03:33  Ulrich Drepper  <drepper@cygnus.com>
+
+	* libgettext.h: Define PARAMS also to `args' if __cplusplus is defined.
+	* intlh.inst.in: Likewise.
+	Reported by Jean-Marc Lasgouttes <Jean-Marc.Lasgouttes@inria.fr>.
+
+	* libintl.glibc: Update from current glibc version.
+
+1997-09-06 02:10  Ulrich Drepper  <drepper@cygnus.com>
+
+	* intlh.inst.in: Reformat copyright.
+
+1997-08-19 15:22  Ulrich Drepper  <drepper@cygnus.com>
+
+	* dcgettext.c (DCGETTEXT): Remove wrong comment.
+
+1997-08-16 00:13  Ulrich Drepper  <drepper@cygnus.com>
+
+	* Makefile.in (install-data): Don't change directory to install.
+
+1997-08-01 14:30  Ulrich Drepper  <drepper@cygnus.com>
+
+	* cat-compat.c: Fix copyright.
+
+	* localealias.c: Don't define strchr unless !HAVE_STRCHR.
+
+	* loadmsgcat.c: Update copyright.  Fix typos.
+
+	* l10nflist.c: Don't define strchr unless !HAVE_STRCHR.
+	(_nl_make_l10nflist): Handle sponsor and revision correctly.
+
+	* gettext.c: Update copyright.
+	* gettext.h: Likewise.
+	* hash-string.h: Likewise.
+
+	* finddomain.c: Remoave dead code.  Define strchr only if
+	!HAVE_STRCHR.
+
+	* explodename.c: Include <sys/types.h>.
+
+	* explodename.c: Reformat copyright text.
+	(_nl_explode_name): Fix typo.
+
+	* dcgettext.c: Define and use __set_errno.
+	(guess_category_value): Don't use setlocale if HAVE_LC_MESSAGES is
+	not defined.
+
+	* bindtextdom.c: Pretty printing.
+
+1997-05-01 02:25  Ulrich Drepper  <drepper@cygnus.com>
+
+	* dcgettext.c (guess_category_value): Don't depend on
+	HAVE_LC_MESSAGES.  We don't need the macro here.
+	Patch by Bruno Haible <haible@ilog.fr>.
+
+	* cat-compat.c (textdomain): DoN't refer to HAVE_SETLOCALE_NULL
+	macro.  Instead use HAVE_LOCALE_NULL and define it when using
+	glibc, as in dcgettext.c.
+	Patch by Bruno Haible <haible@ilog.fr>.
+
+	* Makefile.in (CPPFLAGS): New variable.  Reported by Franc,ois
+	Pinard.
+
+Mon Mar 10 06:51:17 1997  Ulrich Drepper  <drepper@cygnus.com>
+
+	* Makefile.in: Implement handling of libtool.
+
+	* gettextP.h: Change data structures for use of generic lowlevel
+	i18n file handling.
+
+Wed Dec  4 20:21:18 1996  Ulrich Drepper  <drepper@cygnus.com>
+
+	* textdomain.c: Put parentheses around arguments of memcpy macro
+	definition.
+	* localealias.c: Likewise.
+	* l10nflist.c: Likewise.
+	* finddomain.c: Likewise.
+	* bindtextdom.c: Likewise.
+	Reported by Thomas Esken.
+
+Mon Nov 25 22:57:51 1996  Ulrich Drepper  <drepper@cygnus.com>
+
+	* textdomain.c: Move definition of `memcpy` macro to right
+	position.
+
+Fri Nov 22 04:01:58 1996  Ulrich Drepper  <drepper@cygnus.com>
+
+	* finddomain.c [!HAVE_STRING_H && !_LIBC]: Define memcpy using
+ 	bcopy if not already defined.  Reported by Thomas Esken.
+	* bindtextdom.c: Likewise.
+	* l10nflist.c: Likewise.
+	* localealias.c: Likewise.
+	* textdomain.c: Likewise.
+
+Tue Oct 29 11:10:27 1996  Ulrich Drepper  <drepper@cygnus.com>
+
+	* Makefile.in (libdir): Change to use exec_prefix instead of
+ 	prefix.  Reported by Knut-HvardAksnes <etokna@eto.ericsson.se>.
+
+Sat Aug 31 03:07:09 1996  Ulrich Drepper  <drepper@cygnus.com>
+
+	* l10nflist.c (_nl_normalize_codeset): We convert to lower case,
+	so don't prepend uppercase `ISO' for only numeric arg.
+
+Fri Jul 19 00:15:46 1996  Ulrich Drepper  <drepper@cygnus.com>
+
+	* l10nflist.c: Move inclusion of argz.h, ctype.h, stdlib.h after
+	definition of _GNU_SOURCE.  Patch by Roland McGrath.
+
+	* Makefile.in (uninstall): Fix another bug with `for' loop and
+	empty arguments.  Patch by Jim Meyering.  Correct name os
+	uninstalled files: no intl- prefix anymore.
+
+	* Makefile.in (install-data): Again work around shells which
+	cannot handle mpty for list.  Reported by Jim Meyering.
+
+Sat Jul 13 18:11:35 1996  Ulrich Drepper  <drepper@cygnus.com>
+
+	* Makefile.in (install): Split goal.  Now depend on install-exec
+        and install-data.
+	(install-exec, install-data): New goals.  Created from former
+	install goal.
+	Reported by Karl Berry.
+
+Sat Jun 22 04:58:14 1996  Ulrich Drepper  <drepper@cygnus.com>
+
+	* Makefile.in (MKINSTALLDIRS): New variable.  Path to
+        mkinstalldirs script.
+	(install): use MKINSTALLDIRS variable or if the script is not present
+	try to find it in the $top_scrdir).
+
+Wed Jun 19 02:56:56 1996  Ulrich Drepper  <drepper@cygnus.com>
+
+	* l10nflist.c: Linux libc *partly* includes the argz_* functions.
+	Grr.  Work around by renaming the static version and use macros
+	for renaming.
+
+Tue Jun 18 20:11:17 1996  Ulrich Drepper  <drepper@cygnus.com>
+
+	* l10nflist.c: Correct presence test macros of __argz_* functions.
+
+	* l10nflist.c: Include <argz.h> based on test of it instead when
+	__argz_* functions are available.
+	Reported by Andreas Schwab.
+
+Thu Jun 13 15:17:44 1996  Ulrich Drepper  <drepper@cygnus.com>
+
+	* explodename.c, l10nflist.c: Define NULL for dumb systems.
+
+Tue Jun 11 17:05:13 1996  Ulrich Drepper  <drepper@cygnus.com>
+
+	* intlh.inst.in, libgettext.h (dcgettext): Rename local variable
+	result to __result to prevent name clash.
+
+	* l10nflist.c, localealias.c, dcgettext.c: Define _GNU_SOURCE to
+        get prototype for stpcpy and strcasecmp.
+
+	* intlh.inst.in, libgettext.h: Move declaration of
+	`_nl_msg_cat_cntr' outside __extension__ block to prevent warning
+	from gcc's -Wnested-extern option.
+
+Fri Jun  7 01:58:00 1996  Ulrich Drepper  <drepper@cygnus.com>
+
+	* Makefile.in (install): Remove comment.
+
+Thu Jun  6 17:28:17 1996  Ulrich Drepper  <drepper@cygnus.com>
+
+	* Makefile.in (install): Work around for another Buglix stupidity.
+	Always use an `else' close for `if's.  Reported by Nelson Beebe.
+
+	* Makefile.in (intlh.inst): Correct typo in phony rule.
+	Reported by Nelson Beebe.
+
+Thu Jun  6 01:49:52 1996  Ulrich Drepper  <drepper@cygnus.com>
+
+	* dcgettext.c (read_alias_file): Rename variable alloca_list to
+	block_list as the macro calls assume.
+	Patch by Eric Backus.
+
+	* localealias.c [!HAVE_ALLOCA]: Define alloca as macro using
+        malloc.
+	(read_alias_file): Rename varriabe alloca_list to block_list as the
+	macro calls assume.
+	Patch by Eric Backus.
+
+	* l10nflist.c: Correct conditional for <argz.h> inclusion.
+	Reported by Roland McGrath.
+
+	* Makefile.in (all): Depend on all-@USE_INCLUDED_LIBINTL@, not
+        all-@USE_NLS@.
+
+	* Makefile.in (install): intlh.inst comes from local dir, not
+        $(srcdir).
+
+	* Makefile.in (intlh.inst): Special handling of this goal.  If
+	used in gettext, this is really a rul to construct this file.  If
+	used in any other package it is defined as a .PHONY rule with
+	empty body.
+
+	* finddomain.c: Extract locale file information handling into
+	l10nfile.c.  Rename local stpcpy__ function to stpcpy.
+
+	* dcgettext.c (stpcpy): Add local definition.
+
+	* l10nflist.c: Solve some portability problems.  Patches partly by
+	Thomas Esken.  Add local definition of stpcpy.
+
+Tue Jun  4 02:47:49 1996  Ulrich Drepper  <drepper@cygnus.com>
+
+	* intlh.inst.in: Don't depend including <locale.h> on
+	HAVE_LOCALE_H.  Instead configure must rewrite this fiile
+	depending on the result of the configure run.
+
+	* Makefile.in (install): libintl.inst is now called intlh.inst.
+	Add rules for updating intlh.inst from intlh.inst.in.
+
+	* libintl.inst: Renamed to intlh.inst.in.
+
+	* localealias.c, dcgettext.c [__GNUC__]: Define HAVE_ALLOCA to 1
+        because gcc has __buitlin_alloca.
+	Reported by Roland McGrath.
+
+Mon Jun  3 00:32:16 1996  Ulrich Drepper  <drepper@cygnus.com>
+
+	* Makefile.in (installcheck): New goal to fulfill needs of
+        automake's distcheck.
+
+	* Makefile.in (install): Reorder commands so that VERSION is
+        found.
+
+	* Makefile.in (gettextsrcdir): Now use subdirectory intl/ in
+        @datadir@/gettext.
+	(COMSRCS): Add l10nfile.c.
+	(OBJECTS): Add l10nfile.o.
+	(DISTFILES): Rename to DISTFILE.normal.  Remove $(DISTFILES.common).
+	(DISTFILE.gettext): Remove $(DISTFILES.common).
+	(all-gettext): Remove goal.
+	(install): If $(PACKAGE) = gettext install, otherwose do nothing.  No
+	package but gettext itself should install libintl.h + headers.
+	(dist): Extend goal to work for gettext, too.
+	(dist-gettext): Remove goal.
+
+	* dcgettext.c [!HAVE_ALLOCA]: Define macro alloca by using malloc.
+
+Sun Jun  2 17:33:06 1996  Ulrich Drepper  <drepper@cygnus.com>
+
+	* loadmsgcat.c (_nl_load_domain): Parameter is now comes from
+        find_l10nfile.
+
+Sat Jun  1 02:23:03 1996  Ulrich Drepper  <drepper@cygnus.com>
+
+	* l10nflist.c (__argz_next): Add definition.
+
+	* dcgettext.c [!HAVE_ALLOCA]: Add code for handling missing alloca
+	code.  Use new l10nfile handling.
+
+	* localealias.c [!HAVE_ALLOCA]: Add code for handling missing
+        alloca code.
+
+	* l10nflist.c: Initial revision.
+
+Tue Apr  2 18:51:18 1996  Ulrich Drepper  <drepper@myware>
+
+	* Makefile.in (all-gettext): New goal.  Same as all-yes.
+
+Thu Mar 28 23:01:22 1996  Karl Eichwalder  <ke@ke.central.de>
+
+	* Makefile.in (gettextsrcdir): Define using @datadir@.
+
+Tue Mar 26 12:39:14 1996  Ulrich Drepper  <drepper@myware>
+
+	* finddomain.c: Include <ctype.h>.  Reported by Roland McGrath.
+
+Sat Mar 23 02:00:35 1996  Ulrich Drepper  <drepper@myware>
+
+	* finddomain.c (stpcpy): Rename to stpcpy__ to prevent clashing
+        with external declaration.
+
+Sat Mar  2 00:47:09 1996  Ulrich Drepper  <drepper@myware>
+
+	* Makefile.in (all-no): Rename from all_no.
+
+Sat Feb 17 00:25:59 1996  Ulrich Drepper  <drepper@myware>
+
+	* gettextP.h [loaded_domain]: Array `successor' must now contain up
+        to 63 elements (because of codeset name normalization).
+
+	* finddomain.c: Implement codeset name normalization.
+
+Thu Feb 15 04:39:09 1996  Ulrich Drepper  <drepper@myware>
+
+	* Makefile.in (all): Define to `all-@USE_NLS@'.
+	(all-yes, all_no): New goals.  `all-no' is noop, `all-yes'
+	is former all.
+
+Mon Jan 15 21:46:01 1996  Howard Gayle  <howard@hal.com>
+
+	* localealias.c (alias_compare): Increment string pointers in loop
+        of strcasecmp replacement.
+
+Fri Dec 29 21:16:34 1995  Ulrich Drepper  <drepper@myware>
+
+	* Makefile.in (install-src): Who commented this goal out ? :-)
+
+Fri Dec 29 15:08:16 1995  Ulrich Drepper  <drepper@myware>
+
+	* dcgettext.c (DCGETTEXT): Save `errno'.  Failing system calls
+	should not effect it because a missing catalog is no error.
+	Reported by Harald K<o:>nig <koenig@tat.physik.uni-tuebingen.de>.
+
+Tue Dec 19 22:09:13 1995  Ulrich Drepper  <drepper@myware>
+
+	* Makefile.in (Makefile): Explicitly use $(SHELL) for running
+        shell scripts.
+
+Fri Dec 15 17:34:59 1995  Andreas Schwab  <schwab@issan.informatik.uni-dortmund.de>
+
+	* Makefile.in (install-src): Only install library and header when
+	we use the own implementation.  Don't do it when using the
+	system's gettext or catgets functions.
+
+	* dcgettext.c (find_msg): Must not swap domain->hash_size here.
+
+Sat Dec  9 16:24:37 1995  Ulrich Drepper  <drepper@myware>
+
+	* localealias.c, libintl.inst, libgettext.h, hash-string.h,
+	gettextP.h, finddomain.c, dcgettext.c, cat-compat.c:
+	Use PARAMS instead of __P.  Suggested by Roland McGrath.
+
+Tue Dec  5 11:39:14 1995  Larry Schwimmer  <rosebud@cyclone.stanford.edu>
+
+	* libgettext.h: Use `#if !defined (_LIBINTL_H)' instead of `#if
+	!_LIBINTL_H' because Solaris defines _LIBINTL_H as empty.
+
+Mon Dec  4 15:42:07 1995  Ulrich Drepper  <drepper@myware>
+
+	* Makefile.in (install-src):
+	Install libintl.inst instead of libintl.h.install.
+
+Sat Dec  2 22:51:38 1995  Marcus Daniels  <marcus@sysc.pdx.edu>
+
+	* cat-compat.c (textdomain):
+	Reverse order in which files are tried you load.  First
+	try local file, when this failed absolute path.
+
+Wed Nov 29 02:03:53 1995  Nelson H. F. Beebe  <beebe@math.utah.edu>
+
+	* cat-compat.c (bindtextdomain): Add missing { }.
+
+Sun Nov 26 18:21:41 1995  Ulrich Drepper  <drepper@myware>
+
+	* libintl.inst: Add missing __P definition.  Reported by Nelson Beebe.
+
+	* Makefile.in:
+	Add dummy `all' and `dvi' goals.  Reported by Tom Tromey.
+
+Sat Nov 25 16:12:01 1995  Franc,ois Pinard  <pinard@iro.umontreal.ca>
+
+	* hash-string.h: Capitalize arguments of macros.
+
+Sat Nov 25 12:01:36 1995  Ulrich Drepper  <drepper@myware>
+
+	* Makefile.in (DISTFILES): Prevent files names longer than 13
+	characters.  libintl.h.glibc->libintl.glibc,
+	libintl.h.install->libintl.inst.  Reported by Joshua R. Poulson.
+
+Sat Nov 25 11:31:12 1995  Eric Backus  <ericb@lsid.hp.com>
+
+	* dcgettext.c: Fix bug in preprocessor conditionals.
+
+Sat Nov 25 02:35:27 1995  Nelson H. F. Beebe  <beebe@math.utah.edu>
+
+	* libgettext.h: Solaris cc does not understand
+	 #if !SYMBOL1 && !SYMBOL2.  Sad	but true.
+
+Thu Nov 23 16:22:14 1995  Ulrich Drepper  <drepper@myware>
+
+	* hash-string.h (hash_string):
+	Fix for machine with >32 bit `unsigned long's.
+
+	* dcgettext.c (DCGETTEXT):
+	Fix horrible bug in loop for alternative translation.
+
+Thu Nov 23 01:45:29 1995  Ulrich Drepper  <drepper@myware>
+
+	* po2tbl.sed.in, linux-msg.sed, xopen-msg.sed:
+	Some further simplifications in message number generation.
+
+Mon Nov 20 21:08:43 1995  Ulrich Drepper  <drepper@myware>
+
+	* libintl.h.glibc: Use __const instead of const in prototypes.
+
+	* Makefile.in (install-src):
+	Install libintl.h.install instead of libintl.h.  This
+	is a stripped-down version.  Suggested by Peter Miller.
+
+	* libintl.h.install, libintl.h.glibc: Initial revision.
+
+	* localealias.c (_nl_expand_alias, read_alias_file):
+	Protect prototypes in type casts by __P.
+
+Tue Nov 14 16:43:58 1995  Ulrich Drepper  <drepper@myware>
+
+	* hash-string.h: Correct prototype for hash_string.
+
+Sun Nov 12 12:42:30 1995  Ulrich Drepper  <drepper@myware>
+
+	* hash-string.h (hash_string): Add prototype.
+
+	* gettextP.h: Fix copyright.
+	(SWAP): Add prototype.
+
+Wed Nov  8 22:56:33 1995  Ulrich Drepper  <drepper@myware>
+
+	* localealias.c (read_alias_file): Forgot sizeof.
+	Avoid calling *printf function.  This introduces a big overhead.
+	Patch by Roland McGrath.
+
+Tue Nov  7 14:21:08 1995  Ulrich Drepper  <drepper@myware>
+
+	* finddomain.c, cat-compat.c: Wrong indentation in #if for stpcpy.
+
+	* finddomain.c (stpcpy):
+	Define substitution function local.  The macro was to flaky.
+
+	* cat-compat.c: Fix typo.
+
+	* xopen-msg.sed, linux-msg.sed:
+	While bringing message number to right place only accept digits.
+
+	* linux-msg.sed, xopen-msg.sed: Now that the counter does not have
+	leading 0s we don't need to remove them.  Reported by Marcus
+	Daniels.
+
+	* Makefile.in (../po/cat-id-tbl.o): Use $(top_srdir) in
+	dependency.  Reported by Marcus Daniels.
+
+	* cat-compat.c: (stpcpy) [!_LIBC && !HAVE_STPCPY]: Define replacement.
+	Generally cleanup using #if instead of #ifndef.
+
+	* Makefile.in: Correct typos in comment.  By Franc,ois Pinard.
+
+Mon Nov  6 00:27:02 1995  Ulrich Drepper  <drepper@myware>
+
+	* Makefile.in (install-src): Don't install libintl.h and libintl.a
+	if we use an available gettext implementation.
+
+Sun Nov  5 22:02:08 1995  Ulrich Drepper  <drepper@myware>
+
+	* libgettext.h: Fix typo: HAVE_CATGETTS -> HAVE_CATGETS.  Reported
+	by Franc,ois Pinard.
+
+	* libgettext.h: Use #if instead of #ifdef/#ifndef.
+
+	* finddomain.c:
+	Comments describing what has to be done should start with FIXME.
+
+Sun Nov  5 19:38:01 1995  Ulrich Drepper  <drepper@myware>
+
+	* Makefile.in (DISTFILES): Split.  Use DISTFILES with normal meaning.
+	DISTFILES.common names the files common to both dist goals.
+	DISTFILES.gettext are the files only distributed in GNU gettext.
+
+Sun Nov  5 17:32:54 1995  Ulrich Drepper  <drepper@myware>
+
+	* dcgettext.c (DCGETTEXT): Correct searching in derived locales.
+	This was necessary since a change in _nl_find_msg several weeks
+	ago.  I really don't know this is still not fixed.
+
+Sun Nov  5 12:43:12 1995  Ulrich Drepper  <drepper@myware>
+
+	* loadmsgcat.c (_nl_load_domain): Test for FILENAME == NULL.  This
+	might mark a special condition.
+
+	* finddomain.c (make_entry_rec): Don't make illegal entry as decided.
+
+	* Makefile.in (dist): Suppress error message when ln failed.
+	Get files from $(srcdir) explicitly.
+
+	* libgettext.h (gettext_const): Rename to gettext_noop.
+
+Fri Nov  3 07:36:50 1995  Ulrich Drepper  <drepper@myware>
+
+	* finddomain.c (make_entry_rec):
+	Protect against wrong locale names by testing mask.
+
+	* libgettext.h (gettext_const): Add macro definition.
+	Capitalize macro arguments.
+
+Thu Nov  2 23:15:51 1995  Ulrich Drepper  <drepper@myware>
+
+	* finddomain.c (_nl_find_domain):
+	Test for pointer != NULL before accessing value.
+	Reported by Tom Tromey.
+
+	* gettext.c (NULL):
+	Define as (void*)0 instad of 0.  Reported by Franc,ois Pinard.
+
+Mon Oct 30 21:28:52 1995  Ulrich Drepper  <drepper@myware>
+
+	* po2tbl.sed.in: Serious typo bug fixed by Jim Meyering.
+
+Sat Oct 28 23:20:47 1995  Ulrich Drepper  <drepper@myware>
+
+	* libgettext.h: Disable dcgettext optimization for Solaris 2.3.
+
+	* localealias.c (alias_compare):
+	Peter Miller reported that tolower in some systems is
+	even dumber than I thought.  Protect call by `isupper'.
+
+Fri Oct 27 22:22:51 1995  Ulrich Drepper  <drepper@myware>
+
+	* Makefile.in (libdir, includedir): New variables.
+	(install-src): Install libintl.a and libintl.h in correct dirs.
+
+Fri Oct 27 22:07:29 1995  Ulrich Drepper  <drepper@myware>
+
+	* Makefile.in (SOURCES): Fix typo: intrl.compat.c -> intl-compat.c.
+
+	* po2tbl.sed.in: Patch for buggy SEDs by Christian von Roques.
+
+	* localealias.c:
+	Fix typo and superflous test.  Reported by Christian von Roques.
+
+Fri Oct  6 11:52:05 1995  Ulrich Drepper  <drepper@myware>
+
+	* finddomain.c (_nl_find_domain):
+	Correct some remainder from the pre-CEN syntax.  Now
+	we don't have a constant number of successors anymore.
+
+Wed Sep 27 21:41:13 1995  Ulrich Drepper  <drepper@myware>
+
+	* Makefile.in (DISTFILES): Add libintl.h.glibc.
+
+	* Makefile.in (dist-libc): Add goal for packing sources for glibc.
+	(COMSRCS, COMHDRS): Splitted to separate sources shared with glibc.
+
+	* loadmsgcat.c: Forget to continue #if line.
+
+	* localealias.c:
+	[_LIBC]: Rename strcasecmp to __strcasecmp to keep ANSI C name
+	space clean.
+
+	* dcgettext.c, finddomain.c: Better comment to last change.
+
+	* loadmsgcat.c:
+	[_LIBC]: Rename fstat, open, close, read, mmap, and munmap to
+	__fstat, __open, __close, __read, __mmap, and __munmap resp
+	to keep ANSI C name space clean.
+
+	* finddomain.c:
+	[_LIBC]: Rename stpcpy to __stpcpy to keep ANSI C name space clean.
+
+	* dcgettext.c:
+	[_LIBC]: Rename getced and stpcpy to __getcwd and __stpcpy resp to
+	keep ANSI C name space clean.
+
+	* libgettext.h:
+	Include sys/types.h for those old SysV systems out there.
+	Reported by Francesco Potorti`.
+
+	* loadmsgcat.c (use_mmap): Define if compiled for glibc.
+
+	* bindtextdom.c: Include all those standard headers
+	unconditionally if _LIBC is defined.
+
+	* finddomain.c: Fix 2 times defiend -> defined.
+
+	* textdomain.c: Include libintl.h instead of libgettext.h when
+	compiling for glibc.  Include all those standard headers
+	unconditionally if _LIBC is defined.
+
+	* localealias.c, loadmsgcat.c: Prepare to be compiled in glibc.
+
+	* gettext.c:
+	Include libintl.h instead of libgettext.h when compiling for glibc.
+	Get NULL from stddef.h if we compile for glibc.
+
+	* finddomain.c: Include libintl.h instead of libgettext.h when
+	compiling for glibc.  Include all those standard headers
+	unconditionally if _LIBC is defined.
+
+	* dcgettext.c: Include all those standard headers unconditionally
+	if _LIBC is defined.
+
+	* dgettext.c: If compiled in glibc include libintl.h instead of
+	libgettext.h.
+	(locale.h): Don't rely on HAVE_LOCALE_H when compiling for glibc.
+
+	* dcgettext.c: If compiled in glibc include libintl.h instead of
+	libgettext.h.
+	(getcwd): Don't rely on HAVE_GETCWD when compiling for glibc.
+
+	* bindtextdom.c:
+	If compiled in glibc include libintl.h instead of libgettext.h.
+
+Mon Sep 25 22:23:06 1995  Ulrich Drepper  <drepper@myware>
+
+	* localealias.c (_nl_expand_alias): Don't call bsearch if NMAP <= 0.
+	Reported by Marcus Daniels.
+
+	* cat-compat.c (bindtextdomain):
+	String used in putenv must not be recycled.
+	Reported by Marcus Daniels.
+
+	* libgettext.h (__USE_GNU_GETTEXT):
+	Additional symbol to signal that we use GNU gettext
+	library.
+
+	* cat-compat.c (bindtextdomain):
+	Fix bug with the strange stpcpy replacement.
+	Reported by Nelson Beebe.
+
+Sat Sep 23 08:23:51 1995  Ulrich Drepper  <drepper@myware>
+
+	* cat-compat.c: Include <string.h> for stpcpy prototype.
+
+	* localealias.c (read_alias_file):
+	While expand strdup code temporary variable `cp' hided
+	higher level variable with same name.  Rename to `tp'.
+
+	* textdomain.c (textdomain):
+	Avoid warning by using temporary variable in strdup code.
+
+	* finddomain.c (_nl_find_domain): Remove unused variable `application'.
+
+Thu Sep 21 15:51:44 1995  Ulrich Drepper  <drepper@myware>
+
+	* localealias.c (alias_compare):
+	Use strcasecmp() only if available.  Else use
+	implementation in place.
+
+	* intl-compat.c:
+	Wrapper functions now call *__ functions instead of __*.
+
+	* libgettext.h: Declare prototypes for *__ functions instead for __*.
+
+	* cat-compat.c, loadmsgcat.c:
+	Don't use xmalloc, xstrdup, and stpcpy.  These functions are not part
+	of the standard libc and so prevent libintl.a from being used
+	standalone.
+
+	* bindtextdom.c:
+	Don't use xmalloc, xstrdup, and stpcpy.  These functions are not part
+	of the standard libc and so prevent libintl.a from being used
+	standalone.
+	Rename to bindtextdomain__ if not used in GNU C Library.
+
+	* dgettext.c:
+	Rename function to dgettext__ if not used in GNU C Library.
+
+	* gettext.c:
+	Don't use xmalloc, xstrdup, and stpcpy.  These functions are not part
+	of the standard libc and so prevent libintl.a from being used
+	standalone.
+	Functions now called gettext__ if not used in GNU C Library.
+
+	* dcgettext.c, localealias.c, textdomain.c, finddomain.c:
+	Don't use xmalloc, xstrdup, and stpcpy.  These functions are not part
+	of the standard libc and so prevent libintl.a from being used
+	standalone.
+
+Sun Sep 17 23:14:49 1995  Ulrich Drepper  <drepper@myware>
+
+	* finddomain.c: Correct some bugs in handling of CEN standard
+ 	locale definitions.
+
+Thu Sep  7 01:49:28 1995  Ulrich Drepper  <drepper@myware>
+
+	* finddomain.c: Implement CEN syntax.
+
+	* gettextP.h (loaded_domain): Extend number of successors to 31.
+
+Sat Aug 19 19:25:29 1995  Ulrich Drepper  <drepper@myware>
+
+	* Makefile.in (aliaspath): Remove path to X11 locale dir.
+
+	* Makefile.in: Make install-src depend on install.  This helps
+ 	gettext to install the sources and other packages can use the
+ 	install goal.
+
+Sat Aug 19 15:19:33 1995  Ulrich Drepper  <drepper@myware>
+
+	* Makefile.in (uninstall): Remove stuff installed by install-src.
+
+Tue Aug 15 13:13:53 1995  Ulrich Drepper  <drepper@myware>
+
+	* VERSION.in: Initial revision.
+
+	* Makefile.in (DISTFILES):
+	Add VERSION file.  This is not necessary for gettext, but
+	for other packages using this library.
+
+Tue Aug 15 06:16:44 1995  Ulrich Drepper  <drepper@myware>
+
+	* gettextP.h (_nl_find_domain):
+	New prototype after changing search strategy.
+
+	* finddomain.c (_nl_find_domain):
+	We now try only to find a specified catalog.  Fall back to other
+	catalogs listed in the locale list is now done in __dcgettext.
+
+	* dcgettext.c (__dcgettext):
+	Now we provide message fall back even to different languages.
+	I.e. if a message is not available in one language all the other
+ 	in the locale list a tried.  Formerly fall back was only possible
+ 	within one language.  Implemented by moving one loop from
+ 	_nl_find_domain to here.
+
+Mon Aug 14 23:45:50 1995  Ulrich Drepper  <drepper@myware>
+
+	* Makefile.in (gettextsrcdir):
+	Directory where source of GNU gettext library are made
+	available.
+	(INSTALL, INSTALL_DATA): Programs used for installing sources.
+	(gettext-src): New.  Rule to install GNU gettext sources for use in
+	gettextize shell script.
+
+Sun Aug 13 14:40:48 1995  Ulrich Drepper  <drepper@myware>
+
+	* loadmsgcat.c (_nl_load_domain):
+	Use mmap for loading only when munmap function is
+	also available.
+
+	* Makefile.in (install): Depend on `all' goal.
+
+Wed Aug  9 11:04:33 1995  Ulrich Drepper  <drepper@myware>
+
+	* localealias.c (read_alias_file):
+	Do not overwrite '\n' when terminating alias value string.
+
+	* localealias.c (read_alias_file):
+	Handle long lines.  Ignore the rest not fitting in
+	the buffer after the initial `fgets' call.
+
+Wed Aug  9 00:54:29 1995  Ulrich Drepper  <drepper@myware>
+
+	* gettextP.h (_nl_load_domain):
+	Add prototype, replacing prototype for _nl_load_msg_cat.
+
+	* finddomain.c (_nl_find_domain):
+	Remove unneeded variable filename and filename_len.
+	(expand_alias): Remove prototype because functions does not
+ 	exist anymore.
+
+	* localealias.c (read_alias_file):
+	Change type of fname_len parameter to int.
+	(xmalloc): Add prototype.
+
+	* loadmsgcat.c: Better prototypes for xmalloc.
+
+Tue Aug  8 22:30:39 1995  Ulrich Drepper  <drepper@myware>
+
+	* finddomain.c (_nl_find_domain):
+	Allow alias name to be constructed from the four components.
+
+	* Makefile.in (aliaspath): New variable.  Set to preliminary value.
+	(SOURCES): Add localealias.c.
+	(OBJECTS): Add localealias.o.
+
+	* gettextP.h: Add prototype for _nl_expand_alias.
+
+	* finddomain.c: Aliasing handled in intl/localealias.c.
+
+	* localealias.c: Aliasing for locale names.
+
+	* bindtextdom.c: Better prototypes for xmalloc and xstrdup.
+
+Mon Aug  7 23:47:42 1995  Ulrich Drepper  <drepper@myware>
+
+	* Makefile.in (DISTFILES): gettext.perl is now found in misc/.
+
+	* cat-compat.c (bindtextdomain):
+	Correct implementation.  dirname parameter was not used.
+	Reported by Marcus Daniels.
+
+	* gettextP.h (loaded_domain):
+	New fields `successor' and `decided' for oo, lazy
+	message handling implementation.
+
+	* dcgettext.c:
+	Adopt for oo, lazy message handliing.
+  	Now we can inherit translations from less specific locales.
+	(find_msg): New function.
+
+	* loadmsgcat.c, finddomain.c:
+	Complete rewrite.  Implement oo, lazy message handling :-).
+  	We now have an additional environment variable `LANGUAGE' with
+ 	a higher priority than LC_ALL for the LC_MESSAGE locale.
+  	Here we can set a colon separated list of specifications each
+ 	of the form `language[_territory[.codeset]][@modifier]'.
+
+Sat Aug  5 09:55:42 1995  Ulrich Drepper  <drepper@myware>
+
+	* finddomain.c (unistd.h):
+	Include to get _PC_PATH_MAX defined on system having it.
+
+Fri Aug  4 22:42:00 1995  Ulrich Drepper  <drepper@myware>
+
+	* finddomain.c (stpcpy): Include prototype.
+
+	* Makefile.in (dist): Remove `copying instead' message.
+
+Wed Aug  2 18:52:03 1995  Ulrich Drepper  <drepper@myware>
+
+	* Makefile.in (ID, TAGS): Do not use $^.
+
+Tue Aug  1 20:07:11 1995  Ulrich Drepper  <drepper@myware>
+
+	* Makefile.in (TAGS, ID): Use $^ as command argument.
+	(TAGS): Give etags -o option t write to current directory,
+ 	not $(srcdir).
+	(ID): Use $(srcdir) instead os $(top_srcdir)/src.
+	(distclean): Remove ID.
+
+Sun Jul 30 11:51:46 1995  Ulrich Drepper  <drepper@myware>
+
+	* Makefile.in (gnulocaledir):
+	New variable, always using share/ for data directory.
+	(DEFS): Add GNULOCALEDIR, used in finddomain.c.
+
+	* finddomain.c (_nl_default_dirname):
+	Set to GNULOCALEDIR, because it always has to point
+	to the directory where GNU gettext Library writes it to.
+
+	* intl-compat.c (textdomain, bindtextdomain):
+	Undefine macros before function definition.
+
+Sat Jul 22 01:10:02 1995  Ulrich Drepper  <drepper@myware>
+
+	* libgettext.h (_LIBINTL_H):
+	Protect definition in case where this file is included as
+	libgettext.h on Solaris machines.  Add comment about this.
+
+Wed Jul 19 02:36:42 1995  Ulrich Drepper  <drepper@myware>
+
+	* intl-compat.c (textdomain): Correct typo.
+
+Wed Jul 19 01:51:35 1995  Ulrich Drepper  <drepper@myware>
+
+	* dcgettext.c (dcgettext): Function now called __dcgettext.
+
+	* dgettext.c (dgettext): Now called __dgettext and calls
+ 	__dcgettext.
+
+	* gettext.c (gettext):
+	Function now called __gettext and calls __dgettext.
+
+	* textdomain.c (textdomain): Function now called __textdomain.
+
+	* bindtextdom.c (bindtextdomain): Function now called
+ 	__bindtextdomain.
+
+	* intl-compat.c: Initial revision.
+
+	* Makefile.in (SOURCES): Add intl-compat.c.
+	(OBJECTS): We always compile the GNU gettext library functions.
+  	OBJECTS contains all objects but cat-compat.o, ../po/cat-if-tbl.o,
+ 	and intl-compat.o.
+  	(GETTOBJS): Contains now only intl-compat.o.
+
+	* libgettext.h:
+	Re-include protection matches dualistic character of libgettext.h.
+	For all functions in GNU gettext library define __ counter part.
+
+	* finddomain.c (strchr): Define as index if not found in C library.
+	(_nl_find_domain): For relative paths paste / in between.
+
+Tue Jul 18 16:37:45 1995  Ulrich Drepper  <drepper@myware>
+
+	* loadmsgcat.c, finddomain.c: Add inclusion of sys/types.h.
+
+	* xopen-msg.sed: Fix bug with `msgstr ""' lines.
+	A little bit better comments.
+
+Tue Jul 18 01:18:27 1995  Ulrich Drepper  <drepper@myware>
+
+	* Makefile.in:
+	po-mode.el, makelinks, combine-sh are now found in ../misc.
+
+	* po-mode.el, makelinks, combine-sh, elisp-comp:
+	Moved to ../misc/.
+
+	* libgettext.h, gettextP.h, gettext.h: Uniform test for __STDC__.
+
+Sun Jul 16 22:33:02 1995  Ulrich Drepper  <drepper@myware>
+
+	* Makefile.in (INSTALL, INSTALL_DATA): New variables.
+	(install-data, uninstall): Install/uninstall .elc file.
+
+	* po-mode.el (Installation comment):
+	Add .pox as possible extension of .po files.
+
+Sun Jul 16 13:23:27 1995  Ulrich Drepper  <drepper@myware>
+
+	* elisp-comp: Complete new version by Franc,ois: This does not
+ 	fail when not compiling in the source directory.
+
+Sun Jul 16 00:12:17 1995  Ulrich Drepper  <drepper@myware>
+
+	* Makefile.in (../po/cat-id-tbl.o):
+	Use $(MAKE) instead of make for recursive make.
+
+	* Makefile.in (.el.elc): Use $(SHELL) instead of /bin/sh.
+	(install-exec): Add missing dummy goal.
+	(install-data, uninstall): @ in multi-line shell command at
+ 	beginning, not in front of echo.  Reported by Eric Backus.
+
+Sat Jul 15 00:21:28 1995  Ulrich Drepper  <drepper@myware>
+
+	* Makefile.in (DISTFILES):
+	Rename libgettext.perl to gettext.perl to fit in 14 chars
+	file systems.
+
+	* gettext.perl:
+ 	Rename to gettext.perl to fit in 14 chars file systems.
+
+Thu Jul 13 23:17:20 1995  Ulrich Drepper  <drepper@myware>
+
+	* cat-compat.c: If !STDC_HEADERS try to include malloc.h.
+
+Thu Jul 13 20:55:02 1995  Ulrich Drepper  <drepper@myware>
+
+	* po2tbl.sed.in: Pretty printing.
+
+	* linux-msg.sed, xopen-msg.sed:
+	Correct bugs with handling substitute flags in branches.
+
+	* hash-string.h (hash_string):
+	Old K&R compilers don't under stand `unsigned char'.
+
+	* gettext.h (nls_uint32):
+	Some old K&R compilers (eg HP) don't understand `unsigned int'.
+
+	* cat-compat.c (msg_to_cat_id): De-ANSI-fy prototypes.
+
+Thu Jul 13 01:34:33 1995  Ulrich Drepper  <drepper@myware>
+
+	* Makefile.in (ELCFILES): New variable.
+	(DISTFILES): Add elisp-comp.
+	Add implicit rule for .el -> .elc compilation.
+	(install-data): install $ELCFILES
+	(clean): renamed po-to-tbl and po-to-msg to po2tbl and po2msg resp.
+
+	* elisp-comp: Initial revision
+
+Wed Jul 12 16:14:52 1995  Ulrich Drepper  <drepper@myware>
+
+	* Makefile.in:
+	cat-id-tbl.c is now found in po/.  This enables us to use an identical
+	intl/ directory in all packages.
+
+	* dcgettext.c (dcgettext): hashing does not work for table size <= 2.
+
+	* textdomain.c: fix typo (#if def -> #if defined)
+
+Tue Jul 11 18:44:43 1995  Ulrich Drepper  <drepper@myware>
+
+	* Makefile.in (stamp-cat-id): use top_srcdir to address source files
+	(DISTFILES,distclean): move tupdate.perl to src/
+
+	* po-to-tbl.sed.in:
+	add additional jump to clear change flag to recognize multiline strings
+
+Tue Jul 11 01:32:50 1995  Ulrich Drepper  <drepper@myware>
+
+	* textdomain.c: Protect inclusion of stdlib.h and string.h.
+
+	* loadmsgcat.c: Protect inclusion of stdlib.h.
+
+	* libgettext.h: Protect inclusion of locale.h.
+	Allow use in C++ programs.
+	Define NULL is not happened already.
+
+	* Makefile.in (DISTFILES): ship po-to-tbl.sed.in instead of
+	po-to-tbl.sed.
+	(distclean): remove po-to-tbl.sed and tupdate.perl.
+
+	* tupdate.perl.in: Substitute Perl path even in exec line.
+	Don't include entries without translation from old .po file.
+
+Tue Jul  4 00:41:51 1995  Ulrich Drepper  <drepper@myware>
+
+	* tupdate.perl.in: use "Updated: " in msgid "".
+
+	* cat-compat.c: Fix typo (LOCALDIR -> LOCALEDIR).
+ 	Define getenv if !__STDC__.
+
+	* bindtextdom.c: Protect stdlib.h and string.h inclusion.
+ 	Define free if !__STDC__.
+
+	* finddomain.c: Change DEF_MSG_DOM_DIR to LOCALEDIR.
+ 	Define free if !__STDC__.
+
+	* cat-compat.c: Change DEF_MSG_DOM_DIR to LOCALEDIR.
+
+Mon Jul  3 23:56:30 1995  Ulrich Drepper  <drepper@myware>
+
+	* Makefile.in: Use LOCALEDIR instead of DEF_MSG_DOM_DIR.
+	Remove unneeded $(srcdir) from Makefile.in dependency.
+
+	* makelinks: Add copyright and short description.
+
+	* po-mode.el: Last version for 0.7.
+
+	* tupdate.perl.in: Fix die message.
+
+	* dcgettext.c: Protect include of string.h.
+
+	* gettext.c: Protect include of stdlib.h and further tries to get NULL.
+
+	* finddomain.c: Some corrections in includes.
+
+	* Makefile.in (INCLUDES): Prune list correct path to Makefile.in.
+
+	* po-to-tbl.sed: Adopt for new .po file format.
+
+	* linux-msg.sed, xopen-msg.sed: Adopt for new .po file format.
+
+Sun Jul  2 23:55:03 1995  Ulrich Drepper  <drepper@myware>
+
+	* tupdate.perl.in: Complete rewrite for new .po file format.
+
+Sun Jul  2 02:06:50 1995  Ulrich Drepper  <drepper@myware>
+
+	* First official release.  This directory contains all the code
+	needed to internationalize own packages.  It provides functions
+	which allow to use the X/Open catgets function with an interface
+	like the Uniforum gettext function.  For system which does not
+	have neither of those a complete implementation is provided.
--- openjade-1.4devel1.orig/intl/cat-compat.c
+++ openjade-1.4devel1/intl/cat-compat.c
@@ -1,20 +1,19 @@
 /* Compatibility code for gettext-using-catgets interface.
-   Copyright (C) 1995 Free Software Foundation, Inc.
+   Copyright (C) 1995, 1997 Free Software Foundation, Inc.
 
-The GNU C Library is free software; you can redistribute it and/or
-modify it under the terms of the GNU Library General Public License as
-published by the Free Software Foundation; either version 2 of the
-License, or (at your option) any later version.
-
-The GNU C Library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-Library General Public License for more details.
-
-You should have received a copy of the GNU Library General Public
-License along with the GNU C Library; see the file COPYING.LIB.  If
-not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
-Boston, MA 02111-1307, USA.  */
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
 
 #ifdef HAVE_CONFIG_H
 # include <config.h>
@@ -40,6 +39,16 @@
 
 /* @@ end of prolog @@ */
 
+/* XPG3 defines the result of `setlocale (category, NULL)' as:
+   ``Directs `setlocale()' to query `category' and return the current
+     setting of `local'.''
+   However it does not specify the exact format.  And even worse: POSIX
+   defines this not at all.  So we can use this feature only on selected
+   system (e.g. those using GNU C Library).  */
+#ifdef _LIBC
+# define HAVE_LOCALE_NULL
+#endif
+
 /* The catalog descriptor.  */
 static nl_catd catalog = (nl_catd) -1;
 
@@ -50,11 +59,11 @@
 static const char *catalog_name = default_catalog_name;
 
 /* Get ID for given string.  If not found return -1.  */
-static int msg_to_cat_id __P ((const char *msg));
+static int msg_to_cat_id PARAMS ((const char *msg));
 
 /* Substitution for systems lacking this function in their C library.  */
 #if !_LIBC && !HAVE_STPCPY
-static char *stpcpy __P ((char *dest, const char *src));
+static char *stpcpy PARAMS ((char *dest, const char *src));
 #endif
 
 
@@ -68,7 +77,8 @@
   size_t new_name_len;
   char *lang;
 
-#if HAVE_SETLOCALE && HAVE_LC_MESSAGES && HAVE_SETLOCALE_NULL
+#if defined HAVE_SETLOCALE && defined HAVE_LC_MESSAGES \
+    && defined HAVE_LOCALE_NULL
   lang = setlocale (LC_MESSAGES, NULL);
 #else
   lang = getenv ("LC_ALL");
--- openjade-1.4devel1.orig/intl/gettext.h
+++ openjade-1.4devel1/intl/gettext.h
@@ -1,20 +1,20 @@
-/* gettext.h - internal header for GNU gettext internationalization functions
-   Copyright (C) 1995 Software Foundation, Inc.
+/* Internal header for GNU gettext internationalization functions.
+   Copyright (C) 1995, 1997 Free Software Foundation, Inc.
 
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2, or (at your option)
-any later version.
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
 
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
 
-You should have received a copy of the GNU Library General Public
-License along with the GNU C Library; see the file COPYING.LIB.  If
-not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
-Boston, MA 02111-1307, USA.  */
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
 
 #ifndef _GETTEXT_H
 #define _GETTEXT_H 1
--- openjade-1.4devel1.orig/intl/libgettext.h
+++ openjade-1.4devel1/intl/libgettext.h
@@ -1,27 +1,27 @@
-/* libgettext.h -- Message catalogs for internationalization.
-   Copyright (C) 1995 Free Software Foundation, Inc.
+/* Message catalogs for internationalization.
+   Copyright (C) 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
 
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2, or (at your option)
-any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
 
 /* Because on some systems (e.g. Solaris) we sometimes have to include
    the systems libintl.h as well as this file we have more complex
    include protection above.  But the systems header might perhaps also
    define _LIBINTL_H and therefore we have to protect the definition here.  */
 
-#if !defined (_LIBINTL_H) || !defined (_LIBGETTEXT_H)
-#if !_LIBINTL_H
+#if !defined _LIBINTL_H || !defined _LIBGETTEXT_H
+#ifndef _LIBINTL_H
 # define _LIBINTL_H	1
 #endif
 #define _LIBGETTEXT_H	1
@@ -43,11 +43,11 @@
 
 /* @@ end of prolog @@ */
 
-#ifndef __P
-# if __STDC__
-#  define __P(args) args
+#ifndef PARAMS
+# if __STDC__ || defined __cplusplus
+#  define PARAMS(args) args
 # else
-#  define __P(args) ()
+#  define PARAMS(args) ()
 # endif
 #endif
 
@@ -91,33 +91,34 @@
 /* Look up MSGID in the current default message catalog for the current
    LC_MESSAGES locale.  If not found, returns MSGID itself (the default
    text).  */
-extern char *gettext __P ((const char *__msgid));
-extern char *gettext__ __P ((const char *__msgid));
+extern char *gettext PARAMS ((const char *__msgid));
+extern char *gettext__ PARAMS ((const char *__msgid));
 
 /* Look up MSGID in the DOMAINNAME message catalog for the current
    LC_MESSAGES locale.  */
-extern char *dgettext __P ((const char *__domainname, const char *__msgid));
-extern char *dgettext__ __P ((const char *__domainname, const char *__msgid));
+extern char *dgettext PARAMS ((const char *__domainname, const char *__msgid));
+extern char *dgettext__ PARAMS ((const char *__domainname,
+				 const char *__msgid));
 
 /* Look up MSGID in the DOMAINNAME message catalog for the current CATEGORY
    locale.  */
-extern char *dcgettext __P ((const char *__domainname, const char *__msgid,
-			     int __category));
-extern char *dcgettext__ __P ((const char *__domainname, const char *__msgid,
-			       int __category));
+extern char *dcgettext PARAMS ((const char *__domainname, const char *__msgid,
+				int __category));
+extern char *dcgettext__ PARAMS ((const char *__domainname,
+				  const char *__msgid, int __category));
 
 
 /* Set the current default message catalog to DOMAINNAME.
    If DOMAINNAME is null, return the current default.
    If DOMAINNAME is "", reset to the default of "messages".  */
-extern char *textdomain __P ((const char *__domainname));
-extern char *textdomain__ __P ((const char *__domainname));
+extern char *textdomain PARAMS ((const char *__domainname));
+extern char *textdomain__ PARAMS ((const char *__domainname));
 
 /* Specify that the DOMAINNAME message catalog will be found
    in DIRNAME rather than in the system locale data base.  */
-extern char *bindtextdomain __P ((const char *__domainname,
+extern char *bindtextdomain PARAMS ((const char *__domainname,
 				  const char *__dirname));
-extern char *bindtextdomain__ __P ((const char *__domainname,
+extern char *bindtextdomain__ PARAMS ((const char *__domainname,
 				    const char *__dirname));
 
 #if ENABLE_NLS
@@ -127,33 +128,37 @@
    has dcgettext.  */
 # if !HAVE_CATGETS && (!HAVE_GETTEXT || HAVE_DCGETTEXT)
 
-#  define gettext(Msgid) \
+#  define gettext(Msgid)						      \
      dgettext (NULL, Msgid)
 
-#  define dgettext(Domainname, Msgid) \
+#  define dgettext(Domainname, Msgid)					      \
      dcgettext (Domainname, Msgid, LC_MESSAGES)
 
 #  if defined __GNUC__ && __GNUC__ == 2 && __GNUC_MINOR__ >= 7
-#   define dcgettext(Domainname, Msgid, Category) \
+/* This global variable is defined in loadmsgcat.c.  We need a sign,
+   whether a new catalog was loaded, which can be associated with all
+   translations.  */
+extern int _nl_msg_cat_cntr;
+
+#   define dcgettext(Domainname, Msgid, Category)			      \
   (__extension__							      \
    ({									      \
-     char *result;							      \
+     char *__result;							      \
      if (__builtin_constant_p (Msgid))					      \
        {								      \
-	 extern int _nl_msg_cat_cntr;					      \
 	 static char *__translation__;					      \
 	 static int __catalog_counter__;				      \
 	 if (! __translation__ || __catalog_counter__ != _nl_msg_cat_cntr)    \
 	   {								      \
 	     __translation__ =						      \
-	       dcgettext__ ((Domainname), (Msgid), (Category));		      \
+	       dcgettext__ (Domainname, Msgid, Category);		      \
 	     __catalog_counter__ = _nl_msg_cat_cntr;			      \
 	   }								      \
-	 result = __translation__;					      \
+	 __result = __translation__;					      \
        }								      \
      else								      \
-       result = dcgettext__ ((Domainname), (Msgid), (Category));	      \
-     result;								      \
+       __result = dcgettext__ (Domainname, Msgid, Category);		      \
+     __result;								      \
     }))
 #  endif
 # endif
@@ -163,8 +168,8 @@
 # define gettext(Msgid) (Msgid)
 # define dgettext(Domainname, Msgid) (Msgid)
 # define dcgettext(Domainname, Msgid, Category) (Msgid)
-# define textdomain(Domainname) while (0) /* nothing */
-# define bindtextdomain(Domainname, Dirname) while (0) /* nothing */
+# define textdomain(Domainname) ((char *) Domainname)
+# define bindtextdomain(Domainname, Dirname) ((char *) Dirname)
 
 #endif
 
--- openjade-1.4devel1.orig/jade/Makefile.am
+++ openjade-1.4devel1/jade/Makefile.am
@@ -8,13 +8,13 @@
 	HtmlFOTBuilder.h TeXFOTBuilder.h TransformFOTBuilder.h \
 	MifFOTBuilder.h \
 	JadeMessages.h HtmlMessages.h RtfMessages.h TeXMessages.h \
-	MifMessages.h TmpOutputByteStream.h
+	MifMessages.h TmpOutputByteStream.h MessageModule.cxx
 
 openjade_LDADD = $(top_builddir)/style/libostyle.la \
 	$(top_builddir)/spgrove/libospgrove.la \
 	$(top_builddir)/grove/libogrove.la -losp
 
-INCLUDES = -I$(top_srcdir)/grove -I$(top_srcdir)/spgrove -I$(top_srcdir)/style
+AM_CPPFLAGS = -I$(top_srcdir)/grove -I$(top_srcdir)/spgrove -I$(top_srcdir)/style
 
 EXTRA_DIST = JadeMessages.msg JadeMessages.rc \
 	HtmlMessages.msg HtmlMessages.rc \
@@ -38,7 +38,9 @@
 	TeXFOTBuilder_inst.cxx TransformFOTBuilder_inst.cxx \
 	MifFOTBuilder_inst.cxx
 
-MSGGENFLAGS = -l xModule
+MAINTAINERCLEANFILES = Makefile.in  jade-out.fot
+
+MSGGENFLAGS = -l jadeModule
 
 SUFFIXES = .msg .m4 .rc
 
@@ -46,4 +48,4 @@
 	$(PERL) $(top_srcdir)/instmac.pl $< >$@
 
 %.h %.cxx %.rc: %.msg
-	$(PERL) -w $(top_builddir)/msggen.pl $(MSGGENFLAGS) $<
+	[ ! -f $(top_srcdir)/msggen.pl ] || $(PERL) -w $(top_srcdir)/msggen.pl $(MSGGENFLAGS) $<
--- openjade-1.4devel1.orig/jade/MessageModule.cxx
+++ openjade-1.4devel1/jade/MessageModule.cxx
@@ -0,0 +1,24 @@
+// Copyright (c) 2002 Ian Castle
+// See the file COPYING for copying permission.
+
+#ifdef __GNUG__
+#pragma implementation
+#endif
+
+// #include "splib.h"
+// #include "MessageTable.h"
+
+#include "stylelib.h"
+
+#include <OpenSP/MessageModule.h>
+
+#ifdef SP_NAMESPACE
+namespace SP_NAMESPACE {
+#endif
+
+MessageModule jadeModule;
+
+#ifdef SP_NAMESPACE
+}
+#endif
+
--- openjade-1.4devel1.orig/jade/RtfFOTBuilder.cxx
+++ openjade-1.4devel1/jade/RtfFOTBuilder.cxx
@@ -1163,6 +1163,9 @@
 #if 0
   os() << "{\\field{\\*\\fldinst SYMBOL " << (unsigned long)code
        << " \\\\f \"" << symbolFonts[ff - 1].name << "\"}{\\fldrslt ";
+      if (specFormat_.inputWhitespaceTreatment != symbolPreserve)
+              for (; n > 0 && *s == ' '; s++, n--)
+                      ;
 #endif
   int &n = fontFamilyCharsetsTable_[ff].rtfFontNumber[nWinCharsets - 1];
   if (n < 0)
@@ -2051,8 +2054,9 @@
   }
   else if (inlineState_ == inlineField) {
     os() << "\\tab ";
-    inlineState_ = inlineMiddle;
+    
   }
+  inlineState_ = inlineMiddle;
   end();
 }
 
--- openjade-1.4devel1.orig/jade/TeXFOTBuilder.cxx
+++ openjade-1.4devel1/jade/TeXFOTBuilder.cxx
@@ -386,6 +386,7 @@
   void setPageNColumns(long);
   void setPageColumnSep(Length);
   void setPageBalanceColumns(bool);
+  void setPageTwoSide(bool);
   void setGridRowSep(Length);
   void setGridColumnSep(Length);
   void setSubscriptDepth(Length);
@@ -413,11 +414,12 @@
   void setInlineSpaceSpace(const OptInlineSpace &);
   void setGlyphSubstTable(const Vector<ConstPtr<GlyphSubstTable> > &tables);
 
-  void startDisplay( const DisplayNIC & );
-  void endDisplay();
+  void startDisplay( const DisplayNIC & ) {};
+  void endDisplay() {};
 
   enum FotObjectClassType { oc_Unknown, oc_Cell };
  
+  static const Length lengthUnspecified = LONG_MAX;
   
   struct Format {
 
@@ -427,8 +429,10 @@
                FotBorderPriority( 0 ),
                FotBorderPresent( true ),
                FotLineRepeat( 1 ),
+               FotLines( symbolWrap ),
                FotLineSep( 1000 ),
-               FotDisplayAlignment( symbolStart ),
+               FotDisplayAlignment( symbolNotApplicable ),
+               FotCellRowAlignment( symbolNotApplicable ),
                FotStartIndentSpec( 0 ),
                FotEndIndentSpec( 0 ),
                FotLeftMargin( 1 ),
@@ -437,8 +441,9 @@
                FotPageNColumns( 1 ),
                FotPageColumnSep( 72000/2 ),
                FotSpan( 1 ),
-               FotCellBeforeColumnMargin( 0 ),
-               FotCellAfterColumnMargin( 0 ),
+               FotCellBeforeColumnMargin( lengthUnspecified ), 
+               FotCellAfterColumnMargin( lengthUnspecified ),
+	       FotCellBackground(false),
                FotObjectClass( oc_Unknown ) {}
 
     long                 FotCurDisplaySize;
@@ -448,7 +453,9 @@
     bool                 FotBorderPresent;
     long                 FotLineRepeat;
     Length               FotLineSep;
+    Symbol		 FotLines;
     Symbol               FotDisplayAlignment;
+    Symbol               FotCellRowAlignment;
     LengthSpec           FotStartIndentSpec;
     LengthSpec           FotEndIndentSpec;
     Length               FotLeftMargin;
@@ -457,6 +464,8 @@
     long                 FotPageNColumns;
     Length               FotPageColumnSep;
     long                 FotSpan;
+    bool		 FotCellBackground;
+    DeviceRGBColor	 FotBackgroundColor;
     Length               FotCellBeforeColumnMargin;
     Length               FotCellAfterColumnMargin;
     FotObjectClassType   FotObjectClass;
@@ -522,10 +531,13 @@
   struct CompoundFotElement : public FotElement {
 
     CompoundFotElement( CompoundFotElement *parent = NULL )
-     : FotElement( parent ), CurrentlyOpenChildIdx( -1 ), LastClosedChildIdx( -1 ) {}
+     : FotElement( parent ), CurrentlyOpenChildIdx( -1 ),
+       LastClosedChildIdx( -1 ) {}
     virtual bool isAtomic() const { return false; }
     virtual void open( TeXFOTBuilder &builder )
-      { FotElement::open( builder ); builder.setCurOs( &PreContent ); };
+      { FotElement::open( builder ); builder.pushOs( &PreContent ); };
+    virtual void close( TeXFOTBuilder &builder )
+      { builder.popOs(); FotElement::close( builder ); };
     virtual void childJustClosed( FotElement &child )
      { CurrentlyOpenChildIdx = -1; LastClosedChildIdx = child.siblingSeqIdx(); };
     virtual void childJustOpened( FotElement &child )
@@ -552,7 +564,8 @@
       #else
        stream <<  NodeInfoProlog << "\\" << name() << "%\n{" << Characteristics << '}';
       #endif
-       PreContent.commit( stream );
+       
+      PreContent.commit( stream );
      }
     virtual void outEpilog( OutputByteStream &stream ) const {
       #ifdef TEXDEBUG
@@ -618,15 +631,21 @@
   struct Column {
 
     Column() : hasWidth( 0 ), computedWidth( 0 ), defaultTeXLeftBorder( 0 ),
-             defaultTeXRightBorder( 0 ), displayAlignment( symbolStart ),
-             isExplicit( false ) {}
+	       defaultTeXRightBorder( 0 ), displayAlignment( symbolStart ),
+	       isExplicit( false ), displaySize(0),
+	       defaultCellBeforeColumnMargin( 0 ),
+	       defaultCellAfterColumnMargin( 0 ) {}
     bool isExplicit;
     bool hasWidth;
     TableLengthSpec width;
     long computedWidth;
+    long displaySize;
     Symbol displayAlignment;
     int defaultTeXLeftBorder; // also used as column border count;
     int defaultTeXRightBorder; //
+    bool defaultCellBackground;
+    Length defaultCellBeforeColumnMargin;
+    Length defaultCellAfterColumnMargin;
   };
 
   struct TablePart;
@@ -636,9 +655,15 @@
      : CompoundFotElement( parent ), missing( false ), OverlappingCell( NULL ),
        nRowsSpanned( 1 ), nColumnsSpanned( 1 ), displaySize( 0 ),
        beforeRowBorder(), afterRowBorder(), beforeColumnBorder(),
-       afterColumnBorder(), TeXTableRowIdx( -1 ), TeXTableColumnIdx( -1 ),
-       displayAlignment( symbolStart ), effectiveAlignment( symbolStart ),
-       paragraphChildrenNum( 0 )  {}
+       afterColumnBorder(), TeXTableRowIdx( -1 ), TeXTableColumnIdx(-1),
+       needsTeXColumnOverride(false),
+       beforeColumnMargin( lengthUnspecified ), 
+       effectiveBeforeColumnMargin( lengthUnspecified ), 
+       afterColumnMargin( lengthUnspecified ),
+       effectiveAfterColumnMargin( lengthUnspecified ),
+       effectiveAlignment( symbolStart ),
+       rowAlignment( symbolNotApplicable ),
+       cellBackground(false) {}
 
     bool missing;
     int TeXTableRowIdx;
@@ -649,29 +674,37 @@
     CellAfterRowBorder afterRowBorder;
     CellBeforeColumnBorder beforeColumnBorder;
     CellAfterColumnBorder afterColumnBorder;
-    Symbol displayAlignment;
+    bool needsTeXColumnOverride;
+    Length beforeColumnMargin;
+    Length effectiveBeforeColumnMargin;
+    Length afterColumnMargin;
+    Length effectiveAfterColumnMargin;
+    Symbol rowAlignment;
     Symbol effectiveAlignment;
     long displaySize;
-    long paragraphChildrenNum;
+    bool cellBackground;
+    DeviceRGBColor backgroundColor;
 
     Cell *OverlappingCell;
     OutputByteStream &content() { return Content; }
     virtual void open( TeXFOTBuilder &builder )
-     { CompoundFotElement::open( builder );
-       builder.setCurOs( &Content );
+     { builder.pushFotElementState();
+       CompoundFotElement::open( builder );
+       builder.pushOs( &Content );
        builder.curFotElementState().EnforcingStructure = false; }
     virtual void close( TeXFOTBuilder &builder )
-     { computeMultiParFlag();
+     { builder.popOs();
        CompoundFotElement::close( builder );
-       builder.curFotElementState().EnforcingStructure = true; }
+       builder.popFotElementState(); }
     virtual const char *name() const { return "TableCell"; }
     bool singleRowBeforeRowBorderPresent() const;
     bool singleRowAfterRowBorderPresent() const;
     bool singleColumnBeforeColumnBorderPresent() const;
     bool singleColumnAfterColumnBorderPresent() const;
     void computeOverridingTeXColumnBorders( TablePart &tablePart );
-    void computeOverridingTeXDisplayAlignment( TablePart &tablePart );
-    void computeMultiParFlag();
+    void computeEffectiveTeXCellWidth( TablePart &tablePart );
+    void computeEffectiveTeXColumnMargins( TablePart &tablePart );
+    void computeTeXRowSpanFiller( TablePart &tablePart );
 
     bool isOverlapped() const { return OverlappingCell == this ? false : true; }
     virtual FotElement &child( size_t ) { assert( false ); return *this; }
@@ -679,7 +712,8 @@
    protected:
     virtual void outProlog( OutputByteStream &stream ) const;
     virtual void outEpilog( OutputByteStream &stream ) const;
-    void outContent( OutputByteStream &stream ) const { Content.commit( stream ); }
+    void outContent( OutputByteStream &stream ) const 
+      { if ( !isOverlapped() ) Content.commit( stream ); }
     TeXTmpOutputByteStream Content;
   };
 
@@ -716,7 +750,7 @@
     String<char> FooterEpilog;
 
     void processColumns( TeXFOTBuilder &builder );
-    void computeTeXColumnBordersAndDisplayAlignment();
+    void computeOverridingTeXCharacteristics();
     void normalizeRows();
     void begin();
 
@@ -742,7 +776,8 @@
     Table(  CompoundFotElement *parent = NULL )
      : CompoundFotElement( parent ), beforeRowBorder(), afterRowBorder(),
        beforeColumnBorder(), afterColumnBorder(), CurCell( NULL ),
-       CurTablePart( NULL ), NoTablePartsSeen( true ) {}
+       displayAlignment( symbolStart ), CurTablePart( NULL ), 
+       NoTablePartsSeen( true ) {}
 
     Vector<TablePart> TableParts;
 
@@ -763,12 +798,19 @@
                          unsigned startingRowIdx,
                          bool hasFirstTableRow, bool hasLastTableRow );
     void begin();
+    virtual void open( TeXFOTBuilder &builder )
+     { builder.pushFotElementState();
+       CompoundFotElement::open( builder );
+       builder.curFotElementState().EnforcingStructure = true; }
+    virtual void close( TeXFOTBuilder &builder )
+     { CompoundFotElement::close( builder );
+       builder.popFotElementState(); }
     void end( TeXFOTBuilder &builder );
 
     Vector<Row> &curRows() { assert( CurRows != NULL ); return *CurRows; }
     TablePart &curTablePart() { assert( CurTablePart != NULL ); return *CurTablePart; }
     Cell &curCell() { assert( CurCell != NULL ); return *CurCell; }
-
+ 
     TablePart *CurTablePart;
     Cell *CurCell;
     Vector<Row> *CurRows;
@@ -778,18 +820,29 @@
   protected:
     void outContent( OutputByteStream &stream ) const;
   };
-
+  
   long computeLengthSpec( const LengthSpec &spec ) const;
   const Format &curFormat() const { assert( FormatStack.size() > 0 ); return FormatStack.back(); }
-  Table &curTable() { return CurTable; }
-  FotElementState &curFotElementState() { return CurFotElementState; }
-  void setCurOs( OutputByteStream *to ) { CurOs = to; }
+  Table &curTable() { assert( TableStack.size() > 0 ); 
+		      return TableStack.back(); }
+  FotElementState &curFotElementState() 
+    { assert( FotElementStateStack_.size() > 0 );
+      return FotElementStateStack_.back(); }
+  void pushFotElementState()
+    { FotElementStateStack_.resize(FotElementStateStack_.size() + 1 ); }
+  void popFotElementState()
+    { assert( FotElementStateStack_.size() > 0 );
+      FotElementStateStack_.resize(FotElementStateStack_.size() - 1 ); }
+
+  void pushOs( OutputByteStream *to );
+  void popOs();
+  
   void elementStart( FotObjectClassType objectClassType );
   
   OutputByteStream *fileout_;
 private:
 				// Variables.
-  OutputByteStream *CurOs;
+  Vector<OutputByteStream *> osStack_;
   StrOutputByteStream stringout_;
   Messenger *mgr_;
   bool preserveSdata_;
@@ -824,8 +877,8 @@
   Vector<Format> FormatStack;
  
   Format NextFormat; 
-  Table CurTable;
-  FotElementState CurFotElementState;
+  Vector<Table> TableStack;
+  Vector<FotElementState> FotElementStateStack_;
 
 				// Functions.
   OutputByteStream &os();
@@ -844,6 +897,7 @@
   void setlength(const char *,Length);
   void set(const char *,const StringC &);
   void set(const char *,const GroveString &);
+  void set(const char *,const GroveString &,long unsigned int);
   void set(const char *,Symbol);
   void set(const char *,const LengthSpec &);
   void set(const char *,double);
@@ -851,6 +905,7 @@
   void set(const char *,bool);
   void set(const char *,long);
   void set(const char *,long unsigned int);
+  void set(const char *,long unsigned int,long unsigned int);
   void set(const char *name,unsigned int n) {
     set(name, (unsigned long)n);
   }
@@ -960,7 +1015,6 @@
 // --------- TeXFOTBuilder::FotElement ---------------------------------------
 
 void TeXFOTBuilder::FotElement::open( TeXFOTBuilder &builder ) {
-
   builder.curFotElementState().IsOpen = true;
   if( parent() )
     parent()->childJustOpened( *this );
@@ -972,13 +1026,10 @@
 }
 
 void TeXFOTBuilder::FotElement::close( TeXFOTBuilder &builder ) {
-
   if( parent() )
     parent()->childJustClosed( *this );
-  else {
+  else 
     builder.curFotElementState().IsOpen = false;
-    builder.setCurOs( NULL );
-  }
 }  
 
 TeXFOTBuilder::FotElement *TeXFOTBuilder::FotElement::lastClosed_() {
@@ -989,19 +1040,16 @@
 // --------- TeXFOTBuilder Standard Display/Element Handling -----------------
 
 void TeXFOTBuilder::elementStart( FotObjectClassType objectClassType ) {
-
   NextFormat.FotObjectClass = objectClassType;
   FormatStack.push_back( NextFormat );
 }
 
 void TeXFOTBuilder::start() {
-
   NextFormat.FotObjectClass = oc_Unknown;
   FormatStack.push_back( NextFormat );
 }
 
 void TeXFOTBuilder::end() {
-
   assert( FormatStack.size() > 0 );
   FormatStack.resize( FormatStack.size()-1 );
 
@@ -1009,24 +1057,6 @@
   NextFormat = FormatStack.back();
 }
 
-void TeXFOTBuilder::startDisplay( const DisplayNIC & ) {
-
-  if( curTable().CurCell != NULL )
-      NextFormat.FotCurDisplaySize = curTable().CurCell->displaySize;
-  else if( NextFormat.FotSpan > 1 )
-      NextFormat.FotCurDisplaySize
-       = NextFormat.FotPageWidth - NextFormat.FotLeftMargin - NextFormat.FotRightMargin;
-  else
-      NextFormat.FotCurDisplaySize
-       = ( NextFormat.FotPageWidth - NextFormat.FotLeftMargin - NextFormat.FotRightMargin
-            - NextFormat.FotPageColumnSep * ( NextFormat.FotPageNColumns - 1 ) )  
-          / NextFormat.FotPageNColumns;
-
-}
-
-void TeXFOTBuilder::endDisplay() {
-}
-
 // --------- TeXFOTBuilder Misc ----------------------------------------------
 
 long TeXFOTBuilder::computeLengthSpec( const LengthSpec &spec ) const {
@@ -1173,7 +1203,7 @@
       if( tablePart.needsColumnReprocessing )
         tablePart.processColumns( builder );
 
-      tablePart.computeTeXColumnBordersAndDisplayAlignment();
+      tablePart.computeOverridingTeXCharacteristics();
   }
 }
 
@@ -1213,7 +1243,7 @@
   return Footer[idx];
 }
 
-void TeXFOTBuilder::TablePart::computeTeXColumnBordersAndDisplayAlignment() {
+void TeXFOTBuilder::TablePart::computeOverridingTeXCharacteristics() {
 
   Vector<Row> *rows;  
   for( int step = 0; step < 3; step++ ) {
@@ -1274,8 +1304,9 @@
       for( size_t c = 0; c < (*rows)[r].Cells.size()-1; c++ ) {
         if( !(*rows)[r].Cells[c].isOverlapped() ) {
           (*rows)[r].Cells[c].computeOverridingTeXColumnBorders( *this );
-          (*rows)[r].Cells[c].computeOverridingTeXDisplayAlignment( *this );
-        }
+        } else {
+	  (*rows)[r].Cells[c].computeTeXRowSpanFiller( *this );
+	}
       }
     }
   }
@@ -1317,15 +1348,26 @@
           Columns[i].computedWidth = long(proportionalUnit);
   }
 
+  // Compute display size of the column
+  for( size_t i = 0; i < Columns.size(); i++ ) {
+    if (Columns[i].computedWidth > 0) {
+      Columns[i].displaySize = Columns[i].computedWidth;
+      if (Columns[i].defaultCellBeforeColumnMargin != lengthUnspecified)
+	Columns[i].displaySize -= Columns[i].defaultCellBeforeColumnMargin;
+      
+      if (Columns[i].defaultCellAfterColumnMargin != lengthUnspecified)
+	Columns[i].displaySize -= Columns[i].defaultCellAfterColumnMargin;
+    }
+  }
+  
   columnsProcessed = true;
 }
 
 void TeXFOTBuilder::TablePart::outContent( OutputByteStream &stream ) const {
 
   stream << "\\TeXTable%\n{" << LengthInPoints( parentTable().tableWidth ) 
-         << "}{" << Columns.size() << '}';
+         << "}{" << Columns.size() << "}{";
 
-  stream << '{';
   for( size_t i = 0; i < Columns.size(); i++ ) {
     #ifdef TEXDEBUG
       stream << "\nCOLUMN " << i << " DEF_LEFT_B: " <<  Columns[i].defaultTeXLeftBorder
@@ -1333,20 +1375,35 @@
     #endif
     if( i == 0 && Columns[i].defaultTeXLeftBorder )
       stream << '|';
+
+    //Cell before margin
     if( Columns[i].computedWidth > 0 ) {
+      char alignment;
       switch( Columns[i].displayAlignment ) {
-        case symbolInside:  
-        case symbolStart:
-          stream << "L{" << LengthInPoints( Columns[i].computedWidth ) << '}';
-          break;
         case symbolOutside: 
         case symbolEnd:
-          stream << "R{" << LengthInPoints( Columns[i].computedWidth ) << '}';
+	  alignment =  'U';
+          break;
+        case symbolCenter: 
+	  alignment = 'Y';
+	  break;
+        case symbolInside:  
+        case symbolStart:
+        default:
+	  alignment = 'T';
           break;
-        case symbolCenter: default:
-          stream << "C{" << LengthInPoints( Columns[i].computedWidth ) << '}';
       }
+      stream << alignment << '{' 
+	     << LengthInPoints(Columns[i].defaultCellBeforeColumnMargin)
+	     << "}{" << LengthInPoints( Columns[i].displaySize ) 
+	     << "}{" 
+	     << LengthInPoints(Columns[i].defaultCellAfterColumnMargin) 
+	     << '}';
     } else {
+      stream << "@{\\hspace{" 
+	     << LengthInPoints(Columns[i].defaultCellBeforeColumnMargin)
+	     << "}}";
+
       switch( Columns[i].displayAlignment ) {
         case symbolOutside: 
         case symbolEnd:     stream << 'r'; break;
@@ -1355,6 +1412,9 @@
         case symbolStart:
         default:            stream << 'l'; break;
       }
+      stream << "@{\\hspace{" 
+	     << LengthInPoints(Columns[i].defaultCellAfterColumnMargin)
+	     << "}}";
     }
     if( Columns[i].defaultTeXRightBorder )
       stream << '|';
@@ -1424,15 +1484,27 @@
 
   bool first = true;
   for( size_t i = 0; i + 1 < Cells.size(); i++ ) {
-    if( !Cells[i].isOverlapped() ) {
-      if( !first )
-        stream << "&";  
-      else
-        first = false;
-      Cells[i].out( stream );
+    /* Output the overlapped cells in a row span but not
+       those in a column span.
+       
+       If the overlapping cell is both row and column spanning
+       only output the first cell in the row.
+    */
+    bool outputCell = !Cells[i].isOverlapped() ||
+      (Cells[i].OverlappingCell->nRowsSpanned > 1 && 
+       Cells[i].OverlappingCell->TeXTableColumnIdx == i);
+  
+    if( !first ) {
+      if (outputCell)
+	stream << "&";  
     }
+    else
+      first = false;
+    if (outputCell)
+      Cells[i].out( stream );
   }
 }
+  
 
 void TeXFOTBuilder::Row::outVerticalBorders
  ( const TeXFOTBuilder::Row *upperRow, 
@@ -1476,46 +1548,135 @@
 
 // --------- TeXFOTBuilder::Cell ----------------------------------------------
 
-void TeXFOTBuilder::Cell::outProlog( OutputByteStream &stream ) const {
+void TeXFOTBuilder::Cell::outProlog( OutputByteStream &stream ) const
+{
+  if ( nColumnsSpanned > 1 || needsTeXColumnOverride ||
+       (rowAlignment != symbolNotApplicable &&
+	rowAlignment != symbolStart ) ||
+       cellBackground )
+  {
+    char color_buf[32];
+    if ( cellBackground ) {
+      double r,g,b;
+      r = (double)backgroundColor.red   / 255.0;
+      g = (double)backgroundColor.green / 255.0;
+      b = (double)backgroundColor.blue  / 255.0;
+      sprintf( color_buf, "{%.2f, %.2f, %.2f}", r, g, b );
+    }
+    else
+      strcpy( color_buf, "");
 
-  if( nColumnsSpanned > 1 ) {
-    stream << "\\multicolumn%\n{" << nColumnsSpanned << "}{";
+    stream << "\\TeXTableCell{" << nColumnsSpanned << "}{";
+  
     if( beforeColumnBorder.borderPresent )
       stream << '|';
-    switch( effectiveAlignment ) {
+
+    if (displaySize) {
+      char alignment;
+      switch( effectiveAlignment ) {
       case symbolOutside: 
-      case symbolEnd:     stream << 'r'; break;
-      case symbolCenter:  stream << 'c'; break;
+      case symbolEnd:     
+	switch (rowAlignment) {
+	case symbolOutside:
+	case symbolEnd:
+	  alignment = cellBackground ? '3' : 'M';
+	  break;
+	case symbolCenter:
+	  alignment = cellBackground ? '6' : 'J';
+	  break;
+	case symbolInside:
+	case symbolStart:
+	default:
+	  alignment = cellBackground ? '9' : 'U';
+	  break;
+	}
+	break;
+      case symbolCenter:  
+	switch (rowAlignment) {
+	case symbolOutside:
+	case symbolEnd:
+	  alignment = cellBackground ? '2' : 'N';
+	  break;
+	case symbolCenter:
+	  alignment = cellBackground ? '5' : 'H';
+	  break;
+	case symbolInside:
+	case symbolStart:
+	default:
+	  alignment = cellBackground ? '8' : 'Y';
+	  break;
+	}
+	break;
       case symbolInside:  
       case symbolStart:
-      default:            stream << 'l'; break;
+      default:
+	switch (rowAlignment) {
+	case symbolOutside:
+	case symbolEnd:
+	  alignment = cellBackground ? '1' : 'B';
+	  break;
+	case symbolCenter:
+	  alignment = cellBackground ? '4' : 'G';
+	  break;
+	case symbolInside:
+	case symbolStart:
+	default:
+	  alignment = cellBackground ? '7' : 'T';
+	  break;
+	}
+	break;
+      } 
+      stream << alignment 
+	     << '{' << LengthInPoints(effectiveBeforeColumnMargin) 
+	     << "}{" << LengthInPoints(displaySize) << "}{"
+	     << LengthInPoints(effectiveAfterColumnMargin) 
+	     << '}' << color_buf;
+    }
+    else {
+      //cell-before-margin
+      stream << "@{\\hspace{" << LengthInPoints(effectiveBeforeColumnMargin) 
+	     << "}}";
+      if ( cellBackground )
+	stream << ">{\\columncolor[rgb]" << color_buf << "}";
+      
+      switch (rowAlignment) {
+      case symbolOutside:
+      case symbolEnd:
+	stream << 'r';
+	break;
+      case symbolCenter:
+	stream << 'c';
+	break;
+      case symbolInside:
+      case symbolStart:
+      default:
+	stream << 'l';
+	break;
+      }
+      //cell-after-margin
+      stream << "@{\\hspace{" << LengthInPoints(effectiveAfterColumnMargin) 
+	     << "}}";
     }
+  
     if( afterColumnBorder.borderPresent )
       stream << '|';
-    stream << "}{";
-  }
 
+    stream << "}%\n{%\n";
+  }
+  
   CompoundFotElement::outProlog( stream );
 }
 
 void TeXFOTBuilder::Cell::outEpilog( OutputByteStream &stream ) const {
 
   CompoundFotElement::outEpilog( stream );
-  if( nColumnsSpanned > 1 )
+  if ( nColumnsSpanned > 1 || needsTeXColumnOverride ||
+       (rowAlignment != symbolNotApplicable &&
+	rowAlignment != symbolStart ) ||
+       cellBackground )
     stream << "}%\n";
 }
 
-void TeXFOTBuilder::Cell::computeMultiParFlag() {
-
-  if( paragraphChildrenNum > 1 ) {
-    StrOutputByteStream str;
-    str << "\\def\\MultiPar{1}";
-    String<char> s;
-    str.extractString( s );
-    Characteristics += s;
-  }
-}
-
 void TeXFOTBuilder::Cell::computeOverridingTeXColumnBorders( TablePart &tablePart ) {
 
   StrOutputByteStream str;
@@ -1533,28 +1694,49 @@
   Characteristics += s;
 }
 
-void TeXFOTBuilder::Cell::computeOverridingTeXDisplayAlignment( TablePart &tablePart ) {
-
-  effectiveAlignment
-   = tablePart.Columns[TeXTableColumnIdx].isExplicit
-      ? tablePart.Columns[TeXTableColumnIdx].displayAlignment : displayAlignment;
+void TeXFOTBuilder::Cell::computeTeXRowSpanFiller( TablePart &tablePart ) {
 
   StrOutputByteStream str;
-  if( effectiveAlignment != tablePart.Columns[TeXTableColumnIdx].displayAlignment ) {
-    str << "\\def\\TeXTableCellDisplayAlignment{";
-    switch( effectiveAlignment ) {
-      case symbolOutside: 
-      case symbolEnd:     str << 'r'; break;
-      case symbolCenter:  str << 'c'; break;
-      case symbolInside:  
-      case symbolStart:
-      default:            str << 'l'; break;
-    }
-    str << '}';
-    String<char> s;
-    str.extractString( s );
-    Characteristics += s;
+
+  if ( isOverlapped() && OverlappingCell->nRowsSpanned > 1 )
+  {
+    // This isn't output automatically for overlapped cell
+    str << "\\def\\ColumnIndex{" << TeXTableColumnIdx <<'}';
+    str << "\\def\\TeXRowSpanFiller{1}";
   }
+  
+  String<char> s;
+  str.extractString( s );
+  Characteristics += s;
+}
+
+void TeXFOTBuilder::Cell::computeEffectiveTeXColumnMargins( TablePart &tablePart ) {
+  effectiveBeforeColumnMargin = beforeColumnMargin != lengthUnspecified
+    ? beforeColumnMargin : 
+    tablePart.Columns[TeXTableColumnIdx].defaultCellBeforeColumnMargin;
+  if( effectiveBeforeColumnMargin != lengthUnspecified &&
+      (tablePart.Columns[TeXTableColumnIdx].defaultCellBeforeColumnMargin
+       != effectiveBeforeColumnMargin || nColumnsSpanned > 1) ) 
+    needsTeXColumnOverride = true;
+
+  
+  effectiveAfterColumnMargin = afterColumnMargin != lengthUnspecified 
+    ? afterColumnMargin :
+    tablePart.Columns[TeXTableColumnIdx].defaultCellAfterColumnMargin;
+  if( effectiveAfterColumnMargin != lengthUnspecified &&
+      (tablePart.Columns[TeXTableColumnIdx].defaultCellAfterColumnMargin
+       != effectiveAfterColumnMargin || nColumnsSpanned > 1) ) 
+    needsTeXColumnOverride = true;
+}
+
+void TeXFOTBuilder::Cell::computeEffectiveTeXCellWidth( TablePart &tablePart )
+{
+  displaySize = 0;
+  for (unsigned i = 0; i < nColumnsSpanned; i++ )
+    displaySize += tablePart.Columns[TeXTableColumnIdx + i].computedWidth;
+
+  if (displaySize)
+    displaySize -= effectiveBeforeColumnMargin + effectiveAfterColumnMargin;
 }
 
 bool TeXFOTBuilder::Cell::singleRowBeforeRowBorderPresent() const {
@@ -1643,7 +1825,20 @@
 inline
 OutputByteStream &TeXFOTBuilder::os()
 {
-  return CurOs == NULL ? *fileout_ : *CurOs;
+  return  *(osStack_.back());
+}
+
+void
+TeXFOTBuilder::pushOs(OutputByteStream *to)
+{
+  osStack_.push_back( to );
+}
+
+void
+TeXFOTBuilder::popOs()
+{
+  assert( osStack_.size() > 0 );
+  osStack_.resize( osStack_.size() - 1);
 }
 
 //
@@ -1733,6 +1928,12 @@
       0
     },
     {
+      "UNREGISTERED::OpenJade//Characteristic::page-two-side?",
+      (void (FOTBuilder::*)(bool))&TeXFOTBuilder::setPageTwoSide,
+      0,
+      0
+    },
+    {
       "UNREGISTERED::James Clark//Characteristic::subscript-depth",
       0,
       0,
@@ -1821,7 +2022,7 @@
 ////////////////////////////////////////////////////////////////////////
 
 TeXFOTBuilder::TeXFOTBuilder(OutputByteStream *o, Messenger *mgr)
-: fileout_(o), mgr_(mgr), CurOs( NULL ), preserveSdata_(1)
+: fileout_(o), mgr_(mgr), preserveSdata_(1)
 #ifdef OUTLINES
 ,inHeading_(0),headingSet_(0),lastHeaded_(0)
 #endif
@@ -1832,7 +2033,9 @@
   #endif
   NextFormat.FotCurDisplaySize = Format::INITIAL_PAGE_SIZE();
   FormatStack.push_back( NextFormat );
-  os() << "\\FOT{2}";
+  pushFotElementState();
+  pushOs(o);
+  os() << "\\FOT{3}";
 #ifdef OUTLINES
   return_ += Char('\n');
   protectedChar_ += Char('\\');
@@ -1875,6 +2078,19 @@
 	}
 #endif
 	break;
+      case ' ':
+      case '\t':
+	if ( NextFormat.FotLines == symbolAsis )
+	  os() << '~';
+	else
+	  os() << char(*s);
+#ifdef OUTLINES
+	if (needToCollect()){
+	  addHeadedText(s,1);
+	  //top(parStack_).headingText_.append(s,1);
+	}
+#endif
+	break;
       case '\\':
       case '^':
       case '_':
@@ -1972,7 +2188,7 @@
   setTableColumnNIC(nic);
 
   if( nic.columnIndex >= curTable().curTablePart().Columns.size() )
-      curTable().curTablePart().Columns.resize( nic.columnIndex + 1 );
+    curTable().curTablePart().Columns.resize( nic.columnIndex + 1 );
 
   Column &col = curTable().curTablePart().Columns[nic.columnIndex];
 
@@ -1981,7 +2197,12 @@
   if( nic.hasWidth )
       col.width = nic.width;
 
-  col.displayAlignment = curFormat().FotDisplayAlignment;
+  if ( curFormat().FotDisplayAlignment != symbolNotApplicable )
+      col.displayAlignment = curFormat().FotDisplayAlignment;
+  if ( curFormat().FotCellBeforeColumnMargin != lengthUnspecified )
+    col.defaultCellBeforeColumnMargin = curFormat().FotCellBeforeColumnMargin;
+  if ( curFormat().FotCellAfterColumnMargin != lengthUnspecified )
+    col.defaultCellAfterColumnMargin = curFormat().FotCellAfterColumnMargin;
 
   insertAtomic("TableColumn");
 }
@@ -2038,14 +2259,16 @@
 {
   GroveString id;
   unsigned long ei;
-
+  unsigned  long gi;
   // FIX ME!
   // Only PARTIALLY supported -- I currently allow cross-references
   // only to elements.
   if (node->getId(id) == accessOK) {
-    set("Label",id);
+    gi=node->groveIndex();
+    set("Label",id,gi);
   } else if (node->elementIndex(ei) == accessOK) {
-    set("Element",ei);
+    gi=node->groveIndex();
+    set("Element",ei,gi);
   } else {
     message(TeXMessages::unsupportedPageNumberNonElement);
     return;
@@ -2092,8 +2315,6 @@
 void TeXFOTBuilder::startParagraph(const ParagraphNIC &nic)
 {
   startDisplay( nic );
-  if( curFormat().FotObjectClass == oc_Cell )
-    curTable().curCell().paragraphChildrenNum++;
   start();
   setParagraphNIC(nic);
 #ifdef OUTLINES
@@ -2251,16 +2472,20 @@
   #ifdef TEXDEBUG
     *fileout_ << "\nTABLE_START\n";
   #endif
+  TableStack.resize( TableStack.size() + 1 );
   startDisplay( nic );
   start();
-
+  
   setTableNIC(nic);
 
   Length curStartIndent = computeLengthSpec( curFormat().FotStartIndentSpec );
   curTable().startIndent = curStartIndent;
 
+  startGroup( curTable() );
+  curTable().open( *this);
   curTable().begin();
-  curTable().displayAlignment = curFormat().FotDisplayAlignment;
+  if ( curFormat().FotDisplayAlignment != symbolNotApplicable )
+      curTable().displayAlignment = curFormat().FotDisplayAlignment;
 
   if( nic.widthType == TableNIC::widthExplicit )
       curTable().tableWidth = computeLengthSpec( nic.width );
@@ -2269,12 +2494,12 @@
        = curFormat().FotCurDisplaySize - curStartIndent
           - computeLengthSpec( curFormat().FotEndIndentSpec );
 
-  startGroup( curTable() );
   curTable().curTablePart().open( *this );
 }
 
 void TeXFOTBuilder::endTable()
 {
+  assert( TableStack.size() > 0 );
   #ifdef TEXDEBUG
     *fileout_ << "\nTABLE_END\n";
   #endif
@@ -2291,6 +2516,8 @@
   endGroup();
   end();
   endDisplay();
+
+  TableStack.resize( TableStack.size() - 1 );
 }
 
 // A call for each border is made immediately
@@ -2338,17 +2565,20 @@
 
   setTablePartNIC(nic);
 
-  if( curTable().NoTablePartsSeen )
+  if( curTable().NoTablePartsSeen ) {
       curTable().NoTablePartsSeen = false;
+      /* begin() was arleady called from Table() and 
+	 open() was called from startTable() */
+  }
   else {
       curTable().TableParts.resize( curTable().TableParts.size()+1 );
       curTable().TableParts.back().setSiblingSeqIdx( curTable().TableParts.size()-1 );
       curTable().TableParts.back().setParent( &curTable() );    
-  }
-
-  curTable().TableParts.back().begin();    
-  curTable().TableParts.back().open( *this );    
 
+      curTable().TableParts.back().begin();    
+      curTable().TableParts.back().open( *this );    
+  }
+ 
   startGroup( curTable().curTablePart() );
 }
 
@@ -2388,6 +2618,10 @@
   #endif
 }
 
+/* 
+ * FIXME: We are getting one extra table cell in each
+ * row whic nic.missing set . What is this ???
+ */
 void TeXFOTBuilder::startTableCell(const TableCellNIC &nic)
 {
   #ifdef TEXDEBUG
@@ -2420,27 +2654,40 @@
 
   if( nic.nRowsSpanned != 1 )
       cell.nRowsSpanned = nic.nRowsSpanned;
-  
-  long newDisplaySize = 0;
-  for( size_t i = nic.columnIndex; i < nic.columnIndex + nic.nColumnsSpanned; i++ )
-      if( i < tp.Columns.size() ) {
-          if( tp.Columns[i].hasWidth )
-              newDisplaySize
-               += computeLengthSpec( tp.Columns[i].width );
-      } else
-      if( !nic.missing ) {
-          tp.Columns.resize( tp.Columns.size() + 1 ); 
-          tp.Columns.back().hasWidth = false;
-      }
 
-  if( newDisplaySize > 0 ) {
-      newDisplaySize -= NextFormat.FotCellBeforeColumnMargin
-                         + NextFormat.FotCellAfterColumnMargin;
-      NextFormat.FotCurDisplaySize = newDisplaySize;
+  for( size_t i = nic.columnIndex; i < nic.columnIndex + nic.nColumnsSpanned; i++ )
+  {
+    if( i >= tp.Columns.size() && !nic.missing ) {
+      tp.Columns.resize( tp.Columns.size() + 1 ); 
+      tp.Columns.back().hasWidth = false;
+      tp.Columns.back().isExplicit = false;
+      tp.columnsProcessed = false;
+    }
   }
+  // We may need reprocessing
+  if( !tp.columnsProcessed )
+      tp.processColumns( *this );
 
-  cell.displaySize = NextFormat.FotCurDisplaySize;
-  cell.displayAlignment = NextFormat.FotDisplayAlignment;
+  if ( !nic.missing ) {
+    if ( NextFormat.FotCellRowAlignment != symbolNotApplicable )
+      cell.rowAlignment = NextFormat.FotCellRowAlignment;
+    if ( NextFormat.FotCellBeforeColumnMargin != lengthUnspecified )
+      cell.beforeColumnMargin = NextFormat.FotCellBeforeColumnMargin;
+    if ( NextFormat.FotCellAfterColumnMargin != lengthUnspecified )
+      cell.afterColumnMargin = NextFormat.FotCellAfterColumnMargin;
+
+    if (NextFormat.FotCellBackground) {
+      cell.cellBackground = true;
+      cell.backgroundColor = NextFormat.FotBackgroundColor;
+    }
+  
+    cell.TeXTableColumnIdx = nic.columnIndex;
+    cell.effectiveAlignment = tp.Columns[nic.columnIndex].displayAlignment;
+    cell.computeEffectiveTeXColumnMargins( tp );
+    cell.computeEffectiveTeXCellWidth( tp );
+
+    NextFormat.FotCurDisplaySize = cell.displaySize;
+  }
   
   elementStart( oc_Cell );
   startGroup( cell );
@@ -2824,12 +3071,14 @@
 {
   GroveString id;
   unsigned long ei;
-
+  unsigned long gi=0;
   if (node->getId(id) == accessOK) {
-    set("Label",id);
+    gi=node->groveIndex();
+    set("Label",id,gi);
   }
   else if (node->elementIndex(ei) == accessOK) {
-    set("Element", ei);
+    gi=node->groveIndex();
+    set("Element", ei,gi);
   }
   unsigned long g = node->groveIndex();
   if (g) {
@@ -2866,7 +3115,7 @@
 {
   GroveString id;
   unsigned long ei;
-
+  unsigned  long gi;
   // FIX ME!
   // This needs a lot of work -- for now, it supports only links to
   // elements.
@@ -2875,10 +3124,11 @@
   case Address::none:
     break;
   case Address::resolvedNode:
+    gi=addr.node->groveIndex();
     if (addr.node->getId(id) == accessOK) {
-      set("Label",id);
+      set("Label",id,gi);
     } else if (addr.node->elementIndex(ei) == accessOK) {
-      set("Element", ei);
+      set("Element", ei,gi);
     }
     else {
       message(TeXMessages::unsupportedLinkNonElement);
@@ -2997,6 +3247,7 @@
 
 void TeXFOTBuilder::setLines(Symbol lines)
 {
+  NextFormat.FotLines = lines;
   set("Lines",lines);
 }
 
@@ -3028,6 +3279,7 @@
 
 void TeXFOTBuilder::setBackgroundColor(const DeviceRGBColor &color)
 {
+  NextFormat.FotBackgroundColor = color;
   set("BackgroundColor",color);
 }
 
@@ -3178,6 +3430,7 @@
 
 void TeXFOTBuilder::setCellBackground(bool flag)
 {
+  NextFormat.FotCellBackground = flag;
   set("CellBackground",flag);
 }
 
@@ -3304,6 +3557,7 @@
 
 void TeXFOTBuilder::setCellRowAlignment(Symbol align)
 {
+  NextFormat.FotCellRowAlignment = align;
   set("CellRowAlignment",align);
 }
 
@@ -3367,6 +3621,8 @@
 void TeXFOTBuilder::setSpan(long n)
 {
   NextFormat.FotSpan = n;
+  NextFormat.FotCurDisplaySize
+    = NextFormat.FotPageWidth - NextFormat.FotLeftMargin - NextFormat.FotRightMargin;
   set("Span",n);
 }
 
@@ -3794,6 +4050,15 @@
 	      << value
 	      << '}';
 }
+//
+// For idref addresses
+//
+void TeXFOTBuilder::set(const char *name,const GroveString &value, long unsigned int g)
+{
+  stringout_ << "\\def\\" << name << "%\n{"
+	     <<g <<':'<< value
+	      << '}';
+}
 
 //
 // Set a Symbol.
@@ -4181,6 +4446,13 @@
 }
 
 //
+// For addresses.
+//
+void TeXFOTBuilder::set(const char *name,long unsigned int n,long unsigned int g)
+{
+  stringout_ << "\\def\\" << name << "%\n{" << g  <<':' <<n <<'}';
+}
+//
 // Set a PublicId.
 //
 void TeXFOTBuilder::set(const char *name,PublicId id)
@@ -4499,6 +4771,11 @@
  set("PageBalanceColumns",flag);
 }
 
+void TeXFOTBuilder::setPageTwoSide(bool flag)
+{
+  set("PageTwoSide",flag);
+}
+
 void TeXFOTBuilder::setSubscriptDepth(Length w)
 {
  setlength("SubScriptDepth",w);
--- openjade-1.4devel1.orig/jade/TeXFOTBuilder_inst.cxx
+++ openjade-1.4devel1/jade/TeXFOTBuilder_inst.cxx
@@ -83,6 +83,45 @@
 #endif
 #endif
 #endif
+#ifdef __DECCXX
+#pragma define_template Vector<TeXFOTBuilder::Table>
+#else
+#ifdef __xlC__
+#pragma define(Vector<TeXFOTBuilder::Table>)
+#else
+#ifdef SP_ANSI_CLASS_INST
+template class Vector<TeXFOTBuilder::Table>;
+#else
+typedef Vector<TeXFOTBuilder::Table> Dummy_5;
+#endif
+#endif
+#endif
+#ifdef __DECCXX
+#pragma define_template Vector<TeXFOTBuilder::FotElementState>
+#else
+#ifdef __xlC__
+#pragma define(Vector<TeXFOTBuilder::FotElementState>)
+#else
+#ifdef SP_ANSI_CLASS_INST
+template class Vector<TeXFOTBuilder::FotElementState>;
+#else
+typedef Vector<TeXFOTBuilder::FotElementState> Dummy_6;
+#endif
+#endif
+#endif
+#ifdef __DECCXX
+#pragma define_template Vector<OutputByteStream *>
+#else
+#ifdef __xlC__
+#pragma define(Vector<OutputByteStream *>)
+#else
+#ifdef SP_ANSI_CLASS_INST
+template class Vector<OutputByteStream *>;
+#else
+typedef Vector<OutputByteStream *> Dummy_7;
+#endif
+#endif
+#endif
 #ifdef OUTLINES
 #ifdef __DECCXX
 #pragma define_template Vector<TeXFOTBuilder::ParHead>
@@ -93,7 +132,7 @@
 #ifdef SP_ANSI_CLASS_INST
 template class Vector<TeXFOTBuilder::ParHead>;
 #else
-typedef Vector<TeXFOTBuilder::ParHead> Dummy_5;
+typedef Vector<TeXFOTBuilder::ParHead> Dummy_8;
 #endif
 #endif
 #endif
--- openjade-1.4devel1.orig/jade/TeXFOTBuilder_inst.m4
+++ openjade-1.4devel1/jade/TeXFOTBuilder_inst.m4
@@ -15,6 +15,9 @@
 __instantiate(Vector<TeXFOTBuilder::Cell>)
 __instantiate(Vector<TeXFOTBuilder::Column>)
 __instantiate(Vector<TeXFOTBuilder::TablePart>)
+__instantiate(Vector<TeXFOTBuilder::Table>)
+__instantiate(Vector<TeXFOTBuilder::FotElementState>)
+__instantiate(Vector<OutputByteStream *>)
 #ifdef OUTLINES
 __instantiate(Vector<TeXFOTBuilder::ParHead>)
 #endif
--- openjade-1.4devel1.orig/jade/TextFOTBuilder.cxx
+++ openjade-1.4devel1/jade/TextFOTBuilder.cxx
@@ -0,0 +1,954 @@
+// TextFOTBuilder - a formatter for plain text output.
+// Copyright (c) 1999 Avi Kivity
+
+#include <stack>
+#include <stdlib.h>
+#include "config.h"
+#include "TextFOTBuilder.h"
+#include <OpenSP/macros.h>
+#include "dsssl_ns.h"
+
+#ifdef JADE_TEXT
+
+#undef   DBG_TEXT_BACKEND
+#ifndef  DBG_TEXT_BACKEND
+#   define DBG(x) void(0)
+#else
+#   define DBG(x) x
+#   include <iostream.h>
+#endif
+
+#ifdef DSSSL_NAMESPACE
+namespace DSSSL_NAMESPACE {
+#endif
+
+#ifdef DSSSL_NAMESPACE
+    namespace TextBackend {
+#   define TEXTBACKEND_SCOPE TextBackend::
+#else
+#   define TEXTBACKEND_SCOPE
+#endif
+
+#ifdef DBG_TEXT_BACKEND
+class Debugger {
+public:
+  Debugger(const char *func) : context_(func) { indent() << ">> " << context_ << endl; ++level_; }
+  ~Debugger() { --level_; indent() << "<< " << context_ << endl; }
+  ostream& indent() { for (int i = 0; i < level_; ++i) os() << "   "; return os(); }
+  ostream& os() { return cout; }
+private:
+  static int level_;
+  const char* context_;
+};
+
+int Debugger::level_ = 0;
+
+template<class T> ostream& operator << (Debugger& d, const T& v) {
+  return d.indent() << "-- " << v;
+}
+#endif
+
+
+class Uncopyable {
+public:
+  Uncopyable() {}
+private:
+  Uncopyable(const Uncopyable&);     // undefined
+  void operator=(const Uncopyable&); // undefined
+};
+
+class Abstract {
+public:
+  virtual ~Abstract() {}
+};
+
+typedef long Ordinate;
+struct BoundBox {
+  BoundBox() : left(0), right(0), top(0), bottom(0) {}
+  Ordinate left, right, top, bottom;
+};
+
+class LineWidthProvider : Abstract
+{
+public:
+  virtual int& numberOfSpaces() = 0;
+  virtual Ordinate& freeLineWidth() = 0;
+  virtual void nextLine() = 0;
+};
+
+struct TextArea {
+  class Area : Abstract {
+  public:
+    virtual Ordinate width() const = 0;
+    virtual Ordinate height() const = 0;
+    virtual void chars(Ordinate x, Ordinate y, const Char* chars, unsigned n) = 0;
+  };
+  class Page : public Area {
+  public:
+    virtual void flush() = 0;
+  };
+  class RealPage : public Page {
+  public:
+    RealPage(OutputByteStream& os);
+    virtual Ordinate width() const;
+    virtual Ordinate height() const;
+    virtual void chars(Ordinate x, Ordinate y, const Char* chars, unsigned n);
+    virtual void flush();
+  private:
+    Char page_[66][80];
+    OutputByteStream& os_;
+  };
+  class DummyPage : public Page {
+  public:
+    virtual Ordinate width() const;
+    virtual Ordinate height() const;
+    virtual void chars(Ordinate x, Ordinate y, const Char* chars, unsigned n);
+    virtual void flush();
+  };
+  class SubArea : public Area {
+  public:
+    SubArea(Area& container, BoundBox bbox);
+    virtual Ordinate width() const;
+    virtual Ordinate height() const;
+    virtual void chars(Ordinate x, Ordinate y, const Char* chars, unsigned n);
+  private:
+    BoundBox bbox_;
+    Area& area_;
+  };
+  class MeasuredArea : public Area {
+  public:
+    MeasuredArea(Ordinate width, Ordinate max_height = 66);
+    Ordinate measuredWidth() const;
+    Ordinate measuredHeight() const;
+    virtual Ordinate width() const;
+    virtual Ordinate height() const;
+    virtual void chars(Ordinate x, Ordinate y, const Char* chars, unsigned n);
+  private:
+    Ordinate width_;
+    Ordinate height_;
+    Ordinate measuredHeight_;
+    Ordinate measuredWidth_;
+  };
+  class PageFactory : Abstract {
+  public:
+    virtual Page* create() const = 0;
+  };
+  class RealPageFactory : public PageFactory {
+  public:
+    RealPageFactory(OutputByteStream* os) : os_(os) {}
+    virtual Page* create() const { return new RealPage(*os_); }
+  private:
+    OutputByteStream* os_;
+  };
+  class DummyPageFactory : public PageFactory {
+  public:
+    virtual Page* create() const { return new DummyPage; }
+  };
+};
+
+const double xCellSize = (1.0/80)*6.5*72000;
+
+Ordinate
+length2xordinate(Ordinate displaySize, const FOTBuilder::LengthSpec& ls)
+{
+  return ls.length / xCellSize + ls.displaySizeFactor * displaySize;
+}
+
+Ordinate
+length2xordinate(TextArea::Area& area, const FOTBuilder::LengthSpec& ls)
+{
+  return length2xordinate(area.width(), ls);
+}
+
+class TextFOTBuilder
+: Uncopyable, public FOTBuilder
+{
+public:
+  TextFOTBuilder(TextArea::PageFactory& pageFactory, LineWidthProvider& lineWidthProvider);
+  ~TextFOTBuilder();
+private:
+  virtual void startSimplePageSequence(FOTBuilder* headerFooter[nHF]);
+  virtual void endSimplePageSequenceHeaderFooter();
+  virtual void endSimplePageSequence();
+  virtual void startParagraph(const ParagraphNIC &);
+  virtual void endParagraph();
+  virtual void characters(const Char *, size_t);
+  virtual void setQuadding(Symbol);
+  virtual void setStartIndent(const LengthSpec &);
+  virtual void setEndIndent(const LengthSpec &);
+  virtual void setFirstLineStartIndent(const LengthSpec &);
+public:
+  struct Style {
+    Style();
+    Symbol quadding;
+    LengthSpec startIndent;
+    LengthSpec endIndent;
+    LengthSpec firstLineStartIndent;
+  };
+  struct Model {
+    struct Generated {
+      Generated() : height(0), height_specified(0) {}
+      SaveFOTBuilder content;
+      Ordinate height;
+      Boolean height_specified;
+    };
+    struct Region {
+      Generated header;
+      Generated footer;
+      BoundBox  boundBox;  
+    };
+    struct PageModel {
+      PageModel() : principalRegion(0) {}
+      Vector<Region> regions;
+      size_t principalRegion;
+    };
+    struct PageSequence {
+      Vector<PageModel> initial;
+      Vector<PageModel> repeat;
+    };
+  };
+  struct Output {
+    class FlowPort : Abstract {
+    public:
+      // can be defined in terms of next function
+      virtual Ordinate currentWidth() const = 0;
+      virtual void chars(Ordinate x, const Char* chars, unsigned n) = 0;
+      virtual void verticalSpace(Ordinate height) = 0;
+    };
+    class ParaBuilder : Abstract {
+    public:
+      virtual void chars(const Char* chars, unsigned n) = 0;
+      virtual void pbreak() = 0;
+    };
+    class NestedParaBuilder : public ParaBuilder {
+    public:  
+      virtual void chars(const Char* chars, unsigned n);
+      virtual void pbreak();
+      void push(ParaBuilder* inner);
+      void pop();
+      ParaBuilder* top();
+    private:
+      Vector<ParaBuilder*> stack_;
+    };
+    class FlowParaBuilder : public ParaBuilder {
+    public:
+      FlowParaBuilder(FlowPort& flow, TextFOTBuilder& fotb);
+      ~FlowParaBuilder();
+      virtual void chars(const Char* chars, unsigned n);
+      virtual void pbreak();
+    private:
+      void allocLine();
+      void flushLine();
+      Ordinate currentWidth();
+      LengthSpec currentStartIndent();
+    private:
+      FlowPort& flow_;
+      TextFOTBuilder& fotb_;
+      Ordinate x_;
+      Ordinate limit_;
+      Ordinate offset_;
+      Boolean isFirstLine_;
+    };
+    class AreaFlowPort : public FlowPort {
+    public:
+      AreaFlowPort(TextArea::Area& area);
+      virtual Ordinate currentWidth() const;
+      virtual void chars(Ordinate x, const Char* chars, unsigned n);
+      virtual void verticalSpace(Ordinate height);
+    private:
+      TextArea::Area& area_;
+      Ordinate y_;
+    };
+    class PageSeqFlowPort : public FlowPort {
+    public:
+      PageSeqFlowPort(TextFOTBuilder& fotb, Model::PageSequence model);
+      ~PageSeqFlowPort();
+      virtual Ordinate currentWidth() const;
+      virtual void chars(Ordinate x, const Char* chars, unsigned n);
+      virtual void verticalSpace(Ordinate height);
+    private:
+      const TextArea::Area* getArea() const;
+      TextArea::Area* getArea();
+      TextArea::Area* createPrinicipalArea(TextArea::Area& page);
+    private:
+      TextFOTBuilder& fotb_;
+      TextArea::PageFactory& pageFactory_;
+      Vector<TextArea::Page*> output_;
+      TextArea::Area* currentArea_;
+      Model::PageSequence model_;
+      Ordinate y_;
+    };
+  };
+public:
+  Ordinate measureGenerated(const Model::Generated& gen, const TextArea::Area& area);
+  Ordinate quaddingOffset(Symbol quadding, Ordinate freeLineWidth);
+  const Style& style() const { return styleStack_.top(); }
+  Style& style()             { return styleStack_.top(); }
+  virtual void start();
+  virtual void end();
+public:
+  TextArea::PageFactory& pageFactory_;
+  LineWidthProvider& lineWidthProvider_;
+  FOTBuilder bitBucket_;
+  Output::FlowPort* principalPort_;
+  Output::NestedParaBuilder* para_;
+  SaveFOTBuilder* spsHF;
+  std::stack<Style> styleStack_;
+  Style style_;
+};
+
+Ordinate 
+length2xordinate(const TextFOTBuilder::Output::FlowPort& flow, const FOTBuilder::LengthSpec& ls) 
+{
+  return length2xordinate(flow.currentWidth(), ls);
+}
+
+TextFOTBuilder::Style::Style()
+: quadding ( symbolStart )
+{
+}
+
+TextFOTBuilder::TextFOTBuilder(TextArea::PageFactory& pageFactory, LineWidthProvider& lineWidthProvider)
+: pageFactory_(pageFactory)
+, lineWidthProvider_(lineWidthProvider)
+, para_(new Output::NestedParaBuilder)
+, principalPort_(0)
+{
+  styleStack_.push(Style());
+}
+
+TextFOTBuilder::~TextFOTBuilder()
+{
+  delete para_;
+}
+ 
+void 
+TextFOTBuilder::startSimplePageSequence(FOTBuilder* headerFooter[nHF]) 
+{
+  DBG(Debugger dbg("TextFOTBuilder::startSimplePageSequence()"));
+  start();
+  // FIXME: check PagePointer != 0
+  spsHF = new SaveFOTBuilder[nHF];
+  for (int i = 0; i < nHF; ++i)
+    headerFooter[i] = &spsHF[i];
+}
+
+void 
+TextFOTBuilder::endSimplePageSequenceHeaderFooter()
+{
+  DBG(Debugger dbg("TextFOTBuilder::endSimplePageSequenceHeaderFooter()"));
+  Model::PageSequence ps;
+  Model::PageModel pm;
+  Model::Region r;
+  r.boundBox.left = 0;
+  r.boundBox.right = 80;
+  r.boundBox.top = 0;
+  r.boundBox.bottom = 66;
+  pm.regions.push_back(r);
+  ps.repeat.push_back(pm);
+  HF lcr[3] = { leftHF, centerHF, rightHF };
+  HF hf[2] = { headerHF, footerHF };
+  Symbol quadding[3] = { symbolStart, symbolCenter, symbolEnd };
+  Model::Generated (Model::Region::*gen[2]) 
+    = { &Model::Region::header, &Model::Region::footer };
+  for (int i = 0; i < 2; ++i) {
+    Model::Generated& g = ps.repeat[0].regions[0].*(gen[i]);
+    g.content.startSideBySide(DisplayNIC());
+    for ( unsigned j = 0; j < 3; ++j ) {
+      g.content.startSideBySideItem();
+      g.content.setQuadding(quadding[j]);
+      g.content.startParagraph(ParagraphNIC());
+      spsHF[hf[i] | lcr[j] | firstHF | otherHF].emit(g.content);
+      g.content.endParagraph();
+      g.content.endSideBySideItem();
+    }
+    g.content.endSideBySide();
+  }
+  principalPort_ = new Output::PageSeqFlowPort(*this, ps);
+}
+
+void 
+TextFOTBuilder::endSimplePageSequence()
+{
+  DBG(Debugger dbg("TextFOTBuilder::endSimplePageSequence()"));
+  delete principalPort_;
+  principalPort_ = 0;
+  end();
+}
+
+void 
+TextFOTBuilder::startParagraph(const ParagraphNIC &)
+{
+  DBG(Debugger dbg("TextFOTBuilder::startParagraph()"));
+  start();
+  para_->push(new Output::FlowParaBuilder(*principalPort_, *this));
+}
+ 
+void 
+TextFOTBuilder::endParagraph()
+{
+  DBG(Debugger dbg("TextFOTBuilder::endParagraph()"));
+  delete para_->top();
+  para_->pop();
+  end();
+}
+  
+void 
+TextFOTBuilder::characters(const Char* chars, size_t n)
+{
+  atomic();
+  DBG(Debugger dbg("TextFOTBuilder::characters()"));
+  DBG(dbg << "data = \"");
+  DBG(for (size_t i = 0; i<n; ++i) dbg.os() << char(chars[i]));
+  DBG(dbg.os() << "\"" << endl);
+  para_->chars(chars, n);
+}
+
+TextArea::RealPage::RealPage(OutputByteStream& os)
+: os_(os)
+{
+  DBG(Debugger dbg("TextArea::RealPage::RealPage()"));
+  for (unsigned y = 0; y < height(); ++y)
+    for (unsigned x = 0; x < width(); ++x)
+      page_[y][x] = ' ';
+}
+
+Ordinate 
+TextArea::RealPage::width() const
+{
+  return 80;
+}
+
+Ordinate 
+TextArea::RealPage::height() const
+{
+  return 66;
+}
+
+void 
+TextArea::RealPage::chars(Ordinate x, Ordinate y, const Char* chars, unsigned n)
+{
+  DBG(Debugger dbg("TextArea::RealPage::chars()"));
+  DBG(dbg << "x = " << x << ", y = " << y << endl);
+  for (unsigned i = 0; i < n; ++i) 
+    page_[y][x+i] = chars[i];
+}
+
+void 
+TextArea::RealPage::flush()
+{
+  DBG(Debugger dbg("TextArea::RealPage::flush()"));
+  for (Ordinate y = 0; y < height(); ++y) {
+    Ordinate end = width();
+    while (end > 0 && page_[y][end-1] == ' ')
+      --end;
+    for (Ordinate x = 0; x < end; ++x)
+      os_.sputc(char(page_[y][x])); // hope for ascii
+    os_.sputc('\n');
+  }
+  os_.sputc('\f');
+}
+
+Ordinate 
+TextArea::DummyPage::width() const
+{
+  return 80;
+}
+
+Ordinate 
+TextArea::DummyPage::height() const
+{
+  return 66;
+}
+
+void 
+TextArea::DummyPage::chars(Ordinate x, Ordinate y, const Char* chars, unsigned n)
+{
+  DBG(Debugger dbg("TextArea::DummyPage::chars()"));
+  DBG(dbg << "x = " << x << ", y = " << y << endl);
+}
+
+void 
+TextArea::DummyPage::flush()
+{
+}
+
+TextArea::SubArea::SubArea(Area& container, BoundBox bbox)
+: bbox_(bbox)
+, area_(container)
+{
+}
+
+Ordinate 
+TextArea::SubArea::width() const
+{
+  return bbox_.right - bbox_.left;
+}
+
+Ordinate 
+TextArea::SubArea::height() const
+{
+  return bbox_.bottom - bbox_.top;
+}
+
+void 
+TextArea::SubArea::chars(Ordinate x, Ordinate y, const Char* chars, unsigned n)
+{
+  area_.chars(x+bbox_.left, y+bbox_.top, chars, n);
+}
+
+TextArea::MeasuredArea::MeasuredArea(Ordinate width, Ordinate max_height)
+: width_(width)
+, height_(max_height)
+, measuredHeight_(0)
+, measuredWidth_(0)
+{
+}
+
+Ordinate 
+TextArea::MeasuredArea::measuredHeight() const
+{
+  return measuredHeight_;
+}
+
+Ordinate 
+TextArea::MeasuredArea::measuredWidth() const
+{
+  return measuredWidth_;
+}
+
+Ordinate 
+TextArea::MeasuredArea::height() const
+{
+  return height_;
+}
+
+Ordinate 
+TextArea::MeasuredArea::width() const
+{
+  return width_;
+}
+                      
+template <class T>
+const T&
+stdmax(const T& a, const T& b) {
+  return a < b ? b : a;
+}
+                      
+                      
+void 
+TextArea::MeasuredArea::chars(Ordinate x, Ordinate y, const Char* chars, unsigned n)
+{
+  measuredHeight_ = stdmax(Ordinate(y+1), measuredHeight_);
+  measuredWidth_ = stdmax(Ordinate(x+n), measuredWidth_);
+}
+
+TextFOTBuilder::Output::FlowParaBuilder::FlowParaBuilder(FlowPort& flow, TextFOTBuilder& fotb)
+: flow_(flow)
+, fotb_(fotb)
+, x_(0)
+, limit_(0)
+, isFirstLine_(1)
+{
+  DBG(Debugger dbg("TextFOTBuilder::Output::FlowParaBuilder::FlowParaBuilder()"));
+}
+
+TextFOTBuilder::Output::FlowParaBuilder::~FlowParaBuilder()
+{
+  DBG(Debugger dbg("TextFOTBuilder::Output::FlowParaBuilder::~FlowParaBuilder()"));
+  flushLine();
+}
+
+TextFOTBuilder::LengthSpec
+TextFOTBuilder::Output::FlowParaBuilder::currentStartIndent() 
+{
+  LengthSpec result; // why not operator +?
+  result.length = fotb_.style().startIndent.length 
+                + isFirstLine_ * fotb_.style().firstLineStartIndent.length;
+  result.displaySizeFactor = fotb_.style().startIndent.displaySizeFactor 
+                + isFirstLine_ * fotb_.style().firstLineStartIndent.displaySizeFactor;
+  return result;
+}
+
+Ordinate
+TextFOTBuilder::Output::FlowParaBuilder::currentWidth()
+{
+  return flow_.currentWidth() 
+       - length2xordinate(flow_, currentStartIndent())
+       - length2xordinate(flow_, fotb_.style().endIndent);
+}
+
+void
+TextFOTBuilder::Output::FlowParaBuilder::allocLine()
+{
+  DBG(Debugger dbg("TextFOTBuilder::Output::FlowParaBuilder::allocLine()"));
+  x_ = 0;
+  currentWidth(); // Ensure there is an area allocated. FIXME.
+  fotb_.lineWidthProvider_.nextLine();
+  limit_ = currentWidth() - fotb_.lineWidthProvider_.freeLineWidth();
+  offset_ = length2xordinate(flow_, currentStartIndent())
+    + fotb_.quaddingOffset(fotb_.style().quadding, currentWidth() - limit_);
+  DBG(dbg << "limit = " << limit_ << "; setting quadding offset at " << offset_ << endl);
+}
+
+void
+TextFOTBuilder::Output::FlowParaBuilder::flushLine()
+{
+  DBG(Debugger dbg("TextFOTBuilder::Output::FlowParaBuilder::flushLine()"));
+  if (x_ > 0) {
+    DBG(Debugger dbg("flushLine active"));
+    flow_.verticalSpace(1);
+    fotb_.lineWidthProvider_.freeLineWidth() = limit_ - x_;
+  }
+  x_ = limit_ = 0;
+  isFirstLine_ = 0;
+}
+
+void
+TextFOTBuilder::Output::FlowParaBuilder::chars(const Char* chars, unsigned n)
+{
+  DBG(Debugger dbg("TextFOTBuilder::Output::FlowParaBuilder::chars()"));
+  // break lines rather tastelessly.
+  while (n > 0) {
+    if (x_ >= limit_)
+      allocLine();
+    size_t done = limit_ - x_;
+    if (done > n)
+      done = n;
+    flow_.chars(offset_ + x_, chars, done);
+    x_ += done;
+    n -= done;
+    chars += done;
+    if (x_ == limit_)
+      flushLine();
+  }
+}
+
+void
+TextFOTBuilder::Output::FlowParaBuilder::pbreak()
+{
+  flushLine();
+}
+
+void
+TextFOTBuilder::Output::NestedParaBuilder::chars(const Char* chars, unsigned n)
+{
+  if (stack_.size() == 0)
+      CANNOT_HAPPEN();
+  top()->chars(chars, n);
+}
+
+void
+TextFOTBuilder::Output::NestedParaBuilder::pbreak()
+{
+  if (stack_.size() == 0)
+      CANNOT_HAPPEN();
+  top()->pbreak();
+}
+
+void
+TextFOTBuilder::Output::NestedParaBuilder::push(ParaBuilder* inner)
+{
+  if (stack_.size())
+    top()->pbreak();
+  stack_.push_back(inner);
+}
+
+void 
+TextFOTBuilder::Output::NestedParaBuilder::pop()
+{
+  stack_.erase(stack_.begin() + stack_.size()-1, stack_.begin() + stack_.size());
+}
+
+TextFOTBuilder::Output::ParaBuilder*
+TextFOTBuilder::Output::NestedParaBuilder::top()
+{
+  return stack_.back();
+}
+
+TextFOTBuilder::Output::AreaFlowPort::AreaFlowPort(TextArea::Area& area)
+: area_ ( area )
+, y_ ( 0 )
+{
+}
+
+Ordinate 
+TextFOTBuilder::Output::AreaFlowPort::currentWidth() const
+{
+  return area_.width();
+}
+
+void 
+TextFOTBuilder::Output::AreaFlowPort::chars(Ordinate x, const Char* chars, unsigned n)
+{
+  DBG(Debugger dbg("TextFOTBuilder::Output::AreaFlowPort::chars()"));
+  area_.chars(x, y_, chars, n);
+}
+
+void 
+TextFOTBuilder::Output::AreaFlowPort::verticalSpace(Ordinate height)
+{   
+  y_ += height;
+}
+
+TextFOTBuilder::Output::PageSeqFlowPort::PageSeqFlowPort
+  (TextFOTBuilder& fotb, Model::PageSequence model)
+: fotb_(fotb)
+, pageFactory_(fotb.pageFactory_)
+, model_(model)
+, currentArea_(0)
+, y_(0)
+{
+}
+
+TextFOTBuilder::Output::PageSeqFlowPort::~PageSeqFlowPort()
+{
+  for (unsigned i = 0; i < output_.size(); ++i) {
+    output_[i]->flush();
+    delete output_[i];
+  }
+}
+
+TextArea::Area*
+TextFOTBuilder::Output::PageSeqFlowPort::getArea()
+{
+  if (!currentArea_ || (y_+1 >= currentArea_->height())) {
+    DBG(Debugger dbg("TextFOTBuilder::Output::PageSeqFlowPort::getArea()"));
+    DBG(dbg << "Creating a new page." << endl);
+    output_.push_back(pageFactory_.create());
+    currentArea_ = createPrinicipalArea(*output_.back());
+    y_ = 0;
+  }
+  return currentArea_;
+}
+
+const TextArea::Area*
+TextFOTBuilder::Output::PageSeqFlowPort::getArea() const
+{
+  return const_cast<PageSeqFlowPort*>(this)->getArea();
+}
+
+
+TextArea::Area*
+TextFOTBuilder::Output::PageSeqFlowPort::createPrinicipalArea(TextArea::Area& page)
+{
+  DBG(Debugger dbg("TextFOTBuilder::Output::PageSeqFlowPort::createPrinicipalArea()"));
+  FlowPort* save = fotb_.principalPort_;
+  TextFOTBuilder::Output::NestedParaBuilder* save_para = fotb_.para_;
+  fotb_.para_ = new NestedParaBuilder;
+  DBG(dbg << "Measuring header" << endl);
+  Ordinate headerHeight = fotb_.measureGenerated(model_.repeat[0].regions[0].header, page);
+  DBG(dbg << "Measuring footer" << endl);
+  Ordinate footerHeight = fotb_.measureGenerated(model_.repeat[0].regions[0].footer, page);
+  DBG(dbg << "header = " << headerHeight << ", footer = " << footerHeight << endl);
+
+  BoundBox bbox;
+  bbox.left = 0;
+  bbox.right = page.width();
+
+  DBG(dbg << "Emitting header" << endl);
+  bbox.top = 0;
+  bbox.bottom = headerHeight;
+  TextArea::SubArea header(page, bbox);
+  Output::AreaFlowPort fp_h(header);
+  fotb_.principalPort_ = &fp_h;
+  model_.repeat[0].regions[0].header.content.emit(fotb_);
+  
+  DBG(dbg << "Emitting footer" << endl);
+  bbox.top = page.height() - footerHeight;
+  bbox.bottom = page.height();
+  TextArea::SubArea footer(page, bbox);
+  Output::AreaFlowPort fp_f(footer);
+  fotb_.principalPort_ = &fp_f;
+  model_.repeat[0].regions[0].footer.content.emit(fotb_);
+  
+  DBG(dbg << "Creating principal port subarea" << endl);
+  delete fotb_.para_;
+  fotb_.para_ = save_para;
+  fotb_.principalPort_ = save;
+  bbox.top = headerHeight;
+  bbox.bottom = page.height() - footerHeight;
+  return new TextArea::SubArea(page, bbox);
+}
+
+Ordinate
+TextFOTBuilder::measureGenerated(const Model::Generated& g, const TextArea::Area& p)
+{
+  Output::FlowPort* save = principalPort_;
+  TextArea::MeasuredArea ma ( p.width(), p.height() );
+  Output::AreaFlowPort fp ( ma );
+  principalPort_ = &fp;
+  g.content.emit(*this);
+  Ordinate height = ma.measuredHeight();
+  principalPort_ = save;
+  return height;
+}
+
+Ordinate 
+TextFOTBuilder::Output::PageSeqFlowPort::currentWidth() const
+{
+  return getArea()->width();
+}
+
+void 
+TextFOTBuilder::Output::PageSeqFlowPort::chars(Ordinate x, const Char* chars, unsigned n)
+{
+  DBG(Debugger dbg("TextFOTBuilder::Output::PageSeqFlowPort::chars()"));
+  getArea()->chars(x, y_, chars, n);
+}
+
+void  
+TextFOTBuilder::Output::PageSeqFlowPort::verticalSpace(Ordinate height)
+{
+  y_ += height;
+}
+
+void 
+TextFOTBuilder::setQuadding(Symbol quadding)
+{
+  style_.quadding = quadding;
+}
+
+void 
+TextFOTBuilder::setStartIndent(const LengthSpec& l)
+{
+  style_.startIndent = l;
+}
+void 
+TextFOTBuilder::setEndIndent(const LengthSpec& l)
+{
+  style_.endIndent = l;
+}
+
+void 
+TextFOTBuilder::setFirstLineStartIndent(const LengthSpec& l)
+{
+  style_.firstLineStartIndent = l;
+}
+
+void 
+TextFOTBuilder::start()
+{
+  styleStack_.push(style_);
+}
+
+void 
+TextFOTBuilder::end()
+{
+  styleStack_.pop();
+  style_ = styleStack_.top();
+}
+
+Ordinate
+TextFOTBuilder::quaddingOffset(Symbol quadding, long freeLineWidth)
+{
+  switch (quadding)
+  {
+  case symbolStart: return 0;
+  case symbolCenter: return freeLineWidth/2;
+  case symbolEnd: return freeLineWidth;
+  }
+  return 0;
+}
+
+class LineWidthCache
+{
+public:
+  LineWidthCache() : fill_(cache_), use_() {}
+  LineWidthProvider& fill() { return fill_; }
+  LineWidthProvider& use()  { use_.reset(cache_); return use_; }
+private:
+  struct Entry {
+    Entry() : nspaces(0), width(0) {}
+    int nspaces;
+    Ordinate width;
+  };
+  class Fill : public LineWidthProvider {
+  public:
+    Fill(Vector<Entry>& cache) : cache_(cache) { nextLine(); }
+    virtual int& numberOfSpaces() { return cache_.back().nspaces; }
+    virtual Ordinate& freeLineWidth() { return cache_.back().width; }
+    virtual void nextLine() { cache_.push_back(Entry()); }
+  private:
+    Vector<Entry>& cache_;
+  };
+  class Use : public LineWidthProvider {
+  public:
+    virtual int& numberOfSpaces() { return (*line_).nspaces; }
+    virtual Ordinate& freeLineWidth() { return (*line_).width; }
+    virtual void nextLine() { ++line_; }
+    void reset(Vector<Entry>& cache) { line_ = cache.begin(); }
+  private:
+    Vector<Entry>::iterator line_;
+  };
+private:
+  Vector<Entry> cache_;
+  Fill fill_;
+  Use  use_;
+  friend class Fill;
+  friend class Use;
+};
+
+class MultipassTextFOTBuilder
+: Uncopyable, public SaveFOTBuilder
+{
+public:
+  MultipassTextFOTBuilder(OutputByteStream* os);
+  ~MultipassTextFOTBuilder();
+private:
+  void process();
+private:
+  OutputByteStream* os_;
+};
+
+MultipassTextFOTBuilder::MultipassTextFOTBuilder(OutputByteStream* os)
+: os_(os) 
+{
+}
+
+MultipassTextFOTBuilder::~MultipassTextFOTBuilder()
+{
+  process();
+}
+
+void 
+MultipassTextFOTBuilder::process()
+{
+  DBG(Debugger dbg("MultipassTextFOTBuilder::process()"));
+  DBG(dbg << "Measurement pass" << endl);
+  LineWidthCache lwc;
+  TextArea::DummyPageFactory nooutput;
+  TextFOTBuilder pass1(nooutput, lwc.fill());
+  emit(pass1);
+  DBG(dbg << "Output pass" << endl);
+  TextArea::RealPageFactory output(os_);
+  TextFOTBuilder pass2(output, lwc.use());
+  emit(pass2);
+}
+
+#ifdef DSSSL_NAMESPACE
+} // namespace TextBackend
+#endif
+
+FOTBuilder *makeTextFOTBuilder(OutputByteStream* os, Messenger *,
+			      const FOTBuilder::Description *&descr)
+{
+  static const FOTBuilder::Feature features[] = {
+    { "simple-page", 0},
+    { 0, 0}
+  };
+  static const FOTBuilder::Description description = {
+    0, // Extensions
+    features,
+    false
+  };
+  descr = &description;
+
+  return new TEXTBACKEND_SCOPE MultipassTextFOTBuilder(os);
+}
+
+#ifdef DSSSL_NAMESPACE
+}
+#endif
+
+#endif /* JADE_TEXT */
--- openjade-1.4devel1.orig/jade/TextFOTBuilder.h
+++ openjade-1.4devel1/jade/TextFOTBuilder.h
@@ -0,0 +1,22 @@
+// Copyright (c) 1999 Avi Kivity
+
+#ifndef TextFOTBuilder__H_INCLUDED
+#define TextFOTBuilder__H_INCLUDED
+
+#include <OpenSP/OutputByteStream.h>
+#include "FOTBuilder.h"
+#include <OpenSP/Message.h>
+
+#ifdef DSSSL_NAMESPACE
+namespace DSSSL_NAMESPACE {
+#endif
+
+FOTBuilder *makeTextFOTBuilder(OutputByteStream *, Messenger *,
+			      const FOTBuilder::Description *&);
+
+#ifdef DSSSL_NAMESPACE
+}
+#endif
+
+
+#endif
--- openjade-1.4devel1.orig/jade/TransformFOTBuilder.cxx
+++ openjade-1.4devel1/jade/TransformFOTBuilder.cxx
@@ -388,19 +388,32 @@
   for (size_t i = 0; i < atts.size(); i += 2) {
     os() << SP_ << atts[i] << '=';
     const StringC &s = atts[i + 1];
-    if (!contains(s, '"'))
-      os() << '"' << s << '"';
-    else if (!contains(s, '\''))
-      os() << '\'' << s << '\'';
-    else {
-      os() << '"';
-      for (size_t j = 0; j < s.size(); j++) {
+    char quoteChar = 0;
+
+    if (!contains(s, '&'))
+      if (!contains(s, '"'))
+        quoteChar = '"';
+      else if (!contains(s, '\''))
+        quoteChar = '\'';
+    
+    if (quoteChar)
+      os() << quoteChar << s << quoteChar;
+     else {
+       os() << '"';
+       for (size_t j = 0; j < s.size(); j++) {
         if (s[j] == '"') {
 	  if (xml_)
-	    os() << "&quot;";
-	  else
-	    outputNumericCharRef(os(), '"');
-	}
+             os() << "&quot;";
+           else
+             outputNumericCharRef(os(), '"');
+        }
+        else
+        if (s[j] == '&') {
+          if (xml_)
+            os() << "&amp;";
+          else
+            outputNumericCharRef(os(), '&');
+        }
         else
           os().put(s[j]);
       }
--- openjade-1.4devel1.orig/jadedist/bin-files.txt
+++ openjade-1.4devel1/jadedist/bin-files.txt
@@ -0,0 +1,83 @@
+NEWS
+doc\archform.htm
+doc\build.htm
+doc\catalog.htm
+doc\charset.htm
+doc\features.htm
+doc\generic.htm
+doc\ideas.htm
+doc\index.htm
+doc\new.htm
+doc\nsgmls.htm
+doc\sgmldecl.htm
+doc\sgmlnorm.htm
+doc\sgmlsout.htm
+doc\spam.htm
+doc\spent.htm
+doc\sx.htm
+doc\sysdecl.htm
+doc\sysid.htm
+doc\xml.htm
+doc\xmlwarn.htm
+dsssl\builtins.dsl
+dsssl\extensions.dsl
+dsssl\style-sheet.dtd
+dsssl\spec.dtd
+dsssl\fot.dtd
+dsssl\dsssl.dtd
+dsssl\demo.sgm
+dsssl\demo.dsl
+dsssl\catalog
+dsssl\jadetex.dtx
+dsssl\jadetex.ini
+dsssl\jadetex.ins
+dsssl\pdfjadetex.ini
+dsssl\Makefile.jadetex
+bin\sp133.dll
+bin\style.dll
+bin\spgrove.dll
+bin\grove.dll
+bin\groveoa.dll
+bin\jade.exe
+bin\nsgmls.exe
+bin\spam.exe
+bin\sgmlnorm.exe
+bin\spent.exe
+bin\sx.exe
+bin\spcat.exe
+bin\MSVCRT.DLL
+jadedoc/autoconf.htm
+jadedoc/contributors.htm
+jadedoc/copying.txt
+jadedoc/dsssl2.htm
+jadedoc/index.htm
+jadedoc/mif.htm
+jadedoc/rtf.htm
+jadedoc/tex.htm
+jadedoc/transform.htm
+jadedoc/xmlfo.htm
+jadedoc/images/background.gif
+jadedoc/images/dsssltitle.gif
+jadedoc/images/space.gif
+jadedoc/images/top-of-page.gif
+pubtext\ISOlat1.ent
+pubtext\ISOlat1.sgm
+pubtext\html.soc
+pubtext\html-1.dtd
+pubtext\html-1s.dtd
+pubtext\html-s.dtd
+pubtext\html.dcl
+pubtext\html.dtd
+pubtext\HTML32.dcl
+pubtext\HTML32.dtd
+pubtext\HTML32.soc
+pubtext\HTML4.dcl
+pubtext\HTML4-s.dtd
+pubtext\HTML4.dtd
+pubtext\HTML4-f.dtd
+pubtext\HTML4.soc
+pubtext\HTMLlat1.ent
+pubtext\HTMLspec.ent
+pubtext\HTMLsym.ent
+pubtext\xml.dcl
+pubtext\xml.soc
--- openjade-1.4devel1.orig/jadedist/files.txt
+++ openjade-1.4devel1/jadedist/files.txt
@@ -0,0 +1,196 @@
+grove/LocNode.h
+grove/LocNode.cxx
+grove/Node.h
+grove/Node.cxx
+groveoa/CGroveBuilder.cxx
+groveoa/CGroveBuilder.h
+groveoa/GroveBuilder.rgs
+groveoa/GroveNode.cxx
+groveoa/GroveNode.h
+groveoa/StdAfx.cxx
+groveoa/StdAfx.h
+groveoa/groveoa.cxx
+groveoa/groveoa.def
+groveoa/groveoa.dsp
+groveoa/groveoa.idl
+groveoa/groveoa.rc
+groveoa/resource.h
+spgrove/GroveApp.h
+spgrove/GroveBuilder.h
+spgrove/SdNode.cxx
+spgrove/SdNode.h
+spgrove/threads.h
+style/charNames.h
+style/Collector.h
+style/DocumentGenerator.h
+style/DssslApp.h
+style/DssslSpecEventHandler.h
+style/dsssl_ns.h
+style/ELObj.h
+style/ELObjMessageArg.h
+style/ELObjPropVal.h
+style/EvalContext.h
+style/Expression.h
+style/FOTBuilder.h
+style/GroveManager.h
+style/Insn.h
+style/Insn2.h
+style/Interpreter.h
+style/InterpreterMessages.h
+style/jade_version.h
+style/LangObj.h
+style/MacroFlowObj.h
+style/NumberCache.h
+style/primitive.h
+style/Pattern.h
+style/ProcessContext.h
+style/ProcessingMode.h
+style/SchemeParser.h
+style/sdata.h
+style/SosofoObj.h
+style/Style.h
+style/StyleEngine.h
+style/stylelib.h
+style/style_pch.h
+style/VM.h
+style/Collector.cxx
+style/DocumentGenerator.cxx
+style/DssslApp.cxx
+style/DssslSpecEventHandler.cxx
+style/ELObj.cxx
+style/ELObjMessageArg.cxx
+style/Expression.cxx
+style/FOTBuilder.cxx
+style/GroveManager.cxx
+style/Insn.cxx
+style/Interpreter.cxx
+style/InterpreterMessages.cxx
+style/LangObj.cxx
+style/MacroFlowObj.cxx
+style/NumberCache.cxx
+style/primitive.cxx
+style/primitive_inst.cxx
+style/primitive_inst.m4
+style/Pattern.cxx
+style/ProcessContext.cxx
+style/ProcessingMode.cxx
+style/SchemeParser.cxx
+style/Style.cxx
+style/StyleEngine.cxx
+style/stylelib.cxx
+style/style_inst.cxx
+spgrove/GroveApp.cxx
+spgrove/GroveBuilder.cxx
+spgrove/grove_inst.cxx
+spgrove/grove_inst.m4
+style/style_inst.m4
+style/DssslAppMessages.h
+style/DssslAppMessages.msg
+style/DssslAppMessages.rc
+style/InterpreterMessages.msg
+style/InterpreterMessages.rc
+style/FlowObj.cxx
+style/InheritedC.cxx
+style/FlowObj_inst.m4
+style/FlowObj_inst.cxx
+style/common_inst.m4
+style/common_inst.cxx
+grove/Makefile.sub
+grove/grove.dsp
+spgrove/Makefile.sub
+spgrove/spgrove.dsp
+style/Makefile.sub
+style/style.dsp
+jade/jade.cxx
+jade/Makefile.sub
+jade/jade.dsp
+all/all.dsp
+jade/RtfFOTBuilder.cxx
+jade/RtfFOTBuilder.h
+jade/SgmlFOTBuilder.cxx
+jade/SgmlFOTBuilder.h
+jade/TransformFOTBuilder.cxx
+jade/TransformFOTBuilder.h
+jade/TransformFOTBuilder_inst.cxx
+jade/TransformFOTBuilder_inst.m4
+jade.mak
+jade.dsw
+dsssl/demo.dsl
+dsssl/demo.sgm
+dsssl/style-sheet.dtd
+dsssl/spec.dtd
+dsssl/dsssl.dtd
+dsssl/builtins.dsl
+dsssl/extensions.dsl
+dsssl/fot.dtd
+dsssl/catalog
+dsssl/jadetex.dtx
+dsssl/jadetex.ini
+dsssl/jadetex.ins
+dsssl/pdfjadetex.ini
+dsssl/Makefile.jadetex
+jade/HtmlFOTBuilder.cxx
+jade/HtmlFOTBuilder.h
+jade/HtmlFOTBuilder_inst.cxx
+jade/HtmlFOTBuilder_inst.m4
+jade/JadeMessages.msg
+jade/JadeMessages.h
+jade/JadeMessages.rc
+jade/jade.rc
+jade/HtmlMessages.h
+jade/HtmlMessages.msg
+jade/HtmlMessages.rc
+jade/RtfFOTBuilder_inst.cxx
+jade/RtfFOTBuilder_inst.m4
+jade/RtfMessages.h
+jade/RtfMessages.msg
+jade/RtfMessages.rc
+jade/RtfOle.cxx
+jade/RtfOle.h
+jade/TeXFOTBuilder.cxx
+jade/TeXFOTBuilder.h
+jade/TeXFOTBuilder_inst.cxx
+jade/TeXFOTBuilder_inst.m4
+jade/TeXMessages.h
+jade/TeXMessages.msg
+jade/TeXMessages.rc
+jade/TmpOutputByteStream.h
+jade/MifFOTBuilder.cxx
+jade/MifFOTBuilder.h
+jade/MifFOTBuilder_inst.cxx
+jade/MifFOTBuilder_inst.m4
+jade/MifMessages.h
+jade/MifMessages.msg
+jade/MifMessages.rc
+jadedoc/autoconf.htm
+jadedoc/contributors.htm
+jadedoc/copying.txt
+jadedoc/dsssl2.htm
+jadedoc/index.htm
+jadedoc/mif.htm
+jadedoc/rtf.htm
+jadedoc/tex.htm
+jadedoc/transform.htm
+jadedoc/xmlfo.htm
+jadedoc/images/background.gif
+jadedoc/images/dsssltitle.gif
+jadedoc/images/space.gif
+jadedoc/images/top-of-page.gif
+jadedist/bin-files.txt
+jadedist/files.txt
+jadedist/makedist.bat
+jadedist/jadedist.dsp
+jade-generate.mak
+Makefile.comm.in
+Makefile.in
+Makefile.lib.in
+Makefile.prog.in
+NEWS
+config/configure.in
+config/config.guess
+config/config.sub
+config/ltconfig
+config/ltmain.sh
+config/aclocal.m4
+config/install.sh
+configure
--- openjade-1.4devel1.orig/jadedist/jadedist.dsp
+++ openjade-1.4devel1/jadedist/jadedist.dsp
@@ -0,0 +1,76 @@
+# Microsoft Developer Studio Project File - Name="jadedist" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) External Target" 0x0106
+
+CFG=jadedist - Win32 Release
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "jadedist.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "jadedist.mak" CFG="jadedist - Win32 Release"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "jadedist - Win32 Release" (based on "Win32 (x86) External Target")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir ".\Release"
+# PROP BASE Intermediate_Dir ".\Release"
+# PROP BASE Cmd_Line "NMAKE /f jadedist.mak"
+# PROP BASE Rebuild_Opt "/a"
+# PROP BASE Target_File "jadedist\jadedist.exe"
+# PROP BASE Bsc_Name "jadedist\jadedist.bsc"
+# PROP BASE Target_Dir "."
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir ".\Release"
+# PROP Intermediate_Dir ".\Release"
+# PROP Cmd_Line "makedist"
+# PROP Rebuild_Opt ""
+# PROP Target_File "jadedist\jade.zip"
+# PROP Bsc_Name ""
+# PROP Target_Dir "."
+# Begin Target
+
+# Name "jadedist - Win32 Release"
+
+!IF  "$(CFG)" == "jadedist - Win32 Release"
+
+!ENDIF 
+
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat;for;f90"
+# Begin Source File
+
+SOURCE=".\jadedist\bin-files.txt"
+# End Source File
+# Begin Source File
+
+SOURCE=.\jadedist\files.txt
+# End Source File
+# Begin Source File
+
+SOURCE=.\jadedist\makedist.bat
+# End Source File
+# End Group
+# Begin Group "Header Files"
+
+# PROP Default_Filter "h;hpp;hxx;hm;inl;fi;fd"
+# End Group
+# Begin Group "Resource Files"
+
+# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;cnt;rtf;gif;jpg;jpeg;jpe"
+# End Group
+# End Target
+# End Project
--- openjade-1.4devel1.orig/jadedist/makedist.bat
+++ openjade-1.4devel1/jadedist/makedist.bat
@@ -0,0 +1,6 @@
+copy files.txt+..\FILES all-files.txt
+cd ..
+del jadedist\jade.zip
+del jadedist\jadew.zip
+zip -q -@ <jadedist\all-files.txt jadedist\jade.zip
+zip -q -j -@ <jadedist\bin-files.txt jadedist\jadew.zip
--- openjade-1.4devel1.orig/jadedoc/Makefile.am
+++ openjade-1.4devel1/jadedoc/Makefile.am
@@ -2,11 +2,14 @@
 
 SUBDIRS = images
 
-docdir = $(prefix)/doc
+docdir = $(datadir)/doc
 pkgdocdir = $(docdir)/@PACKAGE@
+pkgdochtmldir = $(pkgdocdir)/doc
 
-pkgdoc_DATA = autoconf.htm contributors.htm copying.txt dsssl2.htm \
+pkgdochtml_DATA = autoconf.htm contributors.htm copying.txt dsssl2.htm \
 	index.htm mif.htm rtf.htm tex.htm transform.htm xmlfo.htm
 
 EXTRA_DIST = autoconf.htm contributors.htm copying.txt dsssl2.htm \
 	index.htm mif.htm rtf.htm tex.htm transform.htm xmlfo.htm
+
+MAINTAINERCLEANFILES = Makefile.in
--- openjade-1.4devel1.orig/jadedoc/images/Makefile.am
+++ openjade-1.4devel1/jadedoc/images/Makefile.am
@@ -1,9 +1,11 @@
 ## Process this file with automake to produce Makefile.in
 
-docdir = $(prefix)/doc
+docdir = $(datadir)/doc
 pkgdocdir = $(docdir)/@PACKAGE@
 imagedir = $(pkgdocdir)/images
 
 EXTRA_DIST = background.gif dsssltitle.gif space.gif top-of-page.gif
 
 image_DATA = background.gif dsssltitle.gif space.gif top-of-page.gif
+
+MAINTAINERCLEANFILES = Makefile.in
--- openjade-1.4devel1.orig/msggen.pl.in
+++ openjade-1.4devel1/msggen.pl.in
@@ -1,5 +1,6 @@
-#! /usr/bin/perl
+#! @PERL@
 # Copyright (c) 1994 James Clark, 2000 Matthias Clasen
+# Copyright (c) 2000 Peter Nilsson
 # See the file COPYING for copying permission.
 
 use POSIX;
@@ -7,6 +8,7 @@
 # Package and version.
 $package = '@PACKAGE@';
 $version = '@VERSION@';
+$package = $package; $version = $version; # be quiet, -w
 
 $prog = $0;
 $prog =~ s@.*/@@;
@@ -15,11 +17,17 @@
 
 undef $opt_l;
 undef $opt_p;
+undef $opt_t;
 do 'getopts.pl';
-&Getopts('l:p:');
+&Getopts('l:p:t:');
 $module = $opt_l;
 $pot_file = $opt_p;
 
+if (defined($opt_t)) {
+  # don't try to read translations for English
+  $opt_t =~ /.*en.*/ || &read_po_translations($opt_t);
+}
+
 $num = 0; 
 
 foreach $def_file (@ARGV) {
@@ -183,6 +191,10 @@
 END
 }
 
+if (defined($opt_l)) {
+    print "extern MessageModule $module;\n\n";
+}
+
 foreach $i (0 .. $#message) {
     if (defined($message[$i])) {
 	if ($type[$i] eq "") {
@@ -208,7 +220,11 @@
 	    }
 	    print ",\n";
 	}
-	print "MessageFragment::$module,\n";
+	if (defined($opt_l)) {
+	    print "&$module,\n";
+	} else {
+	    print "0,\n";
+	}
 	print "$i\n";
 	print "#ifndef SP_NO_MESSAGE_TEXT\n";
 	$str = $message[$i];
@@ -254,6 +270,9 @@
 foreach $i (0 .. $#message) {
     if (defined($message[$i])) {
 	$str = $message[$i];
+	if ($translation{$str}) {
+	    $str = $translation{$str};
+	}
 	$str =~ s/"/""/g;
 	printf "  %d, \"%s\"\n", $i, $str;
     }
@@ -322,3 +341,86 @@
 sub error {
     die "$def_file:$.: $_[0]\n";
 }
+
+# Read a PO file with message translations.
+# This doesn't accept every valid PO file, but it seems to work reasonably.
+sub read_po_translations {
+    my $po_in = $_[0];
+    open(PO_IN, "<$po_in") || die "Can't open file $po_in.";
+    my $id = "";
+    my $str = "";
+    my $catching_string = 0;
+
+    while(<PO_IN>) {
+	if (/^\s*msgid/) {
+	    if ($catching_string) {
+		&po_flush($id, $str);
+		$id = "";
+		$str = "";
+	    }
+	    $_ = $';
+	    $catching_string = 1;
+	}
+	elsif (/^\s*msgstr/) {
+	    die "No msgid." if !$catching_string or $id;
+	    $id = $str;
+	    $str = "";
+	    $_ = $';
+	}
+	
+	if ($catching_string) {
+	    my $in_string = 0;
+	    s/\s*//;
+	    while ($_) {
+		if (s/^\"//) {
+		    $in_string = !$in_string;
+		}
+		if ($in_string) {
+		    if (s/^[^\"\\]+//) {
+			$str .= $&;
+		    }
+		    elsif (s/^\\([ntbrf\\\"])//) {
+			$str .= "\n" if $1 eq "n";
+			$str .= "\t" if $1 eq "t";
+			$str .= "\b" if $1 eq "b";
+			$str .= "\r" if $1 eq "r";
+			$str .= "\f" if $1 eq "f";
+			$str .= "\\" if $1 eq "\\";
+			$str .= "\"" if $1 eq "\"";
+		    }
+		    elsif (s/\\([0-9]+)//) {
+			$str .= chr(oct($1));
+		    }
+		    elsif (s/\\[xX]([0-9a-fA-F]+)//) {
+			$str .= chr(hex($1));
+		    }
+		    else {
+			die "Invalid control sequence." if /^\\/;
+		    }
+		}
+		else {
+		    s/\s*//;
+		    last if /^[^"]/;
+	        }
+            }
+        }
+    }
+    if ($catching_string) {
+        &po_flush($id, $str);
+
+    }
+}
+
+sub po_flush {
+    my $id = $_[0];
+    my $str = $_[1];
+    # We use a translation only if $id is non-empty (we don't include the
+    # PO file header) and if $str is non-empty (the message is translated).
+    if ($id && $str) {
+	$translation{$id} = $str;
+    }
+    $id = "";
+    $str = "";
+}
+
+
--- openjade-1.4devel1.orig/po/LINGUAS
+++ openjade-1.4devel1/po/LINGUAS
@@ -0,0 +1 @@
+de ja sv
--- openjade-1.4devel1.orig/po/Makevars
+++ openjade-1.4devel1/po/Makevars
@@ -0,0 +1,72 @@
+# Makefile variables for PO directory in any package using GNU gettext.
+
+# Usually the message domain is the same as the package name.
+DOMAIN = jade
+
+# These two variables depend on the location of this directory.
+subdir = po
+top_builddir = ..
+
+# These options get passed to xgettext.
+XGETTEXT_OPTIONS = --keyword=_ --keyword=N_
+
+# This is the copyright holder that gets inserted into the header of the
+# $(DOMAIN).pot file.  Set this to the copyright holder of the surrounding
+# package.  (Note that the msgstr strings, extracted from the package's
+# sources, belong to the copyright holder of the package.)  Translators are
+# expected to transfer the copyright for their translations to this person
+# or entity, or to disclaim their copyright.  The empty string stands for
+# the public domain; in this case the translators are expected to disclaim
+# their copyright.
+COPYRIGHT_HOLDER = see po-files
+
+# This tells whether or not to prepend "GNU " prefix to the package
+# name that gets inserted into the header of the $(DOMAIN).pot file.
+# Possible values are "yes", "no", or empty.  If it is empty, try to
+# detect it automatically by scanning the files in $(top_srcdir) for
+# "GNU packagename" string.
+PACKAGE_GNU =
+
+# This is the email address or URL to which the translators shall report
+# bugs in the untranslated strings:
+# - Strings which are not entire sentences, see the maintainer guidelines
+#   in the GNU gettext documentation, section 'Preparing Strings'.
+# - Strings which use unclear terms or require additional context to be
+#   understood.
+# - Strings which make invalid assumptions about notation of date, time or
+#   money.
+# - Pluralisation problems.
+# - Incorrect English spelling.
+# - Incorrect formatting.
+# It can be your email address, or a mailing list address where translators
+# can write to without being subscribed, or the URL of a web page through
+# which the translators can contact you.
+MSGID_BUGS_ADDRESS =
+
+# This is the list of locale categories, beyond LC_MESSAGES, for which the
+# message catalogs shall be used.  It is usually empty.
+EXTRA_LOCALE_CATEGORIES =
+
+# This tells whether the $(DOMAIN).pot file contains messages with an 'msgctxt'
+# context.  Possible values are "yes" and "no".  Set this to yes if the
+# package uses functions taking also a message context, like pgettext(), or
+# if in $(XGETTEXT_OPTIONS) you define keywords with a context argument.
+USE_MSGCTXT = no
+
+# These options get passed to msgmerge.
+# Useful options are in particular:
+#   --previous            to keep previous msgids of translated messages,
+#   --quiet               to reduce the verbosity.
+MSGMERGE_OPTIONS =
+
+# This tells whether or not to regenerate a PO file when $(DOMAIN).pot
+# has changed.  Possible values are "yes" and "no".  Set this to no if
+# the POT file is checked in the repository and the version control
+# program ignores timestamps.
+PO_DEPENDS_ON_POT = yes
+
+# This tells whether or not to forcibly update $(DOMAIN).pot and
+# regenerate PO files on "make dist".  Possible values are "yes" and
+# "no".  Set this to no if the POT file and PO files are maintained
+# externally.
+DIST_DEPENDS_ON_UPDATE_PO = yes
--- openjade-1.4devel1.orig/po/cat-id-tbl.c
+++ openjade-1.4devel1/po/cat-id-tbl.c
@@ -1,245 +0,0 @@
-/* Automatically generated by po2tbl.sed from jade.pot.  */
-
-#if HAVE_CONFIG_H
-# include <config.h>
-#endif
-
-#include "libgettext.h"
-
-const struct _msg_ent _msg_tbl[] = {
-  {"", 1},
-  {"cannot open output file %1 (%2)", 2},
-  {"unknown output type %1", 3},
-  {"empty output filename", 4},
-  {"Use the backend %1.", 5},
-  {"Send output to %1.", 6},
-  {"FILE", 7},
-  {"TYPE", 8},
-  {"could not convert system identifier %1 to a single filename", 9},
-  {"missing table column flow object (table-auto-width feature not fully supported)", 10},
-  {"nested tables are not allowed in RTF", 11},
-  {"could not embed %1 with clsid %2", 12},
-  {"TeX backend does not currently support references to page numbers of nodes other than elements", 13},
-  {"TeX backend does not currently support links to nodes other than elements", 14},
-  {"TeX backend does not currently support links to entities", 15},
-  {"TeX backend does not currently support links to other SGML documents", 16},
-  {"TeX backend does not currently support HyTime linkends", 17},
-  {"TeX backend does not currently support TEI links", 18},
-  {"TeX backend does not currently support glyph substitution tables", 19},
-  {"%1 version %2", 20},
-  {"no DSSSL specification: use -d to specify", 21},
-  {"no applicable processing instruction with title %1; available titles: %2", 22},
-  {"Options with a \"doc-\"/\"spec-\" prefix apply only to the document/specification.", 23},
-  {"Enable experimental DSSSL extensions.", 24},
-  {"Debug mode.", 25},
-  {"Use DSSSL specification %1.", 26},
-  {"Use DSSSL specification with title %1.", 27},
-  {"Pretend that %1 appeared in the specification.", 28},
-  {"Strict DSSSL compliance mode.", 29},
-  {"Show open entities in error messages.", 30},
-  {"Show open elements in error messages.", 31},
-  {"Show error numbers in error messages.", 32},
-  {"Show references in error messages.", 33},
-  {"Define parameter entity %1 as \"INCLUDE\".", 34},
-  {"Enable warning %1.", 35},
-  {"SYSID", 36},
-  {"DEFINITION", 37},
-  {"NAME", 38},
-  {"unexpected end of file", 39},
-  {"invalid character", 40},
-  {"invalid character after '#'", 41},
-  {"unknown #! named constant %1", 42},
-  {"unexpected token %1", 43},
-  {"string with no closing quote", 44},
-  {"missing closing parenthesis", 45},
-  {"invalid number %1", 46},
-  {"invalid AFII glyph identifier %1", 47},
-  {"call of non-function object %1", 48},
-  {"too many arguments for function", 49},
-  {"odd number of keyword/value arguments", 50},
-  {"missing argument for function call", 51},
-  {"syntactic keyword %1 used as variable", 52},
-  {"reference to undefined variable %1", 53},
-  {"no character with name %1", 54},
-  {"unknown top level form %1", 55},
-  {"bad form %1 in mode group", 56},
-  {"identifier %1 already defined in same part", 57},
-  {"first definition was here", 58},
-  {"loop in specification of value of %1", 59},
-  {"argument out of range", 60},
-  {"loop in specification of value of unit %1", 61},
-  {"bad value specified for unit %1", 62},
-  {"unit %1 already defined in same part", 63},
-  {"quantity %1 undefined", 64},
-  {"incompatible dimensions", 65},
-  {"%2 argument for primitive %1 of wrong type: %3 not a boolean", 66},
-  {"%2 argument for primitive %1 of wrong type: %3 not a pair", 67},
-  {"%2 argument for primitive %1 of wrong type: %3 not a list", 68},
-  {"%2 argument for primitive %1 of wrong type: %3 not a symbol", 69},
-  {"%2 argument for primitive %1 of wrong type: %3 not a string", 70},
-  {"%2 argument for primitive %1 of wrong type: %3 not a string or symbol", 71},
-  {"%2 argument for primitive %1 of wrong type: %3 not a char", 72},
-  {"%2 argument for primitive %1 of wrong type: %3 not a style", 73},
-  {"%2 argument for primitive %1 of wrong type: %3 not an exact integer", 74},
-  {"%2 argument for primitive %1 of wrong type: %3 not a quantity", 75},
-  {"%2 argument for primitive %1 of wrong type: %3 not a color-space", 76},
-  {"%2 argument for primitive %1 of wrong type: %3 not a number", 77},
-  {"%2 argument for primitive %1 of wrong type: %3 not a sosofo", 78},
-  {"%2 argument for primitive %1 of wrong type: %3 not an optional singleton node list", 79},
-  {"%2 argument for primitive %1 of wrong type: %3 not a singleton node list", 80},
-  {"%2 argument for primitive %1 of wrong type: %3 not a node list", 81},
-  {"%2 argument for primitive %1 of wrong type: %3 not a named node list", 82},
-  {"%2 argument for primitive %1 of wrong type: %3 not a length or length-spec", 83},
-  {"%2 argument for primitive %1 of wrong type: %3 not a quantity or length-spec", 84},
-  {"%2 argument for primitive %1 of wrong type: %3 not an integer or the symbol \"force\"", 85},
-  {"%2 argument for primitive %1 of wrong type: %3 not an address", 86},
-  {"%2 argument for primitive %1 of wrong type: %3 not a glyph-id", 87},
-  {"%2 argument for primitive %1 of wrong type: %3 not a glyph-subst-table", 88},
-  {"%2 argument for primitive %1 of wrong type: %3 not a list of pairs of glyph-ids", 89},
-  {"%2 argument for primitive %1 of wrong type: %3 not a procedure", 90},
-  {"%2 argument for primitive %1 of wrong type: %3 not a vector", 91},
-  {"root rule already defined in same part with same importance", 92},
-  {"initial value already declared for characteristic %1 in same part", 93},
-  {"first declaration was here", 94},
-  {"%1 is not a valid keyword in a style expression", 95},
-  {"%1 is not a valid keyword in a make expression for flow object class %2", 96},
-  {"%1 is not the name of any flow object class", 97},
-  {"content expression cannot be specified in make expression for atomic flow object class %1", 98},
-  {"value for \"label:\" not a symbol", 99},
-  {"no port for label %1", 100},
-  {"invalid content map", 101},
-  {"content map references non-existent port %1", 102},
-  {"invalid value for %1 characteristic", 103},
-  {"no clause in cond expression matched", 104},
-  {"no clause in case expression matched %1", 105},
-  {"expected \"else\" not %1", 106},
-  {"sorry, cannot handle unresolvable quantities in datums in case expression", 107},
-  {"%1", 108},
-  {"division by zero", 109},
-  {"procedure does not have %1 keyword argument", 110},
-  {"argument not a keyword", 111},
-  {"specification document does not have the DSSSL architecture as a base architecture", 112},
-  {"specification document did not contain a style-specification-body element", 113},
-  {"unknown character name %1", 114},
-  {"attempt to use current node when there is none", 115},
-  {"attempt to process node in illegal context", 116},
-  {"radix must be 2, 8, 10 or 16", 117},
-  {"this context requires a sosofo", 118},
-  {"this context requires a style object", 119},
-  {"procedure can only be used in evaluation of characteristic value", 120},
-  {"%1 color requires three arguments", 121},
-  {"arguments for %1 color must be numbers", 122},
-  {"arguments for %1 color must be in the range 0 to 1", 123},
-  {"result of procedure in %1 color must be a number", 124},
-  {"unknown color-space family %1", 125},
-  {"%1 color-space family does not take any arguments", 126},
-  {"invalid parameters for %1 color-space family", 127},
-  {"%1 is not a pre-defined inherited characteristic", 128},
-  {"invalid number format %1", 129},
-  {"invalid character %1 in public identifier", 130},
-  {"debug %1", 131},
-  {"circular use of specification parts", 132},
-  {"no style-specification or external-specification with ID %1", 133},
-  {"document did not contain any style-specifications or external-specifications", 134},
-  {"table-cell flow object not inside a table", 135},
-  {"table-row flow object not inside a table", 136},
-  {"no value for node property %1", 137},
-  {"value returned by procedure was not a node-list", 138},
-  {"called from here", 139},
-  {"called from here...(%1 calls omitted)", 140},
-  {"node processing loop detected", 141},
-  {"unquote-splicing expression does not evaluate to a list", 142},
-  {"object is read-only", 143},
-  {"assignment to top-level variable %1", 144},
-  {"invalid call to continuation", 145},
-  {"empty generic identifier in pattern", 146},
-  {"pattern is not a list", 147},
-  {"%1 cannot be used as a generic identifier in a pattern", 148},
-  {"%1 cannot occur in a pattern", 149},
-  {"value missing for qualifier in pattern", 150},
-  {"unknown pattern qualifier %1", 151},
-  {"bad value %1 for %2 qualifier in pattern", 152},
-  {"repeat qualifier not allowed inside children qualifier", 153},
-  {"bad value for attributes qualifier in pattern", 154},
-  {"characteristic %1 applied in style rule with same specificity", 155},
-  {"other style rule is here", 156},
-  {"node matches more than one pattern with the same specificity", 157},
-  {"reference to uninitialized variable %1", 158},
-  {"circular use of actual value of characteristic %1", 159},
-  {"characteristic %1 already defined in same part", 160},
-  {"flow object class %1 already defined in same part", 161},
-  {"mode %1 not defined", 162},
-  {"duplicate character name %1", 163},
-  {"duplicate SDATA entity name %1", 164},
-  {"duplicate SDATA entity text %1", 165},
-  {"unsupported declaration will be ignored", 166},
-  {"unsupported character repertoire %1 will be ignored", 167},
-  {"error in declaration element", 168},
-  {"%1 is not a valid identifier", 169},
-  {"error in language definition", 170},
-  {"no current language", 171},
-  {"%2 argument for primitive %1 of wrong type: %3 not a language", 172},
-  {"%2 argument for primitive %1 of wrong type: %3 not a positive integer", 173},
-  {"%2 argument for primitive %1 of wrong type: %3 not an integer", 174},
-  {"%2 argument for primitive %1 of wrong type: %3 not a keyword", 175},
-  {"%2 argument for primitive %1 of wrong type: %3 not an alist", 176},
-  {"%2 argument for primitive %1 of wrong type: %3 not a list of characters", 177},
-  {"%2 argument for primitive %1 has wrong length", 178},
-  {"quantity %1 can't be represented exactly", 179},
-  {"default language already declared in this part", 180},
-  {"%1 not a language as required in a default-language-declaration", 181},
-  {"%1 not a valid unit name", 182},
-  {"%1 not a valid character name", 183},
-  {"%1 not a valid character number", 184},
-  {"unknown character property %1", 185},
-  {"error in character property declaration", 186},
-  {"character property %1 already declared in same part", 187},
-  {"added value for character property %1 already declared in same part", 188},
-  {"previous declaration was here", 189},
-  {"value returned by procedure was not a sosofo", 190},
-  {"loop in specification of value of character property %1", 191},
-  {"value for character property %1 of wrong type: %2 not an integer", 192},
-  {"value for character property %1 of wrong type: %2 not an integer or the value \"#f\"", 193},
-  {"%1 not a style or transformation language feature", 194},
-  {"undeclared use of feature %1", 195},
-  {"feature %1 not supported", 196},
-  {"feature %1 only partially supported", 197},
-  {"only allowed in style language", 198},
-  {"only allowed in transformation language", 199},
-  {"style and transformation language parts mixed", 200},
-  {"specification is marked as partial", 201},
-  {"grove plan excluding module %1 not supported", 202},
-  {"grove plan including module %1 not supported", 203},
-  {"%1 not an SGML property set module", 204},
-  {"Function for char-map characteristic returned non-char object %2 for character %1", 205},
-  {"value for character property %1 of wrong type: %2 not a public identifier or the value \"#f\"", 206},
-  {"variable %1 occurs more than once in bindings", 207},
-  {"exactly one of node:, subgrove: and class: needed", 208},
-  {"add:, null:, remove:, children:, sub: make no sense with subgrove:", 209},
-  {"remove: makes no sense with class:", 210},
-  {"%2 argument for primitive %1 of wrong type: %3 not a subgrove-spec", 211},
-  {"wrong type: %1 not a list of create-specs", 212},
-  {"wrong type: %1 not a create-spec or list of create-specs", 213},
-  {"query expression: %1 not a node list", 214},
-  {"priority expression: %1 not an exact integer", 215},
-  {"flow objects at the root must be all of class scroll or all of class page-sequence or simple-page-sequence", 216},
-  {"current flow parent has no principal port", 217},
-  {"this flow object requires a paragraph as an ancestor flow object", 218},
-  {"flow object not accepted by port; only inline flow objects accepted", 219},
-  {"flow object not accepted by port; only display flow objects accepted", 220},
-  {"flow object not accepted by port; only display or inline flow objects accepted", 221},
-  {"flow object not accepted in a paragraph; only inline, display or paragraph-break flow objects accepted", 222},
-  {"a side-by-side flow object only accepts side-by-side-item flow objects as children", 223},
-  {"flow object not accepted by port; only math-sequence, unmath, subscript, superscript, script, mark, fence, fraction, radical, math-operator, grid, character and alignment-point flow objects accepted", 224},
-  {"flow object not accepted by port; must be grid-cell", 225},
-  {"flow object not accepted by port; only a single character flow object accepted", 226},
-  {"flow object not accepted by port; in a table, only either table-part flow objects or table-column flow objects followed by table-row or table-cell flow objects are allowed", 227},
-  {"flow object not accepted by port; only table-row or table-cell flow objects accepted", 228},
-  {"flow object not accepted by port; only table-column flow objects followed by table-row or table-cell flow objects allowd", 229},
-  {"flow object not accepted by port; only table-cell flow objects accepted", 230},
-  {"priority-expression must be a number", 231},
-  {"query-expression must be a node-list", 232},
-  {"Sorry, non-integral priorities not implemented", 233},
-};
-
-int _msg_tbl_length = 233;
--- openjade-1.4devel1.orig/po/de.po
+++ openjade-1.4devel1/po/de.po
@@ -6,16 +6,17 @@
 msgid ""
 msgstr ""
 "Project-Id-Version: PACKAGE VERSION\n"
-"POT-Creation-Date: 2000-03-28 14:20+0000\n"
+"POT-Creation-Date: 2003-09-29 14:47+0000\n"
 "PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
 "Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
 "Language-Team: LANGUAGE <LL@li.org>\n"
+"Language: de\n"
 "MIME-Version:: 1.0\n"
 "Content-Type: text/plain; charset=CHARSET\n"
 "Content-Transfer-Encoding: ENCODING\n"
 
 msgid "cannot open output file %1 (%2)"
-msgstr "Ausgabedatei %1 kann nicht geffnet werden (%2)"
+msgstr "Ausgabedatei %1 kann nicht geffnet werden (%2)"
 
 msgid "unknown output type %1"
 msgstr "Unbekannter Ausgabetyp %1"
@@ -44,8 +45,8 @@
 "missing table column flow object (table-auto-width feature not fully "
 "supported)"
 msgstr ""
-"Fehlendes Tabellenspalten-Fluobjekt (table-auto-width Feature nicht "
-"vollstndig untersttzt)"
+"Fehlendes Tabellenspalten-Fluobjekt (table-auto-width Feature nicht "
+"vollstndig untersttzt)"
 
 msgid "nested tables are not allowed in RTF"
 msgstr "Verschachtelte Tabellen sind in RTF nicht erlaubt"
@@ -57,26 +58,26 @@
 "TeX backend does not currently support references to page numbers of nodes "
 "other than elements"
 msgstr ""
-"TeX Ausgabe untersttzt Querverweise auf Seitenzahlen nur fr Elementknoten"
+"TeX Ausgabe untersttzt Querverweise auf Seitenzahlen nur fr Elementknoten"
 
 msgid ""
 "TeX backend does not currently support links to nodes other than elements"
-msgstr "TeX Ausgabe untersttzt Verknpfungen nur fr Elementknoten"
+msgstr "TeX Ausgabe untersttzt Verknpfungen nur fr Elementknoten"
 
 msgid "TeX backend does not currently support links to entities"
-msgstr "TeX Ausgabe untersttzt keine Verknpfungen auf Entitten"
+msgstr "TeX Ausgabe untersttzt keine Verknpfungen auf Entitten"
 
 msgid "TeX backend does not currently support links to other SGML documents"
-msgstr "TeX Ausgabe untersttzt keine Verknpfungen auf andere SGML Dokumente"
+msgstr "TeX Ausgabe untersttzt keine Verknpfungen auf andere SGML Dokumente"
 
 msgid "TeX backend does not currently support HyTime linkends"
-msgstr "TeX Ausgabe untersttzt keine HyTime Verknpfungsenden"
+msgstr "TeX Ausgabe untersttzt keine HyTime Verknpfungsenden"
 
 msgid "TeX backend does not currently support TEI links"
-msgstr "TeX Ausgabe untersttzt keine TEI Verknpfungen"
+msgstr "TeX Ausgabe untersttzt keine TEI Verknpfungen"
 
 msgid "TeX backend does not currently support glyph substitution tables"
-msgstr "TeX Ausgabe untersttzt keine Glyphersetzungstabellen"
+msgstr "TeX Ausgabe untersttzt keine Glyphersetzungstabellen"
 
 msgid "%1 version %2"
 msgstr "%1 Version %2"
@@ -89,8 +90,8 @@
 msgstr ""
 
 msgid ""
-"Options with a \"doc-\"/\"spec-\" prefix apply only to the "
-"document/specification."
+"Options with a \"doc-\"/\"spec-\" prefix apply only to the document/"
+"specification."
 msgstr ""
 
 msgid "Enable experimental DSSSL extensions."
@@ -144,10 +145,10 @@
 msgstr "Unerwartetes Ende der Datei"
 
 msgid "invalid character"
-msgstr "Ungltiges Zeichen"
+msgstr "Ungltiges Zeichen"
 
 msgid "invalid character after '#'"
-msgstr "Ungltiges Zeichen nach '#'"
+msgstr "Ungltiges Zeichen nach '#'"
 
 msgid "unknown #! named constant %1"
 msgstr "Unbekannte #! benannte Konstante %1"
@@ -156,31 +157,31 @@
 msgstr "Unerwartetes Token %1"
 
 msgid "string with no closing quote"
-msgstr "Zeichenkette ohne abschlieendes Anfhrungszeichen"
+msgstr "Zeichenkette ohne abschlieendes Anfhrungszeichen"
 
 msgid "missing closing parenthesis"
-msgstr "Fehlende schlieende Klammer"
+msgstr "Fehlende schlieende Klammer"
 
 msgid "invalid number %1"
-msgstr "Ungltige Zahl %1"
+msgstr "Ungltige Zahl %1"
 
 msgid "invalid AFII glyph identifier %1"
-msgstr "Ungltiger AFII Glyphbezeichner %1"
+msgstr "Ungltiger AFII Glyphbezeichner %1"
 
 msgid "call of non-function object %1"
 msgstr "Aufruf des nicht-Funktionsobjektes %1"
 
 msgid "too many arguments for function"
-msgstr "Zu viele Argumente fr Funktion"
+msgstr "Zu viele Argumente fr Funktion"
 
 msgid "odd number of keyword/value arguments"
-msgstr "Ungerade Anzahl von Schlsselwort/Wert Argumenten"
+msgstr "Ungerade Anzahl von Schlsselwort/Wert Argumenten"
 
 msgid "missing argument for function call"
-msgstr "Fehlendes Argument fr Funktionsaufruf"
+msgstr "Fehlendes Argument fr Funktionsaufruf"
 
 msgid "syntactic keyword %1 used as variable"
-msgstr "Syntaktisches Schlsselwort %1 als Variable benutzt"
+msgstr "Syntaktisches Schlsselwort %1 als Variable benutzt"
 
 msgid "reference to undefined variable %1"
 msgstr "Referenz auf undefinierte Variable %1"
@@ -204,172 +205,175 @@
 msgstr "Schleife in der Spezifikation des Wertes von %1"
 
 msgid "argument out of range"
-msgstr "Argument auerhalb des zulssigen Bereichs"
+msgstr "Argument auerhalb des zulssigen Bereichs"
 
 msgid "loop in specification of value of unit %1"
 msgstr "Schleife in der Spezifikation des Wertes der Einheit %1"
 
 msgid "bad value specified for unit %1"
-msgstr "Schlechter Wert fr Einheit %1 spezifiziert"
+msgstr "Schlechter Wert fr Einheit %1 spezifiziert"
 
 msgid "unit %1 already defined in same part"
 msgstr "Einheit %1 bereits im selben Teil definiert"
 
 msgid "quantity %1 undefined"
-msgstr "Quantitt %1 undefiniert"
+msgstr "Quantitt %1 undefiniert"
 
 msgid "incompatible dimensions"
 msgstr "Inkompatible Dimensionen"
 
 msgid "%2 argument for primitive %1 of wrong type: %3 not a boolean"
 msgstr ""
-"%2 Argument fr Funktion %1 vom falschen Typ: %3 ist kein boolescher Wert"
+"%2 Argument fr Funktion %1 vom falschen Typ: %3 ist kein boolescher Wert"
 
 msgid "%2 argument for primitive %1 of wrong type: %3 not a pair"
-msgstr "%2 Argument fr Funktion %1 vom falschen Type: %3 ist kein Paar"
+msgstr "%2 Argument fr Funktion %1 vom falschen Type: %3 ist kein Paar"
 
 msgid "%2 argument for primitive %1 of wrong type: %3 not a list"
-msgstr "%2 Argument fr Funktion %1 vom falschen Typ: %3 ist keine Liste"
+msgstr "%2 Argument fr Funktion %1 vom falschen Typ: %3 ist keine Liste"
 
 msgid "%2 argument for primitive %1 of wrong type: %3 not a symbol"
-msgstr "%2 Argument fr Funktion %1 vom falschen Typ: %3 ist kein Symbol"
+msgstr "%2 Argument fr Funktion %1 vom falschen Typ: %3 ist kein Symbol"
 
 msgid "%2 argument for primitive %1 of wrong type: %3 not a string"
-msgstr ""
-"%2 Argument fr Funktion %1 vom falschen Typ: %3 ist keine Zeichenkette"
+msgstr "%2 Argument fr Funktion %1 vom falschen Typ: %3 ist keine Zeichenkette"
 
 msgid "%2 argument for primitive %1 of wrong type: %3 not a string or symbol"
 msgstr ""
-"%2 Argument fr Funktion %1 vom falschen Typ: %3 ist weder Zeichenkette noch "
+"%2 Argument fr Funktion %1 vom falschen Typ: %3 ist weder Zeichenkette noch "
 "Symbol"
 
 msgid "%2 argument for primitive %1 of wrong type: %3 not a char"
-msgstr "%2 Argument fr Funktion %1 vom falschen Typ: %3 ist kein Zeichen"
+msgstr "%2 Argument fr Funktion %1 vom falschen Typ: %3 ist kein Zeichen"
+
+#, fuzzy
+msgid ""
+"%2 argument for primitive %1 of wrong type: %3 not an ISO8601 time string"
+msgstr "%2 Argument fr Funktion %1 vom falschen Typ: %3 ist keine Zeichenkette"
 
 msgid "%2 argument for primitive %1 of wrong type: %3 not a style"
-msgstr "%2 Argument fr Funktion %1 vom falschen Typ: %3 ist kein Stil"
+msgstr "%2 Argument fr Funktion %1 vom falschen Typ: %3 ist kein Stil"
 
 msgid "%2 argument for primitive %1 of wrong type: %3 not an exact integer"
 msgstr ""
-"%2 Argument fr Funktion %1 vom falschen Typ: %3 ist keine exakte ganze Zahl"
+"%2 Argument fr Funktion %1 vom falschen Typ: %3 ist keine exakte ganze Zahl"
 
 msgid "%2 argument for primitive %1 of wrong type: %3 not a quantity"
-msgstr "%2 Argument fr Funktion %1 vom falschen Typ: %3 ist keine Gre"
+msgstr "%2 Argument fr Funktion %1 vom falschen Typ: %3 ist keine Gre"
 
 msgid "%2 argument for primitive %1 of wrong type: %3 not a color-space"
-msgstr "%2 Argument fr Funktion %1 vom falschen Typ: %3 ist kein Farbraum"
+msgstr "%2 Argument fr Funktion %1 vom falschen Typ: %3 ist kein Farbraum"
 
 msgid "%2 argument for primitive %1 of wrong type: %3 not a number"
-msgstr "%2 Argument fr Funktion %1 vom falschen Typ: %3 ist keine Zahl"
+msgstr "%2 Argument fr Funktion %1 vom falschen Typ: %3 ist keine Zahl"
 
 msgid "%2 argument for primitive %1 of wrong type: %3 not a sosofo"
-msgstr "%2 Argument fr Funktion %1 vom falschen Typ: %3 ist kein Sosofo"
+msgstr "%2 Argument fr Funktion %1 vom falschen Typ: %3 ist kein Sosofo"
 
 msgid ""
 "%2 argument for primitive %1 of wrong type: %3 not an optional singleton "
 "node list"
 msgstr ""
-"%2 Argument fr Funktion %1 vom falschen Typ: %3 ist keine optionale "
+"%2 Argument fr Funktion %1 vom falschen Typ: %3 ist keine optionale "
 "Einzelknotenliste"
 
 msgid ""
 "%2 argument for primitive %1 of wrong type: %3 not a singleton node list"
 msgstr ""
-"%2 Argument fr Funktion %1 vom falschen Typ: %3 ist keine Einzelknotenliste"
+"%2 Argument fr Funktion %1 vom falschen Typ: %3 ist keine Einzelknotenliste"
 
 msgid "%2 argument for primitive %1 of wrong type: %3 not a node list"
-msgstr "%2 Argument fr Funktion %1 vom falschen Typ: %3 ist keine Knotenliste"
+msgstr "%2 Argument fr Funktion %1 vom falschen Typ: %3 ist keine Knotenliste"
 
 msgid "%2 argument for primitive %1 of wrong type: %3 not a named node list"
 msgstr ""
-"%2 Argument fr Funktion %1 vom falschen Typ: %3 ist keine benannte "
+"%2 Argument fr Funktion %1 vom falschen Typ: %3 ist keine benannte "
 "Knotenliste"
 
 msgid ""
 "%2 argument for primitive %1 of wrong type: %3 not a length or length-spec"
 msgstr ""
-"%2 Argument fr Funktion %1 vom falschen Typ: %3 ist weder eine Lnge noch "
-"eine Lngen-Spezifikation"
+"%2 Argument fr Funktion %1 vom falschen Typ: %3 ist weder eine Lnge noch "
+"eine Lngen-Spezifikation"
 
 msgid ""
 "%2 argument for primitive %1 of wrong type: %3 not a quantity or length-spec"
 msgstr ""
-"%2 Argument fr Funktion %1 vom falschen Typ: %3 ist weder eine Gre noch "
-"eine Lngen-Spezifikation"
+"%2 Argument fr Funktion %1 vom falschen Typ: %3 ist weder eine Gre noch eine "
+"Lngen-Spezifikation"
 
 msgid ""
 "%2 argument for primitive %1 of wrong type: %3 not an integer or the symbol "
 "\"force\""
 msgstr ""
-"%2 Argument fr Funktion %1 vom falschen Typ: %3 ist weder eine ganze Zahl "
+"%2 Argument fr Funktion %1 vom falschen Typ: %3 ist weder eine ganze Zahl "
 "noch das Symbol \"force\""
 
 msgid "%2 argument for primitive %1 of wrong type: %3 not an address"
-msgstr "%2 Argument fr Funktion %1 vom falschen Typ: %3 ist keine Adresse"
+msgstr "%2 Argument fr Funktion %1 vom falschen Typ: %3 ist keine Adresse"
 
 msgid "%2 argument for primitive %1 of wrong type: %3 not a glyph-id"
 msgstr ""
-"%2 Argument fr Funktion %1 vom falschen Typ: %3 ist kein Glyphbezeichner"
+"%2 Argument fr Funktion %1 vom falschen Typ: %3 ist kein Glyphbezeichner"
 
 msgid "%2 argument for primitive %1 of wrong type: %3 not a glyph-subst-table"
 msgstr ""
-"%2 Argument fr Funktion %1 vom falschen Typ: %3 ist keine "
+"%2 Argument fr Funktion %1 vom falschen Typ: %3 ist keine "
 "Glyphersetzungstabelle"
 
 msgid ""
-"%2 argument for primitive %1 of wrong type: %3 not a list of pairs of "
-"glyph-ids"
+"%2 argument for primitive %1 of wrong type: %3 not a list of pairs of glyph-"
+"ids"
 msgstr ""
-"%2 Argument fr Funktion %1 vom falschen Typ: %3 ist keine Liste von Paaren "
+"%2 Argument fr Funktion %1 vom falschen Typ: %3 ist keine Liste von Paaren "
 "von Glyphbezeichnern"
 
 msgid "%2 argument for primitive %1 of wrong type: %3 not a procedure"
-msgstr "%2 Argument fr Funktion %1 vom falschen Typ: %3 ist keine Prozedur"
+msgstr "%2 Argument fr Funktion %1 vom falschen Typ: %3 ist keine Prozedur"
 
 msgid "%2 argument for primitive %1 of wrong type: %3 not a vector"
-msgstr "%2 Argument fr Funktion %1 vom falschen Typ: %3 ist kein Vektor"
+msgstr "%2 Argument fr Funktion %1 vom falschen Typ: %3 ist kein Vektor"
 
 msgid "root rule already defined in same part with same importance"
 msgstr "Root-Regel bereits im selben Teil mit derselben Wichtigkeit definiert"
 
 msgid "initial value already declared for characteristic %1 in same part"
-msgstr "Initialer Wert fr Charakteristik %1 bereits im selben Teil deklariert"
+msgstr "Initialer Wert fr Charakteristik %1 bereits im selben Teil deklariert"
 
 msgid "first declaration was here"
 msgstr "erste Deklaration war hier"
 
 msgid "%1 is not a valid keyword in a style expression"
-msgstr "%1 ist kein gltiges Schlsselwort in einem Stilausdruck"
+msgstr "%1 ist kein gltiges Schlsselwort in einem Stilausdruck"
 
 msgid "%1 is not a valid keyword in a make expression for flow object class %2"
 msgstr ""
-"%1 ist kein gltiges Schlsselwort in einem make-Ausdruck fr "
-"Fluobjektklasse %2"
+"%1 ist kein gltiges Schlsselwort in einem make-Ausdruck fr Fluobjektklasse %2"
 
 msgid "%1 is not the name of any flow object class"
-msgstr "%1 ist nicht der Name einer Fluobjektklasse"
+msgstr "%1 ist nicht der Name einer Fluobjektklasse"
 
 msgid ""
 "content expression cannot be specified in make expression for atomic flow "
 "object class %1"
 msgstr ""
-"Inhaltsausdruck kann in einem make-Ausdruck fr die atomare Fluobjektklasse "
+"Inhaltsausdruck kann in einem make-Ausdruck fr die atomare Fluobjektklasse "
 "%1 nicht spezifiziert werden"
 
 msgid "value for \"label:\" not a symbol"
-msgstr "Wert fr \"label:\" ist kein Symbol"
+msgstr "Wert fr \"label:\" ist kein Symbol"
 
 msgid "no port for label %1"
-msgstr "Kein Port fr Label %1"
+msgstr "Kein Port fr Label %1"
 
 msgid "invalid content map"
-msgstr "Ungltige Inhaltsabbildung"
+msgstr "Ungltige Inhaltsabbildung"
 
 msgid "content map references non-existent port %1"
 msgstr "Inhaltsabbildung referenziert nicht existierenden Port %1"
 
 msgid "invalid value for %1 characteristic"
-msgstr "Ungltiger Wert fr Charakteristik %1"
+msgstr "Ungltiger Wert fr Charakteristik %1"
 
 msgid "no clause in cond expression matched"
 msgstr "Keine Klausel im cond-Ausdruck traf zu"
@@ -383,7 +387,7 @@
 msgid ""
 "sorry, cannot handle unresolvable quantities in datums in case expression"
 msgstr ""
-"Sorry, kann unauflsbare Quantitten in Datums in case-Ausdrcken nicht "
+"Sorry, kann unauflsbare Quantitten in Datums in case-Ausdrcken nicht "
 "verarbeiten"
 
 msgid "%1"
@@ -393,10 +397,10 @@
 msgstr "Teilung durch Null"
 
 msgid "procedure does not have %1 keyword argument"
-msgstr "Prozedur hat kein %1 Schlsselwortargument"
+msgstr "Prozedur hat kein %1 Schlsselwortargument"
 
 msgid "argument not a keyword"
-msgstr "Argument ist kein Schlsselwort"
+msgstr "Argument ist kein Schlsselwort"
 
 msgid ""
 "specification document does not have the DSSSL architecture as a base "
@@ -411,19 +415,19 @@
 msgstr "Unbekannter Zeichenname %1"
 
 msgid "attempt to use current node when there is none"
-msgstr "Versuch, den gegenwrtigen Knoten zu benutzen, obwohl es keinen gibt"
+msgstr "Versuch, den gegenwrtigen Knoten zu benutzen, obwohl es keinen gibt"
 
 msgid "attempt to process node in illegal context"
 msgstr "Versuch, einen Knoten in illegalem Kontext zu verarbeiten"
 
 msgid "radix must be 2, 8, 10 or 16"
-msgstr "Wurzel mu 2, 8, 10 oder 16 sein"
+msgstr "Wurzel mu 2, 8, 10 oder 16 sein"
 
 msgid "this context requires a sosofo"
-msgstr "Dieser Kontext bentigt ein Sosofo"
+msgstr "Dieser Kontext bentigt ein Sosofo"
 
 msgid "this context requires a style object"
-msgstr "Dieser Kontext bentigt ein Stilobjekt"
+msgstr "Dieser Kontext bentigt ein Stilobjekt"
 
 msgid "procedure can only be used in evaluation of characteristic value"
 msgstr ""
@@ -431,16 +435,16 @@
 "verwendet werden"
 
 msgid "%1 color requires three arguments"
-msgstr "Eine %1 Farbe bentigt drei Argumente"
+msgstr "Eine %1 Farbe bentigt drei Argumente"
 
 msgid "arguments for %1 color must be numbers"
-msgstr "Argumente fr eine %1 Farbe mssen Zahlen sein"
+msgstr "Argumente fr eine %1 Farbe mssen Zahlen sein"
 
 msgid "arguments for %1 color must be in the range 0 to 1"
-msgstr "Argumente fr eine %1 Farbe mssen zwischen 0 und 1 liegen"
+msgstr "Argumente fr eine %1 Farbe mssen zwischen 0 und 1 liegen"
 
 msgid "result of procedure in %1 color must be a number"
-msgstr "Ergebnis der Prozedur in einer %1 Farbe mu eine Zahl sein"
+msgstr "Ergebnis der Prozedur in einer %1 Farbe mu eine Zahl sein"
 
 msgid "unknown color-space family %1"
 msgstr "Unbekannte Farbraumfamilie %1"
@@ -449,22 +453,22 @@
 msgstr "Die %1 Farbraumfamilie akzeptiert keine Argumente"
 
 msgid "invalid parameters for %1 color-space family"
-msgstr "Ungltige Parameter fr die %1 Farbraumfamilie"
+msgstr "Ungltige Parameter fr die %1 Farbraumfamilie"
 
 msgid "%1 is not a pre-defined inherited characteristic"
 msgstr "%1 ist keine vordefinierte vererbte Charakteristik"
 
 msgid "invalid number format %1"
-msgstr "Ungltiges Zahlformat %1"
+msgstr "Ungltiges Zahlformat %1"
 
 msgid "invalid character %1 in public identifier"
-msgstr "Ungltiges Zeichen in ffentlichem Bezeichner"
+msgstr "Ungltiges Zeichen in ffentlichem Bezeichner"
 
 msgid "debug %1"
 msgstr ""
 
 msgid "circular use of specification parts"
-msgstr "Zirkulre Benutzung von Spezifikationsteilen"
+msgstr "Zirkulre Benutzung von Spezifikationsteilen"
 
 msgid "no style-specification or external-specification with ID %1"
 msgstr "Keine style-specification oder external-specificaton mit ID %1"
@@ -476,16 +480,16 @@
 "Elemente"
 
 msgid "table-cell flow object not inside a table"
-msgstr "table-cell Fluobjekt nicht innerhalb einer Tabelle"
+msgstr "table-cell Fluobjekt nicht innerhalb einer Tabelle"
 
 msgid "table-row flow object not inside a table"
-msgstr "table-row Fluobjekt nicht innerhalb einer Tabelle"
+msgstr "table-row Fluobjekt nicht innerhalb einer Tabelle"
 
 msgid "no value for node property %1"
-msgstr "Kein Wert fr Knoteneigenschaft %1"
+msgstr "Kein Wert fr Knoteneigenschaft %1"
 
 msgid "value returned by procedure was not a node-list"
-msgstr "Der Rckgabewert der Prozedur war keine Knotenliste"
+msgstr "Der Rckgabewert der Prozedur war keine Knotenliste"
 
 msgid "called from here"
 msgstr "von hier aufgerufen"
@@ -506,7 +510,7 @@
 msgstr "Zuweisung an Top-Level Variable %1"
 
 msgid "invalid call to continuation"
-msgstr "Ungltiger Aufruf einer Fortsetzung"
+msgstr "Ungltiger Aufruf einer Fortsetzung"
 
 msgid "empty generic identifier in pattern"
 msgstr "Leerer generischer Bezeichner in Muster"
@@ -522,40 +526,40 @@
 msgstr "%1 kann in einem Muster nicht vorkommen"
 
 msgid "value missing for qualifier in pattern"
-msgstr "Im Muster fehlt ein Wert fr einen Qualifikator"
+msgstr "Im Muster fehlt ein Wert fr einen Qualifikator"
 
 msgid "unknown pattern qualifier %1"
 msgstr "Unbekannter Musterqualifikator %1"
 
 msgid "bad value %1 for %2 qualifier in pattern"
-msgstr "Schlechter Wert %1 fr Qualifikator %2 im Muster"
+msgstr "Schlechter Wert %1 fr Qualifikator %2 im Muster"
 
 msgid "repeat qualifier not allowed inside children qualifier"
 msgstr "repeat Qualifikator nicht innerhalb des children Qualifikators erlaubt"
 
 msgid "bad value for attributes qualifier in pattern"
-msgstr "Schlechter Wert fr den attributes Qualifikator im Muster"
+msgstr "Schlechter Wert fr den attributes Qualifikator im Muster"
 
 msgid "characteristic %1 applied in style rule with same specificity"
-msgstr "Charakteristik %1 in Stilregel mit derselben Spezifizitt"
+msgstr "Charakteristik %1 in Stilregel mit derselben Spezifizitt"
 
 msgid "other style rule is here"
 msgstr "die andere Regel ist hier"
 
 msgid "node matches more than one pattern with the same specificity"
-msgstr "Knoten passt zu meheren Mustern mit derselben Spezifizitt"
+msgstr "Knoten passt zu meheren Mustern mit derselben Spezifizitt"
 
 msgid "reference to uninitialized variable %1"
 msgstr "Referenz auf uninitialisierte Variable %1"
 
 msgid "circular use of actual value of characteristic %1"
-msgstr "Zirkulre Benutzung des aktuellen Wertes der Charakteristik %1"
+msgstr "Zirkulre Benutzung des aktuellen Wertes der Charakteristik %1"
 
 msgid "characteristic %1 already defined in same part"
 msgstr "Charakteristik %1 bereits im selben Teil definiert"
 
 msgid "flow object class %1 already defined in same part"
-msgstr "Fluobjektklasse %1 bereits im selben Teil definiert"
+msgstr "Fluobjektklasse %1 bereits im selben Teil definiert"
 
 msgid "mode %1 not defined"
 msgstr "Modus %1 nicht definiert"
@@ -564,72 +568,70 @@
 msgstr "Doppelter Zeichenname %1"
 
 msgid "duplicate SDATA entity name %1"
-msgstr "Doppelter SDATA-Entittsname %1"
+msgstr "Doppelter SDATA-Entittsname %1"
 
 msgid "duplicate SDATA entity text %1"
-msgstr "Doppelter SDATA-Entittstext %1"
+msgstr "Doppelter SDATA-Entittstext %1"
 
 msgid "unsupported declaration will be ignored"
-msgstr "Nicht untersttzte Deklaration wird ignoriert"
+msgstr "Nicht untersttzte Deklaration wird ignoriert"
 
 msgid "unsupported character repertoire %1 will be ignored"
-msgstr "Nicht untersttztes Zeichenrepertoir %1 wird ignoriert"
+msgstr "Nicht untersttztes Zeichenrepertoir %1 wird ignoriert"
 
 msgid "error in declaration element"
 msgstr "Fehler in Deklarationselement"
 
 msgid "%1 is not a valid identifier"
-msgstr "%1 ist kein gltiger Bezeichner"
+msgstr "%1 ist kein gltiger Bezeichner"
 
 msgid "error in language definition"
 msgstr "Fehler in Sprachdefinition"
 
 msgid "no current language"
-msgstr "Keine gegenwrtige Sprache"
+msgstr "Keine gegenwrtige Sprache"
 
 msgid "%2 argument for primitive %1 of wrong type: %3 not a language"
-msgstr "%2 Argument fr Funktion %1 vom falschen Typ: %3 ist keine Sprache"
+msgstr "%2 Argument fr Funktion %1 vom falschen Typ: %3 ist keine Sprache"
 
 msgid "%2 argument for primitive %1 of wrong type: %3 not a positive integer"
 msgstr ""
-"%2 Argument fr Funktion %1 vom falschen Typ: %3 ist keine positive ganze "
-"Zahl"
+"%2 Argument fr Funktion %1 vom falschen Typ: %3 ist keine positive ganze Zahl"
 
 msgid "%2 argument for primitive %1 of wrong type: %3 not an integer"
-msgstr "%2 Argument fr Funktion %1 vom falschen Typ: %3 ist keine ganze Zahl"
+msgstr "%2 Argument fr Funktion %1 vom falschen Typ: %3 ist keine ganze Zahl"
 
 msgid "%2 argument for primitive %1 of wrong type: %3 not a keyword"
-msgstr ""
-"%2 Argument fr Funktion %1 vom falschen Typ: %3 ist kein Schlsselwort"
+msgstr "%2 Argument fr Funktion %1 vom falschen Typ: %3 ist kein Schlsselwort"
 
 msgid "%2 argument for primitive %1 of wrong type: %3 not an alist"
-msgstr "%2 Argument fr Funktion %1 vom falschen Typ: %3 ist keine alist"
+msgstr "%2 Argument fr Funktion %1 vom falschen Typ: %3 ist keine alist"
 
 msgid "%2 argument for primitive %1 of wrong type: %3 not a list of characters"
-msgstr "%2 Argument fr Funktion %1 vom falschen Typ: %3 ist Zeichenliste"
+msgstr "%2 Argument fr Funktion %1 vom falschen Typ: %3 ist Zeichenliste"
 
 msgid "%2 argument for primitive %1 has wrong length"
-msgstr "%2 Argument fr Funktion %1 hat die falsche Lnge"
+msgstr "%2 Argument fr Funktion %1 hat die falsche Lnge"
 
 msgid "quantity %1 can't be represented exactly"
-msgstr "Die Gre %1 kann nicht exakt reprsentiert werden"
+msgstr "Die Gre %1 kann nicht exakt reprsentiert werden"
 
 msgid "default language already declared in this part"
 msgstr "Standardsprache bereits im selben Teil deklariert"
 
 msgid "%1 not a language as required in a default-language-declaration"
 msgstr ""
-"%1 ist keine Sprache wie sie in einer default-language-declaration bentigt "
+"%1 ist keine Sprache wie sie in einer default-language-declaration bentigt "
 "wird"
 
 msgid "%1 not a valid unit name"
-msgstr "%1 ist kein gltiger Einheitsname"
+msgstr "%1 ist kein gltiger Einheitsname"
 
 msgid "%1 not a valid character name"
-msgstr "%1 ist kein gltiger Zeichenname"
+msgstr "%1 ist kein gltiger Zeichenname"
 
 msgid "%1 not a valid character number"
-msgstr "%1 ist keine gltige Zeichennummer"
+msgstr "%1 ist keine gltige Zeichennummer"
 
 msgid "unknown character property %1"
 msgstr "Unbekannte Zeicheneigenschaft %1"
@@ -642,14 +644,14 @@
 
 msgid "added value for character property %1 already declared in same part"
 msgstr ""
-"Neuer Wert fr Zeicheneigenschaft %1, die bereits im selben Teil deklariert "
+"Neuer Wert fr Zeicheneigenschaft %1, die bereits im selben Teil deklariert "
 "war"
 
 msgid "previous declaration was here"
 msgstr "vorige Deklaration war hier"
 
 msgid "value returned by procedure was not a sosofo"
-msgstr "Rckgabewert der Prozedur war kein Sosofo"
+msgstr "Rckgabewert der Prozedur war kein Sosofo"
 
 msgid "loop in specification of value of character property %1"
 msgstr "Schleife in der Spezifikation des Wertes von Zeicheneigenschaft %1"
@@ -672,10 +674,10 @@
 msgstr "Undeklarierte Benutzung von Feature %1"
 
 msgid "feature %1 not supported"
-msgstr "Feature %1 nicht untersttzt"
+msgstr "Feature %1 nicht untersttzt"
 
 msgid "feature %1 only partially supported"
-msgstr "Feature %1 nur teilweise untersttzt"
+msgstr "Feature %1 nur teilweise untersttzt"
 
 msgid "only allowed in style language"
 msgstr "Nur in der Stilsprache erlaubt"
@@ -690,10 +692,10 @@
 msgstr "Spezifikation ist als partiell gekennzeichnet"
 
 msgid "grove plan excluding module %1 not supported"
-msgstr "Groveplan ohne Modul %1 nicht untersttzt"
+msgstr "Groveplan ohne Modul %1 nicht untersttzt"
 
 msgid "grove plan including module %1 not supported"
-msgstr "Groveplan mit Modul %1 nicht untersttzt"
+msgstr "Groveplan mit Modul %1 nicht untersttzt"
 
 msgid "%1 not an SGML property set module"
 msgstr "%1 ist kein Modul der SGML-Eigenschaftsmenge"
@@ -702,22 +704,22 @@
 "Function for char-map characteristic returned non-char object %2 for "
 "character %1"
 msgstr ""
-"Die Funktion fr die char-map Charakteristik lieferte fr das Zeichen %1 das "
+"Die Funktion fr die char-map Charakteristik lieferte fr das Zeichen %1 das "
 "nicht-Zeichen %2"
 
 msgid ""
 "value for character property %1 of wrong type: %2 not a public identifier or "
 "the value \"#f\""
 msgstr ""
-"Wert fr Zeicheneigenschaft %1 vom falschen Typ: %2 ist weder ein "
-"ffentlicher Bezeichner noch \"#f\""
+"Wert fr Zeicheneigenschaft %1 vom falschen Typ: %2 ist weder ein ffentlicher "
+"Bezeichner noch \"#f\""
 
 #, fuzzy
 msgid "variable %1 occurs more than once in bindings"
 msgstr "Variable %1 kommt mehrfach in den Bindungen vor"
 
 msgid "exactly one of node:, subgrove: and class: needed"
-msgstr "Genau eines von node:, subgrove: und class: bentigt"
+msgstr "Genau eines von node:, subgrove: und class: bentigt"
 
 msgid "add:, null:, remove:, children:, sub: make no sense with subgrove:"
 msgstr ""
@@ -728,8 +730,7 @@
 msgstr "remove: macht keinen Sinn mit class:"
 
 msgid "%2 argument for primitive %1 of wrong type: %3 not a subgrove-spec"
-msgstr ""
-"%2 Argument fr Funktion %1 vom falschen Typ: %2 ist kein subgrove-spec"
+msgstr "%2 Argument fr Funktion %1 vom falschen Typ: %2 ist kein subgrove-spec"
 
 msgid "wrong type: %1 not a list of create-specs"
 msgstr "Falscher Typ: %1 ist keine Liste von create-specs"
@@ -741,48 +742,46 @@
 msgstr "query-Ausdruck: %1 ist keine Knotenliste"
 
 msgid "priority expression: %1 not an exact integer"
-msgstr "Priorittsausdruck: %1 ist keine exakte ganze Zahl"
+msgstr "Priorittsausdruck: %1 ist keine exakte ganze Zahl"
 
 msgid ""
-"flow objects at the root must be all of class scroll or all of class "
-"page-sequence or simple-page-sequence"
+"flow objects at the root must be all of class scroll or all of class page-"
+"sequence or simple-page-sequence"
 msgstr ""
-"Fluobjekte an der Wurzel mssen all der Klasse scroll oder alle den Klassen "
-"page-sequence oder simple-page-sequence angehren"
+"Fluobjekte an der Wurzel mssen all der Klasse scroll oder alle den Klassen "
+"page-sequence oder simple-page-sequence angehren"
 
 msgid "current flow parent has no principal port"
-msgstr "Gegenwrtiger Fluvater hat keinen Hauptport"
+msgstr "Gegenwrtiger Fluvater hat keinen Hauptport"
 
 msgid "this flow object requires a paragraph as an ancestor flow object"
-msgstr "Dieses Fluobjekt bentigt ein paragraph Fluobjekt als Fluvorgnger"
+msgstr "Dieses Fluobjekt bentigt ein paragraph Fluobjekt als Fluvorgnger"
 
 msgid "flow object not accepted by port; only inline flow objects accepted"
-msgstr ""
-"Fluobjekt nicht vom Port akzeptiert: nur inline Fluobjekte akzeptiert"
+msgstr "Fluobjekt nicht vom Port akzeptiert: nur inline Fluobjekte akzeptiert"
 
 msgid "flow object not accepted by port; only display flow objects accepted"
-msgstr ""
-"Fluobjekt nicht vom Port akzeptiert: nur display Fluobjekte akzeptiert"
+msgstr "Fluobjekt nicht vom Port akzeptiert: nur display Fluobjekte akzeptiert"
 
 msgid ""
 "flow object not accepted by port; only display or inline flow objects "
 "accepted"
 msgstr ""
-"Fluobjekt nicht vom Port akzeptiert: nur display oder inline Fluobjekte "
+"Fluobjekt nicht vom Port akzeptiert: nur display oder inline Fluobjekte "
 "akzeptiert"
 
 msgid ""
-"flow object not accepted in a paragraph; only inline, display or "
-"paragraph-break flow objects accepted"
+"flow object not accepted in a paragraph; only inline, display or paragraph-"
+"break flow objects accepted"
 msgstr ""
-"Fluobjekt nicht innerhalb eines paragraph Fluobjekts akzeptiert: nur "
-"inline, display oder paragraph-break Fluobjekte akzeptiert"
+"Fluobjekt nicht innerhalb eines paragraph Fluobjekts akzeptiert: nur inline, "
+"display oder paragraph-break Fluobjekte akzeptiert"
 
 msgid ""
 "a side-by-side flow object only accepts side-by-side-item flow objects as "
 "children"
 msgstr ""
-"Ein side-by-side Fluobjekt akzeptiert nur side-by-side-item Fluobjekte als "
+"Ein side-by-side Fluobjekt akzeptiert nur side-by-side-item Fluobjekte als "
 "Kinder"
 
 msgid ""
@@ -790,19 +789,18 @@
 "superscript, script, mark, fence, fraction, radical, math-operator, grid, "
 "character and alignment-point flow objects accepted"
 msgstr ""
-"Fluobjekt nicht vom Port akzeptiert: nur math-sequence, unmath, subscript, "
+"Fluobjekt nicht vom Port akzeptiert: nur math-sequence, unmath, subscript, "
 "superscript, script, mark, fence, fraction, radical, math-operator, grid, "
-"character und alignment-point Fluobjekte akzeptiert"
+"character und alignment-point Fluobjekte akzeptiert"
 
 msgid "flow object not accepted by port; must be grid-cell"
-msgstr ""
-"Fluobjekt nicht vom Port akzeptiert: mu ein grid-cell Fluobjekt sein"
+msgstr "Fluobjekt nicht vom Port akzeptiert: mu ein grid-cell Fluobjekt sein"
 
 msgid ""
 "flow object not accepted by port; only a single character flow object "
 "accepted"
 msgstr ""
-"Fluobjekt nicht vom Port akzeptiert: nur ein einzelnes character Fluobjekt "
+"Fluobjekt nicht vom Port akzeptiert: nur ein einzelnes character Fluobjekt "
 "akzeptiert"
 
 msgid ""
@@ -810,31 +808,31 @@
 "objects or table-column flow objects followed by table-row or table-cell "
 "flow objects are allowed"
 msgstr ""
-"Fluobjekt nicht vom Port akzeptiert: in einer Tabelle werden entweder nur "
-"table-part Fluobjekte oder table-column Fluobjekte, gefolgt von table-row "
-"oder table-column Fluobjekten, akzeptiert"
+"Fluobjekt nicht vom Port akzeptiert: in einer Tabelle werden entweder nur "
+"table-part Fluobjekte oder table-column Fluobjekte, gefolgt von table-row "
+"oder table-column Fluobjekten, akzeptiert"
 
 msgid ""
 "flow object not accepted by port; only table-row or table-cell flow objects "
 "accepted"
 msgstr ""
-"Fluobjekt nicht vom Port akzeptiert: nur table-row oder table-cell "
-"Fluobjekte akzeptiert"
+"Fluobjekt nicht vom Port akzeptiert: nur table-row oder table-cell "
+"Fluobjekte akzeptiert"
 
 msgid ""
 "flow object not accepted by port; only table-column flow objects followed by "
 "table-row or table-cell flow objects allowd"
 msgstr ""
-"Fluobjekt nicht vom Port akzeptiert: nur table-column Fluobjekte, gefolgt "
-"von table-row oder table-cell Fluobjekten, akzeptiert"
+"Fluobjekt nicht vom Port akzeptiert: nur table-column Fluobjekte, gefolgt "
+"von table-row oder table-cell Fluobjekten, akzeptiert"
 
 msgid "flow object not accepted by port; only table-cell flow objects accepted"
 msgstr ""
-"Fluobjekt nicht vom Port akzeptiert: nur table-cell Fluobjekte akzeptiert"
+"Fluobjekt nicht vom Port akzeptiert: nur table-cell Fluobjekte akzeptiert"
 
 #, fuzzy
 msgid "priority-expression must be a number"
-msgstr "Priorittsausdruck: %1 ist keine exakte ganze Zahl"
+msgstr "Priorittsausdruck: %1 ist keine exakte ganze Zahl"
 
 #, fuzzy
 msgid "query-expression must be a node-list"
@@ -844,32 +842,33 @@
 msgstr ""
 
 #~ msgid "MIF: cannot open output file %1 (%2)"
-#~ msgstr "Ausgabedatei %1 kann nicht geffnet werden (%2)"
+#~ msgstr "Ausgabedatei %1 kann nicht geffnet werden (%2)"
 
 #~ msgid "MIF: could not convert system identifier %1 to a single filename"
 #~ msgstr ""
 #~ "Konnte Systembezeichner %1 nicht in einzelnen Dateinamen konvertieren"
 
 #~ msgid "TeX backend does not currently support HTML links"
-#~ msgstr "TeX Ausgabe untersttzt keine HTML Verknpfungen"
+#~ msgstr "TeX Ausgabe untersttzt keine HTML Verknpfungen"
 
 #~ msgid "syntactic keyword %1 not valid in call position"
-#~ msgstr "Syntaktisches Schlsselwort %1 in Aufrufposition nicht gltig"
+#~ msgstr "Syntaktisches Schlsselwort %1 in Aufrufposition nicht gltig"
 
 #~ msgid "symbol required (got %1)"
-#~ msgstr "Symbol bentigt (fand %1)"
+#~ msgstr "Symbol bentigt (fand %1)"
 
 #~ msgid ""
-#~ "%2 argument for primitive %1 of wrong type: %3 neither a string not a symbol"
+#~ "%2 argument for primitive %1 of wrong type: %3 neither a string not a "
+#~ "symbol"
 #~ msgstr ""
-#~ "%2 Argument fr Funktion %1 vom falschen Typ: %3 ist weder Zeichenkette noch "
-#~ "Symbol"
+#~ "%2 Argument fr Funktion %1 vom falschen Typ: %3 ist weder Zeichenkette "
+#~ "noch Symbol"
 
 #~ msgid ""
-#~ "%2 argument for primitive %1 of wrong type: %3 not a valid element matching "
-#~ "pattern"
+#~ "%2 argument for primitive %1 of wrong type: %3 not a valid element "
+#~ "matching pattern"
 #~ msgstr ""
-#~ "%2 Argument fr Funktion %1 vom falschen Typ: %3 ist kein gltiges "
+#~ "%2 Argument fr Funktion %1 vom falschen Typ: %3 ist kein gltiges "
 #~ "Elementsuchmuster"
 
 #~ msgid "duplicate declaration element (%1)"
--- openjade-1.4devel1.orig/po/ja.po
+++ openjade-1.4devel1/po/ja.po
@@ -0,0 +1,851 @@
+# ja.po for openjade.
+# Copyright (C) 2000, 2001 SATO Satoru
+# Satoru Sato <ss@gnome.gr.jp>, 2001.
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: openjade 1.4devel1\n"
+"POT-Creation-Date: 2001-03-26 02:32+0000\n"
+"PO-Revision-Date: 2000-10-15 23:59+09:00\n"
+"Last-Translator: Satoru Sato <ss@gnome.gr.jp>\n"
+"Language-Team: Japanese <translation@gnome.gr.jp>\n"
+"MIME-Version:: 1.0\n"
+"Content-Type: text/plain; charset=euc-jp\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+msgid "cannot open output file %1 (%2)"
+msgstr " %1 (%2) "
+
+msgid "unknown output type %1"
+msgstr " %1"
+
+msgid "empty output filename"
+msgstr ""
+
+msgid "Use the backend %1."
+msgstr " %1 "
+
+msgid "Send output to %1."
+msgstr " %1 "
+
+msgid "FILE"
+msgstr "FILE"
+
+msgid "TYPE"
+msgstr "TYPE"
+
+msgid "could not convert system identifier %1 to a single filename"
+msgstr " %1 "
+
+msgid "missing table column flow object (table-auto-width feature not fully supported)"
+msgstr ""
+""
+"(table-auto-width )"
+
+msgid "nested tables are not allowed in RTF"
+msgstr " RTF "
+
+msgid "could not embed %1 with clsid %2"
+msgstr "%1  clsid %2 "
+
+msgid "TeX backend does not currently support references to page numbers of nodes other than elements"
+msgstr ""
+"TeX "
+""
+
+msgid "TeX backend does not currently support links to nodes other than elements"
+msgstr ""
+"TeX "
+""
+
+msgid "TeX backend does not currently support links to entities"
+msgstr ""
+"TeX "
+""
+
+msgid "TeX backend does not currently support links to other SGML documents"
+msgstr ""
+"TeX  SGML "
+""
+
+msgid "TeX backend does not currently support HyTime linkends"
+msgstr ""
+"TeX  HyTime linkend "
+
+msgid "TeX backend does not currently support TEI links"
+msgstr ""
+"TeX  TEI "
+
+msgid "TeX backend does not currently support glyph substitution tables"
+msgstr ""
+"TeX  glyph "
+
+msgid "%1 version %2"
+msgstr "%1  %2"
+
+msgid "no DSSSL specification: use -d to specify"
+msgstr "DSSSL : -d "
+
+msgid "no applicable processing instruction with title %1; available titles: %2"
+msgstr "title %1  title : %2"
+
+msgid "Options with a \"doc-\"/\"spec-\" prefix apply only to the document/specification."
+msgstr ""
+"\"doc-\"/\"spec-\" prefix  document/specification "
+""
+
+msgid "Enable experimental DSSSL extensions."
+msgstr " DSSSL "
+
+msgid "Debug mode."
+msgstr ""
+
+msgid "Use DSSSL specification %1."
+msgstr "DSSSL  %1 "
+
+msgid "Use DSSSL specification with title %1."
+msgstr "title %1  DSSSL "
+
+msgid "Pretend that %1 appeared in the specification."
+msgstr "%1 "
+
+msgid "Strict DSSSL compliance mode."
+msgstr " DSSSL "
+
+msgid "Show open entities in error messages."
+msgstr ""
+
+msgid "Show open elements in error messages."
+msgstr ""
+
+msgid "Show error numbers in error messages."
+msgstr ""
+
+msgid "Show references in error messages."
+msgstr ""
+
+msgid "Define parameter entity %1 as \"INCLUDE\"."
+msgstr ""
+" %1  \"INCLUDE\" "
+
+msgid "Enable warning %1."
+msgstr " %1 "
+
+msgid "SYSID"
+msgstr "SYSID"
+
+msgid "DEFINITION"
+msgstr "DEFINITION"
+
+msgid "NAME"
+msgstr "NAME"
+
+msgid "unexpected end of file"
+msgstr " EOF"
+
+msgid "invalid character"
+msgstr ""
+
+msgid "invalid character after '#'"
+msgstr "'#' "
+
+msgid "unknown #! named constant %1"
+msgstr " %1  #!"
+
+msgid "unexpected token %1"
+msgstr " %1"
+
+msgid "string with no closing quote"
+msgstr ""
+
+msgid "missing closing parenthesis"
+msgstr ""
+
+msgid "invalid number %1"
+msgstr " %1"
+
+msgid "invalid AFII glyph identifier %1"
+msgstr " AFII glyph  %1"
+
+msgid "call of non-function object %1"
+msgstr " %1 "
+
+msgid "too many arguments for function"
+msgstr ""
+
+msgid "odd number of keyword/value arguments"
+msgstr "keyword/value "
+
+msgid "missing argument for function call"
+msgstr ""
+
+msgid "syntactic keyword %1 used as variable"
+msgstr " keyword %1 "
+
+msgid "reference to undefined variable %1"
+msgstr " %1 "
+
+msgid "no character with name %1"
+msgstr " %1 "
+
+msgid "unknown top level form %1"
+msgstr " form %1"
+
+msgid "bad form %1 in mode group"
+msgstr " form %1"
+
+msgid "identifier %1 already defined in same part"
+msgstr " %1 "
+
+msgid "first definition was here"
+msgstr ""
+
+msgid "loop in specification of value of %1"
+msgstr "%1 "
+
+msgid "argument out of range"
+msgstr ""
+
+msgid "loop in specification of value of unit %1"
+msgstr " %1 "
+
+msgid "bad value specified for unit %1"
+msgstr " %1 "
+
+msgid "unit %1 already defined in same part"
+msgstr " %1 "
+
+msgid "quantity %1 undefined"
+msgstr "quantity %1 "
+
+msgid "incompatible dimensions"
+msgstr " dimension"
+
+msgid "%2 argument for primitive %1 of wrong type: %3 not a boolean"
+msgstr ""
+"%2 ( %1 ): "
+"%3  (boolean) "
+
+msgid "%2 argument for primitive %1 of wrong type: %3 not a pair"
+msgstr ""
+"%2 ( %1 ): "
+"%3  (pair) "
+
+msgid "%2 argument for primitive %1 of wrong type: %3 not a list"
+msgstr ""
+"%2 ( %1 ): "
+"%3  (list) "
+
+msgid "%2 argument for primitive %1 of wrong type: %3 not a symbol"
+msgstr ""
+"%2 ( %1 ): "
+"%3  (symbol) "
+
+msgid "%2 argument for primitive %1 of wrong type: %3 not a string"
+msgstr ""
+"%2 ( %1 ): "
+"%3  (string) "
+
+msgid "%2 argument for primitive %1 of wrong type: %3 not a string or symbol"
+msgstr ""
+"%2 ( %1 ): "
+"%3  (string)  (symbol) "
+
+msgid "%2 argument for primitive %1 of wrong type: %3 not a char"
+msgstr ""
+"%2 ( %1 ): "
+"%3  (char) "
+
+msgid "%2 argument for primitive %1 of wrong type: %3 not an ISO8601 time string"
+msgstr ""
+"%2 ( %1 ): "
+"%3  ISO8601 time "
+
+msgid "%2 argument for primitive %1 of wrong type: %3 not a style"
+msgstr ""
+"%2 ( %1 ): "
+"%3  (style) "
+
+msgid "%2 argument for primitive %1 of wrong type: %3 not an exact integer"
+msgstr ""
+"%2 ( %1 ): "
+"%3  (exact integer) "
+
+msgid "%2 argument for primitive %1 of wrong type: %3 not a quantity"
+msgstr ""
+"%2 ( %1 ): "
+"%3  quantity "
+
+msgid "%2 argument for primitive %1 of wrong type: %3 not a color-space"
+msgstr ""
+"%2 ( %1 ): %3 \n"
+"color-space "
+
+msgid "%2 argument for primitive %1 of wrong type: %3 not a number"
+msgstr ""
+"%2 ( %1 ): "
+"%3  (number) "
+
+msgid "%2 argument for primitive %1 of wrong type: %3 not a sosofo"
+msgstr ""
+"%2 ( %1 ): "
+"%3  sosofo "
+
+msgid "%2 argument for primitive %1 of wrong type: %3 not an optional singleton node list"
+msgstr ""
+"%2 ( %1 ): "
+"%3  (optional singleton node list) "
+""
+
+msgid "%2 argument for primitive %1 of wrong type: %3 not a singleton node list"
+msgstr ""
+"%2 ( %1 ): "
+"%3  (singleton node list) "
+
+msgid "%2 argument for primitive %1 of wrong type: %3 not a node list"
+msgstr ""
+"%2 ( %1 ): "
+"%3  (node list) "
+
+msgid "%2 argument for primitive %1 of wrong type: %3 not a named node list"
+msgstr ""
+"%2 ( %1 ): "
+"%3  (named node list) "
+
+msgid "%2 argument for primitive %1 of wrong type: %3 not a length or length-spec"
+msgstr ""
+"%2 ( %1 ): "
+"%3  length  length-spec "
+
+msgid "%2 argument for primitive %1 of wrong type: %3 not a quantity or length-spec"
+msgstr ""
+"%2 ( %1 ): "
+"%3  quantity  length-spec "
+
+msgid "%2 argument for primitive %1 of wrong type: %3 not an integer or the symbol \"force\""
+msgstr ""
+"%2 ( %1 ): "
+"%3  (integer)  (symbol) \"force\" "
+""
+
+msgid "%2 argument for primitive %1 of wrong type: %3 not an address"
+msgstr ""
+"%2 ( %1 ): "
+"%3  (address) "
+
+msgid "%2 argument for primitive %1 of wrong type: %3 not a glyph-id"
+msgstr ""
+"%2 ( %1 ): "
+"%3  glyph-id "
+
+msgid "%2 argument for primitive %1 of wrong type: %3 not a glyph-subst-table"
+msgstr ""
+"%2 ( %1 ): "
+"%3  glyph-subset-table "
+
+msgid "%2 argument for primitive %1 of wrong type: %3 not a list of pairs of glyph-ids"
+msgstr ""
+"%2 ( %1 ): "
+"%3  glyph-id  (pair)  (list) "
+
+msgid "%2 argument for primitive %1 of wrong type: %3 not a procedure"
+msgstr ""
+"%2 ( %1 ): "
+"%3  (procedure) "
+
+msgid "%2 argument for primitive %1 of wrong type: %3 not a vector"
+msgstr ""
+"%2 ( %1 ): "
+"%3  (vector) "
+
+msgid "root rule already defined in same part with same importance"
+msgstr ""
+"root rule "
+
+msgid "initial value already declared for characteristic %1 in same part"
+msgstr " %1 "
+
+msgid "first declaration was here"
+msgstr ""
+
+msgid "%1 is not a valid keyword in a style expression"
+msgstr "%1  keyword "
+
+msgid "%1 is not a valid keyword in a make expression for flow object class %2"
+msgstr "%1  %2  keyword "
+
+msgid "%1 is not the name of any flow object class"
+msgstr "%1 "
+
+msgid "content expression cannot be specified in make expression for atomic flow object class %1"
+msgstr ""
+" (atomic)  %1 "
+" (content expression) "
+
+msgid "value for \"label:\" not a symbol"
+msgstr "\"label:\"  (symbol) "
+
+msgid "no port for label %1"
+msgstr "label %1  port "
+
+msgid "invalid content map"
+msgstr " content map"
+
+msgid "content map references non-existent port %1"
+msgstr "content map  port %1 "
+
+msgid "invalid value for %1 characteristic"
+msgstr "%1 "
+
+msgid "no clause in cond expression matched"
+msgstr "cond  clause "
+
+msgid "no clause in case expression matched %1"
+msgstr "case  %1  clause "
+
+msgid "expected \"else\" not %1"
+msgstr " \"else\"  %1 "
+
+msgid "sorry, cannot handle unresolvable quantities in datums in case expression"
+msgstr " case  data  quantity "
+
+msgid "%1"
+msgstr "%1"
+
+msgid "division by zero"
+msgstr "0 "
+
+msgid "procedure does not have %1 keyword argument"
+msgstr " (procedure)  %1 "
+
+msgid "argument not a keyword"
+msgstr ""
+
+msgid "specification document does not have the DSSSL architecture as a base architecture"
+msgstr " DSSSL "
+
+msgid "specification document did not contain a style-specification-body element"
+msgstr ""
+" style-specification-body "
+
+msgid "unknown character name %1"
+msgstr " %1"
+
+msgid "attempt to use current node when there is none"
+msgstr ""
+
+msgid "attempt to process node in illegal context"
+msgstr ""
+
+msgid "radix must be 2, 8, 10 or 16"
+msgstr " 281016 "
+
+msgid "this context requires a sosofo"
+msgstr " sosofo "
+
+msgid "this context requires a style object"
+msgstr " (style) "
+
+msgid "procedure can only be used in evaluation of characteristic value"
+msgstr "procedure "
+
+msgid "%1 color requires three arguments"
+msgstr "%1 "
+
+msgid "arguments for %1 color must be numbers"
+msgstr "%1 "
+
+msgid "arguments for %1 color must be in the range 0 to 1"
+msgstr "%1  0  1 "
+
+msgid "result of procedure in %1 color must be a number"
+msgstr "%1  procedure "
+
+msgid "unknown color-space family %1"
+msgstr " color-space  %1"
+
+msgid "%1 color-space family does not take any arguments"
+msgstr "%1 color-space "
+
+msgid "invalid parameters for %1 color-space family"
+msgstr "%1 color-space "
+
+msgid "%1 is not a pre-defined inherited characteristic"
+msgstr "%1 "
+
+msgid "invalid number format %1"
+msgstr " %1"
+
+msgid "invalid character %1 in public identifier"
+msgstr " %1"
+
+msgid "debug %1"
+msgstr " %1"
+
+msgid "circular use of specification parts"
+msgstr ""
+
+msgid "no style-specification or external-specification with ID %1"
+msgstr ""
+"ID %1  style-specification  external-specification "
+
+msgid "document did not contain any style-specifications or external-specifications"
+msgstr ""
+" style-specification  external-specification "
+
+msgid "table-cell flow object not inside a table"
+msgstr "table-cell "
+
+msgid "table-row flow object not inside a table"
+msgstr "table-row "
+
+msgid "no value for node property %1"
+msgstr " %1 "
+
+msgid "value returned by procedure was not a node-list"
+msgstr "procedure "
+
+msgid "called from here"
+msgstr ""
+
+msgid "called from here...(%1 calls omitted)"
+msgstr "... (%1 )"
+
+msgid "node processing loop detected"
+msgstr ""
+
+msgid "unquote-splicing expression does not evaluate to a list"
+msgstr "unquote-splicing "
+
+msgid "object is read-only"
+msgstr " read-only "
+
+msgid "assignment to top-level variable %1"
+msgstr " %1 "
+
+msgid "invalid call to continuation"
+msgstr ""
+
+msgid "empty generic identifier in pattern"
+msgstr ""
+
+msgid "pattern is not a list"
+msgstr ""
+
+msgid "%1 cannot be used as a generic identifier in a pattern"
+msgstr "%1 "
+
+msgid "%1 cannot occur in a pattern"
+msgstr "%1 "
+
+msgid "value missing for qualifier in pattern"
+msgstr " qualifier "
+
+msgid "unknown pattern qualifier %1"
+msgstr " qualifier %1"
+
+msgid "bad value %1 for %2 qualifier in pattern"
+msgstr " %1 (%2 ) qualifier"
+
+msgid "repeat qualifier not allowed inside children qualifier"
+msgstr " qualifier  qualifier "
+
+msgid "bad value for attributes qualifier in pattern"
+msgstr " qualifier "
+
+msgid "characteristic %1 applied in style rule with same specificity"
+msgstr " %1 "
+
+msgid "other style rule is here"
+msgstr ""
+
+msgid "node matches more than one pattern with the same specificity"
+msgstr ""
+
+msgid "reference to uninitialized variable %1"
+msgstr " %1 "
+
+msgid "circular use of actual value of characteristic %1"
+msgstr " %1 "
+
+msgid "characteristic %1 already defined in same part"
+msgstr " %1 "
+
+msgid "flow object class %1 already defined in same part"
+msgstr " %1 "
+
+msgid "mode %1 not defined"
+msgstr " %1 "
+
+msgid "duplicate character name %1"
+msgstr " %1"
+
+msgid "duplicate SDATA entity name %1"
+msgstr " SDATA  %1"
+
+msgid "duplicate SDATA entity text %1"
+msgstr " SDATA  %1"
+
+msgid "unsupported declaration will be ignored"
+msgstr ""
+
+msgid "unsupported character repertoire %1 will be ignored"
+msgstr " %1 "
+
+msgid "error in declaration element"
+msgstr ""
+
+msgid "%1 is not a valid identifier"
+msgstr "%1 "
+
+msgid "error in language definition"
+msgstr ""
+
+msgid "no current language"
+msgstr ""
+
+msgid "%2 argument for primitive %1 of wrong type: %3 not a language"
+msgstr ""
+" %2 ( %1 ): "
+"%3 "
+
+msgid "%2 argument for primitive %1 of wrong type: %3 not a positive integer"
+msgstr ""
+" %2 ( %1 ): "
+"%3 "
+
+msgid "%2 argument for primitive %1 of wrong type: %3 not an integer"
+msgstr ""
+" %2 ( %1 ): "
+"%3 "
+
+msgid "%2 argument for primitive %1 of wrong type: %3 not a keyword"
+msgstr ""
+" %2 ( %1 ): "
+"%3 "
+
+msgid "%2 argument for primitive %1 of wrong type: %3 not an alist"
+msgstr ""
+" %2 ( %1 ): "
+"%3  (alist) "
+
+msgid "%2 argument for primitive %1 of wrong type: %3 not a list of characters"
+msgstr ""
+" %2 ( %1 ): "
+"%3 "
+
+msgid "%2 argument for primitive %1 has wrong length"
+msgstr ""
+"%2 ( %1 ) length "
+
+msgid "quantity %1 can't be represented exactly"
+msgstr "quantity %1 "
+
+msgid "default language already declared in this part"
+msgstr ""
+
+msgid "%1 not a language as required in a default-language-declaration"
+msgstr "%1  default-language-declaration "
+
+msgid "%1 not a valid unit name"
+msgstr "%1 "
+
+msgid "%1 not a valid character name"
+msgstr "%1 "
+
+msgid "%1 not a valid character number"
+msgstr "%1 "
+
+msgid "unknown character property %1"
+msgstr " %1"
+
+msgid "error in character property declaration"
+msgstr ""
+
+msgid "character property %1 already declared in same part"
+msgstr " %1 "
+
+msgid "added value for character property %1 already declared in same part"
+msgstr ""
+" %1 "
+
+msgid "previous declaration was here"
+msgstr ""
+
+msgid "value returned by procedure was not a sosofo"
+msgstr "procedure  sosofo "
+
+msgid "loop in specification of value of character property %1"
+msgstr " %1 "
+
+msgid "value for character property %1 of wrong type: %2 not an integer"
+msgstr ""
+" %1 : %2 "
+
+msgid "value for character property %1 of wrong type: %2 not an integer or the value \"#f\""
+msgstr ""
+" %1 : "
+"%2  \"#f\" "
+
+msgid "%1 not a style or transformation language feature"
+msgstr "%1 "
+
+msgid "undeclared use of feature %1"
+msgstr " %1 "
+
+msgid "feature %1 not supported"
+msgstr " %1 "
+
+msgid "feature %1 only partially supported"
+msgstr " %1 "
+
+msgid "only allowed in style language"
+msgstr ""
+
+msgid "only allowed in transformation language"
+msgstr ""
+
+msgid "style and transformation language parts mixed"
+msgstr ""
+
+msgid "specification is marked as partial"
+msgstr "specification  partial "
+
+msgid "grove plan excluding module %1 not supported"
+msgstr "grove plan excluding  %1 "
+
+msgid "grove plan including module %1 not supported"
+msgstr "grove plan including  %1 "
+
+msgid "%1 not an SGML property set module"
+msgstr "%1  SGML "
+
+msgid "Function for char-map characteristic returned non-char object %2 for character %1"
+msgstr ""
+"char-map  non-char  %2 "
+"( %1 )"
+
+msgid "value for character property %1 of wrong type: %2 not a public identifier or the value \"#f\""
+msgstr ""
+" %1 : %2  \"#f\" "
+
+msgid "variable %1 occurs more than once in bindings"
+msgstr " %1 "
+
+msgid "exactly one of node:, subgrove: and class: needed"
+msgstr ""
+" node:subgrove:class: "
+
+msgid "add:, null:, remove:, children:, sub: make no sense with subgrove:"
+msgstr ""
+"add:, null:, remove:, children:, sub: subgrove :"
+
+msgid "remove: makes no sense with class:"
+msgstr "remove: "
+
+msgid "%2 argument for primitive %1 of wrong type: %3 not a subgrove-spec"
+msgstr ""
+" %2 ( %1 ): "
+"%3  subgrove-spec "
+
+msgid "wrong type: %1 not a list of create-specs"
+msgstr ""
+": %1  create-spec "
+
+msgid "wrong type: %1 not a create-spec or list of create-specs"
+msgstr ""
+": %1  create-spec  create-spec "
+
+msgid "query expression: %1 not a node list"
+msgstr ": %1 "
+
+msgid "priority expression: %1 not an exact integer"
+msgstr ": %1 "
+
+msgid "flow objects at the root must be all of class scroll or all of class page-sequence or simple-page-sequence"
+msgstr ""
+"root  scroll "
+" page-sequence  simple-page-sequence "
+""
+
+msgid "current flow parent has no principal port"
+msgstr " parent  principal port "
+
+msgid "this flow object requires a paragraph as an ancestor flow object"
+msgstr ""
+""
+""
+
+msgid "flow object not accepted by port; only inline flow objects accepted"
+msgstr ""
+"port : "
+"inline "
+
+msgid "flow object not accepted by port; only display flow objects accepted"
+msgstr ""
+"port : "
+"display "
+
+msgid "flow object not accepted by port; only display or inline flow objects accepted"
+msgstr ""
+"port : "
+"display  inline "
+
+msgid "flow object not accepted in a paragraph; only inline, display or paragraph-break flow objects accepted"
+msgstr ""
+"paragraph : "
+"inline  display paragraph-break "
+""
+
+msgid "a side-by-side flow object only accepts side-by-side-item flow objects as children"
+msgstr ""
+"side-by-side  side-by-side-item "
+""
+
+msgid "flow object not accepted by port; only math-sequence, unmath, subscript, superscript, script, mark, fence, fraction, radical, math-operator, grid, character and alignment-point flow objects accepted"
+msgstr ""
+"port ; math-sequence"
+"unmathsubscriptsuperscriptscriptmarkfence"
+"fractionradicalmath-operatorgridcharacter  "
+"alignment-point "
+
+msgid "flow object not accepted by port; must be grid-cell"
+msgstr ""
+"port ; grid-call "
+
+msgid "flow object not accepted by port; only a single character flow object accepted"
+msgstr ""
+"port ; single character "
+""
+
+msgid "flow object not accepted by port; in a table, only either table-part flow objects or table-column flow objects followed by table-row or table-cell flow objects are allowed"
+msgstr ""
+"port : "
+"table table-row  table-cell "
+"table-part  table-column "
+""
+
+msgid "flow object not accepted by port; only table-row or table-cell flow objects accepted"
+msgstr ""
+"port ; "
+"table-row  table-cell "
+
+msgid "flow object not accepted by port; only table-column flow objects followed by table-row or table-cell flow objects allowd"
+msgstr ""
+"port ; "
+"table-row  table-cell "
+"table-column "
+
+msgid "flow object not accepted by port; only table-cell flow objects accepted"
+msgstr ""
+"porc ; table-cell "
+""
+
+msgid "priority-expression must be a number"
+msgstr "priority-expression "
+
+msgid "query-expression must be a node-list"
+msgstr "query-expression  node-list "
+
+msgid "Sorry, non-integral priorities not implemented"
+msgstr "non-integral priority "
--- openjade-1.4devel1.orig/po/jade.pot
+++ openjade-1.4devel1/po/jade.pot
@@ -6,7 +6,7 @@
 msgid ""
 msgstr ""
 "Project-Id-Version: PACKAGE VERSION\n"
-"POT-Creation-Date: 2000-03-28 14:20+0000\n"
+"POT-Creation-Date: 2003-09-29 14:47+0000\n"
 "PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
 "Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
 "Language-Team: LANGUAGE <LL@li.org>\n"
@@ -227,6 +227,9 @@
 msgid "%2 argument for primitive %1 of wrong type: %3 not a char"
 msgstr ""
 
+msgid "%2 argument for primitive %1 of wrong type: %3 not an ISO8601 time string"
+msgstr ""
+
 msgid "%2 argument for primitive %1 of wrong type: %3 not a style"
 msgstr ""
 
--- openjade-1.4devel1.orig/po/stamp-po
+++ openjade-1.4devel1/po/stamp-po
@@ -0,0 +1 @@
+timestamp
--- openjade-1.4devel1.orig/po/sv.po
+++ openjade-1.4devel1/po/sv.po
@@ -2,10 +2,11 @@
 msgid ""
 msgstr ""
 "Project-Id-Version: OpenJade 1.4\n"
-"POT-Creation-Date: 2000-03-28 14:20+0000\n"
+"POT-Creation-Date: 2003-09-29 14:47+0000\n"
 "PO-Revision-Date: 1999-12-08 23:03+01:00\n"
 "Last-Translator: Peter Nilsson <pnidv96@student.vxu.se>\n"
 "Language-Team: Swedish <sv@li.org>\n"
+"Language: sv\n"
 "MIME-Version:: 1.0\n"
 "Content-Type: text/plain; charset=ISO-8859-1\n"
 "Content-Transfer-Encoding: 8bit\n"
@@ -87,8 +88,8 @@
 msgstr ""
 
 msgid ""
-"Options with a \"doc-\"/\"spec-\" prefix apply only to the "
-"document/specification."
+"Options with a \"doc-\"/\"spec-\" prefix apply only to the document/"
+"specification."
 msgstr ""
 
 msgid "Enable experimental DSSSL extensions."
@@ -242,6 +243,11 @@
 msgid "%2 argument for primitive %1 of wrong type: %3 not a char"
 msgstr "%2 argumentet till primitiven %1 r av fel typ: %3 r inget tecken"
 
+#, fuzzy
+msgid ""
+"%2 argument for primitive %1 of wrong type: %3 not an ISO8601 time string"
+msgstr "%2 argumentet till primitiven %1 r av fel typ: %3 r ingen strng"
+
 msgid "%2 argument for primitive %1 of wrong type: %3 not a style"
 msgstr "%2 argumentet till primitiven %1 r av fel typ: %3 inget stilobjekt"
 
@@ -254,8 +260,8 @@
 
 msgid "%2 argument for primitive %1 of wrong type: %3 not a color-space"
 msgstr ""
-"%2 argumentet till primitiven %1 r av fel typ: %3 r inte av typen "
-"color-space"
+"%2 argumentet till primitiven %1 r av fel typ: %3 r inte av typen color-"
+"space"
 
 msgid "%2 argument for primitive %1 of wrong type: %3 not a number"
 msgstr "%2 argumentet till primitiven %1 r av fel typ: %3 r inget tal"
@@ -303,8 +309,8 @@
 msgstr ""
 
 msgid ""
-"%2 argument for primitive %1 of wrong type: %3 not a list of pairs of "
-"glyph-ids"
+"%2 argument for primitive %1 of wrong type: %3 not a list of pairs of glyph-"
+"ids"
 msgstr ""
 
 msgid "%2 argument for primitive %1 of wrong type: %3 not a procedure"
@@ -700,8 +706,8 @@
 msgstr ""
 
 msgid ""
-"flow objects at the root must be all of class scroll or all of class "
-"page-sequence or simple-page-sequence"
+"flow objects at the root must be all of class scroll or all of class page-"
+"sequence or simple-page-sequence"
 msgstr ""
 
 msgid "current flow parent has no principal port"
@@ -722,8 +728,8 @@
 msgstr ""
 
 msgid ""
-"flow object not accepted in a paragraph; only inline, display or "
-"paragraph-break flow objects accepted"
+"flow object not accepted in a paragraph; only inline, display or paragraph-"
+"break flow objects accepted"
 msgstr ""
 
 msgid ""
@@ -783,7 +789,8 @@
 #~ msgstr "symbol krvs (istllet fr 1)"
 
 #~ msgid ""
-#~ "%2 argument for primitive %1 of wrong type: %3 neither a string not a symbol"
-#~ msgstr ""
-#~ "%2 argumentet till primitiven %1 r av fel typ: %3 r varken en strng eller "
+#~ "%2 argument for primitive %1 of wrong type: %3 neither a string not a "
 #~ "symbol"
+#~ msgstr ""
+#~ "%2 argumentet till primitiven %1 r av fel typ: %3 r varken en strng "
+#~ "eller symbol"
--- openjade-1.4devel1.orig/spgrove/GroveBuilder.cxx
+++ openjade-1.4devel1/spgrove/GroveBuilder.cxx
@@ -657,11 +657,11 @@
 };
 
 class PrologPiChunk : public PiChunk {
-  AccessResult getFirstSibling(const GroveImpl *, const Chunk *&) const;
+  AccessResult getFirstSibling(const GroveImpl *, const struct Chunk *&) const;
 };
 
 class EpilogPiChunk : public PiChunk {
-  AccessResult getFirstSibling(const GroveImpl *, const Chunk *&) const;
+  AccessResult getFirstSibling(const GroveImpl *, const struct Chunk *&) const;
 };
 
 class PiNode : public ChunkNode {
@@ -3565,13 +3565,13 @@
   return accessOK;
 }
 
-AccessResult PrologPiChunk::getFirstSibling(const GroveImpl *grove, const Chunk *&p) const
+AccessResult PrologPiChunk::getFirstSibling(const GroveImpl *grove, const struct Chunk *&p) const
 {
   p = grove->root()->prolog;
   return accessOK;
 }
 
-AccessResult EpilogPiChunk::getFirstSibling(const GroveImpl *grove, const Chunk *&p) const
+AccessResult EpilogPiChunk::getFirstSibling(const GroveImpl *grove, const struct Chunk *&p) const
 {
   p = grove->root()->epilog;
   return accessOK;
@@ -5855,7 +5855,7 @@
 AccessResult ElementTypeNode::getRankStem(GroveString &str) const
 {
   const ElementDefinition *def = elementType_.definition();
-  if (def == 0  || !def->nRankStems() != 1)
+  if (def == 0  || def->nRankStems() != 1)
     return accessNull;
   setString(str, def->rankStem(0)->name());
   return accessOK;
--- openjade-1.4devel1.orig/spgrove/GroveBuilder.tmp.cxx
+++ openjade-1.4devel1/spgrove/GroveBuilder.tmp.cxx
@@ -0,0 +1,21891 @@
+# 1 "GroveBuilder.cxx"
+# 1 "/home/neil/debian/openjade1.4/1.4devel1/openjade-1.4devel1/spgrove//"
+# 1 "<built-in>"
+# 1 "<command line>"
+# 1 "GroveBuilder.cxx"
+
+
+
+
+
+# 1 "../config.h" 1
+
+
+
+
+
+
+# 1 "/usr/include/OpenSP/config.h" 1 3 4
+# 8 "../config.h" 2
+# 7 "GroveBuilder.cxx" 2
+# 1 "/usr/include/OpenSP/Boolean.h" 1 3 4
+
+
+
+
+
+
+
+namespace OpenSP {
+
+
+
+
+typedef bool Boolean;
+
+typedef bool PackedBoolean;
+# 28 "/usr/include/OpenSP/Boolean.h" 3 4
+}
+# 8 "GroveBuilder.cxx" 2
+# 1 "../grove/Node.h" 1
+
+
+
+
+
+
+#pragma interface
+
+
+# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
+# 152 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 3 4
+typedef int ptrdiff_t;
+# 214 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 3 4
+typedef unsigned int size_t;
+# 11 "../grove/Node.h" 2
+# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/limits.h" 1 3 4
+# 11 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/limits.h" 3 4
+# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/syslimits.h" 1 3 4
+
+
+
+
+
+
+# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/limits.h" 1 3 4
+# 122 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/limits.h" 3 4
+# 1 "/usr/include/limits.h" 1 3 4
+# 26 "/usr/include/limits.h" 3 4
+# 1 "/usr/include/features.h" 1 3 4
+# 295 "/usr/include/features.h" 3 4
+# 1 "/usr/include/sys/cdefs.h" 1 3 4
+# 296 "/usr/include/features.h" 2 3 4
+# 318 "/usr/include/features.h" 3 4
+# 1 "/usr/include/gnu/stubs.h" 1 3 4
+# 319 "/usr/include/features.h" 2 3 4
+# 27 "/usr/include/limits.h" 2 3 4
+# 144 "/usr/include/limits.h" 3 4
+# 1 "/usr/include/bits/posix1_lim.h" 1 3 4
+# 130 "/usr/include/bits/posix1_lim.h" 3 4
+# 1 "/usr/include/bits/local_lim.h" 1 3 4
+# 36 "/usr/include/bits/local_lim.h" 3 4
+# 1 "/usr/include/linux/limits.h" 1 3 4
+# 37 "/usr/include/bits/local_lim.h" 2 3 4
+# 131 "/usr/include/bits/posix1_lim.h" 2 3 4
+# 145 "/usr/include/limits.h" 2 3 4
+
+
+
+# 1 "/usr/include/bits/posix2_lim.h" 1 3 4
+# 149 "/usr/include/limits.h" 2 3 4
+
+
+
+# 1 "/usr/include/bits/xopen_lim.h" 1 3 4
+# 34 "/usr/include/bits/xopen_lim.h" 3 4
+# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
+# 35 "/usr/include/bits/xopen_lim.h" 2 3 4
+# 153 "/usr/include/limits.h" 2 3 4
+# 123 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/limits.h" 2 3 4
+# 8 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/syslimits.h" 2 3 4
+# 12 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/limits.h" 2 3 4
+# 12 "../grove/Node.h" 2
+# 1 "/usr/include/OpenSP/IList.h" 1 3 4
+
+
+
+
+
+
+# 1 "/usr/include/OpenSP/IListBase.h" 1 3 4
+
+
+
+
+
+
+# 1 "/usr/include/OpenSP/Link.h" 1 3 4
+
+
+
+
+
+
+
+namespace OpenSP {
+
+
+class Link {
+public:
+  Link();
+  Link(Link *);
+  virtual ~Link();
+private:
+  Link *next_;
+
+friend class IListBase;
+friend class IListIterBase;
+friend class IQueueBase;
+};
+
+inline
+Link::Link() : next_(0)
+{
+}
+
+inline
+Link::Link(Link *next) : next_(next)
+{
+}
+
+
+}
+# 8 "/usr/include/OpenSP/IListBase.h" 2 3 4
+# 1 "/usr/include/OpenSP/Boolean.h" 1 3 4
+# 9 "/usr/include/OpenSP/IListBase.h" 2 3 4
+
+
+namespace OpenSP {
+
+
+class IListBase {
+public:
+  IListBase();
+  IListBase(Link *);
+  void append(Link *);
+  void insert(Link *);
+  Link *head() const;
+  Boolean empty() const;
+  Link *get();
+  void remove(Link *);
+  void swap(IListBase &);
+  void clear();
+private:
+  Link *head_;
+friend class IListIterBase;
+};
+
+inline
+IListBase::IListBase() : head_(0)
+{
+}
+
+inline
+IListBase::IListBase(Link *head) : head_(head)
+{
+}
+
+inline
+void IListBase::insert(Link *p)
+{
+  p->next_ = head_;
+  head_ = p;
+}
+
+inline
+Link *IListBase::head() const
+{
+  return head_;
+}
+
+inline
+Boolean IListBase::empty() const
+{
+  return head_ == 0;
+}
+
+inline
+Link *IListBase::get()
+{
+  Link *tem = head_;
+  head_ = head_->next_;
+  return tem;
+}
+
+inline
+void IListBase::swap(IListBase &list)
+{
+  Link *tem = head_;
+  head_ = list.head_;
+  list.head_ = tem;
+}
+
+
+}
+# 8 "/usr/include/OpenSP/IList.h" 2 3 4
+
+
+namespace OpenSP {
+
+
+template<class T> class IListIter;
+
+
+
+template<class T>
+class IList : private IListBase {
+public:
+  IList() { }
+  IList(T *p) : IListBase(p) { }
+  ~IList() { clear(); }
+  void append(T *p) { IListBase::append(p); }
+  void insert(T *p) { IListBase::insert(p); }
+  void remove(T *p) { IListBase::remove(p); }
+  void swap(IList<T> &list) { IListBase::swap(list); }
+  T *head() const { return (T *)IListBase::head(); }
+  T *get() { return (T *)IListBase::get(); }
+  IListBase::clear;
+  IListBase::empty;
+friend class IListIter<T>;
+private:
+  IList(const IList<T> &);
+  IList<T> &operator=(const IList<T> &);
+};
+
+
+}
+# 13 "../grove/Node.h" 2
+# 35 "../grove/Node.h"
+namespace OpenJade_Grove {
+
+
+
+
+typedef unsigned int GroveChar;
+# 49 "../grove/Node.h"
+class NodePtr;
+class NodeListPtr;
+class NamedNodeListPtr;
+class GroveString;
+class NodeVisitor;
+class SdataMapper;
+class GroveStringList;
+class GroveStringListPtr;
+
+enum AccessResult {
+  accessOK,
+  accessNull,
+  accessTimeout,
+  accessNotInClass
+};
+
+struct ComponentName {
+  enum Id {
+    noId = -1,
+    idAllPropertyNames,
+    idAnd,
+    idAny,
+    idApplicationInfo,
+    idAttributeAssignment,
+    idAttributeDef,
+    idAttributeDefs,
+    idAttributes,
+    idAttributeValueToken,
+    idCapacity,
+    idCdata,
+    idChar,
+    idCharset,
+    idChildrenPropertyName,
+    idClassName,
+    idConnector,
+    idConref,
+    idContent,
+    idContentTokens,
+    idContentType,
+    idCurrent,
+    idCurrentAttributeIndex,
+    idCurrentGroup,
+    idDataChar,
+    idDataPropertyName,
+    idDataSepPropertyName,
+    idDeclValueType,
+    idDefaulted,
+    idDefaultedEntities,
+    idDefaultEntity,
+    idDefaultValue,
+    idDefaultValueType,
+    idDoctypesAndLinktypes,
+    idDocument,
+    idDocumentElement,
+    idDocumentType,
+    idDtd,
+    idElement,
+    idElements,
+    idElementToken,
+    idElementType,
+    idElementTypes,
+    idEmpty,
+    idEntities,
+    idEntity,
+    idEntityName,
+    idEntityType,
+    idEpilog,
+    idExclusions,
+    idExternalData,
+    idExternalId,
+    idFixed,
+    idFormalPublicId,
+    idGeneralEntities,
+    idGeneratedSystemId,
+    idGi,
+    idGoverning,
+    idGoverningDoctype,
+    idGroveRoot,
+    idId,
+    idIdref,
+    idIdrefs,
+    idImplied,
+    idIncluded,
+    idInclusions,
+    idIso,
+    idLpd,
+    idModelGroup,
+    idMustOmitEndTag,
+    idName,
+    idNames,
+    idNdata,
+    idNmtkgrp,
+    idNmtoken,
+    idNmtokens,
+    idNonsgml,
+    idNotation,
+    idNotationName,
+    idNotations,
+    idNumber,
+    idNumbers,
+    idNutoken,
+    idNutokens,
+    idOccurenceIndicator,
+    idOmitEndTag,
+    idOmitStartTag,
+    idOpt,
+    idOr,
+    idOrigin,
+    idOriginToSubnodeRelPropertyName,
+    idOwnerId,
+    idOwnerType,
+    idParameterEntities,
+    idParent,
+    idPcdataToken,
+    idPi,
+    idPlus,
+    idProlog,
+    idPublicId,
+    idRankGroup,
+    idRankStem,
+    idRankSuffix,
+    idRcdata,
+    idReferent,
+    idRegistered,
+    idRep,
+    idRequired,
+    idSdata,
+    idSeq,
+    idSgmlConstants,
+    idSgmlDocument,
+    idShortref,
+    idStem,
+    idSubdoc,
+    idSubdocument,
+    idSubnodePropertyNames,
+    idSyntax,
+    idSystemData,
+    idSystemId,
+    idText,
+    idTextClass,
+    idTextDescription,
+    idTextDesignatingSequence,
+    idTextDisplayVersion,
+    idTextLanguage,
+    idToken,
+    idTokens,
+    idTokenSep,
+    idTreeRoot,
+    idUnavailable,
+    idUnregistered,
+    idValue
+  };
+  enum { nIds = idValue + 1 };
+  static const char *rcsName(Id);
+  static const char *sdqlName(Id);
+};
+
+struct ClassDef {
+  ComponentName::Id className;
+  const ComponentName::Id *allPropertyNames;
+  const ComponentName::Id *subnodePropertyNames;
+  ComponentName::Id childrenPropertyName;
+  ComponentName::Id dataPropertyName;
+  ComponentName::Id dataSepPropertyName;
+
+  static const ClassDef sgmlDocument;
+  static const ClassDef sgmlConstants;
+  static const ClassDef dataChar;
+  static const ClassDef element;
+  static const ClassDef attributeAssignment;
+  static const ClassDef attributeDef;
+  static const ClassDef attributeValueToken;
+  static const ClassDef pi;
+  static const ClassDef sdata;
+  static const ClassDef documentType;
+  static const ClassDef entity;
+  static const ClassDef notation;
+  static const ClassDef externalId;
+  static const ClassDef externalData;
+  static const ClassDef subdocument;
+  static const ClassDef nonSgml;
+  static const ClassDef message;
+  static const ClassDef elementType;
+  static const ClassDef modelGroup;
+  static const ClassDef elementToken;
+  static const ClassDef pcdataToken;
+  static const ClassDef defaultEntity;
+  static const ClassDef rankStem;
+  static const ClassDef formalPublicId;
+};
+
+class PropertyValue;
+
+class Node {
+public:
+
+
+
+
+  virtual AccessResult getOrigin(NodePtr &) const;
+  virtual AccessResult getParent(NodePtr &) const;
+  virtual AccessResult getGroveRoot(NodePtr &) const;
+  virtual AccessResult getTreeRoot(NodePtr &) const;
+  virtual AccessResult getOriginToSubnodeRelPropertyName(ComponentName::Id &) const = 0;
+  AccessResult getClassName(ComponentName::Id &) const;
+  AccessResult getChildrenPropertyName(ComponentName::Id &) const;
+  AccessResult getDataPropertyName(ComponentName::Id &) const;
+  AccessResult getDataSepPropertyName(ComponentName::Id &) const;
+  AccessResult getSubnodePropertyNames(const ComponentName::Id *&) const;
+  AccessResult getAllPropertyNames(const ComponentName::Id *&) const;
+
+
+
+  virtual void accept(NodeVisitor &) = 0;
+  virtual const ClassDef &classDef() const = 0;
+
+  virtual AccessResult children(NodeListPtr &) const = 0;
+  virtual AccessResult follow(NodeListPtr &) const = 0;
+
+
+  virtual AccessResult nextSibling(NodePtr &) const;
+
+
+  virtual AccessResult nextChunkSibling(NodePtr &) const;
+
+  virtual AccessResult nextChunkAfter(NodePtr &) const;
+  virtual AccessResult charChunk(const SdataMapper &, GroveString &) const;
+
+
+  virtual AccessResult firstChild(NodePtr &) const;
+
+
+  virtual AccessResult firstSibling(NodePtr &) const;
+
+  virtual AccessResult siblingsIndex(unsigned long &) const;
+
+  virtual AccessResult attributeRef(unsigned long, NodePtr &) const;
+
+
+
+  virtual AccessResult followSiblingRef(unsigned long, NodePtr &) const;
+
+
+  virtual AccessResult tokens(GroveString &) const;
+
+
+
+
+  virtual AccessResult elementIndex(unsigned long &) const;
+
+
+
+  virtual unsigned long hash() const;
+
+  virtual bool operator==(const Node &node) const = 0;
+  bool operator!=(const Node &node) const { return !(*this == node); }
+
+  virtual bool chunkContains(const Node &nd) const;
+  bool sameGrove(const Node &node) const;
+  typedef const char *IID;
+  virtual bool queryInterface(IID, const void *&) const;
+
+  virtual AccessResult getMessages(NodeListPtr &) const;
+
+  enum Severity { info, warning, error };
+  virtual AccessResult getSeverity(Severity &) const;
+  AccessResult property(ComponentName::Id, const SdataMapper &, PropertyValue &) const;
+  virtual unsigned groveIndex() const = 0;
+public:
+  virtual void addRef() = 0;
+
+
+  virtual void release() = 0;
+protected:
+
+
+  virtual
+
+    ~Node() { }
+public:
+
+
+  AccessResult getChar(const SdataMapper &, GroveChar &) const;
+
+
+  virtual AccessResult getAttributes(NamedNodeListPtr &) const;
+  virtual AccessResult getName(GroveString &) const;
+  virtual AccessResult getSystemData(GroveString &) const;
+  virtual AccessResult getEntity(NodePtr &) const;
+  virtual AccessResult getEntityName(GroveString &) const;
+  virtual AccessResult getExternalId(NodePtr &) const;
+  virtual AccessResult getNotation(NodePtr &) const;
+  virtual AccessResult getGi(GroveString &) const;
+  struct OccurIndicator {
+    enum Enum { opt, plus, rep };
+  };
+  virtual AccessResult getOccurIndicator(OccurIndicator::Enum &) const;
+  virtual AccessResult getAttributeDefs(NamedNodeListPtr &) const;
+  virtual AccessResult getText(GroveString &) const;
+  virtual AccessResult getNotationName(GroveString &) const;
+  struct EntityType {
+    enum Enum { text, cdata, sdata, ndata, subdocument, pi };
+  };
+  virtual AccessResult getEntityType(EntityType::Enum &) const;
+
+  virtual AccessResult getDefaulted(bool &) const;
+
+  virtual AccessResult getPublicId(GroveString &) const;
+  virtual AccessResult getSystemId(GroveString &) const;
+  virtual AccessResult getGeneratedSystemId(GroveString &) const;
+  virtual AccessResult getFormalPublicId(NodePtr &) const;
+
+  virtual AccessResult getValue(NodeListPtr &) const;
+  virtual AccessResult getTokenSep(GroveChar &) const;
+  virtual AccessResult getImplied(bool &) const;
+  virtual AccessResult getAttributeDef(NodePtr &) const;
+
+  virtual AccessResult getCurrentAttributeIndex(long &) const;
+  virtual AccessResult getCurrentGroup(NodeListPtr &) const;
+  struct DeclValueType {
+    enum Enum { cdata, entity, entities, id, idref, idrefs, name, names, nmtoken,
+                nmtokens, number, numbers, nutoken, nutokens, notation, nmtkgrp };
+  };
+  virtual AccessResult getDeclValueType(DeclValueType::Enum &) const;
+  struct DefaultValueType {
+    enum Enum { value, fixed, required, current, conref, implied };
+  };
+  virtual AccessResult getDefaultValueType(DefaultValueType::Enum &) const;
+  virtual AccessResult getDefaultValue(NodeListPtr &) const;
+  virtual AccessResult getTokens(GroveStringListPtr &) const;
+
+  virtual bool hasGi(GroveString) const;
+  virtual AccessResult getId(GroveString &) const;
+  virtual AccessResult getContent(NodeListPtr &) const;
+  virtual AccessResult getIncluded(bool &) const;
+  virtual AccessResult getMustOmitEndTag(bool &) const;
+  virtual AccessResult getElementType(NodePtr &) const;
+
+  struct ContentType {
+    enum Enum { cdata, rcdata, empty, any, modelgrp };
+  };
+  virtual AccessResult getContentType(ContentType::Enum &) const;
+  virtual AccessResult getExclusions(GroveStringListPtr &) const;
+  virtual AccessResult getInclusions(GroveStringListPtr &) const;
+  virtual AccessResult getModelGroup(NodePtr &) const;
+  virtual AccessResult getOmitEndTag(bool &) const;
+  virtual AccessResult getOmitStartTag(bool &) const;
+  virtual AccessResult getRankGroup(GroveStringListPtr &) const;
+  virtual AccessResult getRankStem(GroveString &) const;
+  virtual AccessResult getRankSuffix(GroveString &) const;
+
+  virtual AccessResult getElementTypes(NodeListPtr &) const;
+  virtual AccessResult getStem(GroveString &) const;
+
+  struct Connector {
+    enum Enum { and_, or_, seq };
+  };
+  virtual AccessResult getConnector(Connector::Enum &) const;
+  virtual AccessResult getContentTokens(NodeListPtr &) const;
+
+  virtual AccessResult getToken(GroveString &) const;
+  virtual AccessResult getReferent(NodePtr &) const;
+
+  virtual AccessResult getGoverning(bool &) const;
+  virtual AccessResult getGeneralEntities(NamedNodeListPtr &) const;
+  virtual AccessResult getNotations(NamedNodeListPtr &) const;
+  virtual AccessResult getElementTypes(NamedNodeListPtr &) const;
+  virtual AccessResult getDefaultEntity(NodePtr &) const;
+  virtual AccessResult getParameterEntities(NamedNodeListPtr &) const;
+
+  virtual AccessResult getSgmlConstants(NodePtr &) const;
+  virtual AccessResult getApplicationInfo(GroveString &) const;
+  virtual AccessResult getProlog(NodeListPtr &) const;
+  virtual AccessResult getEpilog(NodeListPtr &) const;
+  virtual AccessResult getDocumentElement(NodePtr &) const;
+  virtual AccessResult getElements(NamedNodeListPtr &) const;
+  virtual AccessResult getEntities(NamedNodeListPtr &) const;
+  virtual AccessResult getDefaultedEntities(NamedNodeListPtr &) const;
+  virtual AccessResult getGoverningDoctype(NodePtr &) const;
+  virtual AccessResult getDoctypesAndLinktypes(NamedNodeListPtr &) const;
+
+
+
+  virtual AccessResult getNonSgml(unsigned long &) const;
+
+  struct OwnerType {
+    enum Enum { iso, registered, unregistered };
+  };
+  virtual AccessResult getOwnerType(OwnerType::Enum &) const;
+  virtual AccessResult getOwnerId(GroveString &) const;
+  struct TextClass {
+    enum Enum {
+      capacity,
+      charset,
+      document,
+      dtd,
+      elements,
+      entities,
+      lpd,
+      nonsgml,
+      notation,
+      shortref,
+      subdoc,
+      syntax,
+      text,
+    };
+  };
+  virtual AccessResult getTextClass(TextClass::Enum &) const;
+  virtual AccessResult getUnavailable(bool &) const;
+  virtual AccessResult getTextDescription(GroveString &) const;
+  virtual AccessResult getTextLanguage(GroveString &) const;
+  virtual AccessResult getTextDesignatingSequence(GroveString &) const;
+  virtual AccessResult getTextDisplayVersion(GroveString &) const;
+};
+
+class NodeList {
+public:
+  virtual AccessResult first(NodePtr &) const = 0;
+  virtual AccessResult rest(NodeListPtr &) const = 0;
+  virtual AccessResult chunkRest(NodeListPtr &) const = 0;
+
+
+  virtual AccessResult ref(unsigned long i, NodePtr &) const;
+  virtual void release() = 0;
+  virtual void addRef() = 0;
+protected:
+
+  virtual
+
+    ~NodeList() { }
+};
+
+class NamedNodeList {
+public:
+
+  virtual AccessResult namedNode(GroveString, NodePtr &) const = 0;
+
+
+
+  virtual size_t normalize(GroveChar *, size_t) const = 0;
+
+
+  virtual NodeListPtr nodeList() const = 0;
+
+
+  virtual NodeListPtr nodeListNoOrder() const;
+  enum Type {
+    elements,
+    attributes,
+    entities,
+    notations,
+    doctypesAndLinktypes,
+    elementTypes,
+    attributeDefs
+  };
+  virtual Type type() const = 0;
+
+
+
+
+
+  AccessResult nodeName(const NodePtr &, GroveString &) const;
+  virtual void release() = 0;
+  virtual void addRef() = 0;
+protected:
+
+  virtual
+
+    ~NamedNodeList() { }
+};
+
+class NodePtr {
+public:
+  NodePtr() : node_(0) { }
+  NodePtr(Node *node) : node_(node) { addRef(); }
+  ~NodePtr() { release(); }
+  NodePtr(const NodePtr &ptr) : node_(ptr.node_) { addRef(); }
+  NodePtr &operator=(const NodePtr &ptr) {
+    ptr.addRef();
+    release();
+    node_ = ptr.node_;
+    return *this;
+  }
+  Node *operator->() const { return node_; }
+  Node &operator*() const { return *node_; }
+  AccessResult assignOrigin() { return node_->getOrigin(*this); }
+  AccessResult assignFirstChild() { return node_->firstChild(*this); }
+  AccessResult assignNextSibling() { return node_->nextSibling(*this); }
+  AccessResult assignNextChunkSibling() {
+    return node_->nextChunkSibling(*this);
+  }
+  AccessResult assignNextChunkAfter() {
+    return node_->nextChunkAfter(*this);
+  }
+  AccessResult assignFirstSibling() { return node_->firstSibling(*this); }
+  void assign(Node *node) {
+    if (node)
+      node->addRef();
+    release();
+    node_ = node;
+  }
+  void clear() { release(); node_ = 0; }
+  operator bool() const { return node_ != 0; }
+private:
+  void addRef() const { if (node_) node_->addRef(); }
+  void release() const { if (node_) node_->release(); }
+  Node *node_;
+};
+
+class NodeListPtr {
+public:
+  NodeListPtr() : list_(0) { }
+  NodeListPtr(NodeList *list) : list_(list) { addRef(); }
+  ~NodeListPtr() { release(); }
+  NodeListPtr(const NodeListPtr &ptr) : list_(ptr.list_) { addRef(); }
+  NodeListPtr &operator=(const NodeListPtr &ptr) {
+    ptr.addRef();
+    release();
+    list_ = ptr.list_;
+    return *this;
+  }
+  AccessResult assignRest() { return list_->rest(*this); }
+  AccessResult assignChunkRest() { return list_->chunkRest(*this); }
+  NodeList *operator->() const { return list_; }
+  NodeList &operator*() const { return *list_; }
+  void assign(NodeList *list) {
+    if (list)
+      list->addRef();
+    release();
+    list_ = list;
+  }
+  void clear() { release(); list_ = 0; }
+  operator bool() const { return list_ != 0; }
+private:
+  void addRef() const { if (list_) list_->addRef(); }
+  void release() const { if (list_) list_->release(); }
+  NodeList *list_;
+};
+
+class NamedNodeListPtr {
+public:
+  NamedNodeListPtr() : list_(0) { }
+  NamedNodeListPtr(NamedNodeList *list) : list_(list) { addRef(); }
+  ~NamedNodeListPtr() { release(); }
+  NamedNodeListPtr(const NamedNodeListPtr &ptr) : list_(ptr.list_) { addRef(); }
+  NamedNodeListPtr &operator=(const NamedNodeListPtr &ptr) {
+    ptr.addRef();
+    release();
+    list_ = ptr.list_;
+    return *this;
+  }
+  NamedNodeList *operator->() const { return list_; }
+  NamedNodeList &operator*() const { return *list_; }
+  void assign(NamedNodeList *list) {
+    if (list)
+      list->addRef();
+    release();
+    list_ = list;
+  }
+  void clear() { release(); list_ = 0; }
+  operator bool() const { return list_ != 0; }
+private:
+  void addRef() const { if (list_) list_->addRef(); }
+  void release() const { if (list_) list_->release(); }
+  NamedNodeList *list_;
+};
+
+class GroveString {
+public:
+  typedef const GroveChar *const_iterator;
+  GroveString() : data_(0), size_(0) { }
+  GroveString(const GroveChar *data, size_t size)
+    : data_(data), size_(size) { }
+  size_t size() const { return size_; }
+  const GroveChar *data() const { return data_; }
+  void assign(const GroveChar *data, size_t size) {
+    data_ = data;
+    size_ = size;
+  }
+  bool operator==(const GroveString &str) const;
+  bool operator!=(const GroveString &str) const { return !(*this == str); }
+  GroveChar operator[](size_t i) const { return data_[i]; }
+  const_iterator begin() const { return data_; }
+  const_iterator end() const { return data_ + size_; }
+private:
+  const GroveChar *data_;
+  size_t size_;
+};
+
+class GroveStringLink {
+public:
+  GroveStringLink( const GroveString &gs )
+   : data_(gs), next_(0) { }
+  friend class GroveStringList;
+  friend class ConstGroveStringListIter;
+private:
+  GroveString data_;
+  GroveStringLink *next_;
+};
+
+class GroveStringList;
+
+class ConstGroveStringListIter {
+public:
+  friend class GroveStringList;
+  ConstGroveStringListIter() : link_(0) { }
+  ConstGroveStringListIter(const GroveStringList &list);
+  int done() const { return link_ == 0; }
+  const GroveString &cur() const { return link_->data_; }
+  void next() { link_ = link_->next_; }
+protected:
+  void attach(const GroveStringLink *link) { link_ = link; }
+  const GroveStringLink *link_;
+};
+
+class GroveStringList {
+public:
+  friend class ConstGroveStringListIter;
+  GroveStringList() : head_(0), refCount_(0) { }
+  ~GroveStringList();
+  void append(const GroveString &gs);
+  void release();
+  void addRef();
+  bool canReuse(GroveStringListPtr &ptr) const;
+  AccessResult first(GroveString &) const;
+  AccessResult rest(GroveStringListPtr &) const;
+  const ConstGroveStringListIter &iter() { return iter_; }
+private:
+  unsigned refCount_;
+  GroveStringLink *head_;
+  ConstGroveStringListIter iter_;
+};
+
+class GroveStringListPtr {
+public:
+  GroveStringListPtr() : list_(0) { }
+  GroveStringListPtr(GroveStringList *list) : list_(list) { addRef(); }
+  ~GroveStringListPtr() { release(); }
+  GroveStringListPtr(const GroveStringListPtr &ptr) : list_(ptr.list_) { addRef(); }
+  GroveStringListPtr &operator=(const GroveStringListPtr &ptr) {
+    ptr.addRef();
+    release();
+    list_ = ptr.list_;
+    return *this;
+  }
+  GroveStringList *operator->() const { return list_; }
+  GroveStringList &operator*() const { return *list_; }
+  void assign(GroveStringList *list) {
+    if (list)
+      list->addRef();
+    release();
+    list_ = list;
+  }
+  void clear() { release(); list_ = 0; }
+  operator bool() const { return list_ != 0; }
+private:
+  void addRef() const { if (list_) list_->addRef(); }
+  void release() const { if (list_) list_->release(); }
+  GroveStringList *list_;
+};
+
+class SdataMapper {
+public:
+  virtual ~SdataMapper();
+
+  virtual bool sdataMap(GroveString name, GroveString text, GroveChar &) const;
+};
+
+
+
+class NodeVisitor {
+public:
+  virtual void sgmlDocument(Node &);
+  virtual void sgmlConstants(Node &);
+  virtual void dataChar(Node &);
+  virtual void element(Node &);
+  virtual void attributeAssignment(Node &);
+  virtual void attributeDef(Node &);
+  virtual void attributeValueToken(Node &);
+  virtual void pi(Node &);
+  virtual void sdata(Node &);
+  virtual void documentType(Node &);
+  virtual void entity(Node &);
+  virtual void notation(Node &);
+  virtual void externalId(Node &);
+  virtual void externalData(Node &);
+  virtual void subdocument(Node &);
+  virtual void nonSgml(Node &);
+  virtual void message(Node &);
+  virtual void elementType(Node &);
+  virtual void rankStem(Node &);
+  virtual void modelGroup(Node &);
+  virtual void elementToken(Node &);
+  virtual void pcdataToken(Node &);
+  virtual void defaultEntity(Node &);
+  virtual void formalPublicId(Node &);
+};
+
+class PropertyValue {
+public:
+  virtual ~PropertyValue() { }
+  virtual void set(const NodePtr &) = 0;
+  virtual void set(const NodeListPtr &) = 0;
+  virtual void set(const NamedNodeListPtr &) = 0;
+  virtual void set(bool) = 0;
+  virtual void set(GroveChar) = 0;
+  virtual void set(GroveString) = 0;
+  virtual void set(ComponentName::Id) = 0;
+  virtual void set(const GroveStringListPtr &) = 0;
+  virtual void set(const ComponentName::Id *) = 0;
+  virtual void set(long) = 0;
+};
+
+inline
+AccessResult Node::getChar(const SdataMapper &mapper, GroveChar &c) const
+{
+  GroveString str;
+  AccessResult ret = charChunk(mapper, str);
+  if (ret == accessOK)
+    c = str[0];
+  return ret;
+}
+
+inline
+bool Node::sameGrove(const Node &node) const
+{
+  return groveIndex() == node.groveIndex();
+}
+
+inline
+AccessResult Node::getClassName(ComponentName::Id &name) const
+{
+  name = classDef().className;
+  return accessOK;
+}
+
+inline
+AccessResult Node::getChildrenPropertyName(ComponentName::Id &name) const
+{
+  const ClassDef &def = classDef();
+  if (def.childrenPropertyName == ComponentName::noId)
+    return accessNull;
+  name = def.childrenPropertyName;
+  return accessOK;
+}
+
+inline
+AccessResult Node::getDataPropertyName(ComponentName::Id &name) const
+{
+  const ClassDef &def = classDef();
+  if (def.dataPropertyName == ComponentName::noId)
+    return accessNull;
+  name = def.dataPropertyName;
+  return accessOK;
+}
+
+inline
+AccessResult Node::getDataSepPropertyName(ComponentName::Id &name) const
+{
+  const ClassDef &def = classDef();
+  if (def.dataSepPropertyName == ComponentName::noId)
+    return accessNull;
+  name = def.dataSepPropertyName;
+  return accessOK;
+}
+
+inline
+AccessResult Node::getSubnodePropertyNames(const ComponentName::Id *&names) const
+{
+  names = classDef().subnodePropertyNames;
+  return accessOK;
+}
+
+inline
+AccessResult Node::getAllPropertyNames(const ComponentName::Id *&names) const
+{
+   names = classDef().allPropertyNames;
+   return accessOK;
+}
+
+
+}
+# 9 "GroveBuilder.cxx" 2
+# 1 "/usr/include/OpenSP/Resource.h" 1 3 4
+
+
+
+
+
+
+
+namespace OpenSP {
+
+
+class Resource {
+public:
+  Resource();
+  Resource(const Resource &);
+  int unref();
+  void ref();
+  int count() const;
+private:
+  int count_;
+};
+
+inline
+Resource::Resource()
+: count_(0)
+{
+}
+
+inline
+Resource::Resource(const Resource &)
+: count_(0)
+{
+}
+
+inline
+int Resource::count() const
+{
+  return count_;
+}
+
+inline
+int Resource::unref()
+{
+  return --count_ <= 0;
+}
+
+inline
+void Resource::ref()
+{
+  ++count_;
+}
+
+
+}
+# 10 "GroveBuilder.cxx" 2
+# 1 "/usr/include/OpenSP/Ptr.h" 1 3 4
+# 13 "/usr/include/OpenSP/Ptr.h" 3 4
+namespace OpenSP {
+
+
+template<class T>
+class Ptr {
+public:
+  Ptr() : ptr_(0) { }
+  Ptr(T *ptr);
+  ~Ptr();
+  Ptr(const Ptr<T> &);
+  Ptr<T> &operator=(const Ptr<T> &);
+  Ptr<T> &operator=(T *);
+  T *pointer() const { return ptr_; }
+  T *operator->() const { return ptr_; }
+  T &operator*() const { return *ptr_; }
+  void swap(Ptr<T> &p) {
+    T *tem = p.ptr_;
+    p.ptr_ = ptr_;
+    ptr_ = tem;
+  }
+  Boolean isNull() const { return ptr_ == 0; }
+
+  void clear();
+  Boolean operator==(const Ptr<T> &p) const {
+    return ptr_ == p.ptr_;
+  }
+  Boolean operator!=(const Ptr<T> &p) const {
+    return ptr_ != p.ptr_;
+  }
+  Boolean operator==(const T *p) const {
+    return ptr_ == p;
+  }
+  Boolean operator!=(const T *p) const {
+    return ptr_ != p;
+  }
+private:
+  T *ptr_;
+};
+
+template<class T>
+class ConstPtr : private Ptr<T> {
+public:
+  ConstPtr() { }
+  ConstPtr(T *ptr) : Ptr<T>(ptr) { }
+  ConstPtr(const Ptr<T> &p) : Ptr<T>(p) { }
+  ConstPtr(const ConstPtr<T> &p) : Ptr<T>(p) { }
+  ConstPtr<T> &operator=(const Ptr<T> &p) {
+    Ptr<T>::operator=(p); return *this;
+  }
+  ConstPtr<T> &operator=(const ConstPtr<T> &p) {
+    Ptr<T>::operator=(p); return *this;
+  }
+  ConstPtr<T> &operator=(T *p) {
+    Ptr<T>::operator=(p); return *this;
+  }
+  const T *pointer() const { return Ptr<T>::pointer(); }
+  const T *operator->() const { return Ptr<T>::pointer(); }
+  const T &operator*() const { return *Ptr<T>::pointer(); }
+  void swap(ConstPtr<T> &p) { Ptr<T>::swap(p); }
+  Ptr<T>::isNull;
+  Ptr<T>::clear;
+  Boolean operator==(const Ptr<T> &p) const { return Ptr<T>::operator==(p); }
+  Boolean operator!=(const Ptr<T> &p) const { return Ptr<T>::operator!=(p); }
+  Boolean operator==(const ConstPtr<T> &p) const {
+    return Ptr<T>::operator==(p);
+  }
+  Boolean operator!=(const ConstPtr<T> &p) const {
+    return Ptr<T>::operator!=(p);
+  }
+};
+
+
+}
+
+
+
+
+
+# 1 "/usr/include/OpenSP/Ptr.cxx" 1 3 4
+
+
+
+
+
+
+
+namespace OpenSP {
+
+
+template<class T>
+Ptr<T>::Ptr(T *ptr) : ptr_(ptr)
+{
+  if (ptr_)
+    ptr_->ref();
+}
+
+template<class T>
+Ptr<T>::~Ptr()
+{
+  if (ptr_) {
+    if (ptr_->unref())
+      delete ptr_;
+    ptr_ = 0;
+  }
+}
+
+template<class T>
+Ptr<T>::Ptr(const Ptr<T> &p)
+: ptr_(p.ptr_)
+{
+  if (p.ptr_)
+    p.ptr_->ref();
+}
+
+template<class T>
+Ptr<T> &Ptr<T>::operator=(const Ptr<T> &p)
+{
+  if (p.ptr_)
+    p.ptr_->ref();
+  if (ptr_ && ptr_->unref())
+    delete ptr_;
+  ptr_ = p.ptr_;
+  return *this;
+}
+
+template<class T>
+Ptr<T> &Ptr<T>::operator=(T *p)
+{
+  if (p)
+    p->ref();
+  if (ptr_ && ptr_->unref())
+    delete ptr_;
+  ptr_ = p;
+  return *this;
+}
+
+template<class T>
+void Ptr<T>::clear()
+{
+  if (ptr_) {
+    if (ptr_->unref())
+      delete ptr_;
+    ptr_ = 0;
+  }
+}
+
+
+}
+# 92 "/usr/include/OpenSP/Ptr.h" 2 3 4
+# 11 "GroveBuilder.cxx" 2
+# 1 "/usr/include/OpenSP/xnew.h" 1 3 4
+# 20 "/usr/include/OpenSP/xnew.h" 3 4
+# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/../../../../include/c++/4.0.1/new" 1 3 4
+# 41 "/usr/lib/gcc/i486-linux-gnu/4.0.1/../../../../include/c++/4.0.1/new" 3 4
+# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/../../../../include/c++/4.0.1/cstddef" 1 3 4
+# 46 "/usr/lib/gcc/i486-linux-gnu/4.0.1/../../../../include/c++/4.0.1/cstddef" 3 4
+       
+# 47 "/usr/lib/gcc/i486-linux-gnu/4.0.1/../../../../include/c++/4.0.1/cstddef" 3
+
+# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
+# 49 "/usr/lib/gcc/i486-linux-gnu/4.0.1/../../../../include/c++/4.0.1/cstddef" 2 3
+
+namespace std
+{
+  using ::ptrdiff_t;
+  using ::size_t;
+}
+# 42 "/usr/lib/gcc/i486-linux-gnu/4.0.1/../../../../include/c++/4.0.1/new" 2 3 4
+# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/../../../../include/c++/4.0.1/exception" 1 3 4
+# 40 "/usr/lib/gcc/i486-linux-gnu/4.0.1/../../../../include/c++/4.0.1/exception" 3 4
+#pragma GCC visibility push(default)
+
+extern "C++" {
+
+namespace std
+{
+# 54 "/usr/lib/gcc/i486-linux-gnu/4.0.1/../../../../include/c++/4.0.1/exception" 3 4
+  class exception
+  {
+  public:
+    exception() throw() { }
+    virtual ~exception() throw();
+
+
+    virtual const char* what() const throw();
+  };
+
+
+
+  class bad_exception : public exception
+  {
+  public:
+    bad_exception() throw() { }
+
+
+    virtual ~bad_exception() throw();
+  };
+
+
+  typedef void (*terminate_handler) ();
+
+  typedef void (*unexpected_handler) ();
+
+
+  terminate_handler set_terminate(terminate_handler) throw();
+
+
+  void terminate() __attribute__ ((__noreturn__));
+
+
+  unexpected_handler set_unexpected(unexpected_handler) throw();
+
+
+  void unexpected() __attribute__ ((__noreturn__));
+# 102 "/usr/lib/gcc/i486-linux-gnu/4.0.1/../../../../include/c++/4.0.1/exception" 3 4
+  bool uncaught_exception() throw();
+}
+
+namespace __gnu_cxx
+{
+# 117 "/usr/lib/gcc/i486-linux-gnu/4.0.1/../../../../include/c++/4.0.1/exception" 3 4
+  void __verbose_terminate_handler ();
+}
+
+}
+
+#pragma GCC visibility pop
+# 43 "/usr/lib/gcc/i486-linux-gnu/4.0.1/../../../../include/c++/4.0.1/new" 2 3 4
+
+#pragma GCC visibility push(default)
+
+extern "C++" {
+
+namespace std
+{
+
+
+
+
+
+  class bad_alloc : public exception
+  {
+  public:
+    bad_alloc() throw() { }
+
+
+    virtual ~bad_alloc() throw();
+  };
+
+  struct nothrow_t { };
+  extern const nothrow_t nothrow;
+
+
+  typedef void (*new_handler)();
+
+  new_handler set_new_handler(new_handler) throw();
+}
+# 84 "/usr/lib/gcc/i486-linux-gnu/4.0.1/../../../../include/c++/4.0.1/new" 3 4
+void* operator new(std::size_t) throw (std::bad_alloc);
+void* operator new[](std::size_t) throw (std::bad_alloc);
+void operator delete(void*) throw();
+void operator delete[](void*) throw();
+void* operator new(std::size_t, const std::nothrow_t&) throw();
+void* operator new[](std::size_t, const std::nothrow_t&) throw();
+void operator delete(void*, const std::nothrow_t&) throw();
+void operator delete[](void*, const std::nothrow_t&) throw();
+
+
+inline void* operator new(std::size_t, void* __p) throw() { return __p; }
+inline void* operator new[](std::size_t, void* __p) throw() { return __p; }
+
+
+inline void operator delete (void*, void*) throw() { }
+inline void operator delete[](void*, void*) throw() { }
+
+}
+
+#pragma GCC visibility pop
+# 21 "/usr/include/OpenSP/xnew.h" 2 3 4
+# 12 "GroveBuilder.cxx" 2
+# 1 "/usr/include/OpenSP/Event.h" 1 3 4
+
+
+
+
+
+
+#pragma interface
+
+
+
+# 1 "/usr/include/OpenSP/Allocator.h" 1 3 4
+
+
+
+
+
+
+# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
+# 8 "/usr/include/OpenSP/Allocator.h" 2 3 4
+
+
+namespace OpenSP {
+
+
+class Allocator {
+public:
+  Allocator(size_t maxSize, unsigned blocksPerSegment);
+  ~Allocator();
+  void *alloc(size_t);
+  static void *allocSimple(size_t);
+  static void free(void *);
+
+
+  union ForceAlign {
+    unsigned long n;
+    struct {
+      char c;
+    } s;
+    char *cp;
+    long *lp;
+  };
+  struct SegmentHeader;
+  union BlockHeader;
+  friend union BlockHeader;
+  union BlockHeader {
+    SegmentHeader *seg;
+    ForceAlign align;
+  };
+  struct Block;
+  friend struct Block;
+  struct Block {
+    BlockHeader header;
+    Block *next;
+  };
+  friend struct SegmentHeader;
+  struct SegmentHeader {
+    union {
+      Block **freeList;
+      ForceAlign align;
+    };
+    unsigned liveCount;
+    SegmentHeader *next;
+  };
+private:
+  Allocator(const Allocator &);
+  Allocator &operator=(const Allocator &);
+  Block *freeList_;
+  size_t objectSize_;
+  unsigned blocksPerSegment_;
+  SegmentHeader *segments_;
+  void *alloc1();
+  void tooBig(size_t);
+};
+
+
+}
+# 12 "/usr/include/OpenSP/Event.h" 2 3 4
+# 1 "/usr/include/OpenSP/Location.h" 1 3 4
+
+
+
+
+
+
+#pragma interface
+
+
+# 1 "/usr/include/OpenSP/types.h" 1 3 4
+
+
+
+
+
+
+# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/limits.h" 1 3 4
+# 8 "/usr/include/OpenSP/types.h" 2 3 4
+# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
+# 9 "/usr/include/OpenSP/types.h" 2 3 4
+
+
+namespace OpenSP {
+
+
+
+typedef unsigned int Unsigned32;
+typedef int Signed32;
+
+
+
+
+
+
+typedef Unsigned32 Number;
+typedef Unsigned32 Offset;
+typedef Unsigned32 Index;
+
+
+
+typedef Unsigned32 Char;
+typedef Signed32 Xchar;
+# 40 "/usr/include/OpenSP/types.h" 3 4
+typedef Unsigned32 UnivChar;
+typedef Unsigned32 WideChar;
+
+
+
+
+typedef Unsigned32 SyntaxChar;
+
+typedef unsigned short CharClassIndex;
+
+typedef unsigned Token;
+
+
+typedef unsigned short EquivCode;
+
+
+
+
+
+}
+# 11 "/usr/include/OpenSP/Location.h" 2 3 4
+
+# 1 "/usr/include/OpenSP/Ptr.h" 1 3 4
+# 13 "/usr/include/OpenSP/Location.h" 2 3 4
+# 1 "/usr/include/OpenSP/Resource.h" 1 3 4
+# 14 "/usr/include/OpenSP/Location.h" 2 3 4
+
+# 1 "/usr/include/OpenSP/Vector.h" 1 3 4
+
+
+
+
+
+
+# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
+# 8 "/usr/include/OpenSP/Vector.h" 2 3 4
+# 1 "/usr/include/OpenSP/xnew.h" 1 3 4
+# 9 "/usr/include/OpenSP/Vector.h" 2 3 4
+
+
+
+
+
+
+namespace OpenSP {
+
+
+template<class T>
+class Vector {
+public:
+  typedef size_t size_type;
+  typedef T *iterator;
+  typedef const T *const_iterator;
+  Vector() : ptr_(0), size_(0), alloc_(0) { }
+  Vector(size_t n) : ptr_(0), size_(0), alloc_(0) { append(n); }
+  virtual ~Vector();
+  void resize(size_t n) {
+    if (n < size_)
+      erase(ptr_ + n, ptr_ + size_);
+    else if (n > size_)
+      append(n - size_);
+  }
+
+  Vector(size_t, const T &);
+  Vector(const Vector<T> &);
+  Vector<T> &operator=(const Vector<T> &);
+  void assign(size_t, const T &);
+  void push_back(const T &t) {
+    reserve(size_ + 1);
+    (void)new (ptr_ + size_) T(t);
+    size_++;
+  }
+  void insert(const_iterator p, size_t n, const T &t);
+  void insert(const_iterator p, const_iterator q1, const_iterator q2);
+
+  void swap(Vector<T> &);
+  void clear() { erase(ptr_, ptr_ + size_); }
+  size_t size() const { return size_; }
+  T &operator[](size_t i) { return ptr_[i]; }
+  const T &operator[](size_t i) const { return ptr_[i]; }
+  iterator begin() { return ptr_; }
+  const_iterator begin() const { return ptr_; }
+  T &back() { return ptr_[size_ - 1]; }
+  const T &back() const { return ptr_[size_ - 1]; }
+  void reserve(size_t n) { if (n > alloc_) reserve1(n); }
+  iterator erase(const_iterator, const_iterator);
+private:
+
+
+
+
+  void append(size_t);
+  void reserve1(size_t);
+
+  size_t size_;
+  T *ptr_;
+  size_t alloc_;
+};
+
+
+}
+
+
+
+
+
+# 1 "/usr/include/OpenSP/Vector.cxx" 1 3 4
+
+
+
+
+
+
+# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
+# 8 "/usr/include/OpenSP/Vector.cxx" 2 3 4
+# 1 "/usr/include/string.h" 1 3 4
+# 28 "/usr/include/string.h" 3 4
+extern "C" {
+
+
+
+
+# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
+# 34 "/usr/include/string.h" 2 3 4
+
+
+
+
+extern void *memcpy (void *__restrict __dest,
+       __const void *__restrict __src, size_t __n) throw ();
+
+
+extern void *memmove (void *__dest, __const void *__src, size_t __n)
+     throw ();
+
+
+
+
+
+
+extern void *memccpy (void *__restrict __dest, __const void *__restrict __src,
+        int __c, size_t __n)
+     throw ();
+
+
+
+
+
+extern void *memset (void *__s, int __c, size_t __n) throw ();
+
+
+extern int memcmp (__const void *__s1, __const void *__s2, size_t __n)
+     throw () __attribute__ ((__pure__));
+
+
+extern void *memchr (__const void *__s, int __c, size_t __n)
+      throw () __attribute__ ((__pure__));
+
+
+
+
+
+extern void *rawmemchr (__const void *__s, int __c) throw () __attribute__ ((__pure__));
+
+
+extern void *memrchr (__const void *__s, int __c, size_t __n)
+      throw () __attribute__ ((__pure__));
+
+
+
+
+
+extern char *strcpy (char *__restrict __dest, __const char *__restrict __src)
+     throw ();
+
+extern char *strncpy (char *__restrict __dest,
+        __const char *__restrict __src, size_t __n) throw ();
+
+
+extern char *strcat (char *__restrict __dest, __const char *__restrict __src)
+     throw ();
+
+extern char *strncat (char *__restrict __dest, __const char *__restrict __src,
+        size_t __n) throw ();
+
+
+extern int strcmp (__const char *__s1, __const char *__s2)
+     throw () __attribute__ ((__pure__));
+
+extern int strncmp (__const char *__s1, __const char *__s2, size_t __n)
+     throw () __attribute__ ((__pure__));
+
+
+extern int strcoll (__const char *__s1, __const char *__s2)
+     throw () __attribute__ ((__pure__));
+
+extern size_t strxfrm (char *__restrict __dest,
+         __const char *__restrict __src, size_t __n) throw ();
+
+
+
+
+
+
+# 1 "/usr/include/xlocale.h" 1 3 4
+# 28 "/usr/include/xlocale.h" 3 4
+typedef struct __locale_struct
+{
+
+  struct locale_data *__locales[13];
+
+
+  const unsigned short int *__ctype_b;
+  const int *__ctype_tolower;
+  const int *__ctype_toupper;
+
+
+  const char *__names[13];
+} *__locale_t;
+# 115 "/usr/include/string.h" 2 3 4
+
+
+extern int strcoll_l (__const char *__s1, __const char *__s2, __locale_t __l)
+     throw () __attribute__ ((__pure__));
+
+extern size_t strxfrm_l (char *__dest, __const char *__src, size_t __n,
+    __locale_t __l) throw ();
+
+
+
+
+extern char *strdup (__const char *__s) throw () __attribute__ ((__malloc__));
+
+
+
+
+
+
+extern char *strndup (__const char *__string, size_t __n)
+     throw () __attribute__ ((__malloc__));
+# 160 "/usr/include/string.h" 3 4
+
+
+extern char *strchr (__const char *__s, int __c) throw () __attribute__ ((__pure__));
+
+extern char *strrchr (__const char *__s, int __c) throw () __attribute__ ((__pure__));
+
+
+
+
+
+extern char *strchrnul (__const char *__s, int __c) throw () __attribute__ ((__pure__));
+
+
+
+
+
+extern size_t strcspn (__const char *__s, __const char *__reject)
+     throw () __attribute__ ((__pure__));
+
+
+extern size_t strspn (__const char *__s, __const char *__accept)
+     throw () __attribute__ ((__pure__));
+
+extern char *strpbrk (__const char *__s, __const char *__accept)
+     throw () __attribute__ ((__pure__));
+
+extern char *strstr (__const char *__haystack, __const char *__needle)
+     throw () __attribute__ ((__pure__));
+
+
+
+extern char *strtok (char *__restrict __s, __const char *__restrict __delim)
+     throw ();
+
+
+
+
+extern char *__strtok_r (char *__restrict __s,
+    __const char *__restrict __delim,
+    char **__restrict __save_ptr) throw ();
+
+extern char *strtok_r (char *__restrict __s, __const char *__restrict __delim,
+         char **__restrict __save_ptr) throw ();
+
+
+
+
+extern char *strcasestr (__const char *__haystack, __const char *__needle)
+     throw () __attribute__ ((__pure__));
+
+
+
+
+
+
+extern void *memmem (__const void *__haystack, size_t __haystacklen,
+       __const void *__needle, size_t __needlelen)
+     throw () __attribute__ ((__pure__));
+
+
+
+extern void *__mempcpy (void *__restrict __dest,
+   __const void *__restrict __src, size_t __n) throw ();
+extern void *mempcpy (void *__restrict __dest,
+        __const void *__restrict __src, size_t __n) throw ();
+
+
+
+
+
+extern size_t strlen (__const char *__s) throw () __attribute__ ((__pure__));
+
+
+
+
+
+extern size_t strnlen (__const char *__string, size_t __maxlen)
+     throw () __attribute__ ((__pure__));
+
+
+
+
+
+extern char *strerror (int __errnum) throw ();
+
+
+
+
+extern char *strerror_r (int __errnum, char *__buf, size_t __buflen) throw ();
+
+
+
+
+extern void __bzero (void *__s, size_t __n) throw ();
+
+
+
+extern void bcopy (__const void *__src, void *__dest, size_t __n) throw ();
+
+
+extern void bzero (void *__s, size_t __n) throw ();
+
+
+extern int bcmp (__const void *__s1, __const void *__s2, size_t __n)
+     throw () __attribute__ ((__pure__));
+
+
+extern char *index (__const char *__s, int __c) throw () __attribute__ ((__pure__));
+
+
+extern char *rindex (__const char *__s, int __c) throw () __attribute__ ((__pure__));
+
+
+
+extern int ffs (int __i) throw () __attribute__ ((__const__));
+
+
+
+
+extern int ffsl (long int __l) throw () __attribute__ ((__const__));
+
+__extension__ extern int ffsll (long long int __ll)
+     throw () __attribute__ ((__const__));
+
+
+
+
+extern int strcasecmp (__const char *__s1, __const char *__s2)
+     throw () __attribute__ ((__pure__));
+
+
+extern int strncasecmp (__const char *__s1, __const char *__s2, size_t __n)
+     throw () __attribute__ ((__pure__));
+
+
+
+
+
+extern int strcasecmp_l (__const char *__s1, __const char *__s2,
+    __locale_t __loc) throw () __attribute__ ((__pure__));
+
+extern int strncasecmp_l (__const char *__s1, __const char *__s2,
+     size_t __n, __locale_t __loc)
+     throw () __attribute__ ((__pure__));
+
+
+
+
+
+extern char *strsep (char **__restrict __stringp,
+       __const char *__restrict __delim) throw ();
+
+
+
+
+extern int strverscmp (__const char *__s1, __const char *__s2)
+     throw () __attribute__ ((__pure__));
+
+
+extern char *strsignal (int __sig) throw ();
+
+
+extern char *__stpcpy (char *__restrict __dest, __const char *__restrict __src)
+     throw ();
+extern char *stpcpy (char *__restrict __dest, __const char *__restrict __src)
+     throw ();
+
+
+
+extern char *__stpncpy (char *__restrict __dest,
+   __const char *__restrict __src, size_t __n) throw ();
+extern char *stpncpy (char *__restrict __dest,
+        __const char *__restrict __src, size_t __n) throw ();
+
+
+extern char *strfry (char *__string) throw ();
+
+
+extern void *memfrob (void *__s, size_t __n) throw ();
+
+
+
+
+
+
+extern char *basename (__const char *__filename) throw ();
+# 379 "/usr/include/string.h" 3 4
+}
+# 9 "/usr/include/OpenSP/Vector.cxx" 2 3 4
+
+
+namespace OpenSP {
+
+
+template<class T>
+Vector<T>::~Vector()
+{
+  if (ptr_) {
+    erase(ptr_, ptr_ + size_);
+    ::operator delete((void *)ptr_);
+  }
+}
+
+
+
+template<class T>
+Vector<T>::Vector(const Vector<T> &v)
+: ptr_(0), size_(0), alloc_(0)
+{
+  insert(ptr_ + size_, v.ptr_, v.ptr_ + v.size_);
+}
+
+template<class T>
+Vector<T>::Vector(size_t n, const T &t)
+: ptr_(0), size_(0), alloc_(0)
+{
+  insert(ptr_ + size_, n, t);
+}
+
+template<class T>
+Vector<T> &Vector<T>::operator=(const Vector<T> &v)
+{
+  if (&v != this) {
+    size_t n = v.size_;
+    if (n > size_) {
+      n = size_;
+      insert(ptr_ + size_, v.ptr_ + size_, v.ptr_ + v.size_);
+    }
+    else if (n < size_)
+      erase(ptr_ + n, ptr_ + size_);
+    while (n-- > 0)
+      ptr_[n] = v.ptr_[n];
+  }
+  return *this;
+}
+
+template<class T>
+void Vector<T>::assign(size_t n, const T &t)
+{
+  size_t sz = n;
+  if (n > size_) {
+    sz = size_;
+    insert(ptr_ + size_, n - size_, t);
+  }
+  else if (n < size_)
+    erase(ptr_ + n, ptr_ + size_);
+  while (sz-- > 0)
+    ptr_[sz] = t;
+}
+
+template<class T>
+void Vector<T>::insert(const T *p, size_t n, const T &t)
+{
+  size_t i = p - ptr_;
+  reserve(size_ + n);
+  if (i != size_)
+    memmove(ptr_ + i + n, ptr_ + i, (size_ - i)*sizeof(T));
+  for (T *pp = ptr_ + i; n-- > 0; pp++) {
+    (void)new (pp) T(t);
+    size_++;
+  }
+}
+
+template<class T>
+void Vector<T>::insert(const T *p, const T *q1, const T *q2)
+{
+  size_t i = p - ptr_;
+  size_t n = q2 - q1;
+  reserve(size_ + n);
+  if (i != size_)
+    memmove(ptr_ + i + n, ptr_ + i, (size_ - i)*sizeof(T));
+  for (T *pp = ptr_ + i; q1 != q2; q1++, pp++) {
+    (void)new (pp) T(*q1);
+    size_++;
+  }
+}
+
+
+
+template<class T>
+void Vector<T>::swap(Vector<T> &v)
+{
+  {
+    T *tem = ptr_;
+    ptr_ = v.ptr_;
+    v.ptr_ = tem;
+  }
+  {
+    size_t tem = size_;
+    size_ = v.size_;
+    v.size_ = tem;
+  }
+  {
+    size_t tem = alloc_;
+    alloc_ = v.alloc_;
+    v.alloc_ = tem;
+  }
+}
+
+template<class T>
+void Vector<T>::append(size_t n)
+{
+  reserve(size_ + n);
+  while (n-- > 0)
+    (void)new (ptr_ + size_++) T;
+}
+
+template<class T>
+T *Vector<T>::erase(const T *p1, const T *p2)
+{
+  typedef T X;
+  for (const T *p = p1; p != p2; p++)
+    ((X *)p)->~X();
+  if (p2 != ptr_ + size_)
+    memmove((T *)p1, p2, ((const T *)(ptr_ + size_) - p2)*sizeof(T));
+  size_ -= p2 - p1;
+  return (T *)p1;
+}
+
+template<class T>
+void Vector<T>::reserve1(size_t size)
+{
+
+
+  size_t newAlloc = alloc_*2;
+  if (size > newAlloc)
+    newAlloc += size;
+  void *p = ::operator new(newAlloc * sizeof(T));
+  alloc_ = newAlloc;
+  if (ptr_) {
+    memcpy(p, ptr_, size_*sizeof(T));
+    ::operator delete((void *)ptr_);
+  }
+  ptr_ = (T *)p;
+}
+
+
+}
+# 78 "/usr/include/OpenSP/Vector.h" 2 3 4
+# 16 "/usr/include/OpenSP/Location.h" 2 3 4
+# 1 "/usr/include/OpenSP/Owner.h" 1 3 4
+# 12 "/usr/include/OpenSP/Owner.h" 3 4
+namespace OpenSP {
+
+
+template<class T>
+class Owner {
+public:
+  Owner() : p_(0) { }
+  Owner(T *p) : p_(p) { }
+  virtual ~Owner();
+  void operator=(T *p) {
+    if (p_) del();
+    p_ = p;
+  }
+  operator int() const { return p_ != 0; }
+  T *pointer() const { return p_; }
+  T *operator->() const { return p_; }
+  T &operator*() const { return *p_; }
+  void swap(Owner<T> &x) {
+    T *tem = p_;
+    p_ = x.p_;
+    x.p_ = tem;
+  }
+  T *extract() {
+    T *tem = p_;
+    p_ = 0;
+    return tem;
+  }
+  void clear() {
+    if (p_) {
+      del();
+      p_ = 0;
+    }
+  }
+private:
+  Owner(const Owner<T> &);
+  void operator=(const Owner<T> &o);
+  void del();
+  T *p_;
+};
+
+
+}
+
+
+
+
+
+# 1 "/usr/include/OpenSP/Owner.cxx" 1 3 4
+
+
+
+
+
+
+
+namespace OpenSP {
+
+
+template<class T>
+Owner<T>::~Owner()
+{
+  if (p_)
+    delete p_;
+}
+
+template<class T>
+void Owner<T>::del()
+{
+  delete p_;
+}
+
+
+}
+# 60 "/usr/include/OpenSP/Owner.h" 2 3 4
+# 17 "/usr/include/OpenSP/Location.h" 2 3 4
+# 1 "/usr/include/OpenSP/StringC.h" 1 3 4
+
+
+
+
+
+
+
+# 1 "/usr/include/OpenSP/StringOf.h" 1 3 4
+# 14 "/usr/include/OpenSP/StringOf.h" 3 4
+# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
+# 15 "/usr/include/OpenSP/StringOf.h" 2 3 4
+
+
+
+
+namespace OpenSP {
+
+
+template<class T>
+class String {
+public:
+  typedef size_t size_type;
+  typedef T *iterator;
+  typedef const T *const_iterator;
+  String();
+  ~String() { if (ptr_) delete [] ptr_; }
+  String(const T *, size_t);
+  String(const String<T> &);
+  String<T> &operator=(const String<T> &);
+  size_t size() const { return length_; }
+  String<T> &assign(const T *, size_t);
+  String<T> &insert(size_t i, const String<T> &s);
+  void swap(String<T> &str);
+  T operator[](size_t i) const { return ptr_[i]; }
+  T &operator[](size_t i) { return ptr_[i]; }
+  iterator begin() { return ptr_; }
+  const_iterator begin() const { return ptr_; }
+  const T *data() const { return ptr_; }
+  String<T> &operator+=(T c) {
+    if (length_ >= alloc_)
+      grow(1);
+    ptr_[length_++] = c;
+    return *this;
+  }
+  String<T> &operator+=(const String<T> &s) {
+    append(s.ptr_, s.length_);
+    return *this;
+  }
+  String<T> &append(const T *, size_t);
+  Boolean operator==(const String<T> &s) const {
+    return (length_ == s.length_
+     && (length_ == 0
+  || (*ptr_ == *s.ptr_
+      && (memcmp(ptr_ + 1, s.ptr_ + 1, (length_ - 1)*sizeof(T))
+   == 0))));
+  }
+  Boolean operator!=(const String<T> &str) const {
+    return !(*this == str);
+  }
+  void resize(size_t n);
+private:
+  void grow(size_t);
+  T *ptr_;
+  size_t length_;
+  size_t alloc_;
+};
+
+
+}
+
+
+
+
+
+# 1 "/usr/include/OpenSP/StringOf.cxx" 1 3 4
+
+
+
+
+
+
+
+# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
+# 9 "/usr/include/OpenSP/StringOf.cxx" 2 3 4
+
+
+namespace OpenSP {
+
+
+template<class T>
+String<T>::String(const T *ptr, size_t length)
+: length_(length), alloc_(length)
+{
+  if (length) {
+    ptr_ = new T[length];
+    memcpy(ptr_, ptr, length*sizeof(T));
+  }
+  else
+    ptr_ = 0;
+}
+
+template<class T>
+String<T>::String()
+: ptr_(0), length_(0), alloc_(0)
+{
+}
+
+template<class T>
+String<T>::String(const String<T> &s)
+: length_(s.length_), alloc_(s.length_)
+{
+  if (length_) {
+    ptr_ = new T[length_];
+    memcpy(ptr_, s.ptr_, length_*sizeof(T));
+  }
+  else
+    ptr_ = 0;
+}
+
+template<class T>
+String<T> &String<T>::operator=(const String<T> &s)
+{
+  if (&s != this) {
+    if (s.length_ > alloc_) {
+      T *oldPtr = ptr_;
+      ptr_ = new T[alloc_ = s.length_];
+      if (oldPtr)
+ delete [] oldPtr;
+    }
+    memcpy(ptr_, s.ptr_, s.length_*sizeof(T));
+    length_ = s.length_;
+  }
+  return *this;
+}
+
+template<class T>
+String<T> &String<T>::insert(size_t i, const String<T> &s)
+{
+  if (length_ + s.length_ > alloc_)
+    grow(s.length_);
+  for (size_t n = length_ - i; n > 0; n--)
+    ptr_[i + n - 1 + s.length_] = ptr_[i + n - 1];
+  length_ += s.length_;
+  memcpy(ptr_ + i, s.ptr_, s.length_*sizeof(T));
+  return *this;
+}
+
+template<class T>
+String<T> &String<T>::append(const T *p, size_t length)
+{
+  if (length_ + length > alloc_)
+    grow(length);
+  memcpy(ptr_ + length_, p, length*sizeof(T));
+  length_ += length;
+  return *this;
+}
+
+template<class T>
+void String<T>::grow(size_t n)
+{
+  size_t newAlloc = alloc_;
+  if (alloc_ < n)
+    newAlloc += n + 16;
+  else
+    newAlloc += alloc_;
+  T *s = new T[newAlloc];
+  memcpy(s, ptr_, length_*sizeof(T));
+  delete [] ptr_;
+  ptr_ = s;
+  alloc_ = newAlloc;
+}
+
+template<class T>
+void String<T>::swap(String<T> &to)
+{
+  {
+    T *tem = to.ptr_;
+    to.ptr_ = ptr_;
+    ptr_ = tem;
+  }
+  {
+    size_t tem = to.length_;
+    to.length_ = length_;
+    length_ = tem;
+  }
+  {
+    size_t tem = to.alloc_;
+    to.alloc_ = alloc_;
+    alloc_ = tem;
+  }
+}
+
+template<class T>
+String<T> &String<T>::assign(const T *p, size_t n)
+{
+  if (alloc_ < n) {
+    T *oldPtr = ptr_;
+    ptr_ = new T[n];
+    alloc_ = n;
+    if (oldPtr)
+      delete [] oldPtr;
+  }
+  length_ = n;
+  for(T *to = ptr_; n > 0; n--, to++, p++)
+    *to = *p;
+  return *this;
+}
+
+template<class T>
+void String<T>::resize(size_t n)
+{
+  if (alloc_ < n) {
+    T *oldPtr = ptr_;
+    ptr_ = new T[n];
+    alloc_ = n;
+    if (length_ > 0) {
+      memcpy(ptr_, oldPtr, length_*sizeof(T));
+      delete [] oldPtr;
+    }
+  }
+  length_ = n;
+}
+
+
+}
+# 79 "/usr/include/OpenSP/StringOf.h" 2 3 4
+# 9 "/usr/include/OpenSP/StringC.h" 2 3 4
+
+
+namespace OpenSP {
+
+
+typedef String<Char> StringC;
+
+
+}
+# 18 "/usr/include/OpenSP/Location.h" 2 3 4
+# 1 "/usr/include/OpenSP/rtti.h" 1 3 4
+# 19 "/usr/include/OpenSP/Location.h" 2 3 4
+
+
+namespace OpenSP {
+
+
+class ExternalInfo;
+class EntityOrigin;
+class InputSourceOrigin;
+class Entity;
+class EntityDecl;
+class Location;
+class Markup;
+class Text;
+class NamedCharRef;
+
+class Origin : public Resource {
+public:
+  virtual ~Origin();
+  virtual const EntityOrigin *asEntityOrigin() const;
+  virtual const InputSourceOrigin *asInputSourceOrigin() const;
+  virtual const Location &parent() const = 0;
+  virtual Index refLength() const;
+  virtual Boolean origChars(const Char *&) const;
+  virtual Boolean inBracketedTextOpenDelim() const;
+  virtual Boolean inBracketedTextCloseDelim() const;
+  virtual Boolean isNumericCharRef(const Markup *&markup) const;
+  virtual Boolean isNamedCharRef(Index ind, NamedCharRef &ref) const;
+  virtual const EntityDecl *entityDecl() const;
+  virtual Boolean defLocation(Offset off, const Origin *&, Index &) const;
+  virtual const Markup *markup() const;
+  virtual const Entity *entity() const;
+  virtual const ExternalInfo *externalInfo() const;
+  virtual Offset startOffset(Index ind) const;
+  const StringC *entityName() const;
+};
+
+class ProxyOrigin : public Origin {
+public:
+  ProxyOrigin(const Origin *origin);
+  const EntityOrigin *asEntityOrigin() const;
+  const InputSourceOrigin *asInputSourceOrigin() const;
+  const Location &parent() const;
+  Index refLength() const;
+  Boolean origChars(const Char *&) const;
+  Boolean inBracketedTextOpenDelim() const;
+  Boolean inBracketedTextCloseDelim() const;
+  Boolean isNumericCharRef(const Markup *&markup) const;
+  Boolean isNamedCharRef(Index ind, NamedCharRef &ref) const;
+  const EntityDecl *entityDecl() const;
+  Boolean defLocation(Offset off, const Origin *&, Index &) const;
+  const Markup *markup() const;
+  const Entity *entity() const;
+  const ExternalInfo *externalInfo() const;
+  Offset startOffset(Index ind) const;
+private:
+  const Origin *origin_;
+};
+
+class Location {
+public:
+  Location();
+  Location(Origin *, Index);
+  Location(ConstPtr<Origin>, Index);
+  void operator+=(Index i) { index_ += i; }
+  void operator-=(Index i) { index_ -= i; }
+  Index index() const { return index_; }
+  const ConstPtr<Origin> &origin() const { return origin_; }
+  void clear() { origin_.clear(); }
+  void swap(Location &to) {
+    origin_.swap(to.origin_);
+    Index tem = to.index_;
+    to.index_ = index_;
+    index_ = tem;
+  }
+private:
+  ConstPtr<Origin> origin_;
+  Index index_;
+};
+
+class ExternalInfo {
+ 
+public:
+  virtual ~ExternalInfo();
+};
+
+class NamedCharRef {
+public:
+  enum RefEndType {
+    endOmitted,
+    endRE,
+    endRefc
+    };
+  NamedCharRef();
+  NamedCharRef(Index, RefEndType, const StringC &);
+  Index refStartIndex() const;
+  RefEndType refEndType() const;
+  const StringC &origName() const;
+  void set(Index, RefEndType, const Char *, size_t);
+private:
+  Index refStartIndex_;
+  RefEndType refEndType_;
+  StringC origName_;
+};
+
+struct InputSourceOriginNamedCharRef {
+  Index replacementIndex;
+  size_t origNameOffset;
+  Index refStartIndex;
+  NamedCharRef::RefEndType refEndType;
+};
+
+class InputSourceOrigin : public Origin {
+public:
+  virtual void noteCharRef(Index replacementIndex, const NamedCharRef &) = 0;
+  virtual void setExternalInfo(ExternalInfo *) = 0;
+  virtual InputSourceOrigin *copy() const = 0;
+  static InputSourceOrigin *make();
+  static InputSourceOrigin *make(const Location &refLocation);
+};
+
+
+
+class BracketOrigin : public Origin {
+public:
+  enum Position { open, close };
+  BracketOrigin(const Location &, Position);
+  const Location &parent() const;
+  Boolean inBracketedTextOpenDelim() const;
+  Boolean inBracketedTextCloseDelim() const;
+private:
+  Position pos_;
+  Location loc_;
+};
+
+class ReplacementOrigin : public Origin {
+public:
+  ReplacementOrigin(const Location &, Char origChar);
+  const Location &parent() const;
+  Boolean origChars(const Char *&) const;
+private:
+  Location loc_;
+  Char origChar_;
+};
+
+class MultiReplacementOrigin : public Origin {
+public:
+  MultiReplacementOrigin(const Location &, StringC &origChars);
+  const Location &parent() const;
+  Boolean origChars(const Char *&) const;
+private:
+  Location loc_;
+  StringC origChars_;
+};
+
+inline
+Index NamedCharRef::refStartIndex() const
+{
+  return refStartIndex_;
+}
+
+inline
+NamedCharRef::RefEndType NamedCharRef::refEndType() const
+{
+  return refEndType_;
+}
+
+inline
+const StringC &NamedCharRef::origName() const
+{
+  return origName_;
+}
+
+
+}
+# 13 "/usr/include/OpenSP/Event.h" 2 3 4
+# 1 "/usr/include/OpenSP/Vector.h" 1 3 4
+# 14 "/usr/include/OpenSP/Event.h" 2 3 4
+# 1 "/usr/include/OpenSP/Owner.h" 1 3 4
+# 15 "/usr/include/OpenSP/Event.h" 2 3 4
+
+
+# 1 "/usr/include/OpenSP/Ptr.h" 1 3 4
+# 18 "/usr/include/OpenSP/Event.h" 2 3 4
+
+# 1 "/usr/include/OpenSP/Notation.h" 1 3 4
+
+
+
+
+
+
+#pragma interface
+
+
+# 1 "/usr/include/OpenSP/Owner.h" 1 3 4
+# 11 "/usr/include/OpenSP/Notation.h" 2 3 4
+
+# 1 "/usr/include/OpenSP/NamedResource.h" 1 3 4
+
+
+
+
+
+
+# 1 "/usr/include/OpenSP/Named.h" 1 3 4
+# 10 "/usr/include/OpenSP/Named.h" 3 4
+namespace OpenSP {
+
+
+class Named {
+public:
+  Named(const StringC &name) : name_(name) { }
+  virtual ~Named() { }
+  const StringC &name() const { return name_; }
+  const StringC *namePointer() const { return &name_; }
+  void setName(const StringC &name) { name_ = name; }
+  void swap(Named &to) { name_.swap(to.name_); }
+private:
+  StringC name_;
+};
+
+
+}
+# 8 "/usr/include/OpenSP/NamedResource.h" 2 3 4
+
+
+
+namespace OpenSP {
+
+
+class NamedResource : public Named, public Resource {
+public:
+  NamedResource(const StringC &str) : Named(str) { }
+};
+
+
+}
+# 13 "/usr/include/OpenSP/Notation.h" 2 3 4
+
+# 1 "/usr/include/OpenSP/Ptr.h" 1 3 4
+# 15 "/usr/include/OpenSP/Notation.h" 2 3 4
+# 1 "/usr/include/OpenSP/ExternalId.h" 1 3 4
+
+
+
+
+
+
+#pragma interface
+
+
+
+
+# 1 "/usr/include/OpenSP/Text.h" 1 3 4
+
+
+
+
+
+
+#pragma interface
+
+
+
+
+# 1 "/usr/include/OpenSP/Vector.h" 1 3 4
+# 13 "/usr/include/OpenSP/Text.h" 2 3 4
+
+# 1 "/usr/include/OpenSP/SubstTable.h" 1 3 4
+# 9 "/usr/include/OpenSP/SubstTable.h" 3 4
+# 1 "/usr/include/OpenSP/Vector.h" 1 3 4
+# 10 "/usr/include/OpenSP/SubstTable.h" 2 3 4
+
+
+namespace OpenSP {
+
+
+class SubstTable {
+public:
+  SubstTable();
+  void addSubst(Char from, Char to);
+  void subst(Char &) const;
+  void subst(StringC &) const;
+  Char operator[](Char from) const;
+  void sort() const;
+  Char at(Char from) const;
+  StringC inverse(Char to) const;
+  void inverseTable(SubstTable &) const;
+  struct Pair {
+    Pair() {}
+    Pair(Char f, Char t) : from(f), to(t) {}
+    Char from;
+    Char to;
+  };
+private:
+  Char lo_[256];
+  mutable Vector<Pair> map_;
+  mutable bool isSorted_;
+};
+
+inline
+void SubstTable::subst(StringC &str) const
+{
+  for (size_t i = 0; i < str.size(); i++)
+    subst(str[i]);
+}
+
+inline
+Char SubstTable::operator[](Char t) const
+{
+  if (t < 256)
+    return lo_[t];
+  else
+    return at(t);
+}
+
+inline
+void SubstTable::subst(Char &c) const
+{
+  c = operator[](c);
+}
+
+
+}
+# 15 "/usr/include/OpenSP/Text.h" 2 3 4
+# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
+# 16 "/usr/include/OpenSP/Text.h" 2 3 4
+
+
+namespace OpenSP {
+
+
+struct TextItem {
+  TextItem();
+  enum Type {
+    data,
+    cdata,
+    sdata,
+    nonSgml,
+    entityStart,
+    entityEnd,
+    startDelim,
+    endDelim,
+    endDelimA,
+    ignore
+    };
+  Type type;
+
+  Char c;
+
+
+
+
+
+
+
+  Location loc;
+
+  size_t index;
+};
+
+
+
+class Text {
+public:
+  Text();
+
+  ~Text();
+  void clear();
+  void swap(Text &to);
+  void addChar(Char c, const Location &);
+  void addChars(const StringC &, const Location &);
+  void addChars(const Char *, size_t, const Location &);
+  void insertChars(const StringC &, const Location &);
+  void ignoreChar(Char, const Location &);
+  void ignoreLastChar();
+  void addNonSgmlChar(Char c, const Location &);
+  void addEntityStart(const Location &);
+  void addEntityEnd(const Location &);
+  void addCdata(const StringC &, const ConstPtr<Origin> &);
+  void addSdata(const StringC &, const ConstPtr<Origin> &);
+  void addStartDelim(const Location &loc);
+  void addEndDelim(const Location &loc, Boolean lita);
+  void subst(const SubstTable &, Char space);
+  void addCharsTokenize(const Char *, size_t, const Location &loc, Char space);
+  void addCharsTokenize(const StringC &, const Location &loc, Char space);
+  void tokenize(Char space, Text &text) const;
+  Location charLocation(size_t i) const;
+  Boolean charLocation(size_t, const Origin *&, Index &) const;
+  Boolean charLocation(size_t i, const ConstPtr<Origin> *&, Index &) const;
+  size_t size() const;
+  Char lastChar() const;
+  const StringC &string() const;
+  size_t normalizedLength(size_t normsep) const;
+  Boolean fixedEqual(const Text &) const;
+
+  Boolean startDelimLocation(Location &) const;
+
+  Boolean endDelimLocation(Location &) const;
+
+  Boolean delimType(Boolean &lita) const;
+private:
+  void addSimple(TextItem::Type, const Location &);
+  StringC chars_;
+  Vector<TextItem> items_;
+  friend class TextIter;
+};
+
+class TextIter {
+public:
+  TextIter(const Text &);
+  void rewind();
+  Boolean next(TextItem::Type &, const Char *&, size_t &,
+        const Location *&);
+
+  Boolean valid() const;
+  void advance();
+  TextItem::Type type() const;
+  const Location &location() const;
+  const Char *chars(size_t &length) const;
+private:
+  const TextItem *ptr_;
+  const Text *text_;
+};
+
+inline
+size_t Text::size() const
+{
+  return chars_.size();
+}
+
+inline
+Char Text::lastChar() const
+{
+  return chars_[chars_.size() - 1];
+}
+
+inline
+const StringC &Text::string() const
+{
+  return chars_;
+}
+
+inline
+void Text::addEntityStart(const Location &loc)
+{
+  addSimple(TextItem::entityStart, loc);
+}
+
+inline
+void Text::addEntityEnd(const Location &loc)
+{
+  addSimple(TextItem::entityEnd, loc);
+}
+
+inline
+void Text::addChars(const StringC &s, const Location &loc)
+{
+  addChars(s.data(), s.size(), loc);
+}
+
+inline
+void Text::addStartDelim(const Location &loc)
+{
+  addSimple(TextItem::startDelim, loc);
+}
+
+inline
+void Text::addEndDelim(const Location &loc, Boolean lita)
+{
+  addSimple(lita ? TextItem::endDelimA : TextItem::endDelim,
+     loc);
+}
+
+inline
+void Text::addCharsTokenize(const StringC &str, const Location &loc,
+       Char space)
+{
+  addCharsTokenize(str.data(), str.size(), loc, space);
+}
+
+inline
+Location Text::charLocation(size_t i) const
+{
+  const ConstPtr<Origin> *originP;
+  Index index;
+  if (charLocation(i, originP, index))
+    return Location(*originP, index);
+  else
+    return Location();
+}
+
+inline
+Boolean Text::charLocation(size_t i, const Origin *&origin, Index &index) const
+{
+  const ConstPtr<Origin> *originP;
+  if (charLocation(i, originP, index)) {
+    origin = originP->pointer();
+    return 1;
+  }
+  else
+    return 0;
+}
+
+inline
+void TextIter::rewind()
+{
+  ptr_ = text_->items_.begin();
+}
+
+inline
+void TextIter::advance()
+{
+  ptr_++;
+}
+
+inline
+Boolean TextIter::valid() const
+{
+  return ptr_ != (text_->items_.begin() + text_->items_.size());
+}
+
+inline
+const Location &TextIter::location() const
+{
+  return ptr_->loc;
+}
+
+inline
+TextItem::Type TextIter::type() const
+{
+  return ptr_->type;
+}
+
+
+}
+# 13 "/usr/include/OpenSP/ExternalId.h" 2 3 4
+
+# 1 "/usr/include/OpenSP/Message.h" 1 3 4
+
+
+
+
+
+
+
+#pragma interface
+
+
+# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
+# 12 "/usr/include/OpenSP/Message.h" 2 3 4
+
+# 1 "/usr/include/OpenSP/Vector.h" 1 3 4
+# 14 "/usr/include/OpenSP/Message.h" 2 3 4
+# 1 "/usr/include/OpenSP/CopyOwner.h" 1 3 4
+
+
+
+
+
+
+# 1 "/usr/include/OpenSP/Owner.h" 1 3 4
+# 8 "/usr/include/OpenSP/CopyOwner.h" 2 3 4
+
+
+namespace OpenSP {
+
+
+template<class T>
+class CopyOwner : public Owner<T> {
+public:
+  CopyOwner() { }
+  CopyOwner(T *p) : Owner<T>(p) { }
+  CopyOwner(const CopyOwner<T> &);
+  void operator=(const CopyOwner<T> &o);
+  void operator=(T *p) { Owner<T>::operator=(p); }
+};
+
+
+}
+
+
+
+
+
+# 1 "/usr/include/OpenSP/CopyOwner.cxx" 1 3 4
+
+
+
+
+
+
+
+namespace OpenSP {
+
+
+template<class T>
+CopyOwner<T>::CopyOwner(const CopyOwner<T> &o)
+: Owner<T>(o.pointer() ? o.pointer()->copy() : 0)
+{
+}
+
+template<class T>
+void CopyOwner<T>::operator=(const CopyOwner<T> &o)
+{
+  Owner<T>::operator=(o.pointer() ? o.pointer()->copy() : 0);
+}
+
+
+}
+# 31 "/usr/include/OpenSP/CopyOwner.h" 2 3 4
+# 15 "/usr/include/OpenSP/Message.h" 2 3 4
+
+
+# 1 "/usr/include/OpenSP/MessageArg.h" 1 3 4
+
+
+
+
+
+
+#pragma interface
+
+
+
+# 1 "/usr/include/OpenSP/Vector.h" 1 3 4
+# 12 "/usr/include/OpenSP/MessageArg.h" 2 3 4
+
+
+
+namespace OpenSP {
+
+
+class MessageBuilder;
+
+class MessageArg {
+public:
+  MessageArg();
+  virtual ~MessageArg();
+  virtual MessageArg *copy() const = 0;
+  virtual void append(MessageBuilder &) const = 0;
+};
+
+class StringMessageArg : public MessageArg {
+public:
+  StringMessageArg(const StringC &);
+  MessageArg *copy() const;
+  void append(MessageBuilder &) const;
+private:
+  StringC s_;
+};
+
+class NumberMessageArg : public MessageArg {
+public:
+  NumberMessageArg(unsigned long);
+  MessageArg *copy() const;
+  void append(MessageBuilder &) const;
+private:
+  unsigned long n_;
+};
+
+class OrdinalMessageArg : public MessageArg {
+public:
+  OrdinalMessageArg(unsigned long);
+  MessageArg *copy() const;
+  void append(MessageBuilder &) const;
+private:
+  unsigned long n_;
+};
+
+class OtherMessageArg : public MessageArg {
+ 
+public:
+  OtherMessageArg();
+  void append(MessageBuilder &) const;
+};
+
+class StringVectorMessageArg : public MessageArg {
+public:
+  StringVectorMessageArg(const Vector<StringC> &);
+  MessageArg *copy() const;
+  void append(MessageBuilder &) const;
+private:
+  Vector<StringC> v_;
+};
+
+
+
+}
+# 18 "/usr/include/OpenSP/Message.h" 2 3 4
+
+
+namespace OpenSP {
+
+
+class MessageModule;
+extern MessageModule libModule;
+extern MessageModule appModule;
+
+class MessageFragment {
+public:
+  MessageFragment(const MessageModule *module, unsigned number, const char *text = 0);
+  const MessageModule *module() const;
+  unsigned number() const;
+  const char *text() const;
+private:
+  unsigned short number_;
+  const MessageModule * module_;
+protected:
+  unsigned char spare_;
+private:
+
+  const char *text_;
+
+};
+
+class MessageType : public MessageFragment {
+public:
+  enum Severity {
+    info,
+    warning,
+    quantityError,
+    idrefError,
+    error
+    };
+  MessageType(Severity = info, const MessageModule *module = &libModule,
+       unsigned number = unsigned(-1),
+       const char *text = 0, const char *clauses = 0,
+              const char *auxText = 0);
+  Severity severity() const;
+  MessageFragment auxFragment() const;
+  Boolean isError() const;
+  const char *clauses() const;
+private:
+
+  const char *clauses_;
+  const char *auxText_;
+
+};
+
+
+class MessageType0 : public MessageType {
+public:
+  MessageType0(Severity = info, const MessageModule *module = &libModule,
+        unsigned number = unsigned(-1), const char *text = 0,
+               const char *clauses = 0);
+};
+
+class MessageType1 : public MessageType {
+public:
+  MessageType1(Severity = info, const MessageModule *module = &libModule,
+        unsigned number = unsigned(-1), const char *text = 0,
+               const char *clauses = 0);
+};
+
+class MessageType2 : public MessageType {
+public:
+  MessageType2(Severity = info, const MessageModule *module = &libModule,
+        unsigned number = unsigned(-1), const char *text = 0,
+               const char *clauses = 0);
+};
+
+class MessageType3 : public MessageType {
+public:
+  MessageType3(Severity = info, const MessageModule *module = &libModule,
+        unsigned number = unsigned(-1), const char *text = 0,
+               const char *clauses = 0);
+};
+
+class MessageType4 : public MessageType {
+public:
+  MessageType4(Severity = info, const MessageModule *module = &libModule,
+        unsigned number = unsigned(-1), const char *text = 0,
+               const char *clauses = 0);
+};
+
+class MessageType5 : public MessageType {
+public:
+  MessageType5(Severity = info, const MessageModule *module = &libModule,
+        unsigned number = unsigned(-1), const char *text = 0,
+               const char *clauses = 0);
+};
+
+class MessageType6 : public MessageType {
+public:
+  MessageType6(Severity = info, const MessageModule *module = &libModule,
+        unsigned number = unsigned(-1), const char *text = 0,
+               const char *clauses = 0);
+};
+
+class MessageType0L : public MessageType {
+public:
+  MessageType0L(Severity = info, const MessageModule *module = &libModule,
+  unsigned number = unsigned(-1), const char *text = 0,
+  const char *clauses = 0, const char *auxText = 0);
+};
+
+class MessageType1L : public MessageType {
+public:
+  MessageType1L(Severity = info, const MessageModule *module = &libModule,
+  unsigned number = unsigned(-1), const char *text = 0,
+  const char *clauses = 0, const char *auxText = 0);
+};
+
+class OpenElementInfo {
+public:
+  OpenElementInfo();
+  PackedBoolean included;
+  StringC gi;
+  StringC matchType;
+  unsigned matchIndex;
+};
+
+class Message {
+public:
+  Message();
+  Message(int nArgs);
+  const MessageType *type;
+  Location loc;
+  Location auxLoc;
+  Vector<CopyOwner<MessageArg> > args;
+  Vector<OpenElementInfo> openElementInfo;
+  void swap(Message &);
+  Boolean isError() const;
+};
+
+class Messenger {
+public:
+  Messenger();
+  virtual ~Messenger();
+  void message(const MessageType0 &);
+  void message(const MessageType1 &, const MessageArg &);
+  void message(const MessageType2 &,
+        const MessageArg &,
+        const MessageArg &);
+  void message(const MessageType3 &,
+        const MessageArg &,
+        const MessageArg &,
+        const MessageArg &);
+  void message(const MessageType4 &,
+        const MessageArg &,
+        const MessageArg &,
+        const MessageArg &,
+        const MessageArg &);
+  void message(const MessageType5 &,
+        const MessageArg &,
+        const MessageArg &,
+        const MessageArg &,
+        const MessageArg &,
+        const MessageArg &);
+  void message(const MessageType6 &,
+        const MessageArg &,
+        const MessageArg &,
+        const MessageArg &,
+        const MessageArg &,
+        const MessageArg &,
+        const MessageArg &);
+  void message(const MessageType0L &, const Location &);
+  void message(const MessageType1L &, const MessageArg &, const Location &);
+  void setNextLocation(const Location &);
+  virtual void initMessage(Message &);
+  virtual void dispatchMessage(const Message &) = 0;
+  virtual void dispatchMessage(Message &);
+private:
+  void doInitMessage(Message &);
+  Boolean haveNextLocation_;
+  Location nextLocation_;
+};
+
+class ForwardingMessenger : public Messenger {
+public:
+  ForwardingMessenger(Messenger &);
+  void dispatchMessage(const Message &);
+  void dispatchMessage(Message &);
+  void initMessage(Message &);
+private:
+  Messenger *to_;
+};
+
+class ParentLocationMessenger : public ForwardingMessenger {
+public:
+  ParentLocationMessenger(Messenger &);
+  void initMessage(Message &);
+};
+
+class NullMessenger : public Messenger {
+public:
+  NullMessenger();
+  void dispatchMessage(const Message &);
+};
+
+inline
+const MessageModule *MessageFragment::module() const
+{
+  return module_;
+}
+
+inline
+unsigned MessageFragment::number() const
+{
+  return number_;
+}
+
+inline
+const char *MessageFragment::text() const
+{
+
+
+
+  return text_;
+
+}
+
+inline
+MessageType::Severity MessageType::severity() const
+{
+  return Severity(spare_);
+}
+
+inline
+MessageFragment MessageType::auxFragment() const
+{
+  return MessageFragment(module(),
+    number() + 1,
+
+
+
+    auxText_
+
+    );
+}
+
+inline
+Boolean MessageType::isError() const
+{
+  return severity() != info && severity() != warning;
+}
+
+inline
+const char *MessageType::clauses() const
+{
+
+
+
+  return clauses_;
+
+}
+
+inline
+Boolean Message::isError() const
+{
+  return type->isError();
+}
+
+
+}
+# 15 "/usr/include/OpenSP/ExternalId.h" 2 3 4
+
+
+namespace OpenSP {
+
+
+class CharsetInfo;
+
+class PublicId {
+public:
+  enum Type {
+    informal,
+    fpi,
+    urn
+  };
+  enum TextClass {
+    CAPACITY,
+    CHARSET,
+    DOCUMENT,
+    DTD,
+    ELEMENTS,
+    ENTITIES,
+    LPD,
+    NONSGML,
+    NOTATION,
+    SD,
+    SHORTREF,
+    SUBDOC,
+    SYNTAX,
+    TEXT
+  };
+  enum OwnerType {
+    ISO,
+    registered,
+    unregistered
+    };
+  PublicId();
+
+  Boolean getOwnerType(OwnerType &) const;
+  Boolean getOwner(StringC &) const;
+  Boolean getTextClass(TextClass &) const;
+  Boolean getUnavailable(Boolean &) const;
+  Boolean getDescription(StringC &) const;
+  Boolean getLanguage(StringC &) const;
+  Boolean getDesignatingSequence(StringC &) const;
+  Boolean getDisplayVersion(StringC &) const;
+
+  Boolean getNamespaceIdentifier(StringC &) const;
+  Boolean getNamespaceSpecificString(StringC &) const;
+
+
+
+  Type init(Text &, const CharsetInfo &, Char space,
+        const MessageType1 *&fpierror,
+               const MessageType1 *&urnerror);
+  const StringC &string() const;
+  const Text &text() const;
+  const Type type() const { return type_; }
+private:
+  Boolean initFpi(const StringC &, const CharsetInfo &, Char,
+               const MessageType1 *&);
+  Boolean initUrn(const StringC &, const CharsetInfo &, Char,
+               const MessageType1 *&);
+  static Boolean nextField(Char solidus,
+      const Char *&next,
+      const Char *lim,
+      const Char *&fieldStart,
+      size_t &fieldLength,
+                           Boolean dup = 1);
+  static Boolean lookupTextClass(const StringC &, const CharsetInfo &,
+     TextClass &);
+  static const char *const textClasses[];
+
+  Type type_;
+  OwnerType ownerType_;
+  StringC owner_;
+  TextClass textClass_;
+  PackedBoolean unavailable_;
+  StringC description_;
+  StringC languageOrDesignatingSequence_;
+  PackedBoolean haveDisplayVersion_;
+  StringC displayVersion_;
+  Text text_;
+  StringC nid_;
+  StringC nss_;
+};
+
+class ExternalId {
+public:
+  ExternalId();
+  const StringC *systemIdString() const;
+  const StringC *publicIdString() const;
+  const StringC &effectiveSystemId() const;
+  const Text *systemIdText() const;
+  const Text *publicIdText() const;
+  const PublicId *publicId() const;
+  void setSystem(Text &);
+  void setEffectiveSystem(StringC &);
+
+
+
+  PublicId::Type setPublic(Text &, const CharsetInfo &, Char space,
+      const MessageType1 *&fpierror,
+      const MessageType1 *&urnerror);
+  void setLocation(const Location &);
+
+  const Location &location() const;
+private:
+  PackedBoolean haveSystem_;
+  PackedBoolean havePublic_;
+  Text system_;
+  PublicId public_;
+  Location loc_;
+  StringC effectiveSystem_;
+};
+
+inline
+const StringC &PublicId::string() const
+{
+  return text_.string();
+}
+
+inline
+const Text &PublicId::text() const
+{
+  return text_;
+}
+
+inline
+const StringC *ExternalId::systemIdString() const
+{
+  return haveSystem_ ? &system_.string() : 0;
+}
+
+inline
+const StringC *ExternalId::publicIdString() const
+{
+  return havePublic_ ? &public_.string() : 0;
+}
+
+inline
+const Text *ExternalId::systemIdText() const
+{
+  return haveSystem_ ? &system_ : 0;
+}
+
+inline
+const Text *ExternalId::publicIdText() const
+{
+  return havePublic_ ? &public_.text() : 0;
+}
+
+inline
+const PublicId *ExternalId::publicId() const
+{
+  return havePublic_ ? &public_ : 0;
+}
+
+inline
+const Location &ExternalId::location() const
+{
+  return loc_;
+}
+
+inline
+const StringC &ExternalId::effectiveSystemId() const
+{
+  return effectiveSystem_;
+}
+
+inline
+void ExternalId::setEffectiveSystem(StringC &str)
+{
+  str.swap(effectiveSystem_);
+}
+
+
+}
+# 16 "/usr/include/OpenSP/Notation.h" 2 3 4
+
+# 1 "/usr/include/OpenSP/Attributed.h" 1 3 4
+
+
+
+
+
+
+# 1 "/usr/include/OpenSP/Ptr.h" 1 3 4
+# 8 "/usr/include/OpenSP/Attributed.h" 2 3 4
+# 1 "/usr/include/OpenSP/Attribute.h" 1 3 4
+
+
+
+
+
+
+#pragma interface
+
+
+# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
+# 11 "/usr/include/OpenSP/Attribute.h" 2 3 4
+
+# 1 "/usr/include/OpenSP/Owner.h" 1 3 4
+# 13 "/usr/include/OpenSP/Attribute.h" 2 3 4
+
+# 1 "/usr/include/OpenSP/Vector.h" 1 3 4
+# 15 "/usr/include/OpenSP/Attribute.h" 2 3 4
+# 1 "/usr/include/OpenSP/CopyOwner.h" 1 3 4
+# 16 "/usr/include/OpenSP/Attribute.h" 2 3 4
+
+
+# 1 "/usr/include/OpenSP/Ptr.h" 1 3 4
+# 19 "/usr/include/OpenSP/Attribute.h" 2 3 4
+
+
+
+namespace OpenSP {
+
+
+class Entity;
+class Notation;
+class DeclaredValue;
+class AttributeValue;
+class TokenizedAttributeValue;
+class AttributeSemantics;
+class AttributeContext;
+class Syntax;
+
+ class AttributeValue : public Resource {
+ public:
+   enum Type {
+     implied,
+     cdata,
+     tokenized
+   };
+   AttributeValue();
+   virtual ~AttributeValue();
+   virtual AttributeSemantics *makeSemantics(const DeclaredValue *,
+                                             AttributeContext &,
+                                             const StringC &,
+                                             unsigned &,
+                                             unsigned &) const;
+   virtual Type info(const Text *&, const StringC *&) const = 0;
+   virtual const Text *text() const;
+   virtual Boolean recoverUnquoted(const StringC &, const Location &,
+                                   AttributeContext &, const StringC &);
+   static Boolean handleAsUnterminated(const Text &, AttributeContext &);
+ };
+
+class AttributeDefinitionDesc {
+public:
+  AttributeDefinitionDesc() { }
+  enum DeclaredValue {
+    cdata,
+    name,
+    number,
+    nmtoken,
+    nutoken,
+    entity,
+    idref,
+    names,
+    numbers,
+    nmtokens,
+    nutokens,
+    entities,
+    idrefs,
+    id,
+    notation,
+    nameTokenGroup
+  };
+  DeclaredValue declaredValue;
+  enum DefaultValueType {
+    required,
+    current,
+    implied,
+    conref,
+    defaulted,
+    fixed
+  };
+  DefaultValueType defaultValueType;
+  ConstPtr<AttributeValue> defaultValue;
+  Vector<StringC> allowedValues;
+  Vector<StringC> origAllowedValues;
+
+
+  size_t currentIndex;
+private:
+  AttributeDefinitionDesc(const AttributeDefinitionDesc &);
+  void operator=(const AttributeDefinitionDesc &);
+};
+
+class DeclaredValue {
+public:
+  DeclaredValue();
+  virtual ~DeclaredValue();
+
+  virtual AttributeValue *makeValue(Text &, AttributeContext &,
+        const StringC &name,
+        unsigned &specLength) const = 0;
+
+
+  virtual AttributeValue *makeValueFromToken(Text &,
+          AttributeContext &,
+          const StringC &name,
+          unsigned &specLength) const;
+
+  virtual AttributeSemantics *makeSemantics(const TokenizedAttributeValue &,
+         AttributeContext &,
+         const StringC &,
+         unsigned &nIdrefs,
+         unsigned &nEntityNames) const;
+  virtual Boolean containsToken(const StringC &) const;
+  virtual Boolean tokenized() const = 0;
+  virtual Boolean isNotation() const;
+  virtual Boolean isEntity() const;
+  virtual Boolean isId() const;
+  virtual Boolean isIdref() const;
+  virtual const Vector<StringC> *getTokens() const;
+  virtual const Vector<StringC> *getOrigTokens() const;
+  virtual void buildDesc(AttributeDefinitionDesc &) const = 0;
+  virtual DeclaredValue *copy() const = 0;
+};
+
+class CdataDeclaredValue : public DeclaredValue {
+public:
+  CdataDeclaredValue();
+  Boolean tokenized() const;
+  AttributeValue *makeValue(Text &, AttributeContext &, const StringC &,
+       unsigned &) const;
+  void buildDesc(AttributeDefinitionDesc &) const;
+  DeclaredValue *copy() const;
+protected:
+  void checkNormalizedLength(Text &, AttributeContext &, unsigned &) const;
+};
+
+
+class TokenizedDeclaredValue : public DeclaredValue {
+public:
+
+  enum TokenType {
+    name,
+    number,
+    nameToken,
+    numberToken,
+    entityName
+  };
+  TokenizedDeclaredValue(TokenType type, Boolean isList);
+  AttributeValue *makeValue(Text &, AttributeContext &, const StringC &,
+       unsigned &) const;
+  TokenizedAttributeValue *makeTokenizedValue(Text &, AttributeContext &,
+           const StringC &, unsigned &) const;
+  Boolean tokenized() const;
+  void buildDesc(AttributeDefinitionDesc &) const;
+  DeclaredValue *copy() const;
+private:
+  TokenType type_;
+  Boolean isList_;
+  unsigned initialCategories_;
+  unsigned subsequentCategories_;
+};
+
+class GroupDeclaredValue : public TokenizedDeclaredValue {
+public:
+  GroupDeclaredValue(TokenType, Vector<StringC> &);
+  Boolean containsToken(const StringC &) const;
+  AttributeValue *makeValue(Text &, AttributeContext &, const StringC &,
+       unsigned &) const;
+  AttributeValue *makeValueFromToken(Text &,
+         AttributeContext &,
+         const StringC &name,
+         unsigned &) const;
+  const Vector<StringC> *getTokens() const;
+  const Vector<StringC> *getOrigTokens() const;
+  void buildDesc(AttributeDefinitionDesc &) const;
+  DeclaredValue *copy() const;
+  void setOrigAllowedValues(Vector<StringC> &origAllowedValues);
+
+private:
+  Vector<StringC> allowedValues_;
+  Vector<StringC> origAllowedValues_;
+};
+
+class NameTokenGroupDeclaredValue : public GroupDeclaredValue {
+public:
+  NameTokenGroupDeclaredValue(Vector<StringC> &);
+  void buildDesc(AttributeDefinitionDesc &) const;
+  DeclaredValue *copy() const;
+};
+
+class NotationDeclaredValue : public GroupDeclaredValue {
+public:
+  NotationDeclaredValue(Vector<StringC> &);
+  AttributeSemantics *makeSemantics(const TokenizedAttributeValue &,
+        AttributeContext &,
+        const StringC &,
+        unsigned &nIdrefs,
+        unsigned &nEntityNames) const;
+  Boolean isNotation() const;
+  void buildDesc(AttributeDefinitionDesc &) const;
+  DeclaredValue *copy() const;
+};
+
+class EntityDeclaredValue : public TokenizedDeclaredValue {
+public:
+  EntityDeclaredValue(Boolean isList);
+  AttributeSemantics *makeSemantics(const TokenizedAttributeValue &,
+        AttributeContext &,
+        const StringC &,
+        unsigned &nIdrefs,
+        unsigned &nEntityNames) const;
+  Boolean isEntity() const;
+  DeclaredValue *copy() const;
+};
+
+class IdDeclaredValue : public TokenizedDeclaredValue {
+public:
+  IdDeclaredValue();
+  AttributeSemantics *makeSemantics(const TokenizedAttributeValue &,
+        AttributeContext &,
+        const StringC &,
+        unsigned &nIdrefs,
+        unsigned &nEntityNames) const;
+  Boolean isId() const;
+  void buildDesc(AttributeDefinitionDesc &) const;
+  DeclaredValue *copy() const;
+};
+
+class IdrefDeclaredValue : public TokenizedDeclaredValue {
+public:
+  IdrefDeclaredValue(Boolean isList);
+  AttributeSemantics *makeSemantics(const TokenizedAttributeValue &,
+        AttributeContext &,
+        const StringC &,
+        unsigned &nIdrefs,
+        unsigned &nEntityNames) const;
+  Boolean isIdref() const;
+  void buildDesc(AttributeDefinitionDesc &) const;
+  DeclaredValue *copy() const;
+};
+
+class AttributeDefinition {
+public:
+  AttributeDefinition(const StringC &, DeclaredValue *);
+  virtual ~AttributeDefinition();
+  virtual ConstPtr<AttributeValue>
+    makeMissingValue(AttributeContext &) const = 0;
+  virtual Boolean missingValueWouldMatch(const Text &,
+      const AttributeContext &) const;
+  virtual const AttributeValue *
+    defaultValue(const AttributeValue *impliedValue) const;
+  AttributeValue *makeValue(Text &, AttributeContext &, unsigned &) const;
+  AttributeValue *makeValueFromToken(Text &,
+         AttributeContext &,
+         unsigned &) const;
+
+  virtual Boolean isConref() const;
+  virtual Boolean isCurrent() const;
+  virtual Boolean isFixed() const;
+  AttributeSemantics *makeSemantics(const AttributeValue *,
+        AttributeContext &,
+        unsigned &nIdrefs,
+        unsigned &nEntityNames) const;
+  Boolean tokenized() const;
+  const StringC &name() const;
+  const StringC &origName() const;
+  Boolean containsToken(const StringC &) const;
+  Boolean isNotation() const;
+  Boolean isEntity() const;
+  Boolean isId() const;
+  Boolean isIdref() const;
+  void getDesc(AttributeDefinitionDesc &) const;
+  const Vector<StringC> *getTokens() const;
+  const Vector<StringC> *getOrigTokens() const;
+  virtual AttributeDefinition *copy() const = 0;
+  void setDeclaredValue(DeclaredValue *);
+  void setSpecified(Boolean implicit);
+  Boolean isSpecified(Boolean &implicit);
+  void setOrigName(StringC &origName);
+private:
+  virtual void buildDesc(AttributeDefinitionDesc &) const = 0;
+  virtual AttributeValue *checkValue(AttributeValue *, AttributeContext &) const;
+  PackedBoolean implicit_;
+  PackedBoolean all_;
+  StringC name_;
+  StringC origName_;
+  CopyOwner<DeclaredValue> declaredValue_;
+};
+
+class RequiredAttributeDefinition : public AttributeDefinition {
+public:
+  RequiredAttributeDefinition(const StringC &, DeclaredValue *);
+  ConstPtr<AttributeValue> makeMissingValue(AttributeContext &) const;
+  void buildDesc(AttributeDefinitionDesc &) const;
+  AttributeDefinition *copy() const;
+};
+
+class CurrentAttributeDefinition : public AttributeDefinition {
+public:
+  CurrentAttributeDefinition(const StringC &, DeclaredValue *, size_t index);
+  ConstPtr<AttributeValue> makeMissingValue(AttributeContext &) const;
+  Boolean missingValueWouldMatch(const Text &, const AttributeContext &) const;
+  AttributeValue *checkValue(AttributeValue *, AttributeContext &) const;
+  void buildDesc(AttributeDefinitionDesc &) const;
+  Boolean isCurrent() const;
+  AttributeDefinition *copy() const;
+private:
+  size_t currentIndex_;
+};
+
+class ImpliedAttributeDefinition : public AttributeDefinition {
+public:
+  ImpliedAttributeDefinition(const StringC &, DeclaredValue *);
+  ConstPtr<AttributeValue> makeMissingValue(AttributeContext &) const;
+  const AttributeValue *defaultValue(const AttributeValue *) const;
+  void buildDesc(AttributeDefinitionDesc &) const;
+  AttributeDefinition *copy() const;
+};
+
+class ConrefAttributeDefinition : public ImpliedAttributeDefinition {
+public:
+  ConrefAttributeDefinition(const StringC &, DeclaredValue *);
+  Boolean isConref() const;
+  void buildDesc(AttributeDefinitionDesc &) const;
+  AttributeDefinition *copy() const;
+};
+
+class DefaultAttributeDefinition : public AttributeDefinition {
+public:
+  DefaultAttributeDefinition(const StringC &, DeclaredValue *,
+        AttributeValue *);
+  ConstPtr<AttributeValue> makeMissingValue(AttributeContext &) const;
+  Boolean missingValueWouldMatch(const Text &, const AttributeContext &) const;
+  void buildDesc(AttributeDefinitionDesc &) const;
+  AttributeDefinition *copy() const;
+  const AttributeValue *defaultValue(const AttributeValue *) const;
+private:
+  ConstPtr<AttributeValue> value_;
+};
+
+class FixedAttributeDefinition : public DefaultAttributeDefinition {
+public:
+  FixedAttributeDefinition(const StringC &, DeclaredValue *,
+      AttributeValue *);
+
+  AttributeValue *checkValue(AttributeValue *, AttributeContext &) const;
+  void buildDesc(AttributeDefinitionDesc &) const;
+  Boolean isFixed() const;
+  AttributeDefinition *copy() const;
+};
+
+class AttributeDefinitionList : public Resource {
+public:
+  AttributeDefinitionList(Vector<CopyOwner<AttributeDefinition> > &,
+     size_t listIndex,
+     Boolean anyCurrent = 0,
+     size_t idIndex = size_t(-1),
+     size_t notationIndex = size_t(-1));
+  AttributeDefinitionList(const ConstPtr<AttributeDefinitionList> &);
+  size_t size() const;
+  AttributeDefinition *def(size_t);
+  const AttributeDefinition *def(size_t) const;
+  Boolean tokenIndex(const StringC &, unsigned &) const;
+  Boolean tokenIndexUnique(const StringC &, unsigned) const;
+  Boolean attributeIndex(const StringC &, unsigned &) const;
+  size_t index() const;
+  size_t idIndex() const;
+  size_t notationIndex() const;
+  Boolean anyCurrent() const;
+  void setIndex(size_t);
+  void append(AttributeDefinition *);
+private:
+  Vector<CopyOwner<AttributeDefinition> > defs_;
+  size_t index_;
+  size_t idIndex_;
+  size_t notationIndex_;
+  Boolean anyCurrent_;
+  ConstPtr<AttributeDefinitionList> prev_;
+};
+
+class AttributeSemantics {
+public:
+  AttributeSemantics();
+  virtual ~AttributeSemantics();
+  virtual size_t nEntities() const;
+  virtual ConstPtr<Entity> entity(size_t) const;
+  virtual ConstPtr<Notation> notation() const;
+  virtual AttributeSemantics *copy() const = 0;
+};
+
+class EntityAttributeSemantics : public AttributeSemantics {
+public:
+  EntityAttributeSemantics(Vector<ConstPtr<Entity> > &);
+  size_t nEntities() const;
+  ConstPtr<Entity> entity(size_t) const;
+  AttributeSemantics *copy() const;
+private:
+  Vector<ConstPtr<Entity> > entity_;
+};
+
+class NotationAttributeSemantics : public AttributeSemantics {
+public:
+  NotationAttributeSemantics(const ConstPtr<Notation> &);
+  ConstPtr<Notation> notation() const;
+  AttributeSemantics *copy() const;
+private:
+  ConstPtr<Notation> notation_;
+};
+
+class ImpliedAttributeValue : public AttributeValue {
+public:
+  ImpliedAttributeValue();
+  Type info(const Text *&, const StringC *&) const;
+};
+
+class CdataAttributeValue : public AttributeValue {
+public:
+  CdataAttributeValue(Text &);
+  Type info(const Text *&, const StringC *&) const;
+  const Text *text() const;
+  Boolean recoverUnquoted(const StringC &, const Location &,
+     AttributeContext &, const StringC &);
+  virtual const Notation *notation() const;
+private:
+  Text text_;
+};
+
+
+class TokenizedAttributeValue : public AttributeValue {
+public:
+  TokenizedAttributeValue(Text &, const Vector<size_t> &);
+  size_t nTokens() const;
+  AttributeSemantics *makeSemantics(const DeclaredValue *,
+        AttributeContext &,
+        const StringC &,
+        unsigned &,
+        unsigned &) const;
+  Type info(const Text *&, const StringC *&) const;
+  const Text *text() const;
+  const StringC &string() const;
+  StringC token(size_t) const;
+  void token(size_t, const Char *&, size_t &) const;
+  Location tokenLocation(size_t) const;
+  Boolean tokenLocation(size_t, const ConstPtr<Origin> *&, Index &) const;
+  Boolean recoverUnquoted(const StringC &, const Location &,
+     AttributeContext &, const StringC &);
+private:
+  TokenizedAttributeValue(const TokenizedAttributeValue &);
+  void operator=(const TokenizedAttributeValue &);
+  Text text_;
+
+
+  Vector<size_t> spaceIndex_;
+};
+
+class Attribute {
+public:
+  Attribute();
+  Boolean specified() const;
+  size_t specIndex() const;
+  const AttributeValue *value() const;
+  const ConstPtr<AttributeValue> &valuePointer() const;
+  const AttributeSemantics *semantics() const;
+  void setSpec(size_t);
+  void setValue(const ConstPtr<AttributeValue> &);
+  void setSemantics(AttributeSemantics *);
+  void clear();
+private:
+  size_t specIndexPlus_;
+  ConstPtr<AttributeValue> value_;
+  CopyOwner<AttributeSemantics> semantics_;
+};
+
+class AttributeList {
+public:
+  AttributeList();
+  AttributeList(const ConstPtr<AttributeDefinitionList> &);
+  void init(const ConstPtr<AttributeDefinitionList> &);
+
+  Boolean conref() const;
+  size_t size() const;
+  const StringC &name(unsigned) const;
+  const AttributeValue *value(unsigned) const;
+  size_t specIndex(size_t) const;
+  const ConstPtr<AttributeValue> &valuePointer(unsigned) const;
+  const AttributeSemantics *semantics(unsigned) const;
+  Boolean tokenized(unsigned index) const;
+  Boolean tokenIndex(const StringC &, unsigned &) const;
+  Boolean tokenIndexUnique(const StringC &, unsigned) const;
+  Boolean attributeIndex(const StringC &, unsigned &) const;
+  void finish(AttributeContext &);
+  Boolean setValue(unsigned index, Text &, AttributeContext &,
+     unsigned &specLength);
+  void setValueToken(unsigned index, Text &, AttributeContext &,
+       unsigned &specLength);
+  void setSpec(unsigned index, AttributeContext &);
+  Boolean recoverUnquoted(const StringC &, const Location &,
+     AttributeContext &);
+  Boolean handleAsUnterminated(AttributeContext &context);
+  void swap(AttributeList &);
+  size_t nSpec() const;
+  size_t defIndex() const;
+
+  Boolean current(unsigned) const;
+  Boolean anyCurrent() const;
+  Boolean specified(unsigned) const;
+  Boolean id(unsigned) const;
+  Boolean idref(unsigned) const;
+  const Vector<StringC> *getAllowedTokens(unsigned) const;
+  const StringC *getId() const;
+  Boolean idIndex(unsigned &) const;
+  void noteInvalidSpec();
+  void changeDef(const ConstPtr<AttributeDefinitionList> &);
+  const ConstPtr<AttributeDefinitionList> &def() const;
+private:
+  const AttributeDefinition *def(size_t) const;
+  PackedBoolean conref_;
+  unsigned nIdrefs_;
+  unsigned nEntityNames_;
+  size_t nSpec_;
+  Vector<Attribute> vec_;
+  ConstPtr<AttributeDefinitionList> def_;
+};
+
+class DataDeclaredValue : public CdataDeclaredValue {
+public:
+  DataDeclaredValue(const ConstPtr<Notation> &, AttributeList &);
+  AttributeValue *makeValue(Text &, AttributeContext &, const StringC &,
+                            unsigned &) const;
+  DeclaredValue *copy() const;
+private:
+  ConstPtr<Notation> notation_;
+  AttributeList attributes_;
+};
+
+class DataAttributeValue : public CdataAttributeValue {
+public:
+  DataAttributeValue(Text &, const ConstPtr<Notation> &, const AttributeList &);
+  const AttributeList &attributes() const;
+  const Notation *notation() const;
+private:
+  const ConstPtr<Notation> notation_;
+  const AttributeList *attributes_;
+};
+
+class AttributeContext : public Messenger {
+public:
+  AttributeContext();
+  virtual ~AttributeContext();
+  virtual Boolean defineId(const StringC &, const Location &, Location &);
+  virtual void noteIdref(const StringC &, const Location &);
+  virtual void noteCurrentAttribute(size_t, AttributeValue *);
+  virtual ConstPtr<AttributeValue> getCurrentAttribute(size_t) const;
+  virtual ConstPtr<Entity> getAttributeEntity(const StringC &,
+           const Location &);
+  virtual ConstPtr<Notation> getAttributeNotation(const StringC &,
+        const Location &);
+  virtual const Syntax &attributeSyntax() const = 0;
+
+  ConstPtr<AttributeValue> makeImpliedAttributeValue();
+  Boolean mayDefaultAttribute() const;
+  Boolean validate() const;
+protected:
+  Boolean mayDefaultAttribute_;
+  Boolean validate_;
+private:
+  ConstPtr<AttributeValue> impliedAttributeValue_;
+};
+
+inline
+Boolean AttributeDefinition::tokenized() const
+{
+  return declaredValue_->tokenized();
+}
+
+inline
+Boolean AttributeDefinition::isNotation() const
+{
+  return declaredValue_->isNotation();
+}
+
+inline
+Boolean AttributeDefinition::isEntity() const
+{
+  return declaredValue_->isEntity();
+}
+
+inline
+Boolean AttributeDefinition::isId() const
+{
+  return declaredValue_->isId();
+}
+
+inline
+Boolean AttributeDefinition::isIdref() const
+{
+  return declaredValue_->isIdref();
+}
+
+inline
+const Vector<StringC> *AttributeDefinition::getTokens() const
+{
+  return declaredValue_->getTokens();
+}
+
+inline
+const Vector<StringC> *AttributeDefinition::getOrigTokens() const
+{
+  return declaredValue_->getOrigTokens();
+}
+
+inline
+AttributeSemantics *
+AttributeDefinition::makeSemantics(const AttributeValue *value,
+       AttributeContext &context,
+       unsigned &nIdrefs,
+       unsigned &nEntityNames) const
+{
+  return value->makeSemantics(declaredValue_.pointer(), context, name_,
+         nIdrefs, nEntityNames);
+}
+
+inline
+AttributeValue *AttributeDefinition::makeValue(Text &text,
+            AttributeContext &context,
+            unsigned &specLength) const
+{
+  return checkValue(declaredValue_->makeValue(text, context, name_,
+           specLength),
+      context);
+}
+
+inline
+AttributeValue *
+AttributeDefinition::makeValueFromToken(Text &text,
+     AttributeContext &context,
+     unsigned &specLength) const
+{
+  return checkValue(declaredValue_->makeValueFromToken(text, context,
+             name_, specLength),
+      context);
+}
+
+inline
+Boolean AttributeDefinition::containsToken(const StringC &token) const
+{
+  return declaredValue_->containsToken(token);
+}
+
+inline
+const StringC &AttributeDefinition::name() const
+{
+  return name_;
+}
+
+inline
+const StringC &AttributeDefinition::origName() const
+{
+  return origName_;
+}
+
+inline
+void AttributeDefinition::setDeclaredValue(DeclaredValue *declaredValue)
+{
+  declaredValue_ = declaredValue;
+}
+
+inline
+size_t AttributeDefinitionList::size() const
+{
+  return defs_.size();
+}
+
+inline
+size_t AttributeDefinitionList::index() const
+{
+  return index_;
+}
+
+inline
+void AttributeDefinitionList::setIndex(size_t index)
+{
+  index_ = index;
+}
+
+inline
+size_t AttributeDefinitionList::idIndex() const
+{
+  return idIndex_;
+}
+
+inline
+size_t AttributeDefinitionList::notationIndex() const
+{
+  return notationIndex_;
+}
+
+inline
+Boolean AttributeDefinitionList::anyCurrent() const
+{
+  return anyCurrent_;
+}
+
+inline
+AttributeDefinition *AttributeDefinitionList::def(size_t i)
+{
+  return defs_[i].pointer();
+}
+
+inline
+const AttributeDefinition *AttributeDefinitionList::def(size_t i) const
+{
+  return defs_[i].pointer();
+}
+
+inline
+size_t TokenizedAttributeValue::nTokens() const
+{
+  return spaceIndex_.size() + 1;
+}
+
+inline
+const StringC &TokenizedAttributeValue::string() const
+{
+  return text_.string();
+}
+
+inline
+void TokenizedAttributeValue::token(size_t i,
+        const Char *&ptr, size_t &len) const
+{
+  size_t startIndex = i == 0 ? 0 : spaceIndex_[i - 1] + 1;
+  ptr = text_.string().data() + startIndex;
+  len = (i == spaceIndex_.size() ? text_.size() : spaceIndex_[i]) - startIndex;
+}
+
+inline
+StringC TokenizedAttributeValue::token(size_t i) const
+{
+  const Char *ptr;
+  size_t len;
+  token(i, ptr, len);
+  return StringC(ptr, len);
+}
+
+
+inline
+Location TokenizedAttributeValue::tokenLocation(size_t i) const
+{
+  return text_.charLocation(i == 0 ? 0 : spaceIndex_[i - 1] + 1);
+}
+
+inline
+Boolean TokenizedAttributeValue::tokenLocation(size_t i,
+            const ConstPtr<Origin> *&origin,
+            Index &index) const
+{
+  return text_.charLocation(i == 0 ? 0 : spaceIndex_[i - 1] + 1, origin, index);
+}
+
+inline
+size_t Attribute::specIndex() const
+{
+  return specIndexPlus_ - 1;
+}
+
+inline
+Boolean Attribute::specified() const
+{
+  return specIndexPlus_ != 0;
+}
+
+inline
+const AttributeValue *Attribute::value() const
+{
+  return value_.pointer();
+}
+
+inline
+const ConstPtr<AttributeValue> &Attribute::valuePointer() const
+{
+  return value_;
+}
+
+inline
+const AttributeSemantics *Attribute::semantics() const
+{
+  return semantics_.pointer();
+}
+
+inline
+void Attribute::setSpec(size_t index)
+{
+  specIndexPlus_ = index + 1;
+}
+
+inline
+void Attribute::setValue(const ConstPtr<AttributeValue> &value)
+{
+  value_ = value;
+}
+
+inline
+void Attribute::setSemantics(AttributeSemantics *semantics)
+{
+  semantics_ = semantics;
+}
+
+inline
+size_t AttributeList::size() const
+{
+  return vec_.size();
+}
+
+inline
+const AttributeDefinition *AttributeList::def(size_t i) const
+{
+  return def_->def(i);
+}
+
+inline
+const ConstPtr<AttributeDefinitionList> &AttributeList::def() const
+{
+  return def_;
+}
+
+inline
+Boolean AttributeList::tokenized(unsigned i) const
+{
+  return def(i)->tokenized();
+}
+
+inline
+Boolean AttributeList::tokenIndex(const StringC &name, unsigned &index) const
+{
+  return !def_.isNull() && def_->tokenIndex(name, index);
+}
+
+inline
+Boolean AttributeList::tokenIndexUnique(const StringC &name, unsigned index) const
+{
+  return def_->tokenIndexUnique(name, index);
+}
+
+inline
+Boolean AttributeList::attributeIndex(const StringC &name, unsigned &index) const
+{
+  return !def_.isNull() && def_->attributeIndex(name, index);
+}
+
+inline
+const StringC &AttributeList::name(unsigned i) const
+{
+  return def(i)->name();
+}
+
+inline
+const Vector<StringC> *AttributeList::getAllowedTokens(unsigned i) const
+{
+  return def(i)->getTokens();
+}
+
+inline
+const AttributeValue *AttributeList::value(unsigned i) const
+{
+  return vec_[i].value();
+}
+
+inline
+const ConstPtr<AttributeValue> &AttributeList::valuePointer(unsigned i)
+     const
+{
+  return vec_[i].valuePointer();
+}
+
+inline
+const AttributeSemantics *AttributeList::semantics(unsigned i) const
+{
+  return vec_[i].semantics();
+}
+
+inline
+size_t AttributeList::specIndex(size_t i) const
+{
+  return vec_[i].specIndex();
+}
+
+inline
+size_t AttributeList::nSpec() const
+{
+  return nSpec_;
+}
+
+inline
+Boolean AttributeList::conref() const
+{
+  return conref_;
+}
+
+inline
+size_t AttributeList::defIndex() const
+{
+  return def_.isNull() ? size_t(-1) : def_->index();
+}
+
+inline
+Boolean AttributeList::current(unsigned i) const
+{
+  return def(i)->isCurrent();
+}
+
+inline
+Boolean AttributeList::anyCurrent() const
+{
+  return !def_.isNull() && def_->anyCurrent();
+}
+
+inline
+const AttributeValue *
+DefaultAttributeDefinition::defaultValue(const AttributeValue *)
+     const
+{
+  return value_.pointer();
+}
+
+inline
+Boolean AttributeList::idIndex(unsigned &ind) const
+{
+  if (def_.isNull() || def_->idIndex() == size_t(-1))
+    return 0;
+  else {
+    ind = def_->idIndex();
+    return 1;
+  }
+}
+
+inline
+Boolean AttributeList::id(unsigned i) const
+{
+  return def(i)->isId();
+}
+
+inline
+Boolean AttributeList::idref(unsigned i) const
+{
+  return def(i)->isIdref();
+}
+
+inline
+Boolean AttributeList::specified(unsigned i) const
+{
+  return vec_[i].specified();
+}
+
+inline
+Boolean AttributeContext::mayDefaultAttribute() const
+{
+  return mayDefaultAttribute_;
+}
+
+inline
+Boolean AttributeContext::validate() const
+{
+  return validate_;
+}
+
+
+}
+# 9 "/usr/include/OpenSP/Attributed.h" 2 3 4
+
+
+
+
+
+namespace OpenSP {
+
+
+class Attributed {
+public:
+  Attributed() { }
+  ConstPtr<AttributeDefinitionList> attributeDef() const;
+  const AttributeDefinitionList *attributeDefTemp() const;
+  Ptr<AttributeDefinitionList> attributeDef();
+  void setAttributeDef(const Ptr<AttributeDefinitionList> &);
+private:
+  Ptr<AttributeDefinitionList> attributeDef_;
+
+};
+
+inline
+ConstPtr<AttributeDefinitionList> Attributed::attributeDef() const
+{
+  return attributeDef_;
+}
+
+inline
+const AttributeDefinitionList *Attributed::attributeDefTemp() const
+{
+  return attributeDef_.pointer();
+}
+
+inline
+Ptr<AttributeDefinitionList> Attributed::attributeDef()
+{
+  return attributeDef_;
+}
+
+inline
+void Attributed::setAttributeDef(const Ptr<AttributeDefinitionList> &def)
+{
+  attributeDef_ = def;
+}
+
+
+}
+# 18 "/usr/include/OpenSP/Notation.h" 2 3 4
+# 1 "/usr/include/OpenSP/StringResource.h" 1 3 4
+
+
+
+
+
+
+# 1 "/usr/include/OpenSP/StringOf.h" 1 3 4
+# 8 "/usr/include/OpenSP/StringResource.h" 2 3 4
+
+
+
+namespace OpenSP {
+
+
+template<class T>
+class StringResource : public String<T>, public Resource {
+public:
+  StringResource(const String<T> &s) : String<T>(s) { }
+};
+
+
+}
+# 19 "/usr/include/OpenSP/Notation.h" 2 3 4
+# 1 "/usr/include/OpenSP/EntityDecl.h" 1 3 4
+
+
+
+
+
+
+
+#pragma interface
+
+
+
+# 1 "/usr/include/OpenSP/Ptr.h" 1 3 4
+# 13 "/usr/include/OpenSP/EntityDecl.h" 2 3 4
+
+
+
+
+
+namespace OpenSP {
+
+
+class EntityDecl : public NamedResource {
+public:
+  enum DeclType { generalEntity, parameterEntity, doctype, linktype,
+    notation, sgml };
+  enum DataType { sgmlText, pi, cdata, sdata, ndata, subdoc };
+  EntityDecl(const StringC &, DeclType declType, DataType dataType,
+      const Location &defLocation);
+  DataType dataType() const;
+  DeclType declType() const;
+  const Location &defLocation() const;
+  Boolean declInDtdIsBase() const;
+  Boolean declInActiveLpd() const;
+  const StringC *declInDtdNamePointer() const;
+  const StringC *declInLpdNamePointer() const;
+  void setDeclIn(const ConstPtr<StringResource<Char> > &dtdName,
+   Boolean dtdIsBase,
+   const ConstPtr<StringResource<Char> > &lpdName,
+   Boolean lpdIsActive);
+  void setDeclIn(const ConstPtr<StringResource<Char> > &dtdName,
+   Boolean dtdIsBase);
+  void setDefLocation(const Location &);
+  virtual const StringC *systemIdPointer() const;
+  virtual const StringC *publicIdPointer() const;
+  virtual const StringC *effectiveSystemIdPointer() const;
+private:
+  DeclType declType_;
+  DataType dataType_;
+  PackedBoolean dtdIsBase_;
+  PackedBoolean lpdIsActive_;
+  Location defLocation_;
+  ConstPtr<StringResource<Char> > dtdName_;
+  ConstPtr<StringResource<Char> > lpdName_;
+};
+
+inline
+const Location &EntityDecl::defLocation() const
+{
+  return defLocation_;
+}
+
+inline
+EntityDecl::DeclType EntityDecl::declType() const
+{
+  return declType_;
+}
+
+inline
+EntityDecl::DataType EntityDecl::dataType() const
+{
+  return dataType_;
+}
+
+inline
+const StringC *EntityDecl::declInDtdNamePointer() const
+{
+  return dtdName_.pointer();
+}
+
+inline
+const StringC *EntityDecl::declInLpdNamePointer() const
+{
+  return lpdName_.pointer();
+}
+
+inline
+Boolean EntityDecl::declInDtdIsBase() const
+{
+  return dtdIsBase_;
+}
+
+inline
+Boolean EntityDecl::declInActiveLpd() const
+{
+  return lpdIsActive_;
+}
+
+inline
+void EntityDecl::setDefLocation(const Location &loc)
+{
+  defLocation_ = loc;
+}
+
+
+}
+# 20 "/usr/include/OpenSP/Notation.h" 2 3 4
+
+
+namespace OpenSP {
+
+
+class ParserState;
+
+class Notation : public EntityDecl, public Attributed {
+public:
+  Notation(const StringC &,
+    const ConstPtr<StringResource<Char> > &dtdName,
+    Boolean dtdIsBase);
+  void setExternalId(const ExternalId &, const Location &);
+  const ExternalId &externalId() const;
+  Boolean defined() const;
+  void generateSystemId(ParserState &);
+  const StringC *systemIdPointer() const;
+  const StringC *publicIdPointer() const;
+private:
+  Notation(const Notation &);
+  void operator=(const Notation &);
+  PackedBoolean defined_;
+  ExternalId externalId_;
+};
+
+inline
+const ExternalId &Notation::externalId() const
+{
+  return externalId_;
+}
+
+inline
+Boolean Notation::defined() const
+{
+  return defined_;
+}
+
+
+}
+# 20 "/usr/include/OpenSP/Event.h" 2 3 4
+# 1 "/usr/include/OpenSP/Sd.h" 1 3 4
+
+
+
+
+
+
+#pragma interface
+
+
+
+
+
+# 1 "/usr/include/OpenSP/CharsetInfo.h" 1 3 4
+
+
+
+
+
+
+#pragma interface
+
+
+# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/limits.h" 1 3 4
+# 11 "/usr/include/OpenSP/CharsetInfo.h" 2 3 4
+# 1 "/usr/include/OpenSP/UnivCharsetDesc.h" 1 3 4
+
+
+
+
+
+
+#pragma interface
+
+
+# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
+# 11 "/usr/include/OpenSP/UnivCharsetDesc.h" 2 3 4
+
+# 1 "/usr/include/OpenSP/CharMap.h" 1 3 4
+# 11 "/usr/include/OpenSP/CharMap.h" 3 4
+namespace OpenSP {
+
+
+
+
+class CharMapBits {
+public:
+
+  enum { level0 = 5, level1 = 8, level2 = 4, level3 = 4 };
+
+  enum {
+    planes = (1 << CharMapBits::level0) ,
+    pagesPerPlane = (1 << CharMapBits::level1),
+    columnsPerPage = (1 << CharMapBits::level2),
+    cellsPerColumn = (1 << CharMapBits::level3),
+    planeSize = (1 << (CharMapBits::level1 + CharMapBits::level2 + CharMapBits::level3)),
+    pageSize = (1 << (CharMapBits::level2 + CharMapBits::level3)),
+    columnSize = (1 << CharMapBits::level3)
+  };
+
+  static size_t planeIndex(size_t c) {
+    return (c >> (CharMapBits::level1 + CharMapBits::level2 + CharMapBits::level3));
+  }
+  static size_t pageIndex(size_t c) {
+    return ((c >> (CharMapBits::level2 + CharMapBits::level3)) & (pagesPerPlane - 1));
+  }
+  static size_t columnIndex(size_t c) {
+    return ((c >> CharMapBits::level3) & (columnsPerPage - 1));
+  }
+  static size_t cellIndex(size_t c) {
+    return (c & (cellsPerColumn - 1));
+  }
+  static size_t maxInPlane(size_t c) {
+    return (c | (planeSize - 1));
+  }
+  static size_t maxInPage(size_t c) {
+    return (c | (pageSize - 1));
+  }
+  static size_t maxInColumn(size_t c) {
+    return (c | (columnSize - 1));
+  }
+};
+# 73 "/usr/include/OpenSP/CharMap.h" 3 4
+template<class T>
+class CharMapColumn {
+public:
+  CharMapColumn();
+  CharMapColumn(const CharMapColumn<T> &);
+  void operator=(const CharMapColumn<T> &);
+  ~CharMapColumn();
+  T *values;
+  T value;
+};
+
+template<class T>
+class CharMapPage {
+public:
+  CharMapPage();
+  CharMapPage(const CharMapPage<T> &);
+  void operator=(const CharMapPage<T> &);
+  ~CharMapPage();
+  void swap(CharMapPage<T> &);
+  CharMapColumn<T> *values;
+  T value;
+};
+
+template<class T>
+class CharMapPlane {
+public:
+  CharMapPlane();
+  CharMapPlane(const CharMapPlane<T> &);
+  void operator=(const CharMapPlane<T> &);
+  ~CharMapPlane();
+  void swap(CharMapPlane<T> &);
+  CharMapPage<T> *values;
+  T value;
+};
+
+
+template<class T>
+class CharMap {
+public:
+  CharMap();
+  CharMap(T);
+  T operator[](Char) const;
+  T getRange(Char from, Char &to) const;
+  void swap(CharMap<T> &);
+  void setChar(Char, T);
+  void setRange(Char from, Char to, T val);
+  void setAll(T);
+private:
+
+
+  CharMapPlane<T> values_[CharMapBits::planes];
+  T lo_[256];
+
+
+
+};
+
+template<class T>
+class CharMapResource : public CharMap<T>, public Resource {
+public:
+  CharMapResource() { }
+  CharMapResource(T t) : CharMap<T>(t) { }
+};
+
+
+
+template<class T>
+inline
+T CharMap<T>::operator[](Char c) const
+{
+  if (c < 256)
+    return lo_[c];
+  const CharMapPlane<T> &pl = values_[CharMapBits::planeIndex(c)];
+  if (pl.values) {
+    const CharMapPage<T> &pg = pl.values[CharMapBits::pageIndex(c)];
+    if (pg.values) {
+      const CharMapColumn<T> &column = pg.values[CharMapBits::columnIndex(c)];
+      if (column.values)
+        return column.values[CharMapBits::cellIndex(c)];
+      else
+        return column.value;
+    }
+    else
+      return pg.value;
+  }
+  else
+    return pl.value;
+}
+
+template<class T>
+inline
+T CharMap<T>::getRange(Char c, Char &max) const
+{
+  if (c < 256) {
+    max = c;
+    return lo_[c];
+  }
+  const CharMapPlane<T> &pl = values_[CharMapBits::planeIndex(c)];
+  if (pl.values) {
+    const CharMapPage<T> &pg = pl.values[CharMapBits::pageIndex(c)];
+    if (pg.values) {
+      const CharMapColumn<T> &column = pg.values[CharMapBits::columnIndex(c)];
+      if (column.values) {
+        max = c;
+        return column.values[CharMapBits::cellIndex(c)];
+      }
+      else {
+        max = CharMapBits::maxInColumn(c);
+        return column.value;
+      }
+    }
+    else {
+      max = CharMapBits::maxInPage(c);
+      return pg.value;
+    }
+  }
+  else {
+    max = CharMapBits::maxInPlane(c);
+    return pl.value;
+  }
+}
+# 222 "/usr/include/OpenSP/CharMap.h" 3 4
+}
+
+
+
+
+
+# 1 "/usr/include/OpenSP/CharMap.cxx" 1 3 4
+
+
+
+
+
+
+
+namespace OpenSP {
+
+
+
+
+template<class T>
+CharMap<T>::CharMap()
+{
+}
+
+template<class T>
+CharMap<T>::CharMap(T dflt)
+{
+  for (size_t i = 0; i < 256; i++)
+    lo_[i] = dflt;
+  for (size_t i = 0; i < CharMapBits::planes; i++)
+    values_[i].value = dflt;
+}
+
+template<class T>
+void CharMap<T>::setAll(T val)
+{
+  for (size_t i = 0; i < 256; i++)
+    lo_[i] = val;
+  for (size_t i = 0; i < CharMapBits::planes; i++) {
+    values_[i].value = val;
+    delete [] values_[i].values;
+    values_[i].values = 0;
+  }
+}
+
+template<class T>
+void CharMap<T>::swap(CharMap<T> &map)
+{
+  for (size_t i = 0; i < 256; i++) {
+    T tem(lo_[i]);
+    lo_[i] = map.lo_[i];
+    map.lo_[i] = tem;
+  }
+  for (size_t i = 0; i < CharMapBits::planes; i++)
+    values_[i].swap(map.values_[i]);
+}
+
+template<class T>
+void CharMap<T>::setChar(Char c, T val)
+{
+  if (c < 256) {
+    lo_[c] = val;
+    return;
+  }
+  CharMapPlane<T> &pl = values_[CharMapBits::planeIndex(c)];
+  if (pl.values) {
+    CharMapPage<T> &pg = pl.values[CharMapBits::pageIndex(c)];
+    if (pg.values) {
+      CharMapColumn<T> &column = pg.values[CharMapBits::columnIndex(c)];
+      if (column.values)
+        column.values[CharMapBits::cellIndex(c)] = val;
+      else if (val != column.value) {
+        column.values = new T[CharMapBits::columnSize];
+        for (size_t i = 0; i < CharMapBits::columnSize; i++)
+     column.values[i] = column.value;
+        column.values[CharMapBits::cellIndex(c)] = val;
+      }
+    }
+    else if (val != pg.value) {
+      pg.values = new CharMapColumn<T>[CharMapBits::columnsPerPage];
+      for (size_t i = 0; i < CharMapBits::columnsPerPage; i++)
+        pg.values[i].value = pg.value;
+      CharMapColumn<T> &column = pg.values[CharMapBits::columnIndex(c)];
+      column.values = new T[CharMapBits::cellsPerColumn];
+      for (size_t i = 0; i < CharMapBits::cellsPerColumn; i++)
+        column.values[i] = column.value;
+      column.values[CharMapBits::cellIndex(c)] = val;
+    }
+  }
+  else if (val != pl.value) {
+    pl.values = new CharMapPage<T>[CharMapBits::pagesPerPlane];
+    for (size_t i = 0; i < CharMapBits::pagesPerPlane; i++)
+      pl.values[i].value = pl.value;
+    CharMapPage<T> &page = pl.values[CharMapBits::pageIndex(c)];
+    page.values = new CharMapColumn<T>[CharMapBits::columnsPerPage];
+    for (size_t i = 0; i < CharMapBits::columnsPerPage; i++)
+      page.values[i].value = page.value;
+    CharMapColumn<T> &column = page.values[CharMapBits::columnIndex(c)];
+    column.values = new T[CharMapBits::cellsPerColumn];
+    for (size_t i = 0; i < CharMapBits::cellsPerColumn; i++)
+      column.values[i] = column.value;
+    column.values[CharMapBits::cellIndex(c)] = val;
+  }
+}
+
+template<class T>
+void CharMap<T>::setRange(Char from, Char to, T val)
+{
+  for (; from < 256; from++) {
+    lo_[from] = val;
+    if (from == to)
+      return;
+  }
+  do {
+    if ((from & (CharMapBits::columnSize - 1)) == 0
+        && to - from >= CharMapBits::columnSize - 1) {
+      if ((from & (CharMapBits::pageSize - 1)) == 0
+   && to - from >= CharMapBits::pageSize - 1) {
+        if ((from & (CharMapBits::planeSize - 1)) == 0
+     && to - from >= CharMapBits::planeSize - 1) {
+
+   CharMapPlane<T> &pl = values_[CharMapBits::planeIndex(from)];
+          pl.value = val;
+          delete [] pl.values;
+          pl.values = 0;
+   from += CharMapBits::planeSize - 1;
+        }
+        else {
+
+   CharMapPlane<T> &pl = values_[CharMapBits::planeIndex(from)];
+          if (pl.values) {
+     CharMapPage<T> &pg = pl.values[CharMapBits::pageIndex(from)];
+     pg.value = val;
+     delete [] pg.values;
+     pg.values = 0;
+          }
+          else if (val != pl.value) {
+
+     pl.values = new CharMapPage<T>[CharMapBits::pagesPerPlane];
+            for (size_t i = 0; i < CharMapBits::pagesPerPlane; i++)
+       pl.values[i].value = pl.value;
+     CharMapPage<T> &page = pl.values[CharMapBits::pageIndex(from)];
+            page.value = val;
+   }
+   from += CharMapBits::pageSize - 1;
+        }
+      }
+      else {
+
+ CharMapPlane<T> &pl = values_[CharMapBits::planeIndex(from)];
+        if (pl.values) {
+   CharMapPage<T> &pg = pl.values[CharMapBits::pageIndex(from)];
+   if (pg.values) {
+     CharMapColumn<T> &column = pg.values[CharMapBits::columnIndex(from)];
+     column.value = val;
+     delete [] column.values;
+     column.values = 0;
+   }
+   else if (val != pg.value) {
+
+     pg.values = new CharMapColumn<T>[CharMapBits::columnsPerPage];
+            for (size_t i = 0; i < CharMapBits::columnsPerPage; i++)
+       pg.values[i].value = pg.value;
+     CharMapColumn<T> &column = pg.values[CharMapBits::columnIndex(from)];
+     column.value = val;
+   }
+        }
+        else if (val != pl.value) {
+
+   pl.values = new CharMapPage<T>[CharMapBits::pagesPerPlane];
+          for (size_t i = 0; i < CharMapBits::pagesPerPlane; i++)
+     pl.values[i].value = pl.value;
+   CharMapPage<T> &pg = pl.values[CharMapBits::pageIndex(from)];
+          pg.value = val;
+
+   pg.values = new CharMapColumn<T>[CharMapBits::columnsPerPage];
+          for (size_t i = 0; i < CharMapBits::columnsPerPage; i++)
+     pg.values[i].value = pg.value;
+   CharMapColumn<T> &column = pg.values[CharMapBits::columnIndex(from)];
+   column.value = val;
+ }
+ from += CharMapBits::columnSize - 1;
+      }
+    }
+    else
+      setChar(from, val);
+  } while (from++ != to);
+}
+
+template<class T>
+CharMapPlane<T>::CharMapPlane()
+: values(0)
+{
+}
+
+template<class T>
+CharMapPlane<T>::CharMapPlane(const CharMapPlane<T> &pl)
+{
+  if (pl.values) {
+    values = new CharMapPage<T>[CharMapBits::pagesPerPlane];
+    for (size_t i = 0; i < CharMapBits::pagesPerPlane; i++)
+      values[i] = pl.values[i];
+  }
+  else {
+    value = pl.value;
+    values = 0;
+  }
+}
+
+template<class T>
+void CharMapPlane<T>::operator=(const CharMapPlane<T> &pl)
+{
+  if (pl.values) {
+    if (!values)
+      values = new CharMapPage<T>[CharMapBits::pagesPerPlane];
+    for (size_t i = 0; i < CharMapBits::pagesPerPlane; i++)
+      values[i] = pl.values[i];
+  }
+  else {
+    if (values) {
+      delete [] values;
+      values = 0;
+    }
+    value = pl.value;
+  }
+}
+
+template<class T>
+CharMapPlane<T>::~CharMapPlane()
+{
+  delete [] values;
+}
+
+template<class T>
+void CharMapPlane<T>::swap(CharMapPlane<T> &pl)
+{
+  {
+    CharMapPage<T> *tem = values;
+    values = pl.values;
+    pl.values = tem;
+  }
+  {
+    T tem(value);
+    value = pl.value;
+    pl.value = tem;
+  }
+}
+
+template<class T>
+CharMapPage<T>::CharMapPage()
+: values(0)
+{
+}
+
+template<class T>
+CharMapPage<T>::CharMapPage(const CharMapPage<T> &pg)
+{
+  if (pg.values) {
+    values = new CharMapColumn<T>[CharMapBits::columnsPerPage];
+    for (size_t i = 0; i < CharMapBits::columnsPerPage; i++)
+      values[i] = pg.values[i];
+  }
+  else {
+    value = pg.value;
+    values = 0;
+  }
+}
+
+template<class T>
+void CharMapPage<T>::operator=(const CharMapPage<T> &pg)
+{
+  if (pg.values) {
+    if (!values)
+      values = new CharMapColumn<T>[CharMapBits::columnsPerPage];
+    for (size_t i = 0; i < CharMapBits::columnsPerPage; i++)
+      values[i] = pg.values[i];
+  }
+  else {
+    if (values) {
+      delete [] values;
+      values = 0;
+    }
+    value = pg.value;
+  }
+}
+
+template<class T>
+CharMapPage<T>::~CharMapPage()
+{
+  delete [] values;
+}
+
+template<class T>
+void CharMapPage<T>::swap(CharMapPage<T> &pg)
+{
+  {
+    CharMapColumn<T> *tem = values;
+    values = pg.values;
+    pg.values = tem;
+  }
+  {
+    T tem(value);
+    value = pg.value;
+    pg.value = tem;
+  }
+}
+
+template<class T>
+CharMapColumn<T>::CharMapColumn()
+: values(0)
+{
+}
+
+template<class T>
+CharMapColumn<T>::CharMapColumn(const CharMapColumn<T> &col)
+{
+  if (col.values) {
+    values = new T[CharMapBits::cellsPerColumn];
+    for (size_t i = 0; i < CharMapBits::cellsPerColumn; i++)
+      values[i] = col.values[i];
+  }
+  else {
+    values = 0;
+    value = col.value;
+  }
+}
+
+template<class T>
+void CharMapColumn<T>::operator=(const CharMapColumn<T> &col)
+{
+  if (col.values) {
+    if (!values)
+      values = new T[CharMapBits::cellsPerColumn];
+    for (size_t i = 0; i < CharMapBits::cellsPerColumn; i++)
+      values[i] = col.values[i];
+  }
+  else {
+    if (values) {
+      delete [] values;
+      values = 0;
+    }
+    value = col.value;
+  }
+}
+
+template<class T>
+CharMapColumn<T>::~CharMapColumn()
+{
+  delete [] values;
+}
+# 387 "/usr/include/OpenSP/CharMap.cxx" 3 4
+}
+# 229 "/usr/include/OpenSP/CharMap.h" 2 3 4
+# 13 "/usr/include/OpenSP/UnivCharsetDesc.h" 2 3 4
+# 1 "/usr/include/OpenSP/RangeMap.h" 1 3 4
+
+
+
+
+
+
+# 1 "/usr/include/OpenSP/Vector.h" 1 3 4
+# 8 "/usr/include/OpenSP/RangeMap.h" 2 3 4
+
+# 1 "/usr/include/OpenSP/ISet.h" 1 3 4
+
+
+
+
+
+
+
+# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
+# 9 "/usr/include/OpenSP/ISet.h" 2 3 4
+# 1 "/usr/include/OpenSP/Vector.h" 1 3 4
+# 10 "/usr/include/OpenSP/ISet.h" 2 3 4
+
+
+
+namespace OpenSP {
+
+
+template<class T> class ISetIter;
+
+template<class T>
+struct ISetRange {
+  T min;
+  T max;
+};
+
+template<class T>
+class ISet {
+public:
+  ISet();
+  ISet(const T *, size_t);
+  ~ISet();
+  Boolean contains(T) const;
+  void remove(T);
+  void add(T x) { addRange(x, x); }
+  void addRange(T, T);
+
+
+
+  void check();
+  void operator+=(T x) { addRange(x, x); }
+  void clear();
+  Boolean isSingleton() const {
+    return r_.size() == 1 && r_[0].min == r_[0].max;
+  }
+  Boolean isEmpty() const { return r_.size() == 0; }
+  void swap(ISet<T> &x) { r_.swap(x.r_); }
+friend class ISetIter<T>;
+private:
+  Vector<ISetRange<T> > r_;
+};
+
+
+}
+
+
+
+
+
+# 1 "/usr/include/OpenSP/ISet.cxx" 1 3 4
+
+
+
+
+
+
+# 1 "/usr/include/stdlib.h" 1 3 4
+# 33 "/usr/include/stdlib.h" 3 4
+# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
+# 34 "/usr/include/stdlib.h" 2 3 4
+
+extern "C" {
+
+
+
+
+
+
+# 1 "/usr/include/bits/waitflags.h" 1 3 4
+# 43 "/usr/include/stdlib.h" 2 3 4
+# 1 "/usr/include/bits/waitstatus.h" 1 3 4
+# 63 "/usr/include/bits/waitstatus.h" 3 4
+# 1 "/usr/include/endian.h" 1 3 4
+# 37 "/usr/include/endian.h" 3 4
+# 1 "/usr/include/bits/endian.h" 1 3 4
+# 38 "/usr/include/endian.h" 2 3 4
+# 64 "/usr/include/bits/waitstatus.h" 2 3 4
+
+union wait
+  {
+    int w_status;
+    struct
+      {
+
+ unsigned int __w_termsig:7;
+ unsigned int __w_coredump:1;
+ unsigned int __w_retcode:8;
+ unsigned int:16;
+
+
+
+
+
+
+
+      } __wait_terminated;
+    struct
+      {
+
+ unsigned int __w_stopval:8;
+ unsigned int __w_stopsig:8;
+ unsigned int:16;
+
+
+
+
+
+
+      } __wait_stopped;
+  };
+# 44 "/usr/include/stdlib.h" 2 3 4
+# 93 "/usr/include/stdlib.h" 3 4
+
+
+typedef struct
+  {
+    int quot;
+    int rem;
+  } div_t;
+
+
+
+typedef struct
+  {
+    long int quot;
+    long int rem;
+  } ldiv_t;
+
+
+
+
+
+
+
+__extension__ typedef struct
+  {
+    long long int quot;
+    long long int rem;
+  } lldiv_t;
+
+
+# 137 "/usr/include/stdlib.h" 3 4
+extern size_t __ctype_get_mb_cur_max (void) throw ();
+
+
+
+
+extern double atof (__const char *__nptr) throw () __attribute__ ((__pure__));
+
+extern int atoi (__const char *__nptr) throw () __attribute__ ((__pure__));
+
+extern long int atol (__const char *__nptr) throw () __attribute__ ((__pure__));
+
+
+
+
+
+__extension__ extern long long int atoll (__const char *__nptr)
+     throw () __attribute__ ((__pure__));
+
+
+
+
+
+extern double strtod (__const char *__restrict __nptr,
+        char **__restrict __endptr) throw ();
+
+
+
+
+
+extern float strtof (__const char *__restrict __nptr,
+       char **__restrict __endptr) throw ();
+
+extern long double strtold (__const char *__restrict __nptr,
+       char **__restrict __endptr) throw ();
+
+
+
+
+
+extern long int strtol (__const char *__restrict __nptr,
+   char **__restrict __endptr, int __base) throw ();
+
+extern unsigned long int strtoul (__const char *__restrict __nptr,
+      char **__restrict __endptr, int __base)
+     throw ();
+
+
+
+
+__extension__
+extern long long int strtoq (__const char *__restrict __nptr,
+        char **__restrict __endptr, int __base) throw ();
+
+__extension__
+extern unsigned long long int strtouq (__const char *__restrict __nptr,
+           char **__restrict __endptr, int __base)
+     throw ();
+
+
+
+
+
+__extension__
+extern long long int strtoll (__const char *__restrict __nptr,
+         char **__restrict __endptr, int __base) throw ();
+
+__extension__
+extern unsigned long long int strtoull (__const char *__restrict __nptr,
+     char **__restrict __endptr, int __base)
+     throw ();
+
+# 229 "/usr/include/stdlib.h" 3 4
+extern long int strtol_l (__const char *__restrict __nptr,
+     char **__restrict __endptr, int __base,
+     __locale_t __loc) throw ();
+
+extern unsigned long int strtoul_l (__const char *__restrict __nptr,
+        char **__restrict __endptr,
+        int __base, __locale_t __loc) throw ();
+
+__extension__
+extern long long int strtoll_l (__const char *__restrict __nptr,
+    char **__restrict __endptr, int __base,
+    __locale_t __loc) throw ();
+
+__extension__
+extern unsigned long long int strtoull_l (__const char *__restrict __nptr,
+       char **__restrict __endptr,
+       int __base, __locale_t __loc)
+     throw ();
+
+extern double strtod_l (__const char *__restrict __nptr,
+   char **__restrict __endptr, __locale_t __loc)
+     throw ();
+
+extern float strtof_l (__const char *__restrict __nptr,
+         char **__restrict __endptr, __locale_t __loc) throw ();
+
+extern long double strtold_l (__const char *__restrict __nptr,
+         char **__restrict __endptr,
+         __locale_t __loc) throw ();
+
+
+
+
+
+
+extern double __strtod_internal (__const char *__restrict __nptr,
+     char **__restrict __endptr, int __group)
+     throw ();
+extern float __strtof_internal (__const char *__restrict __nptr,
+    char **__restrict __endptr, int __group)
+     throw ();
+extern long double __strtold_internal (__const char *__restrict __nptr,
+           char **__restrict __endptr,
+           int __group) throw ();
+
+extern long int __strtol_internal (__const char *__restrict __nptr,
+       char **__restrict __endptr,
+       int __base, int __group) throw ();
+
+
+
+extern unsigned long int __strtoul_internal (__const char *__restrict __nptr,
+          char **__restrict __endptr,
+          int __base, int __group) throw ();
+
+
+
+
+__extension__
+extern long long int __strtoll_internal (__const char *__restrict __nptr,
+      char **__restrict __endptr,
+      int __base, int __group) throw ();
+
+
+
+__extension__
+extern unsigned long long int __strtoull_internal (__const char *
+         __restrict __nptr,
+         char **__restrict __endptr,
+         int __base, int __group)
+     throw ();
+
+
+
+
+
+
+
+
+extern __inline double
+strtod (__const char *__restrict __nptr, char **__restrict __endptr) throw ()
+{
+  return __strtod_internal (__nptr, __endptr, 0);
+}
+extern __inline long int
+strtol (__const char *__restrict __nptr, char **__restrict __endptr,
+ int __base) throw ()
+{
+  return __strtol_internal (__nptr, __endptr, __base, 0);
+}
+extern __inline unsigned long int
+strtoul (__const char *__restrict __nptr, char **__restrict __endptr,
+  int __base) throw ()
+{
+  return __strtoul_internal (__nptr, __endptr, __base, 0);
+}
+
+
+
+
+extern __inline float
+strtof (__const char *__restrict __nptr, char **__restrict __endptr) throw ()
+{
+  return __strtof_internal (__nptr, __endptr, 0);
+}
+extern __inline long double
+strtold (__const char *__restrict __nptr, char **__restrict __endptr) throw ()
+{
+  return __strtold_internal (__nptr, __endptr, 0);
+}
+
+
+
+
+__extension__ extern __inline long long int
+strtoq (__const char *__restrict __nptr, char **__restrict __endptr,
+ int __base) throw ()
+{
+  return __strtoll_internal (__nptr, __endptr, __base, 0);
+}
+__extension__ extern __inline unsigned long long int
+strtouq (__const char *__restrict __nptr, char **__restrict __endptr,
+  int __base) throw ()
+{
+  return __strtoull_internal (__nptr, __endptr, __base, 0);
+}
+
+
+
+
+__extension__ extern __inline long long int
+strtoll (__const char *__restrict __nptr, char **__restrict __endptr,
+  int __base) throw ()
+{
+  return __strtoll_internal (__nptr, __endptr, __base, 0);
+}
+__extension__ extern __inline unsigned long long int
+strtoull (__const char * __restrict __nptr, char **__restrict __endptr,
+   int __base) throw ()
+{
+  return __strtoull_internal (__nptr, __endptr, __base, 0);
+}
+
+
+
+
+extern __inline double
+atof (__const char *__nptr) throw ()
+{
+  return strtod (__nptr, (char **) __null);
+}
+extern __inline int
+atoi (__const char *__nptr) throw ()
+{
+  return (int) strtol (__nptr, (char **) __null, 10);
+}
+extern __inline long int
+atol (__const char *__nptr) throw ()
+{
+  return strtol (__nptr, (char **) __null, 10);
+}
+
+
+
+
+__extension__ extern __inline long long int
+atoll (__const char *__nptr) throw ()
+{
+  return strtoll (__nptr, (char **) __null, 10);
+}
+
+# 408 "/usr/include/stdlib.h" 3 4
+extern char *l64a (long int __n) throw ();
+
+
+extern long int a64l (__const char *__s) throw () __attribute__ ((__pure__));
+
+
+
+
+# 1 "/usr/include/sys/types.h" 1 3 4
+# 29 "/usr/include/sys/types.h" 3 4
+extern "C" {
+
+# 1 "/usr/include/bits/types.h" 1 3 4
+# 28 "/usr/include/bits/types.h" 3 4
+# 1 "/usr/include/bits/wordsize.h" 1 3 4
+# 29 "/usr/include/bits/types.h" 2 3 4
+
+
+# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
+# 32 "/usr/include/bits/types.h" 2 3 4
+
+
+typedef unsigned char __u_char;
+typedef unsigned short int __u_short;
+typedef unsigned int __u_int;
+typedef unsigned long int __u_long;
+
+
+typedef signed char __int8_t;
+typedef unsigned char __uint8_t;
+typedef signed short int __int16_t;
+typedef unsigned short int __uint16_t;
+typedef signed int __int32_t;
+typedef unsigned int __uint32_t;
+
+
+
+
+__extension__ typedef signed long long int __int64_t;
+__extension__ typedef unsigned long long int __uint64_t;
+
+
+
+
+
+
+
+__extension__ typedef long long int __quad_t;
+__extension__ typedef unsigned long long int __u_quad_t;
+# 129 "/usr/include/bits/types.h" 3 4
+# 1 "/usr/include/bits/typesizes.h" 1 3 4
+# 130 "/usr/include/bits/types.h" 2 3 4
+
+
+
+
+
+
+__extension__ typedef unsigned long long int __dev_t;
+__extension__ typedef unsigned int __uid_t;
+__extension__ typedef unsigned int __gid_t;
+__extension__ typedef unsigned long int __ino_t;
+__extension__ typedef unsigned long long int __ino64_t;
+__extension__ typedef unsigned int __mode_t;
+__extension__ typedef unsigned int __nlink_t;
+__extension__ typedef long int __off_t;
+__extension__ typedef long long int __off64_t;
+__extension__ typedef int __pid_t;
+__extension__ typedef struct { int __val[2]; } __fsid_t;
+__extension__ typedef long int __clock_t;
+__extension__ typedef unsigned long int __rlim_t;
+__extension__ typedef unsigned long long int __rlim64_t;
+__extension__ typedef unsigned int __id_t;
+__extension__ typedef long int __time_t;
+__extension__ typedef unsigned int __useconds_t;
+__extension__ typedef long int __suseconds_t;
+
+__extension__ typedef int __daddr_t;
+__extension__ typedef long int __swblk_t;
+__extension__ typedef int __key_t;
+
+
+__extension__ typedef int __clockid_t;
+
+
+__extension__ typedef int __timer_t;
+
+
+__extension__ typedef long int __blksize_t;
+
+
+
+
+__extension__ typedef long int __blkcnt_t;
+__extension__ typedef long long int __blkcnt64_t;
+
+
+__extension__ typedef unsigned long int __fsblkcnt_t;
+__extension__ typedef unsigned long long int __fsblkcnt64_t;
+
+
+__extension__ typedef unsigned long int __fsfilcnt_t;
+__extension__ typedef unsigned long long int __fsfilcnt64_t;
+
+__extension__ typedef int __ssize_t;
+
+
+
+typedef __off64_t __loff_t;
+typedef __quad_t *__qaddr_t;
+typedef char *__caddr_t;
+
+
+__extension__ typedef int __intptr_t;
+
+
+__extension__ typedef unsigned int __socklen_t;
+# 32 "/usr/include/sys/types.h" 2 3 4
+
+
+
+typedef __u_char u_char;
+typedef __u_short u_short;
+typedef __u_int u_int;
+typedef __u_long u_long;
+typedef __quad_t quad_t;
+typedef __u_quad_t u_quad_t;
+typedef __fsid_t fsid_t;
+
+
+
+
+typedef __loff_t loff_t;
+
+
+
+typedef __ino_t ino_t;
+
+
+
+
+
+
+typedef __ino64_t ino64_t;
+
+
+
+
+typedef __dev_t dev_t;
+
+
+
+
+typedef __gid_t gid_t;
+
+
+
+
+typedef __mode_t mode_t;
+
+
+
+
+typedef __nlink_t nlink_t;
+
+
+
+
+typedef __uid_t uid_t;
+
+
+
+
+
+typedef __off_t off_t;
+
+
+
+
+
+
+typedef __off64_t off64_t;
+
+
+
+
+typedef __pid_t pid_t;
+
+
+
+
+typedef __id_t id_t;
+
+
+
+
+typedef __ssize_t ssize_t;
+
+
+
+
+
+typedef __daddr_t daddr_t;
+typedef __caddr_t caddr_t;
+
+
+
+
+
+typedef __key_t key_t;
+# 133 "/usr/include/sys/types.h" 3 4
+# 1 "/usr/include/time.h" 1 3 4
+# 58 "/usr/include/time.h" 3 4
+
+
+typedef __clock_t clock_t;
+
+
+
+# 74 "/usr/include/time.h" 3 4
+
+
+typedef __time_t time_t;
+
+
+
+# 92 "/usr/include/time.h" 3 4
+typedef __clockid_t clockid_t;
+# 104 "/usr/include/time.h" 3 4
+typedef __timer_t timer_t;
+# 134 "/usr/include/sys/types.h" 2 3 4
+
+
+
+typedef __useconds_t useconds_t;
+
+
+
+typedef __suseconds_t suseconds_t;
+
+
+
+
+
+# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
+# 148 "/usr/include/sys/types.h" 2 3 4
+
+
+
+typedef unsigned long int ulong;
+typedef unsigned short int ushort;
+typedef unsigned int uint;
+# 191 "/usr/include/sys/types.h" 3 4
+typedef int int8_t __attribute__ ((__mode__ (__QI__)));
+typedef int int16_t __attribute__ ((__mode__ (__HI__)));
+typedef int int32_t __attribute__ ((__mode__ (__SI__)));
+typedef int int64_t __attribute__ ((__mode__ (__DI__)));
+
+
+typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
+typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
+typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
+typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));
+
+typedef int register_t __attribute__ ((__mode__ (__word__)));
+# 216 "/usr/include/sys/types.h" 3 4
+# 1 "/usr/include/sys/select.h" 1 3 4
+# 31 "/usr/include/sys/select.h" 3 4
+# 1 "/usr/include/bits/select.h" 1 3 4
+# 32 "/usr/include/sys/select.h" 2 3 4
+
+
+# 1 "/usr/include/bits/sigset.h" 1 3 4
+# 23 "/usr/include/bits/sigset.h" 3 4
+typedef int __sig_atomic_t;
+
+
+
+
+typedef struct
+  {
+    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
+  } __sigset_t;
+# 35 "/usr/include/sys/select.h" 2 3 4
+
+
+
+typedef __sigset_t sigset_t;
+
+
+
+
+
+# 1 "/usr/include/time.h" 1 3 4
+# 118 "/usr/include/time.h" 3 4
+struct timespec
+  {
+    __time_t tv_sec;
+    long int tv_nsec;
+  };
+# 45 "/usr/include/sys/select.h" 2 3 4
+
+# 1 "/usr/include/bits/time.h" 1 3 4
+# 69 "/usr/include/bits/time.h" 3 4
+struct timeval
+  {
+    __time_t tv_sec;
+    __suseconds_t tv_usec;
+  };
+# 47 "/usr/include/sys/select.h" 2 3 4
+# 55 "/usr/include/sys/select.h" 3 4
+typedef long int __fd_mask;
+# 67 "/usr/include/sys/select.h" 3 4
+typedef struct
+  {
+
+
+
+    __fd_mask fds_bits[1024 / (8 * sizeof (__fd_mask))];
+
+
+
+
+
+  } fd_set;
+
+
+
+
+
+
+typedef __fd_mask fd_mask;
+# 99 "/usr/include/sys/select.h" 3 4
+extern "C" {
+# 109 "/usr/include/sys/select.h" 3 4
+extern int select (int __nfds, fd_set *__restrict __readfds,
+     fd_set *__restrict __writefds,
+     fd_set *__restrict __exceptfds,
+     struct timeval *__restrict __timeout);
+# 121 "/usr/include/sys/select.h" 3 4
+extern int pselect (int __nfds, fd_set *__restrict __readfds,
+      fd_set *__restrict __writefds,
+      fd_set *__restrict __exceptfds,
+      const struct timespec *__restrict __timeout,
+      const __sigset_t *__restrict __sigmask);
+
+
+}
+# 217 "/usr/include/sys/types.h" 2 3 4
+
+
+# 1 "/usr/include/sys/sysmacros.h" 1 3 4
+# 220 "/usr/include/sys/types.h" 2 3 4
+
+
+
+
+typedef __blksize_t blksize_t;
+
+
+
+
+
+
+typedef __blkcnt_t blkcnt_t;
+
+
+
+typedef __fsblkcnt_t fsblkcnt_t;
+
+
+
+typedef __fsfilcnt_t fsfilcnt_t;
+# 258 "/usr/include/sys/types.h" 3 4
+typedef __blkcnt64_t blkcnt64_t;
+typedef __fsblkcnt64_t fsblkcnt64_t;
+typedef __fsfilcnt64_t fsfilcnt64_t;
+
+
+
+
+
+# 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
+# 23 "/usr/include/bits/pthreadtypes.h" 3 4
+# 1 "/usr/include/bits/sched.h" 1 3 4
+# 83 "/usr/include/bits/sched.h" 3 4
+struct __sched_param
+  {
+    int __sched_priority;
+  };
+# 24 "/usr/include/bits/pthreadtypes.h" 2 3 4
+
+typedef int __atomic_lock_t;
+
+
+struct _pthread_fastlock
+{
+  long int __status;
+  __atomic_lock_t __spinlock;
+
+};
+
+
+
+typedef struct _pthread_descr_struct *_pthread_descr;
+
+
+
+
+
+typedef struct __pthread_attr_s
+{
+  int __detachstate;
+  int __schedpolicy;
+  struct __sched_param __schedparam;
+  int __inheritsched;
+  int __scope;
+  size_t __guardsize;
+  int __stackaddr_set;
+  void *__stackaddr;
+  size_t __stacksize;
+} pthread_attr_t;
+
+
+
+
+
+__extension__ typedef long long __pthread_cond_align_t;
+
+
+
+
+typedef struct
+{
+  struct _pthread_fastlock __c_lock;
+  _pthread_descr __c_waiting;
+  char __padding[48 - sizeof (struct _pthread_fastlock)
+   - sizeof (_pthread_descr) - sizeof (__pthread_cond_align_t)];
+  __pthread_cond_align_t __align;
+} pthread_cond_t;
+
+
+
+typedef struct
+{
+  int __dummy;
+} pthread_condattr_t;
+
+
+typedef unsigned int pthread_key_t;
+
+
+
+
+
+typedef struct
+{
+  int __m_reserved;
+  int __m_count;
+  _pthread_descr __m_owner;
+  int __m_kind;
+  struct _pthread_fastlock __m_lock;
+} pthread_mutex_t;
+
+
+
+typedef struct
+{
+  int __mutexkind;
+} pthread_mutexattr_t;
+
+
+
+typedef int pthread_once_t;
+
+
+
+
+typedef struct _pthread_rwlock_t
+{
+  struct _pthread_fastlock __rw_lock;
+  int __rw_readers;
+  _pthread_descr __rw_writer;
+  _pthread_descr __rw_read_waiting;
+  _pthread_descr __rw_write_waiting;
+  int __rw_kind;
+  int __rw_pshared;
+} pthread_rwlock_t;
+
+
+
+typedef struct
+{
+  int __lockkind;
+  int __pshared;
+} pthread_rwlockattr_t;
+
+
+
+
+typedef volatile int pthread_spinlock_t;
+
+
+typedef struct {
+  struct _pthread_fastlock __ba_lock;
+  int __ba_required;
+  int __ba_present;
+  _pthread_descr __ba_waiting;
+} pthread_barrier_t;
+
+
+typedef struct {
+  int __pshared;
+} pthread_barrierattr_t;
+
+
+
+
+
+typedef unsigned long int pthread_t;
+# 267 "/usr/include/sys/types.h" 2 3 4
+
+
+}
+# 417 "/usr/include/stdlib.h" 2 3 4
+
+
+
+
+
+
+extern long int random (void) throw ();
+
+
+extern void srandom (unsigned int __seed) throw ();
+
+
+
+
+
+extern char *initstate (unsigned int __seed, char *__statebuf,
+   size_t __statelen) throw ();
+
+
+
+extern char *setstate (char *__statebuf) throw ();
+
+
+
+
+
+
+
+struct random_data
+  {
+    int32_t *fptr;
+    int32_t *rptr;
+    int32_t *state;
+    int rand_type;
+    int rand_deg;
+    int rand_sep;
+    int32_t *end_ptr;
+  };
+
+extern int random_r (struct random_data *__restrict __buf,
+       int32_t *__restrict __result) throw ();
+
+extern int srandom_r (unsigned int __seed, struct random_data *__buf) throw ();
+
+extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
+   size_t __statelen,
+   struct random_data *__restrict __buf) throw ();
+
+extern int setstate_r (char *__restrict __statebuf,
+         struct random_data *__restrict __buf) throw ();
+
+
+
+
+
+
+extern int rand (void) throw ();
+
+extern void srand (unsigned int __seed) throw ();
+
+
+
+
+extern int rand_r (unsigned int *__seed) throw ();
+
+
+
+
+
+
+
+extern double drand48 (void) throw ();
+extern double erand48 (unsigned short int __xsubi[3]) throw ();
+
+
+extern long int lrand48 (void) throw ();
+extern long int nrand48 (unsigned short int __xsubi[3]) throw ();
+
+
+extern long int mrand48 (void) throw ();
+extern long int jrand48 (unsigned short int __xsubi[3]) throw ();
+
+
+extern void srand48 (long int __seedval) throw ();
+extern unsigned short int *seed48 (unsigned short int __seed16v[3]) throw ();
+extern void lcong48 (unsigned short int __param[7]) throw ();
+
+
+
+
+
+struct drand48_data
+  {
+    unsigned short int __x[3];
+    unsigned short int __old_x[3];
+    unsigned short int __c;
+    unsigned short int __init;
+    unsigned long long int __a;
+  };
+
+
+extern int drand48_r (struct drand48_data *__restrict __buffer,
+        double *__restrict __result) throw ();
+extern int erand48_r (unsigned short int __xsubi[3],
+        struct drand48_data *__restrict __buffer,
+        double *__restrict __result) throw ();
+
+
+extern int lrand48_r (struct drand48_data *__restrict __buffer,
+        long int *__restrict __result) throw ();
+extern int nrand48_r (unsigned short int __xsubi[3],
+        struct drand48_data *__restrict __buffer,
+        long int *__restrict __result) throw ();
+
+
+extern int mrand48_r (struct drand48_data *__restrict __buffer,
+        long int *__restrict __result) throw ();
+extern int jrand48_r (unsigned short int __xsubi[3],
+        struct drand48_data *__restrict __buffer,
+        long int *__restrict __result) throw ();
+
+
+extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
+     throw ();
+
+extern int seed48_r (unsigned short int __seed16v[3],
+       struct drand48_data *__buffer) throw ();
+
+extern int lcong48_r (unsigned short int __param[7],
+        struct drand48_data *__buffer) throw ();
+
+
+
+
+
+
+
+
+
+extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__));
+
+extern void *calloc (size_t __nmemb, size_t __size)
+     throw () __attribute__ ((__malloc__));
+
+
+
+
+
+
+
+extern void *realloc (void *__ptr, size_t __size) throw () __attribute__ ((__malloc__));
+
+extern void free (void *__ptr) throw ();
+
+
+
+
+extern void cfree (void *__ptr) throw ();
+
+
+
+# 1 "/usr/include/alloca.h" 1 3 4
+# 25 "/usr/include/alloca.h" 3 4
+# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
+# 26 "/usr/include/alloca.h" 2 3 4
+
+extern "C" {
+
+
+
+
+
+extern void *alloca (size_t __size) throw ();
+
+
+
+
+
+}
+# 579 "/usr/include/stdlib.h" 2 3 4
+
+
+
+
+extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__));
+
+
+
+
+extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
+     throw () __attribute__ ((__malloc__));
+
+
+
+
+extern void abort (void) throw () __attribute__ ((__noreturn__));
+
+
+
+extern int atexit (void (*__func) (void)) throw ();
+
+
+
+
+
+extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
+     throw ();
+
+
+
+
+
+
+extern void exit (int __status) throw () __attribute__ ((__noreturn__));
+
+
+
+
+
+
+extern void _Exit (int __status) throw () __attribute__ ((__noreturn__));
+
+
+
+
+
+
+extern char *getenv (__const char *__name) throw ();
+
+
+
+
+extern char *__secure_getenv (__const char *__name) throw ();
+
+
+
+
+
+extern int putenv (char *__string) throw ();
+
+
+
+
+
+extern int setenv (__const char *__name, __const char *__value, int __replace)
+     throw ();
+
+
+extern int unsetenv (__const char *__name) throw ();
+
+
+
+
+
+
+extern int clearenv (void) throw ();
+# 663 "/usr/include/stdlib.h" 3 4
+extern char *mktemp (char *__template) throw ();
+# 674 "/usr/include/stdlib.h" 3 4
+extern int mkstemp (char *__template);
+# 683 "/usr/include/stdlib.h" 3 4
+extern int mkstemp64 (char *__template);
+# 693 "/usr/include/stdlib.h" 3 4
+extern char *mkdtemp (char *__template) throw ();
+
+
+
+
+
+
+
+
+extern int system (__const char *__command);
+
+
+
+
+
+
+
+extern char *canonicalize_file_name (__const char *__name) throw ();
+# 720 "/usr/include/stdlib.h" 3 4
+extern char *realpath (__const char *__restrict __name,
+         char *__restrict __resolved) throw ();
+
+
+
+
+
+
+typedef int (*__compar_fn_t) (__const void *, __const void *);
+
+
+typedef __compar_fn_t comparison_fn_t;
+
+
+
+
+
+
+extern void *bsearch (__const void *__key, __const void *__base,
+        size_t __nmemb, size_t __size, __compar_fn_t __compar);
+
+
+
+extern void qsort (void *__base, size_t __nmemb, size_t __size,
+     __compar_fn_t __compar);
+
+
+
+extern int abs (int __x) throw () __attribute__ ((__const__));
+extern long int labs (long int __x) throw () __attribute__ ((__const__));
+
+
+
+__extension__ extern long long int llabs (long long int __x)
+     throw () __attribute__ ((__const__));
+
+
+
+
+
+
+
+extern div_t div (int __numer, int __denom)
+     throw () __attribute__ ((__const__));
+extern ldiv_t ldiv (long int __numer, long int __denom)
+     throw () __attribute__ ((__const__));
+
+
+
+
+__extension__ extern lldiv_t lldiv (long long int __numer,
+        long long int __denom)
+     throw () __attribute__ ((__const__));
+
+# 784 "/usr/include/stdlib.h" 3 4
+extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
+     int *__restrict __sign) throw ();
+
+
+
+
+extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
+     int *__restrict __sign) throw ();
+
+
+
+
+extern char *gcvt (double __value, int __ndigit, char *__buf) throw ();
+
+
+
+
+extern char *qecvt (long double __value, int __ndigit,
+      int *__restrict __decpt, int *__restrict __sign) throw ();
+extern char *qfcvt (long double __value, int __ndigit,
+      int *__restrict __decpt, int *__restrict __sign) throw ();
+extern char *qgcvt (long double __value, int __ndigit, char *__buf) throw ();
+
+
+
+
+extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
+     int *__restrict __sign, char *__restrict __buf,
+     size_t __len) throw ();
+extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
+     int *__restrict __sign, char *__restrict __buf,
+     size_t __len) throw ();
+
+extern int qecvt_r (long double __value, int __ndigit,
+      int *__restrict __decpt, int *__restrict __sign,
+      char *__restrict __buf, size_t __len) throw ();
+extern int qfcvt_r (long double __value, int __ndigit,
+      int *__restrict __decpt, int *__restrict __sign,
+      char *__restrict __buf, size_t __len) throw ();
+
+
+
+
+
+
+
+extern int mblen (__const char *__s, size_t __n) throw ();
+
+
+extern int mbtowc (wchar_t *__restrict __pwc,
+     __const char *__restrict __s, size_t __n) throw ();
+
+
+extern int wctomb (char *__s, wchar_t __wchar) throw ();
+
+
+
+extern size_t mbstowcs (wchar_t *__restrict __pwcs,
+   __const char *__restrict __s, size_t __n) throw ();
+
+extern size_t wcstombs (char *__restrict __s,
+   __const wchar_t *__restrict __pwcs, size_t __n)
+     throw ();
+
+
+
+
+
+
+
+
+extern int rpmatch (__const char *__response) throw ();
+# 866 "/usr/include/stdlib.h" 3 4
+extern int getsubopt (char **__restrict __optionp,
+        char *__const *__restrict __tokens,
+        char **__restrict __valuep) throw ();
+
+
+
+
+
+extern void setkey (__const char *__key) throw ();
+
+
+
+
+
+
+
+extern int posix_openpt (int __oflag);
+
+
+
+
+
+
+
+extern int grantpt (int __fd) throw ();
+
+
+
+extern int unlockpt (int __fd) throw ();
+
+
+
+
+extern char *ptsname (int __fd) throw ();
+
+
+
+
+
+
+extern int ptsname_r (int __fd, char *__buf, size_t __buflen) throw ();
+
+
+extern int getpt (void);
+
+
+
+
+
+
+extern int getloadavg (double __loadavg[], int __nelem) throw ();
+
+
+
+
+
+}
+# 8 "/usr/include/OpenSP/ISet.cxx" 2 3 4
+
+
+namespace OpenSP {
+
+
+template<class T>
+ISet<T>::ISet()
+{
+}
+
+template<class T>
+ISet<T>::~ISet()
+{
+}
+
+template<class T>
+ISet<T>::ISet(const T *v, size_t n)
+{
+  for (size_t i = 0; i < n; i++)
+    add(v[i]);
+}
+
+template<class T>
+Boolean ISet<T>::contains(T x) const
+{
+  for (size_t i = 0; i < r_.size(); i++)
+    if (r_[i].max >= x)
+      return r_[i].min <= x ? 1 : 0;
+  return 0;
+}
+
+template<class T>
+void ISet<T>::addRange(T min, T max)
+{
+  size_t i;
+  if (min == 0)
+    i = 0;
+  else {
+    for (i = r_.size(); i > 0 && min - 1 <= r_[i - 1].max; i--)
+      ;
+  }
+
+  if (i < r_.size() && (r_[i].min == 0 || max >= r_[i].min - 1)) {
+
+    if (min < r_[i].min)
+      r_[i].min = min;
+    if (max > r_[i].max) {
+      r_[i].max = max;
+      size_t j;
+      for (j = i + 1; j < r_.size() && r_[i].max >= r_[j].min - 1; j++)
+ r_[i].max = r_[j].max;
+
+      if (j > i + 1) {
+ for (size_t k = j; k < r_.size(); k++)
+   r_[k - (j - i - 1)] = r_[k];
+ r_.resize(r_.size() - (j - i - 1));
+      }
+    }
+  }
+  else {
+
+
+    r_.resize(r_.size() + 1);
+    for (size_t j = r_.size() - 1; j > i; j--)
+      r_[j] = r_[j - 1];
+    r_[i].max = max;
+    r_[i].min = min;
+  }
+}
+
+template<class T>
+void ISet<T>::remove(T c)
+{
+  for (size_t i = 0; i < r_.size(); i++)
+    if (r_[i].max >= c) {
+      if (r_[i].min <= c) {
+ if (r_[i].min == r_[i].max) {
+   while (++i < r_.size())
+     r_[i - 1] = r_[i];
+   r_.resize(r_.size() - 1);
+ }
+ else if (c == r_[i].min)
+   r_[i].min += 1;
+ else if (c == r_[i].max)
+   r_[i].max -= 1;
+ else {
+   r_.resize(r_.size() + 1);
+
+
+   for (size_t j = r_.size() - 2; j > i; j--)
+     r_[j + 1] = r_[j];
+   r_[i + 1].max = r_[i].max;
+   r_[i + 1].min = c + 1;
+   r_[i].max = c - 1;
+ }
+      }
+      break;
+    }
+}
+
+template<class T>
+void ISet<T>::check()
+{
+  for (size_t i = 0; i < r_.size(); i++) {
+    if (r_[i].min > r_[i].max)
+      abort();
+
+    if (i > 0 && r_[i].min - 1 <= r_[i - 1].max)
+      abort();
+  }
+}
+
+template<class T>
+void ISet<T>::clear()
+{
+  r_.resize(0);
+}
+
+
+}
+# 58 "/usr/include/OpenSP/ISet.h" 2 3 4
+# 10 "/usr/include/OpenSP/RangeMap.h" 2 3 4
+
+# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
+# 12 "/usr/include/OpenSP/RangeMap.h" 2 3 4
+
+
+namespace OpenSP {
+
+
+template<class From, class To>
+struct RangeMapRange {
+  From fromMin;
+  From fromMax;
+  To toMin;
+};
+
+template<class From, class To> class RangeMapIter;
+
+template<class From, class To>
+class RangeMap {
+public:
+  RangeMap();
+  Boolean map(From, To &, From &alsoMax) const;
+
+  unsigned inverseMap(To, From &, ISet<WideChar> &, WideChar &count) const;
+  void addRange(From, From, To);
+private:
+  Vector<RangeMapRange<From,To> > ranges_;
+  friend class RangeMapIter<From,To>;
+};
+
+template<class From, class To>
+class RangeMapIter {
+public:
+  RangeMapIter(const RangeMap<From,To> &map);
+  Boolean next(From &fromMin, From &fromMax, To &toMin) {
+    if (!count_)
+      return 0;
+    else {
+      fromMin = ptr_->fromMin;
+      fromMax = ptr_->fromMax;
+      toMin = ptr_->toMin;
+      ptr_++;
+      count_--;
+      return 1;
+    }
+  }
+private:
+  size_t count_;
+  typename Vector<RangeMapRange<From,To> >::const_iterator ptr_;
+};
+
+
+}
+
+
+
+
+
+# 1 "/usr/include/OpenSP/RangeMap.cxx" 1 3 4
+
+
+
+
+
+
+# 1 "/usr/include/OpenSP/RangeMap.h" 1 3 4
+# 67 "/usr/include/OpenSP/RangeMap.h" 3 4
+# 1 "/usr/include/OpenSP/RangeMap.cxx" 1 3 4
+# 68 "/usr/include/OpenSP/RangeMap.h" 2 3 4
+# 8 "/usr/include/OpenSP/RangeMap.cxx" 2 3 4
+# 1 "/usr/include/OpenSP/ISet.h" 1 3 4
+# 9 "/usr/include/OpenSP/RangeMap.cxx" 2 3 4
+
+# 1 "/usr/include/OpenSP/constant.h" 1 3 4
+
+
+
+
+
+
+namespace OpenSP {
+
+
+
+
+const Char charMax = 0x10ffff;
+
+
+
+const WideChar wideCharMax = WideChar(-1);
+const UnivChar univCharMax = UnivChar(-1);
+const SyntaxChar syntaxCharMax = SyntaxChar(-1);
+
+
+}
+# 11 "/usr/include/OpenSP/RangeMap.cxx" 2 3 4
+
+
+namespace OpenSP {
+
+
+template<class From, class To>
+RangeMap<From, To>::RangeMap()
+{
+}
+
+template<class From, class To>
+Boolean RangeMap<From, To>::map(From from, To &to, From &alsoMax) const
+{
+
+  for (size_t i = 0; i < ranges_.size(); i++) {
+    const RangeMapRange<From,To> &r = ranges_[i];
+    if (r.fromMin <= from && from <= r.fromMax) {
+      to = r.toMin + (from - r.fromMin);
+      alsoMax = r.fromMax;
+      return 1;
+    }
+    if (r.fromMin > from) {
+      alsoMax = r.fromMin - 1;
+      return 0;
+    }
+  }
+  alsoMax = From(-1);
+  return 0;
+}
+
+
+typedef ISet<WideChar> RangeMap_dummy;
+
+template<class From, class To>
+unsigned RangeMap<From, To>::inverseMap(To to, From &from,
+     ISet<WideChar> &fromSet,
+     WideChar &count) const
+{
+
+  unsigned ret = 0;
+  count = wideCharMax;
+  for (size_t i = 0; i < ranges_.size(); i++) {
+    const RangeMapRange<From,To> &r = ranges_[i];
+    if (r.toMin <= to && to <= r.toMin + (r.fromMax - r.fromMin)) {
+      From n = r.fromMin + (to - r.toMin);
+      WideChar thisCount = r.fromMax - n + 1;
+      if (ret > 1) {
+ fromSet.add(n);
+ if (thisCount < count)
+   count = thisCount;
+      }
+      else if (ret == 1) {
+ fromSet.add(from);
+ fromSet.add(n);
+ ret = 2;
+ if (thisCount < count)
+   count = thisCount;
+      }
+      else {
+ count = thisCount;
+ from = n;
+ ret = 1;
+      }
+    }
+    else if (ret == 0 && r.toMin > to && (r.toMin - to < count))
+      count = r.toMin - to;
+  }
+  return ret;
+}
+
+template<class From, class To>
+RangeMapIter<From, To>::RangeMapIter(const RangeMap<From, To> &map)
+: count_(map.ranges_.size()), ptr_(map.ranges_.begin())
+{
+}
+
+
+
+
+template<class From, class To>
+void RangeMap<From, To>::addRange(From fromMin, From fromMax, To toMin)
+{
+
+  size_t i;
+  for (i = ranges_.size(); i > 0; i--)
+    if (fromMin > ranges_[i - 1].fromMax)
+      break;
+
+  Boolean coalesced = 0;
+  if (i > 0
+      && ranges_[i - 1].fromMax + 1 == fromMin
+      && ranges_[i - 1].toMin + (fromMin - ranges_[i - 1].fromMin) == toMin) {
+
+    ranges_[i - 1].fromMax = fromMax;
+    i--;
+    coalesced = 1;
+  }
+  else if (i < ranges_.size() && fromMax >= ranges_[i].fromMin - 1) {
+
+    if (fromMin <= ranges_[i].fromMin) {
+      if (toMin + (ranges_[i].fromMin - fromMin) == ranges_[i].toMin) {
+ ranges_[i].fromMin = fromMin;
+ if (fromMax <= ranges_[i].fromMax)
+   return;
+ ranges_[i].fromMax = fromMax;
+ coalesced = 1;
+      }
+    }
+    else {
+
+      if (ranges_[i].toMin + (fromMin - ranges_[i].fromMin) == toMin) {
+ if (fromMax < ranges_[i].fromMax)
+   return;
+ ranges_[i].fromMax = fromMax;
+ coalesced = 1;
+      }
+    }
+  }
+  if (!coalesced) {
+
+    ranges_.resize(ranges_.size() + 1);
+    for (size_t j = ranges_.size() - 1; j > i; j--)
+      ranges_[j] = ranges_[j - 1];
+    ranges_[i].fromMin = fromMin;
+    ranges_[i].fromMax = fromMax;
+    ranges_[i].toMin = toMin;
+  }
+
+  size_t j;
+  for (j = i + 1; j < ranges_.size(); j++) {
+    if (fromMax < ranges_[j].fromMax) {
+      if (fromMax >= ranges_[j].fromMin)
+ ranges_[j].fromMin = fromMax + 1;
+      break;
+    }
+  }
+  if (j > i + 1) {
+
+
+
+    size_t count = ranges_.size() - j;
+    for (size_t k = 0; k < count; k++)
+      ranges_[i + 1 + count] = ranges_[j + count];
+    ranges_.resize(ranges_.size() - (j - (i + 1)));
+  }
+}
+
+
+}
+# 68 "/usr/include/OpenSP/RangeMap.h" 2 3 4
+# 14 "/usr/include/OpenSP/UnivCharsetDesc.h" 2 3 4
+
+# 1 "/usr/include/OpenSP/ISet.h" 1 3 4
+# 16 "/usr/include/OpenSP/UnivCharsetDesc.h" 2 3 4
+
+
+
+namespace OpenSP {
+
+
+class UnivCharsetDesc {
+public:
+  struct Range {
+    WideChar descMin;
+
+
+    unsigned long count;
+    UnivChar univMin;
+  };
+  enum {
+    zero = 48,
+    A = 65,
+    a = 97,
+    tab = 9,
+    rs = 10,
+    re = 13,
+    space = 32,
+    exclamation = 33,
+    lessThan = 60,
+    greaterThan = 62
+    };
+  UnivCharsetDesc();
+  UnivCharsetDesc(const Range *, size_t);
+  void set(const Range *, size_t);
+  Boolean descToUniv(WideChar from, UnivChar &to) const;
+  Boolean descToUniv(WideChar from, UnivChar &to, WideChar &alsoMax) const;
+
+  unsigned univToDesc(UnivChar from, WideChar &to, ISet<WideChar> &toSet)
+       const;
+  unsigned univToDesc(UnivChar from, WideChar &to, ISet<WideChar> &toSet,
+        WideChar &count)
+       const;
+  void addRange(WideChar descMin, WideChar descMax, UnivChar univMin);
+  void addBaseRange(const UnivCharsetDesc &baseSet,
+      WideChar descMin,
+      WideChar descMax,
+      WideChar baseMin,
+      ISet<WideChar> &baseMissing);
+private:
+  static Boolean noDesc(Unsigned32 n) {
+    return (n & (unsigned(1) << 31));
+  }
+  static UnivChar extractChar(Unsigned32 n, Char ch) {
+    return UnivChar((n + ch) & ((unsigned(1) << 31) - 1));
+  }
+  static Unsigned32 wrapChar(UnivChar univ, Char ch) {
+    return Unsigned32((univ - ch) & ((unsigned(1) << 31) - 1));
+  }
+
+  CharMap<Unsigned32> charMap_;
+
+  RangeMap<WideChar,UnivChar> rangeMap_;
+  friend class UnivCharsetDescIter;
+};
+
+class UnivCharsetDescIter {
+public:
+  UnivCharsetDescIter(const UnivCharsetDesc &);
+  Boolean next(WideChar &descMin, WideChar &descMax, UnivChar &univMin);
+  void skipTo(WideChar);
+private:
+  const CharMap<Unsigned32> *charMap_;
+  Char nextChar_;
+  Boolean doneCharMap_;
+  RangeMapIter<WideChar,UnivChar> rangeMapIter_;
+};
+
+inline
+Boolean UnivCharsetDesc::descToUniv(WideChar from, UnivChar &to) const
+{
+  if (from > charMax) {
+    WideChar tem;
+    return rangeMap_.map(from, to, tem);
+  }
+  else {
+    Unsigned32 tem = charMap_[from];
+    if (noDesc(tem))
+      return 0;
+    else {
+      to = extractChar(tem, from);
+      return 1;
+    }
+  }
+}
+
+inline
+Boolean UnivCharsetDesc::descToUniv(WideChar from, UnivChar &to,
+        WideChar &alsoMax) const
+{
+  if (from > charMax)
+    return rangeMap_.map(from, to, alsoMax);
+  else {
+    Char max;
+    Unsigned32 tem = charMap_.getRange(from, max);
+    alsoMax = max;
+    if (noDesc(tem))
+      return 0;
+    else {
+      to = extractChar(tem, from);
+      return 1;
+    }
+  }
+}
+
+inline
+unsigned UnivCharsetDesc::univToDesc(UnivChar from, WideChar &to,
+         ISet<WideChar> &toSet) const
+{
+  WideChar tem;
+  return univToDesc(from, to, toSet, tem);
+}
+
+inline
+void UnivCharsetDescIter::skipTo(WideChar ch)
+{
+  if (ch > charMax)
+    doneCharMap_ = 1;
+  else
+    nextChar_ = ch;
+}
+
+
+}
+# 12 "/usr/include/OpenSP/CharsetInfo.h" 2 3 4
+
+
+
+# 1 "/usr/include/OpenSP/ISet.h" 1 3 4
+# 16 "/usr/include/OpenSP/CharsetInfo.h" 2 3 4
+# 1 "/usr/include/OpenSP/CharMap.h" 1 3 4
+# 17 "/usr/include/OpenSP/CharsetInfo.h" 2 3 4
+
+
+namespace OpenSP {
+
+
+class CharsetInfo {
+public:
+  CharsetInfo();
+  CharsetInfo(const UnivCharsetDesc &);
+  void set(const UnivCharsetDesc &);
+
+
+
+  Char execToDesc(char) const;
+  StringC execToDesc(const char *s) const;
+  Boolean descToUniv(WideChar from, UnivChar &to) const;
+  Boolean descToUniv(WideChar from, UnivChar &to, WideChar &alsoMax) const;
+
+
+
+  unsigned univToDesc(UnivChar from, WideChar &to, ISet<WideChar> &toSet)
+       const;
+  unsigned univToDesc(UnivChar from, WideChar &to, ISet<WideChar> &toSet,
+        WideChar &count)
+       const;
+  void getDescSet(ISet<Char> &) const;
+  int digitWeight(Char) const;
+  int hexDigitWeight(Char) const;
+  const UnivCharsetDesc &desc() const;
+private:
+  void init();
+  UnivCharsetDesc desc_;
+  CharMap<Unsigned32> inverse_;
+  Char execToDesc_[(127 * 2 + 1) + 1];
+};
+
+inline
+unsigned CharsetInfo::univToDesc(UnivChar from, WideChar &to,
+     ISet<WideChar> &toSet)
+     const
+{
+  if (from <= charMax) {
+    Unsigned32 n = inverse_[from];
+    if (n == Unsigned32(-1))
+      return 0;
+    if (n != Unsigned32(-2)) {
+      to = ((n + from) & ((Unsigned32(1) << 31) - 1));
+      return 1;
+    }
+  }
+  return desc_.univToDesc(from, to, toSet);
+}
+
+inline
+unsigned CharsetInfo::univToDesc(UnivChar from, WideChar &to,
+     ISet<WideChar> &toSet, WideChar &count)
+     const
+{
+  if (from <= charMax) {
+    Char fromMax;
+    Unsigned32 n = inverse_.getRange(from, fromMax);
+    if (n == Unsigned32(-1)) {
+      count = (fromMax - from) + 1;
+      return 0;
+    }
+    if (n != Unsigned32(-2)) {
+      to = ((n + from) & ((Unsigned32(1) << 31) - 1));
+      count = (fromMax - from) + 1;
+      return 1;
+    }
+  }
+  return desc_.univToDesc(from, to, toSet, count);
+}
+
+inline
+Boolean CharsetInfo::descToUniv(UnivChar from, WideChar &to) const
+{
+  return desc_.descToUniv(from, to);
+}
+
+inline
+Char CharsetInfo::execToDesc(char c) const
+{
+  return execToDesc_[(unsigned char)c];
+}
+
+inline
+Boolean CharsetInfo::descToUniv(WideChar from, UnivChar &to,
+    WideChar &alsoMax) const
+{
+  return desc_.descToUniv(from, to, alsoMax);
+}
+
+inline
+const UnivCharsetDesc &CharsetInfo::desc() const
+{
+  return desc_;
+}
+
+
+}
+# 14 "/usr/include/OpenSP/Sd.h" 2 3 4
+
+# 1 "/usr/include/OpenSP/ISet.h" 1 3 4
+# 16 "/usr/include/OpenSP/Sd.h" 2 3 4
+# 1 "/usr/include/OpenSP/Syntax.h" 1 3 4
+
+
+
+
+
+
+#pragma interface
+
+
+
+
+# 1 "/usr/include/OpenSP/ISet.h" 1 3 4
+# 13 "/usr/include/OpenSP/Syntax.h" 2 3 4
+
+
+# 1 "/usr/include/OpenSP/HashTable.h" 1 3 4
+
+
+
+
+
+
+# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
+# 8 "/usr/include/OpenSP/HashTable.h" 2 3 4
+# 1 "/usr/include/OpenSP/OwnerTable.h" 1 3 4
+
+
+
+
+
+
+# 1 "/usr/include/OpenSP/PointerTable.h" 1 3 4
+
+
+
+
+
+
+# 1 "/usr/include/OpenSP/Vector.h" 1 3 4
+# 8 "/usr/include/OpenSP/PointerTable.h" 2 3 4
+
+# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
+# 10 "/usr/include/OpenSP/PointerTable.h" 2 3 4
+
+
+namespace OpenSP {
+
+
+template<class P, class K, class HF, class KF> class PointerTableIter;
+
+template<class P, class K, class HF, class KF>
+class PointerTable {
+  void constraints() {
+    P p(0);
+    const K &key = KF::key(*p);
+    unsigned long n = HF::hash(key);
+    n = 0;
+  }
+public:
+  PointerTable();
+  P insert(P, Boolean replace = 0);
+
+
+  const P &lookup(const K &) const;
+  P remove(const K &);
+  size_t count() const { return used_; }
+  void clear();
+  void swap(PointerTable<P, K, HF, KF> &);
+protected:
+  size_t used_;
+  size_t usedLimit_;
+  Vector<P> vec_;
+  P null_;
+
+  size_t startIndex(const K &k) const {
+    return size_t(HF::hash(k) & (vec_.size() - 1));
+  }
+  size_t nextIndex(size_t i) const {
+    return i == 0 ? vec_.size() - 1 : i - 1;
+  }
+  friend class PointerTableIter<P, K, HF, KF>;
+};
+
+template<class P, class K, class HF, class KF>
+class PointerTableIter {
+public:
+  PointerTableIter(const PointerTable<P, K, HF, KF> &);
+  const P &next();
+private:
+  const PointerTable<P, K, HF, KF> *tablePtr_;
+  size_t i_;
+};
+
+
+}
+
+
+
+
+
+# 1 "/usr/include/OpenSP/PointerTable.cxx" 1 3 4
+# 10 "/usr/include/OpenSP/PointerTable.cxx" 3 4
+namespace OpenSP {
+
+
+template<class P, class K, class HF, class KF>
+PointerTable<P, K, HF, KF>::PointerTable()
+: used_(0), usedLimit_(0), null_(0)
+{
+}
+
+template<class P, class K, class HF, class KF>
+void PointerTable<P, K, HF, KF>::clear()
+{
+  vec_.clear();
+  used_ = 0;
+  usedLimit_ = 0;
+}
+
+template<class P, class K, class HF, class KF>
+P PointerTable<P, K, HF, KF>::insert(P p, Boolean replace)
+{
+  size_t h;
+  if (vec_.size() == 0) {
+    vec_.assign(8, P(0));
+    usedLimit_ = 4;
+    h = startIndex(KF::key(*p));
+  }
+  else {
+    for (h = startIndex(KF::key(*p)); vec_[h] != 0 ; h = nextIndex(h))
+      if (KF::key(*vec_[h]) == KF::key(*p)) {
+ if (replace) {
+   P tem(vec_[h]);
+   vec_[h] = p;
+   return tem;
+ }
+ else
+   return vec_[h];
+      }
+    if (used_ >= usedLimit_) {
+      if (vec_.size() > size_t(-1)/2) {
+ if (usedLimit_ == vec_.size() - 1)
+   abort();
+ else
+   usedLimit_ = vec_.size() - 1;
+      }
+      else {
+
+ Vector<P> oldVec(vec_.size()*2, P(0));
+ vec_.swap(oldVec);
+ usedLimit_ = vec_.size() / 2;
+ for (size_t i = 0; i < oldVec.size(); i++)
+   if (oldVec[i] != 0) {
+     size_t j;
+     for (j = startIndex(KF::key(*oldVec[i]));
+   vec_[j] != 0;
+   j = nextIndex(j))
+       ;
+     vec_[j] = oldVec[i];
+   }
+ for (h = startIndex(KF::key(*p)); vec_[h] != 0; h = nextIndex(h))
+   ;
+      }
+    }
+  }
+  used_++;
+  vec_[h] = p;
+  return 0;
+}
+
+template<class P, class K, class HF, class KF>
+const P &PointerTable<P, K, HF, KF>::lookup(const K &k) const
+{
+  if (used_ > 0) {
+    for (size_t i = startIndex(k); vec_[i] != 0; i = nextIndex(i))
+      if (KF::key(*vec_[i]) == k)
+ return vec_[i];
+  }
+  return null_;
+}
+
+template<class P, class K, class HF, class KF>
+P PointerTable<P, K, HF, KF>::remove(const K &k)
+{
+  if (used_ > 0) {
+    for (size_t i = startIndex(k); vec_[i] != 0; i = nextIndex(i))
+      if (KF::key(*vec_[i]) == k) {
+ P p = vec_[i];
+ do {
+   vec_[i] = P(0);
+   size_t j = i;
+   size_t r;
+   do {
+     i = nextIndex(i);
+     if (vec_[i] == 0)
+       break;
+     r = startIndex(KF::key(*vec_[i]));
+   } while ((i <= r && r < j) || (r < j && j < i) || (j < i && i <= r));
+   vec_[j] = vec_[i];
+ } while (vec_[i] != 0);
+ --used_;
+ return p;
+      }
+  }
+  return 0;
+}
+
+template<class P, class K, class HF, class KF>
+void PointerTable<P, K, HF, KF>::swap(PointerTable<P, K, HF, KF> &to)
+{
+  vec_.swap(to.vec_);
+  size_t tem = to.used_;
+  to.used_ = used_;
+  used_ = tem;
+  tem = to.usedLimit_;
+  to.usedLimit_ = usedLimit_;
+  usedLimit_ = tem;
+}
+
+template<class P, class K, class HF, class KF>
+PointerTableIter<P, K, HF, KF>::PointerTableIter(const PointerTable<P, K, HF, KF> &table)
+: tablePtr_(&table), i_(0)
+{
+}
+
+template<class P, class K, class HF, class KF>
+const P &PointerTableIter<P, K, HF, KF>::next()
+{
+  for (; i_ < tablePtr_->vec_.size(); i_++)
+    if (tablePtr_->vec_[i_] != 0)
+      return tablePtr_->vec_[i_++];
+  return tablePtr_->null_;
+}
+
+
+}
+# 68 "/usr/include/OpenSP/PointerTable.h" 2 3 4
+# 8 "/usr/include/OpenSP/OwnerTable.h" 2 3 4
+
+
+namespace OpenSP {
+
+
+template<class T, class K, class HF, class KF>
+class OwnerTable : public PointerTable<T *, K, HF, KF> {
+public:
+  OwnerTable() { }
+  ~OwnerTable();
+  void clear();
+  void swap(OwnerTable<T, K, HF, KF> &x) {
+    PointerTable<T *, K, HF, KF>::swap(x);
+  }
+private:
+  OwnerTable(const OwnerTable<T, K, HF, KF> &);
+  void operator=(const OwnerTable<T, K, HF, KF> &);
+};
+
+template<class T, class K, class HF, class KF>
+class OwnerTableIter : public PointerTableIter<T *, K, HF, KF> {
+public:
+  OwnerTableIter(const OwnerTable<T, K, HF, KF> &table)
+    : PointerTableIter<T *, K, HF, KF>(table) { }
+};
+
+template<class T, class K, class HF, class KF>
+class CopyOwnerTable : public OwnerTable<T, K, HF, KF> {
+public:
+  CopyOwnerTable() { }
+  CopyOwnerTable(const CopyOwnerTable<T, K, HF, KF> &tab) { *this = tab; }
+  void operator=(const CopyOwnerTable<T, K, HF, KF> &tab);
+};
+
+
+}
+
+
+
+
+
+# 1 "/usr/include/OpenSP/OwnerTable.cxx" 1 3 4
+
+
+
+
+
+
+
+namespace OpenSP {
+
+
+
+
+template<class T, class K, class HF, class KF>
+OwnerTable<T, K, HF, KF>::~OwnerTable()
+{
+  for (size_t i = 0; i < this->vec_.size(); i++)
+    delete this->vec_[i];
+}
+
+template<class T, class K, class HF, class KF>
+void OwnerTable<T, K, HF, KF>::clear()
+{
+  for (size_t i = 0; i < this->vec_.size(); i++)
+    delete this->vec_[i];
+  PointerTable<T *, K, HF, KF>::clear();
+}
+
+template<class T, class K, class HF, class KF>
+void
+CopyOwnerTable<T, K, HF, KF>::operator=(const CopyOwnerTable<T, K, HF, KF> &t)
+{
+  this->clear();
+  PointerTable<T *, K, HF, KF>::operator=(t);
+
+  for (size_t i = 0; i < this->vec_.size(); i++)
+    if (this->vec_[i])
+      this->vec_[i] = this->vec_[i]->copy();
+}
+
+
+}
+# 50 "/usr/include/OpenSP/OwnerTable.h" 2 3 4
+# 9 "/usr/include/OpenSP/HashTable.h" 2 3 4
+# 1 "/usr/include/OpenSP/Hash.h" 1 3 4
+
+
+
+
+
+
+#pragma interface
+
+
+
+
+
+namespace OpenSP {
+
+
+class Hash {
+public:
+  static unsigned long hash(const StringC &);
+};
+
+
+}
+# 10 "/usr/include/OpenSP/HashTable.h" 2 3 4
+
+# 1 "/usr/include/OpenSP/HashTableItemBase.h" 1 3 4
+# 11 "/usr/include/OpenSP/HashTableItemBase.h" 3 4
+namespace OpenSP {
+
+
+template<class K>
+class HashTableItemBase {
+public:
+  HashTableItemBase(const K &k);
+  virtual ~HashTableItemBase();
+  virtual HashTableItemBase<K> *copy() const = 0;
+  K key;
+};
+
+template<class K>
+struct HashTableKeyFunction {
+  static inline const K &key(const HashTableItemBase<K> &obj) {
+    return obj.key;
+  }
+};
+
+
+}
+
+
+
+
+
+# 1 "/usr/include/OpenSP/HashTableItemBase.cxx" 1 3 4
+
+
+
+
+
+
+
+namespace OpenSP {
+
+
+template<class K>
+HashTableItemBase<K>::~HashTableItemBase()
+{
+}
+
+template<class K>
+HashTableItemBase<K>::HashTableItemBase(const K &k) : key(k)
+{
+}
+
+
+
+}
+# 38 "/usr/include/OpenSP/HashTableItemBase.h" 2 3 4
+# 12 "/usr/include/OpenSP/HashTable.h" 2 3 4
+
+
+namespace OpenSP {
+
+
+template<class K, class V>
+class HashTableItem : public HashTableItemBase<K> {
+public:
+  HashTableItem(const K &k, const V &v);
+  HashTableItemBase<K> *copy() const;
+  V value;
+};
+
+template<class K, class V> class HashTableIter;
+
+template<class K, class V>
+class HashTable {
+public:
+  HashTable() { }
+  void insert(const K &key, const V &value, Boolean replace = 1);
+  const V *lookup(const K &key) const {
+    HashTableItem<K, V> *tem = (HashTableItem<K, V> *)table_.lookup(key);
+    return tem ? &tem->value : 0;
+  }
+  size_t count() const { return table_.count(); }
+private:
+  CopyOwnerTable<HashTableItemBase<K>, K, Hash, HashTableKeyFunction<K> > table_;
+friend class HashTableIter<K,V>;
+};
+
+template<class K, class V>
+class HashTableIter {
+public:
+  HashTableIter(const HashTable<K, V> &table) : iter_(table.table_) { }
+  Boolean next(const K *&key, const V *&value) {
+    HashTableItem<K, V> *p = (HashTableItem<K, V> *)iter_.next();
+    if (p) {
+      key = &p->key;
+      value = &p->value;
+      return 1;
+    }
+    else
+      return 0;
+  }
+private:
+  OwnerTableIter<HashTableItemBase<K>, K, Hash, HashTableKeyFunction<K> > iter_;
+};
+
+
+}
+
+
+
+
+
+# 1 "/usr/include/OpenSP/HashTable.cxx" 1 3 4
+
+
+
+
+
+
+
+namespace OpenSP {
+
+
+template<class K, class V>
+void HashTable<K,V>::insert(const K &key, const V &value, Boolean replace)
+{
+  HashTableItem<K, V> *newItem = new HashTableItem<K, V>(key, value);
+  HashTableItem<K, V> *tem = (HashTableItem<K, V> *)table_.insert(newItem);
+  if (tem) {
+    delete newItem;
+    if (replace) {
+      tem->key = key;
+      tem->value = value;
+    }
+  }
+}
+
+template<class K, class V>
+HashTableItem<K,V>::HashTableItem(const K &k, const V &v)
+: HashTableItemBase<K>(k), value(v)
+{
+}
+
+template<class K, class V>
+HashTableItemBase<K> *HashTableItem<K,V>::copy() const
+{
+  return new HashTableItem<K, V>(*this);
+}
+
+
+}
+# 68 "/usr/include/OpenSP/HashTable.h" 2 3 4
+# 16 "/usr/include/OpenSP/Syntax.h" 2 3 4
+# 1 "/usr/include/OpenSP/Vector.h" 1 3 4
+# 17 "/usr/include/OpenSP/Syntax.h" 2 3 4
+
+# 1 "/usr/include/OpenSP/XcharMap.h" 1 3 4
+# 9 "/usr/include/OpenSP/XcharMap.h" 3 4
+# 1 "/usr/include/OpenSP/Ptr.h" 1 3 4
+# 10 "/usr/include/OpenSP/XcharMap.h" 2 3 4
+
+# 1 "/usr/include/OpenSP/CharMap.h" 1 3 4
+# 12 "/usr/include/OpenSP/XcharMap.h" 2 3 4
+
+
+namespace OpenSP {
+
+
+template<class T>
+class SharedXcharMap : public Resource {
+public:
+  SharedXcharMap();
+  SharedXcharMap(T defaultValue);
+  T *ptr() { return v + 1; }
+private:
+
+  T v[2 + 0xffff];
+
+
+
+};
+
+template<class T>
+class XcharMap {
+public:
+  XcharMap();
+  XcharMap(T defaultValue);
+  T operator[](Xchar c) const;
+  void setRange(Char min, Char max, T val);
+  void setChar(Char c, T val);
+  void setEe(T val);
+  void clear();
+private:
+  T *ptr_;
+  Ptr<SharedXcharMap<T> > sharedMap_;
+
+  Ptr<CharMapResource<T> > hiMap_;
+
+};
+
+
+template<class T>
+inline
+T XcharMap<T>::operator[](Xchar c) const
+{
+
+  if (c > 0xffff)
+    return hiMap_->operator[]((Char)c);
+
+  return ptr_[c];
+}
+
+template<class T>
+inline
+void XcharMap<T>::setChar(Char c, T val)
+{
+
+  if (c > 0xffff) {
+    hiMap_->setChar(c, val);
+    return;
+  }
+
+  ptr_[c] = val;
+}
+
+template<class T>
+inline
+void XcharMap<T>::setEe(T val)
+{
+  ptr_[-1] = val;
+}
+
+template<class T>
+inline
+void XcharMap<T>::clear()
+{
+  ptr_ = 0;
+  sharedMap_.clear();
+
+  hiMap_.clear();
+
+}
+
+
+}
+
+
+
+
+
+# 1 "/usr/include/OpenSP/XcharMap.cxx" 1 3 4
+
+
+
+
+
+
+# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
+# 8 "/usr/include/OpenSP/XcharMap.cxx" 2 3 4
+
+
+namespace OpenSP {
+
+
+template<class T>
+SharedXcharMap<T>::SharedXcharMap()
+{
+}
+
+template<class T>
+SharedXcharMap<T>::SharedXcharMap(T defaultValue)
+{
+  for (size_t i = 0; i < sizeof(v)/sizeof(v[0]); i++)
+    v[i] = defaultValue;
+}
+
+template<class T>
+XcharMap<T>::XcharMap()
+: ptr_(0)
+{
+}
+
+template<class T>
+XcharMap<T>::XcharMap(T defaultValue)
+: sharedMap_(new SharedXcharMap<T>(defaultValue))
+
+  , hiMap_(new CharMapResource<T>(defaultValue))
+
+{
+  ptr_ = sharedMap_->ptr();
+}
+
+template<class T>
+void XcharMap<T>::setRange(Char min, Char max, T val)
+{
+  if (min <= max) {
+
+    if (min <= 0xffff) {
+      Char m = max <= 0xffff ? max : 0xffff;
+
+
+
+      do {
+ ptr_[min] = val;
+      } while (min++ != m);
+
+    }
+    if (max >= 0x10000)
+      hiMap_->setRange(min < 0x10000 ? 0x10000 : min, max, val);
+
+  }
+}
+
+
+}
+# 100 "/usr/include/OpenSP/XcharMap.h" 2 3 4
+# 19 "/usr/include/OpenSP/Syntax.h" 2 3 4
+# 1 "/usr/include/OpenSP/EntityCatalog.h" 1 3 4
+
+
+
+
+#pragma interface
+# 14 "/usr/include/OpenSP/EntityCatalog.h" 3 4
+namespace OpenSP {
+
+
+class Messenger;
+class CharsetInfo;
+class EntityDecl;
+
+class EntityCatalog : public Resource {
+public:
+  class Syntax {
+  public:
+    virtual Boolean namecaseGeneral() const = 0;
+    virtual Boolean namecaseEntity() const = 0;
+    virtual const SubstTable &upperSubstTable() const = 0;
+    virtual const StringC &peroDelim() const = 0;
+  };
+  virtual ~EntityCatalog();
+  virtual Boolean sgmlDecl(const CharsetInfo &,
+      Messenger &,
+      const StringC &,
+      StringC &) const;
+  virtual Boolean lookup(const EntityDecl &,
+    const Syntax &,
+    const CharsetInfo &,
+    Messenger &,
+    StringC &) const;
+  virtual Boolean lookupPublic(const StringC &,
+          const CharsetInfo &,
+          Messenger &,
+          StringC &) const;
+
+
+  virtual Boolean lookupChar(const StringC &,
+                             const CharsetInfo &,
+        Messenger &,
+        UnivChar &) const;
+};
+
+
+}
+# 20 "/usr/include/OpenSP/Syntax.h" 2 3 4
+
+
+namespace OpenSP {
+
+
+class Sd;
+class CharsetInfo;
+
+class Syntax : public Resource, public EntityCatalog::Syntax {
+public:
+  enum ReservedName {
+    rALL,
+    rANY,
+    rATTLIST,
+    rCDATA,
+    rCONREF,
+    rCURRENT,
+    rDATA,
+    rDEFAULT,
+    rDOCTYPE,
+    rELEMENT,
+    rEMPTY,
+    rENDTAG,
+    rENTITIES,
+    rENTITY,
+    rFIXED,
+    rID,
+    rIDLINK,
+    rIDREF,
+    rIDREFS,
+    rIGNORE,
+    rIMPLICIT,
+    rIMPLIED,
+    rINCLUDE,
+    rINITIAL,
+    rLINK,
+    rLINKTYPE,
+    rMD,
+    rMS,
+    rNAME,
+    rNAMES,
+    rNDATA,
+    rNMTOKEN,
+    rNMTOKENS,
+    rNOTATION,
+    rNUMBER,
+    rNUMBERS,
+    rNUTOKEN,
+    rNUTOKENS,
+    rO,
+    rPCDATA,
+    rPI,
+    rPOSTLINK,
+    rPUBLIC,
+    rRCDATA,
+    rRE,
+    rREQUIRED,
+    rRESTORE,
+    rRS,
+    rSDATA,
+    rSHORTREF,
+    rSIMPLE,
+    rSPACE,
+    rSTARTTAG,
+    rSUBDOC,
+    rSYSTEM,
+    rTEMP,
+    rUSELINK,
+    rUSEMAP
+  };
+  enum { nNames = rUSEMAP + 1 };
+  enum Quantity {
+    qATTCNT,
+    qATTSPLEN,
+    qBSEQLEN,
+    qDTAGLEN,
+    qDTEMPLEN,
+    qENTLVL,
+    qGRPCNT,
+    qGRPGTCNT,
+    qGRPLVL,
+    qLITLEN,
+    qNAMELEN,
+    qNORMSEP,
+    qPILEN,
+    qTAGLEN,
+    qTAGLVL
+  };
+  enum { nQuantity = qTAGLVL + 1 };
+  enum { unlimited = 100000000 };
+  enum DelimGeneral {
+    dAND,
+    dCOM,
+    dCRO,
+    dDSC,
+    dDSO,
+    dDTGC,
+    dDTGO,
+    dERO,
+    dETAGO,
+    dGRPC,
+    dGRPO,
+    dHCRO,
+    dLIT,
+    dLITA,
+    dMDC,
+    dMDO,
+    dMINUS,
+    dMSC,
+    dNET,
+    dNESTC,
+    dOPT,
+    dOR,
+    dPERO,
+    dPIC,
+    dPIO,
+    dPLUS,
+    dREFC,
+    dREP,
+    dRNI,
+    dSEQ,
+    dSTAGO,
+    dTAGC,
+    dVI
+  };
+  enum { nDelimGeneral = dVI + 1 };
+  enum StandardFunction {
+    fRE,
+    fRS,
+    fSPACE
+  };
+  enum FunctionClass {
+    cFUNCHAR,
+    cSEPCHAR,
+    cMSOCHAR,
+    cMSICHAR,
+    cMSSCHAR
+  };
+  enum Set {
+    nameStart,
+    digit,
+    hexDigit,
+    nmchar,
+    s,
+    blank,
+    sepchar,
+    minimumData,
+    significant,
+    functionChar,
+    sgmlChar
+  };
+  enum { nSet = sgmlChar + 1 };
+  enum Category {
+    otherCategory = 0,
+    sCategory = 01,
+    nameStartCategory = 02,
+    digitCategory = 04,
+    otherNameCategory = 010
+    };
+
+  Syntax(const Sd &);
+  Boolean lookupFunctionChar(const StringC &, Char *) const;
+  HashTableIter<StringC,Char> functionIter() const;
+  Boolean charFunctionName(Char c, const StringC *&name) const;
+  Boolean lookupReservedName(const StringC &, ReservedName *) const;
+  const StringC &reservedName(ReservedName) const;
+  StringC rniReservedName(ReservedName) const;
+  Number quantity(Quantity) const;
+  Char standardFunction(int) const;
+  Boolean getStandardFunction(int, Char &) const;
+  const StringC &delim() const;
+  const ISet<Char> *charSet(int i) const;
+  const SubstTable *generalSubstTable() const;
+  const SubstTable *entitySubstTable() const;
+  const SubstTable &upperSubstTable() const;
+  Boolean namecaseGeneral() const;
+  Boolean namecaseEntity() const;
+  const StringC &peroDelim() const;
+  const StringC &delimGeneral(int) const;
+  const StringC &delimShortrefComplex(size_t) const;
+  const ISet<Char> &delimShortrefSimple() const;
+  int nDelimShortrefComplex() const;
+  Boolean isValidShortref(const StringC &) const;
+  Boolean hasShortrefs() const;
+  Boolean isNameCharacter(Xchar) const;
+  Boolean isNameStartCharacter(Xchar) const;
+  Boolean isDigit(Xchar) const;
+  Boolean isHexDigit(Xchar) const;
+  Boolean isS(Xchar) const;
+  Boolean isB(Xchar c) const;
+  Category charCategory(Xchar) const;
+  Boolean isSgmlChar(Xchar) const;
+  size_t attcnt() const;
+  size_t attsplen() const;
+  size_t namelen() const;
+  size_t penamelen() const;
+  size_t litlen() const;
+  size_t normsep() const;
+  size_t dtemplen() const;
+  size_t grpcnt() const;
+  size_t grpgtcnt() const;
+  size_t grplvl() const;
+  size_t taglvl() const;
+  size_t taglen() const;
+  size_t entlvl() const;
+  size_t pilen() const;
+  Char space() const;
+
+  void setStandardFunction(StandardFunction, Char);
+  void enterStandardFunctionNames();
+  void addFunctionChar(const StringC &, FunctionClass, Char);
+  void setNamecaseGeneral(Boolean);
+  void setNamecaseEntity(Boolean);
+  void setDelimGeneral(int, const StringC &);
+  void addDelimShortref(const StringC &, const CharsetInfo &);
+  void addDelimShortrefs(const ISet<Char> &shortrefChars,
+    const CharsetInfo &charset);
+  void addNameCharacters(const ISet<Char> &);
+  void addNameStartCharacters(const ISet<Char> &);
+  void addSubst(Char lc, Char uc);
+  void addShunchar(Char);
+  void setShuncharControls();
+  void setQuantity(int, Number);
+  void setName(int, const StringC &);
+  void setSgmlChar(const ISet<Char> &);
+  void implySgmlChar(const Sd &);
+
+  void checkSgmlChar(const Sd &,
+       const ::OpenSP:: Syntax *otherSyntax,
+       Boolean invalidUseDocumentCharset,
+       ISet<WideChar> &invalid)
+       const;
+  static int referenceQuantity(Quantity);
+  const XcharMap<unsigned char> &markupScanTable() const;
+  Boolean multicode() const;
+  void addEntity(const StringC &, Char);
+  size_t nEntities() const;
+  const StringC &entityName(size_t) const;
+  Char entityChar(size_t) const;
+private:
+  void subst(Char, Char);
+  void checkUnivControlChar(UnivChar univChar,
+       const CharsetInfo &docCharset,
+       const ::OpenSP:: Syntax *otherSyntax,
+       ISet<WideChar> &invalid) const;
+
+  ISet<Char> shunchar_;
+  PackedBoolean shuncharControls_;
+  ISet<Char> set_[nSet];
+  Char standardFunction_[3];
+  PackedBoolean standardFunctionValid_[3];
+  Boolean namecaseGeneral_;
+  Boolean namecaseEntity_;
+  StringC delimGeneral_[nDelimGeneral];
+  Vector<StringC> delimShortrefComplex_;
+  ISet<Char> delimShortrefSimple_;
+  StringC names_[nNames];
+  Number quantity_[nQuantity];
+  HashTable<StringC,int> nameTable_;
+  HashTable<StringC,Char> functionTable_;
+  SubstTable upperSubst_;
+  SubstTable identitySubst_;
+  const SubstTable *generalSubst_;
+  const SubstTable *entitySubst_;
+  XcharMap<unsigned char> categoryTable_;
+  Boolean multicode_;
+  XcharMap<unsigned char> markupScanTable_;
+  Boolean hasMarkupScanTable_;
+  Vector<StringC> entityNames_;
+  StringC entityChars_;
+  static const int referenceQuantity_[];
+};
+
+inline Number Syntax::quantity(Quantity q) const
+{
+  return quantity_[q];
+}
+
+inline void Syntax::setQuantity(int i, Number n)
+{
+  quantity_[i] = n;
+}
+
+inline const SubstTable *Syntax::generalSubstTable() const
+{
+  return generalSubst_;
+}
+
+inline const SubstTable *Syntax::entitySubstTable() const
+{
+  return entitySubst_;
+}
+
+inline int Syntax::nDelimShortrefComplex() const
+{
+  return int(delimShortrefComplex_.size());
+}
+
+inline const StringC &Syntax::delimGeneral(int i) const
+{
+  return delimGeneral_[i];
+}
+
+inline const StringC &Syntax::delimShortrefComplex(size_t i) const
+{
+  return delimShortrefComplex_[i];
+}
+
+inline const ISet<Char> &Syntax::delimShortrefSimple() const
+{
+  return delimShortrefSimple_;
+}
+
+inline Boolean Syntax::hasShortrefs() const
+{
+  return delimShortrefComplex_.size() > 0 || !delimShortrefSimple_.isEmpty();
+}
+
+inline Char Syntax::standardFunction(int i) const
+{
+  return standardFunction_[i];
+}
+
+inline Boolean Syntax::getStandardFunction(int i, Char &result) const
+{
+  if (standardFunctionValid_[i]) {
+    result = standardFunction_[i];
+    return 1;
+  }
+  else
+    return 0;
+}
+
+inline const ISet<Char> *Syntax::charSet(int i) const
+{
+  return &set_[i];
+}
+
+inline Boolean Syntax::isNameCharacter(Xchar c) const
+{
+  return categoryTable_[c] >= nameStartCategory;
+}
+
+inline Boolean Syntax::isNameStartCharacter(Xchar c) const
+{
+  return categoryTable_[c] == nameStartCategory;
+}
+
+inline Boolean Syntax::isDigit(Xchar c) const
+{
+  return categoryTable_[c] == digitCategory;
+}
+
+inline Boolean Syntax::isS(Xchar c) const
+{
+  return categoryTable_[c] == sCategory;
+}
+
+inline Boolean Syntax::isB(Xchar c) const
+{
+  return (categoryTable_[c] == sCategory
+   && !(standardFunctionValid_[fRE] && c == standardFunction_[fRE])
+   && !(standardFunctionValid_[fRS] && c == standardFunction_[fRS]));
+}
+
+inline Syntax::Category Syntax::charCategory(Xchar c) const
+{
+  return Category(categoryTable_[c]);
+}
+
+inline Boolean Syntax::isSgmlChar(Xchar c) const
+{
+  return c >= 0 && set_[sgmlChar].contains(Char(c));
+}
+
+inline const StringC &Syntax::reservedName(ReservedName i) const
+{
+  return names_[i];
+}
+
+inline size_t Syntax::attcnt() const
+{
+  return quantity(Syntax::qATTCNT);
+}
+
+inline size_t Syntax::attsplen() const
+{
+  return quantity(Syntax::qATTSPLEN);
+}
+
+inline size_t Syntax::namelen() const
+{
+  return quantity(Syntax::qNAMELEN);
+}
+
+inline size_t Syntax::penamelen() const
+{
+  return quantity(Syntax::qNAMELEN) - delimGeneral(Syntax::dPERO).size();
+}
+
+inline size_t Syntax::litlen() const
+{
+  return quantity(Syntax::qLITLEN);
+}
+
+inline size_t Syntax::normsep() const
+{
+  return quantity(Syntax::qNORMSEP);
+}
+
+inline size_t Syntax::dtemplen() const
+{
+  return quantity(Syntax::qDTEMPLEN);
+}
+
+inline size_t Syntax::grpcnt() const
+{
+  return quantity(Syntax::qGRPCNT);
+}
+
+inline size_t Syntax::grpgtcnt() const
+{
+  return quantity(Syntax::qGRPGTCNT);
+}
+
+inline size_t Syntax::grplvl() const
+{
+  return quantity(Syntax::qGRPLVL);
+}
+
+inline size_t Syntax::taglvl() const
+{
+  return quantity(Syntax::qTAGLVL);
+}
+
+inline size_t Syntax::taglen() const
+{
+  return quantity(Syntax::qTAGLEN);
+}
+
+inline size_t Syntax::entlvl() const
+{
+  return quantity(Syntax::qENTLVL);
+}
+
+inline size_t Syntax::pilen() const
+{
+  return quantity(Syntax::qPILEN);
+}
+
+inline Char Syntax::space() const
+{
+  return standardFunction(Syntax::fSPACE);
+}
+
+inline void Syntax::setSgmlChar(const ISet<Char> &set)
+{
+  set_[sgmlChar] = set;
+}
+
+inline int Syntax::referenceQuantity(Quantity i)
+{
+  return referenceQuantity_[i];
+}
+
+inline void Syntax::setShuncharControls()
+{
+  shuncharControls_ = 1;
+}
+
+inline const XcharMap<unsigned char> &Syntax::markupScanTable() const
+{
+  return markupScanTable_;
+}
+
+inline Boolean Syntax::multicode() const
+{
+  return multicode_;
+}
+
+inline Boolean Syntax::namecaseGeneral() const
+{
+  return namecaseGeneral_;
+}
+
+inline Boolean Syntax::namecaseEntity() const
+{
+  return namecaseEntity_;
+}
+
+inline size_t Syntax::nEntities() const
+{
+  return entityNames_.size();
+}
+
+inline const StringC &Syntax::entityName(size_t i) const
+{
+  return entityNames_[i];
+}
+
+inline Char Syntax::entityChar(size_t i) const
+{
+  return entityChars_[i];
+}
+
+
+}
+# 17 "/usr/include/OpenSP/Sd.h" 2 3 4
+# 1 "/usr/include/OpenSP/CharsetDecl.h" 1 3 4
+
+
+
+
+
+
+#pragma interface
+
+
+
+# 1 "/usr/include/OpenSP/Vector.h" 1 3 4
+# 12 "/usr/include/OpenSP/CharsetDecl.h" 2 3 4
+
+# 1 "/usr/include/OpenSP/ISet.h" 1 3 4
+# 14 "/usr/include/OpenSP/CharsetDecl.h" 2 3 4
+
+
+
+namespace OpenSP {
+
+
+class CharsetDeclRange {
+public:
+  enum Type {
+    number,
+    string,
+    unused
+    };
+  CharsetDeclRange();
+  CharsetDeclRange(WideChar, Number, WideChar);
+  CharsetDeclRange(WideChar, Number);
+  CharsetDeclRange(WideChar, Number, const StringC &);
+  void rangeDeclared(WideChar min, Number count,
+       ISet<WideChar> &declared) const;
+  void usedSet(ISet<Char> &) const;
+  Boolean getCharInfo(WideChar fromChar,
+        CharsetDeclRange::Type &type,
+        Number &n,
+        StringC &str,
+        Number &count) const;
+  void stringToChar(const StringC &str, ISet<WideChar> &to) const;
+  void numberToChar(Number n, ISet<WideChar> &to, Number &count) const;
+private:
+  WideChar descMin_;
+  Number count_;
+  WideChar baseMin_;
+  Type type_;
+  StringC str_;
+};
+
+class CharsetDeclSection {
+public:
+  CharsetDeclSection();
+  void setPublicId(const PublicId &);
+  void addRange(const CharsetDeclRange &);
+  void rangeDeclared(WideChar min, Number count,
+       ISet<WideChar> &declared) const;
+  void usedSet(ISet<Char> &) const;
+  Boolean getCharInfo(WideChar fromChar,
+        const PublicId *&id,
+        CharsetDeclRange::Type &type,
+        Number &n,
+        StringC &str,
+        Number &cout) const;
+  void stringToChar(const StringC &str, ISet<WideChar> &to) const;
+  void numberToChar(const PublicId *id, Number n,
+      ISet<WideChar> &to, Number &count) const;
+private:
+  PublicId baseset_;
+  Vector<CharsetDeclRange> ranges_;
+};
+
+class CharsetDecl {
+public:
+  CharsetDecl();
+  void addSection(const PublicId &);
+  void swap(CharsetDecl &);
+  void clear();
+  void usedSet(ISet<Char> &) const;
+  void declaredSet(ISet<WideChar> &set) const;
+  Boolean charDeclared(WideChar) const;
+  void rangeDeclared(WideChar min, Number count,
+       ISet<WideChar> &declared) const;
+  void addRange(WideChar, Number, WideChar);
+  void addRange(WideChar, Number);
+  void addRange(WideChar, Number, const StringC &);
+  Boolean getCharInfo(WideChar fromChar,
+        const PublicId *&id,
+        CharsetDeclRange::Type &type,
+        Number &n,
+        StringC &str) const;
+  Boolean getCharInfo(WideChar fromChar,
+        const PublicId *&id,
+        CharsetDeclRange::Type &type,
+        Number &n,
+        StringC &str,
+        Number &count) const;
+  void stringToChar(const StringC &str, ISet<WideChar> &to) const;
+  void numberToChar(const PublicId *id, Number n,
+      ISet<WideChar> &to, Number &count) const;
+  void numberToChar(const PublicId *id, Number n, ISet<WideChar> &to) const;
+private:
+  Vector<CharsetDeclSection> sections_;
+  ISet<WideChar> declaredSet_;
+};
+
+inline
+Boolean CharsetDecl::getCharInfo(WideChar fromChar,
+     const PublicId *&id,
+     CharsetDeclRange::Type &type,
+     Number &n,
+     StringC &str) const
+{
+  Number tem;
+  return getCharInfo(fromChar, id, type, n, str, tem);
+}
+
+inline
+void CharsetDecl::numberToChar(const PublicId *id, Number n,
+          ISet<WideChar> &to) const
+{
+  Number tem;
+  numberToChar(id, n, to, tem);
+}
+
+inline
+void CharsetDecl::declaredSet(ISet<WideChar> &set) const
+{
+  set = declaredSet_;
+}
+
+inline
+Boolean CharsetDecl::charDeclared(WideChar c) const
+{
+  return declaredSet_.contains(c);
+}
+
+
+}
+# 18 "/usr/include/OpenSP/Sd.h" 2 3 4
+# 1 "/usr/include/OpenSP/HashTable.h" 1 3 4
+# 19 "/usr/include/OpenSP/Sd.h" 2 3 4
+# 1 "/usr/include/OpenSP/EntityManager.h" 1 3 4
+
+
+
+
+
+
+
+#pragma interface
+
+
+
+
+
+
+# 1 "/usr/include/OpenSP/Ptr.h" 1 3 4
+# 16 "/usr/include/OpenSP/EntityManager.h" 2 3 4
+
+
+
+namespace OpenSP {
+
+
+class Messenger;
+class InputSourceOrigin;
+class CharsetInfo;
+class InputSource;
+
+class EntityManager : public Resource {
+public:
+  enum { mayRewind = 01, maySetDocCharset = 02 };
+  virtual ~EntityManager();
+  virtual Boolean internalCharsetIsDocCharset() const = 0;
+  virtual const CharsetInfo &charset() const = 0;
+  virtual InputSource *open(const StringC &sysid,
+       const CharsetInfo &docCharset,
+       InputSourceOrigin *,
+       unsigned flags,
+       Messenger &) = 0;
+
+
+
+  virtual ConstPtr<EntityCatalog>
+    makeCatalog(StringC &systemId, const CharsetInfo &, Messenger &) = 0;
+};
+
+
+}
+# 20 "/usr/include/OpenSP/Sd.h" 2 3 4
+# 1 "/usr/include/OpenSP/Ptr.h" 1 3 4
+# 21 "/usr/include/OpenSP/Sd.h" 2 3 4
+
+
+
+
+namespace OpenSP {
+
+
+class Sd : public Resource {
+public:
+
+  enum BooleanFeature {
+    fDATATAG,
+    fOMITTAG,
+    fRANK,
+    fSTARTTAGEMPTY,
+    fSTARTTAGUNCLOSED,
+    fENDTAGEMPTY,
+    fENDTAGUNCLOSED,
+    fATTRIBDEFAULT,
+    fATTRIBOMITNAME,
+    fATTRIBVALUE,
+    fEMPTYNRM,
+    fIMPLYDEFATTLIST,
+    fIMPLYDEFDOCTYPE,
+    fIMPLYDEFENTITY,
+    fIMPLYDEFNOTATION,
+    fIMPLICIT,
+    fFORMAL,
+    fURN,
+    fKEEPRSRE
+    };
+  enum {
+    nBooleanFeature = fKEEPRSRE + 1,
+    fSHORTTAG_FIRST = fSTARTTAGEMPTY,
+    fSHORTTAG_LAST = fATTRIBVALUE
+  };
+
+  enum NumberFeature {
+    fSIMPLE,
+    fEXPLICIT,
+    fCONCUR,
+    fSUBDOC
+  };
+  enum { nNumberFeature = fSUBDOC + 1 };
+  enum NetEnable {
+    netEnableNo,
+    netEnableImmednet,
+    netEnableAll
+  };
+  enum EntityRef {
+    entityRefAny,
+    entityRefInternal,
+    entityRefNone
+  };
+  enum ImplydefElement {
+    implydefElementNo,
+    implydefElementYes,
+    implydefElementAnyother
+  };
+
+  enum ReservedName {
+    rALL,
+    rANY,
+    rANYOTHER,
+    rAPPINFO,
+    rATTLIST,
+    rATTRIB,
+    rBASESET,
+    rCAPACITY,
+    rCHARSET,
+    rCONCUR,
+    rCONTROLS,
+    rDATATAG,
+    rDEFAULT,
+    rDELIM,
+    rDESCSET,
+    rDOCTYPE,
+    rDOCUMENT,
+    rELEMENT,
+    rEMPTY,
+    rEMPTYNRM,
+    rENDTAG,
+    rENTITIES,
+    rENTITY,
+    rEXPLICIT,
+    rFEATURES,
+    rFORMAL,
+    rFUNCHAR,
+    rFUNCTION,
+    rGENERAL,
+    rIMMEDNET,
+    rIMPLICIT,
+    rIMPLYDEF,
+    rINSTANCE,
+    rINTEGRAL,
+    rINTERNAL,
+    rKEEPRSRE,
+    rLCNMCHAR,
+    rLCNMSTRT,
+    rLINK,
+    rMINIMIZE,
+    rMSICHAR,
+    rMSOCHAR,
+    rMSSCHAR,
+    rNAMECASE,
+    rNAMECHAR,
+    rNAMES,
+    rNAMESTRT,
+    rNAMING,
+    rNETENABL,
+    rNO,
+    rNOASSERT,
+    rNONE,
+    rNOTATION,
+    rOMITNAME,
+    rOMITTAG,
+    rOTHER,
+    rPUBLIC,
+    rQUANTITY,
+    rRANK,
+    rRE,
+    rREF,
+    rRS,
+    rSCOPE,
+    rSEEALSO,
+    rSEPCHAR,
+    rSGML,
+    rSGMLREF,
+    rSHORTREF,
+    rSHORTTAG,
+    rSHUNCHAR,
+    rSIMPLE,
+    rSPACE,
+    rSTARTTAG,
+    rSUBDOC,
+    rSWITCHES,
+    rSYNTAX,
+    rSYSTEM,
+    rTYPE,
+    rUCNMCHAR,
+    rUCNMSTRT,
+    rUNCLOSED,
+    rUNUSED,
+    rURN,
+    rVALIDITY,
+    rVALUE,
+    rYES
+  };
+  enum Capacity {
+    TOTALCAP,
+    ENTCAP,
+    ENTCHCAP,
+    ELEMCAP,
+    GRPCAP,
+    EXGRPCAP,
+    EXNMCAP,
+    ATTCAP,
+    ATTCHCAP,
+    AVGRPCAP,
+    NOTCAP,
+    NOTCHCAP,
+    IDCAP,
+    IDREFCAP,
+    MAPCAP,
+    LKSETCAP,
+    LKNMCAP
+  };
+  enum { nCapacity = LKNMCAP + 1 };
+  Sd(const Ptr<EntityManager> &);
+  void setDocCharsetDesc(const UnivCharsetDesc &);
+  Boolean matchesReservedName(const StringC &, ReservedName) const;
+  int digitWeight(Char) const;
+  int hexDigitWeight(Char) const;
+  Boolean link() const;
+  Number simpleLink() const;
+  Boolean implicitLink() const;
+  Number explicitLink() const;
+  Boolean startTagEmpty() const;
+  Boolean startTagUnclosed() const;
+  NetEnable startTagNetEnable() const;
+  void setStartTagNetEnable(NetEnable);
+  Boolean endTagEmpty() const;
+  Boolean endTagUnclosed() const;
+  Boolean attributeDefault() const;
+  Boolean attributeValueNotLiteral() const;
+  Boolean attributeOmitName() const;
+  Boolean emptyElementNormal() const;
+  Boolean implydefAttlist() const;
+  Boolean implydefDoctype() const;
+  ImplydefElement implydefElement() const;
+  void setImplydefElement(ImplydefElement);
+  Boolean implydefEntity() const;
+  Boolean implydefNotation() const;
+  Number concur() const;
+  Boolean omittag() const;
+  Boolean rank() const;
+  Boolean datatag() const;
+  Boolean formal() const;
+  Boolean urn() const;
+  Boolean keeprsre() const;
+  Number subdoc() const;
+  StringC reservedName(int) const;
+  Boolean lookupQuantityName(const StringC &, Syntax::Quantity &) const;
+  Boolean lookupGeneralDelimiterName(const StringC &, Syntax::DelimGeneral &)
+       const;
+  Boolean lookupCapacityName(const StringC &, Sd::Capacity &) const;
+  StringC quantityName(Syntax::Quantity) const;
+  Boolean internalCharsetIsDocCharset() const;
+  const CharsetInfo &internalCharset() const;
+  const CharsetInfo &docCharset() const;
+  Char execToInternal(char) const;
+  StringC execToInternal(const char *) const;
+  Number capacity(int) const;
+  void setCapacity(int, Number);
+  StringC capacityName(int) const;
+  Boolean scopeInstance() const;
+  void setScopeInstance();
+  void setDocCharsetDecl(CharsetDecl &);
+  const CharsetDecl &docCharsetDecl() const;
+  void setBooleanFeature(BooleanFeature, Boolean);
+  void setShorttag(Boolean);
+  void setNumberFeature(NumberFeature, Number);
+  StringC generalDelimiterName(Syntax::DelimGeneral) const;
+  UnivChar nameToUniv(const StringC &);
+  Boolean www() const;
+  void setWww(Boolean);
+  EntityRef entityRef() const;
+  void setEntityRef(EntityRef);
+  Boolean typeValid() const;
+  void setTypeValid(Boolean);
+  Boolean integrallyStored() const;
+  void setIntegrallyStored(Boolean);
+private:
+  PackedBoolean booleanFeature_[nBooleanFeature];
+  Number numberFeature_[nNumberFeature];
+  Number capacity_[nCapacity];
+  PackedBoolean internalCharsetIsDocCharset_;
+
+  const CharsetInfo *internalCharsetPtr_;
+  CharsetInfo docCharset_;
+  CharsetDecl docCharsetDecl_;
+  Boolean scopeInstance_;
+  Boolean www_;
+  NetEnable netEnable_;
+  EntityRef entityRef_;
+  ImplydefElement implydefElement_;
+  Boolean typeValid_;
+  Boolean integrallyStored_;
+  HashTable<StringC,int> namedCharTable_;
+  Ptr<EntityManager> entityManager_;
+  static const char *const reservedName_[];
+  static const char *const generalDelimiterName_[];
+  static const char *const capacityName_[];
+  static const char *const quantityName_[];
+};
+
+inline
+Boolean Sd::link() const
+{
+  return (numberFeature_[fSIMPLE]
+   || booleanFeature_[fIMPLICIT]
+   || numberFeature_[fEXPLICIT]);
+}
+
+inline
+Number Sd::explicitLink() const
+{
+  return numberFeature_[fEXPLICIT];
+}
+
+inline
+Boolean Sd::implicitLink() const
+{
+  return booleanFeature_[fIMPLICIT];
+}
+
+inline
+Number Sd::simpleLink() const
+{
+  return numberFeature_[fSIMPLE];
+}
+
+inline
+Boolean Sd::startTagEmpty() const
+{
+  return booleanFeature_[fSTARTTAGEMPTY];
+}
+
+inline
+Boolean Sd::startTagUnclosed() const
+{
+  return booleanFeature_[fSTARTTAGUNCLOSED];
+}
+
+inline
+Sd::NetEnable Sd::startTagNetEnable() const
+{
+  return netEnable_;
+}
+
+inline
+void Sd::setStartTagNetEnable(NetEnable e)
+{
+  netEnable_ = e;
+}
+
+inline
+Boolean Sd::endTagEmpty() const
+{
+  return booleanFeature_[fENDTAGEMPTY];
+}
+
+inline
+Boolean Sd::endTagUnclosed() const
+{
+  return booleanFeature_[fENDTAGUNCLOSED];
+}
+
+inline
+Boolean Sd::attributeDefault() const
+{
+  return booleanFeature_[fATTRIBDEFAULT];
+}
+
+inline
+Boolean Sd::attributeValueNotLiteral() const
+{
+  return booleanFeature_[fATTRIBVALUE];
+}
+
+inline
+Boolean Sd::attributeOmitName() const
+{
+  return booleanFeature_[fATTRIBOMITNAME];
+}
+
+inline
+Boolean Sd::emptyElementNormal() const
+{
+  return booleanFeature_[fEMPTYNRM];
+}
+
+inline
+Boolean Sd::implydefAttlist() const
+{
+  return booleanFeature_[fIMPLYDEFATTLIST];
+}
+
+inline
+Boolean Sd::implydefDoctype() const
+{
+  return booleanFeature_[fIMPLYDEFDOCTYPE];
+}
+
+inline
+Sd::ImplydefElement Sd::implydefElement() const
+{
+  return implydefElement_;
+}
+
+inline
+void Sd::setImplydefElement(ImplydefElement i)
+{
+  implydefElement_ = i;
+}
+
+inline
+Boolean Sd::implydefEntity() const
+{
+  return booleanFeature_[fIMPLYDEFENTITY];
+}
+
+inline
+Boolean Sd::implydefNotation() const
+{
+  return booleanFeature_[fIMPLYDEFNOTATION];
+}
+
+inline
+Number Sd::concur() const
+{
+  return numberFeature_[fCONCUR];
+}
+
+inline
+Number Sd::subdoc() const
+{
+  return numberFeature_[fSUBDOC];
+}
+
+
+inline
+Boolean Sd::omittag() const
+{
+  return booleanFeature_[fOMITTAG];
+}
+
+inline
+Boolean Sd::rank() const
+{
+  return booleanFeature_[fRANK];
+}
+
+inline
+Boolean Sd::datatag() const
+{
+  return booleanFeature_[fDATATAG];
+}
+
+inline
+Boolean Sd::formal() const
+{
+  return booleanFeature_[fFORMAL];
+}
+
+inline
+Boolean Sd::urn() const
+{
+  return booleanFeature_[fURN];
+}
+
+inline
+Boolean Sd::keeprsre() const
+{
+  return booleanFeature_[fKEEPRSRE];
+}
+
+inline
+const CharsetInfo &Sd::internalCharset() const
+{
+  return internalCharsetPtr_ ? *internalCharsetPtr_ : docCharset_;
+}
+
+inline
+Char Sd::execToInternal(char c) const
+{
+  return internalCharset().execToDesc(c);
+}
+
+inline
+StringC Sd::execToInternal(const char *s) const
+{
+  return internalCharset().execToDesc(s);
+}
+
+inline
+StringC Sd::reservedName(int i) const
+{
+  return execToInternal(reservedName_[i]);
+}
+
+inline
+Boolean Sd::internalCharsetIsDocCharset() const
+{
+  return internalCharsetIsDocCharset_;
+}
+
+inline
+const CharsetInfo &Sd::docCharset() const
+{
+  return docCharset_;
+}
+
+inline
+int Sd::digitWeight(Char c) const
+{
+  return internalCharset().digitWeight(c);
+}
+
+inline
+int Sd::hexDigitWeight(Char c) const
+{
+  return internalCharset().hexDigitWeight(c);
+}
+
+inline
+Number Sd::capacity(int i) const
+{
+  return capacity_[i];
+}
+
+inline
+void Sd::setCapacity(int i, Number n)
+{
+  capacity_[i] = n;
+}
+
+inline
+StringC Sd::capacityName(int i) const
+{
+  return execToInternal(capacityName_[i]);
+}
+
+inline
+Boolean Sd::scopeInstance() const
+{
+  return scopeInstance_;
+}
+
+inline
+void Sd::setScopeInstance()
+{
+  scopeInstance_ = 1;
+}
+
+inline
+void Sd::setDocCharsetDecl(CharsetDecl &decl)
+{
+  decl.swap(docCharsetDecl_);
+}
+
+inline
+const CharsetDecl &Sd::docCharsetDecl() const
+{
+  return docCharsetDecl_;
+}
+
+inline
+void Sd::setBooleanFeature(BooleanFeature i, Boolean b)
+{
+  booleanFeature_[i] = b;
+}
+
+inline
+void Sd::setNumberFeature(NumberFeature i, Number n)
+{
+  numberFeature_[i] = n;
+}
+
+inline
+Boolean Sd::www() const
+{
+  return www_;
+}
+
+inline
+void Sd::setWww(Boolean b)
+{
+  www_ = b;
+}
+
+inline
+Sd::EntityRef Sd::entityRef() const
+{
+  return entityRef_;
+}
+
+inline
+void Sd::setEntityRef(EntityRef r)
+{
+  entityRef_ = r;
+}
+
+inline
+Boolean Sd::typeValid() const
+{
+  return typeValid_;
+}
+
+inline
+void Sd::setTypeValid(Boolean b)
+{
+  typeValid_ = b;
+}
+
+inline
+Boolean Sd::integrallyStored() const
+{
+  return integrallyStored_;
+}
+
+inline
+void Sd::setIntegrallyStored(Boolean b)
+{
+  integrallyStored_ = b;
+}
+
+
+}
+# 21 "/usr/include/OpenSP/Event.h" 2 3 4
+
+# 1 "/usr/include/OpenSP/Dtd.h" 1 3 4
+
+
+
+
+
+
+#pragma interface
+
+
+# 1 "/usr/include/OpenSP/NamedTable.h" 1 3 4
+# 10 "/usr/include/OpenSP/NamedTable.h" 3 4
+# 1 "/usr/include/OpenSP/OwnerTable.h" 1 3 4
+# 11 "/usr/include/OpenSP/NamedTable.h" 2 3 4
+
+
+namespace OpenSP {
+
+
+class NamedTableKeyFunction {
+public:
+  static inline const StringC &key(const Named &obj) { return obj.name(); }
+};
+
+template<class T> class NamedTableIter;
+template<class T> class ConstNamedTableIter;
+
+template<class T>
+class NamedTable {
+public:
+  NamedTable() { }
+  T *insert(T *p) { return (T *)table_.insert(p); }
+  T *lookup(const StringC &str) const { return (T *)table_.lookup(str); }
+  T *remove(const StringC &str) { return (T *)table_.remove(str); }
+  size_t count() const { return table_.count(); }
+  void clear() { table_.clear(); }
+  void swap(NamedTable<T> &to) { table_.swap(to.table_); }
+private:
+  NamedTable(const NamedTable<T> &);
+  void operator=(const NamedTable<T> &);
+  OwnerTable<Named, StringC, Hash, NamedTableKeyFunction>
+    table_;
+  friend class NamedTableIter<T>;
+  friend class ConstNamedTableIter<T>;
+};
+
+template<class T>
+class NamedTableIter {
+public:
+  NamedTableIter(const NamedTable<T> &table) : iter_(table.table_) { }
+  T *next() { return (T *)iter_.next(); }
+private:
+  OwnerTableIter<Named, StringC, Hash, NamedTableKeyFunction> iter_;
+};
+
+template<class T>
+class ConstNamedTableIter {
+public:
+  ConstNamedTableIter(const NamedTable<T> &table) : iter_(table.table_) { }
+  const T *next() { return (T *)iter_.next(); }
+private:
+  OwnerTableIter<Named, StringC, Hash, NamedTableKeyFunction> iter_;
+};
+
+
+}
+# 11 "/usr/include/OpenSP/Dtd.h" 2 3 4
+# 1 "/usr/include/OpenSP/NamedResourceTable.h" 1 3 4
+
+
+
+
+
+
+
+# 1 "/usr/include/OpenSP/PointerTable.h" 1 3 4
+# 9 "/usr/include/OpenSP/NamedResourceTable.h" 2 3 4
+
+
+# 1 "/usr/include/OpenSP/Ptr.h" 1 3 4
+# 12 "/usr/include/OpenSP/NamedResourceTable.h" 2 3 4
+
+
+namespace OpenSP {
+
+
+struct NamedResourceKeyFunction {
+  static inline
+    const StringC &key(const NamedResource &p) {
+      return p.name();
+    }
+};
+
+template<class T> class NamedResourceTableIter;
+template<class T> class ConstNamedResourceTableIter;
+
+template<class T>
+class NamedResourceTable {
+
+
+
+
+
+public:
+  NamedResourceTable() { }
+  Ptr<T> insert(const Ptr<T> &p, Boolean replace = 0) {
+    return (T *)table_.insert((NamedResource *)p.pointer(), replace).pointer();
+  }
+  Ptr<T> lookup(const StringC &str) const {
+    return (T *)table_.lookup(str).pointer();
+  }
+  ConstPtr<T> lookupConst(const StringC &str) const {
+    return (T *)table_.lookup(str).pointer();
+  }
+  const T *lookupTemp(const StringC &str) const {
+    return (const T *)table_.lookup(str).pointer();
+  }
+  Ptr<T> remove(const StringC &str) {
+    return (T *)table_.remove(str).pointer();
+  }
+  size_t count() const { return table_.count(); }
+  void clear() { table_.clear(); }
+  void swap(NamedResourceTable<T> &to) { table_.swap(to.table_); }
+private:
+  PointerTable<Ptr<NamedResource>, StringC, Hash,
+        NamedResourceKeyFunction> table_;
+  friend class NamedResourceTableIter<T>;
+  friend class ConstNamedResourceTableIter<T>;
+};
+
+template<class T>
+class NamedResourceTableIter {
+public:
+  NamedResourceTableIter(const NamedResourceTable<T> &table)
+  : iter_(table.table_) { }
+  Ptr<T> next() {
+    return (T *)iter_.next().pointer();
+  }
+private:
+  PointerTableIter<Ptr<NamedResource>, StringC, Hash,
+                   NamedResourceKeyFunction> iter_;
+};
+
+template<class T>
+class ConstNamedResourceTableIter {
+public:
+  ConstNamedResourceTableIter(const NamedResourceTable<T> &table)
+  : iter_(table.table_) { }
+  ConstPtr<T> next() {
+    return (T *)iter_.next().pointer();
+  }
+  const T *nextTemp() {
+    return (const T *)iter_.next().pointer();
+  }
+private:
+  PointerTableIter<Ptr<NamedResource>, StringC, Hash,
+                   NamedResourceKeyFunction> iter_;
+};
+
+
+}
+# 12 "/usr/include/OpenSP/Dtd.h" 2 3 4
+# 1 "/usr/include/OpenSP/ElementType.h" 1 3 4
+
+
+
+
+
+
+#pragma interface
+
+
+# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
+# 11 "/usr/include/OpenSP/ElementType.h" 2 3 4
+
+# 1 "/usr/include/OpenSP/Vector.h" 1 3 4
+# 13 "/usr/include/OpenSP/ElementType.h" 2 3 4
+# 1 "/usr/include/OpenSP/Owner.h" 1 3 4
+# 14 "/usr/include/OpenSP/ElementType.h" 2 3 4
+
+# 1 "/usr/include/OpenSP/Ptr.h" 1 3 4
+# 16 "/usr/include/OpenSP/ElementType.h" 2 3 4
+
+# 1 "/usr/include/OpenSP/Vector.h" 1 3 4
+# 18 "/usr/include/OpenSP/ElementType.h" 2 3 4
+
+# 1 "/usr/include/OpenSP/Mode.h" 1 3 4
+
+
+
+
+
+
+
+namespace OpenSP {
+
+
+enum Mode {
+  grpMode,
+  alitMode,
+  alitaMode,
+  aliteMode,
+  talitMode,
+  talitaMode,
+  taliteMode,
+  mdMode,
+  mdMinusMode,
+  mdPeroMode,
+  sdMode,
+  comMode,
+  sdcomMode,
+  piMode,
+  refMode,
+  imsMode,
+  cmsMode,
+  rcmsMode,
+
+  proMode,
+  dsMode,
+
+  dsiMode,
+
+  plitMode,
+  plitaMode,
+  pliteMode,
+  sdplitMode,
+
+  sdplitaMode,
+
+  grpsufMode,
+  mlitMode,
+  mlitaMode,
+  asMode,
+  piPasMode,
+  slitMode,
+  slitaMode,
+  sdslitMode,
+
+  sdslitaMode,
+
+
+  cconMode,
+  rcconMode,
+  cconnetMode,
+  rcconnetMode,
+  rcconeMode,
+  tagMode,
+  econMode,
+  mconMode,
+  econnetMode,
+  mconnetMode
+  };
+
+const int nModes = mconnetMode + 1;
+
+const int minShortrefMode = econMode;
+
+
+}
+# 20 "/usr/include/OpenSP/ElementType.h" 2 3 4
+# 1 "/usr/include/OpenSP/ContentToken.h" 1 3 4
+
+
+
+
+
+
+#pragma interface
+
+
+# 1 "/usr/include/OpenSP/Owner.h" 1 3 4
+# 11 "/usr/include/OpenSP/ContentToken.h" 2 3 4
+
+# 1 "/usr/include/OpenSP/Vector.h" 1 3 4
+# 13 "/usr/include/OpenSP/ContentToken.h" 2 3 4
+# 1 "/usr/include/OpenSP/NCVector.h" 1 3 4
+# 12 "/usr/include/OpenSP/NCVector.h" 3 4
+# 1 "/usr/include/OpenSP/Vector.h" 1 3 4
+
+
+
+
+
+
+# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
+# 8 "/usr/include/OpenSP/Vector.h" 2 3 4
+
+
+
+
+
+
+
+namespace OpenSP {
+
+
+template<class T>
+class NCVector {
+public:
+  typedef size_t size_type;
+  typedef T *iterator;
+  typedef const T *const_iterator;
+  NCVector() : ptr_(0), size_(0), alloc_(0) { }
+  NCVector(size_t n) : ptr_(0), size_(0), alloc_(0) { append(n); }
+  virtual ~NCVector();
+  void resize(size_t n) {
+    if (n < size_)
+      erase(ptr_ + n, ptr_ + size_);
+    else if (n > size_)
+      append(n - size_);
+  }
+# 46 "/usr/include/OpenSP/Vector.h" 3 4
+  void swap(NCVector<T> &);
+  void clear() { erase(ptr_, ptr_ + size_); }
+  size_t size() const { return size_; }
+  T &operator[](size_t i) { return ptr_[i]; }
+  const T &operator[](size_t i) const { return ptr_[i]; }
+  iterator begin() { return ptr_; }
+  const_iterator begin() const { return ptr_; }
+  T &back() { return ptr_[size_ - 1]; }
+  const T &back() const { return ptr_[size_ - 1]; }
+  void reserve(size_t n) { if (n > alloc_) reserve1(n); }
+  iterator erase(const_iterator, const_iterator);
+private:
+
+  NCVector(const NCVector<T> &);
+  void operator=(const NCVector<T> &);
+
+  void append(size_t);
+  void reserve1(size_t);
+
+  size_t size_;
+  T *ptr_;
+  size_t alloc_;
+};
+
+
+}
+# 13 "/usr/include/OpenSP/NCVector.h" 2 3 4
+# 48 "/usr/include/OpenSP/NCVector.h" 3 4
+# 1 "/usr/include/OpenSP/Vector.cxx" 1 3 4
+
+
+
+
+
+
+# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
+# 8 "/usr/include/OpenSP/Vector.cxx" 2 3 4
+
+
+
+namespace OpenSP {
+
+
+template<class T>
+NCVector<T>::~NCVector()
+{
+  if (ptr_) {
+    erase(ptr_, ptr_ + size_);
+    ::operator delete((void *)ptr_);
+  }
+}
+# 99 "/usr/include/OpenSP/Vector.cxx" 3 4
+template<class T>
+void NCVector<T>::swap(NCVector<T> &v)
+{
+  {
+    T *tem = ptr_;
+    ptr_ = v.ptr_;
+    v.ptr_ = tem;
+  }
+  {
+    size_t tem = size_;
+    size_ = v.size_;
+    v.size_ = tem;
+  }
+  {
+    size_t tem = alloc_;
+    alloc_ = v.alloc_;
+    v.alloc_ = tem;
+  }
+}
+
+template<class T>
+void NCVector<T>::append(size_t n)
+{
+  reserve(size_ + n);
+  while (n-- > 0)
+    (void)new (ptr_ + size_++) T;
+}
+
+template<class T>
+T *NCVector<T>::erase(const T *p1, const T *p2)
+{
+  typedef T X;
+  for (const T *p = p1; p != p2; p++)
+    ((X *)p)->~X();
+  if (p2 != ptr_ + size_)
+    memmove((T *)p1, p2, ((const T *)(ptr_ + size_) - p2)*sizeof(T));
+  size_ -= p2 - p1;
+  return (T *)p1;
+}
+
+template<class T>
+void NCVector<T>::reserve1(size_t size)
+{
+
+
+  size_t newAlloc = alloc_*2;
+  if (size > newAlloc)
+    newAlloc += size;
+  void *p = ::operator new(newAlloc * sizeof(T));
+  alloc_ = newAlloc;
+  if (ptr_) {
+    memcpy(p, ptr_, size_*sizeof(T));
+    ::operator delete((void *)ptr_);
+  }
+  ptr_ = (T *)p;
+}
+
+
+}
+# 49 "/usr/include/OpenSP/NCVector.h" 2 3 4
+# 14 "/usr/include/OpenSP/ContentToken.h" 2 3 4
+
+
+
+namespace OpenSP {
+
+
+class LeafContentToken;
+
+struct Transition {
+  enum { invalidIndex = -1 };
+
+  unsigned clearAndStateStartIndex;
+
+
+
+  unsigned andDepth;
+
+
+
+
+  PackedBoolean isolated;
+
+
+  unsigned requireClear;
+
+  unsigned toSet;
+};
+
+class FirstSet {
+public:
+  FirstSet();
+  void init(LeafContentToken *);
+  void append(const FirstSet &);
+  size_t size() const;
+  LeafContentToken *token(size_t i) const;
+  size_t requiredIndex() const;
+  void setNotRequired();
+private:
+  Vector<LeafContentToken *> v_;
+
+  size_t requiredIndex_;
+};
+
+class LastSet : public Vector<LeafContentToken *> {
+public:
+  LastSet() { }
+  LastSet(size_t n) : Vector<LeafContentToken *>(n) { }
+  void append(const LastSet &);
+};
+
+class ElementType;
+class AndModelGroup;
+struct GroupInfo;
+
+struct ContentModelAmbiguity {
+  const LeafContentToken *from;
+  const LeafContentToken *to1;
+  const LeafContentToken *to2;
+  unsigned andDepth;
+};
+
+class ModelGroup;
+
+class ContentToken {
+public:
+  enum OccurrenceIndicator { none = 0, opt = 01, plus = 02, rep = 03 };
+  ContentToken(OccurrenceIndicator);
+  virtual ~ContentToken();
+  OccurrenceIndicator occurrenceIndicator() const;
+  Boolean inherentlyOptional() const;
+  static unsigned andDepth(const AndModelGroup *);
+  static unsigned andIndex(const AndModelGroup *);
+  void analyze(GroupInfo &, const AndModelGroup *, unsigned,
+        FirstSet &, LastSet &);
+  static void addTransitions(const LastSet &from,
+        const FirstSet &to,
+        Boolean maybeRequired,
+        unsigned andClearIndex,
+        unsigned andDepth,
+        Boolean isolated = 0,
+        unsigned requireClear
+          = (unsigned)Transition::invalidIndex,
+        unsigned toSet
+          = (unsigned)Transition::invalidIndex);
+  virtual void finish(Vector<unsigned> &minAndDepth,
+        Vector<size_t> &elementTransition,
+        Vector<ContentModelAmbiguity> &,
+        Boolean &pcdataUnreachable) = 0;
+  virtual unsigned long grpgtcnt() const;
+  virtual void setOrGroupMember();
+  unsigned andGroupIndex() const;
+  virtual const ModelGroup *asModelGroup() const;
+  virtual const LeafContentToken *asLeafContentToken() const;
+protected:
+  PackedBoolean inherentlyOptional_;
+private:
+  ContentToken(const ContentToken &);
+  void operator=(const ContentToken &);
+  virtual void analyze1(GroupInfo &, const AndModelGroup *, unsigned,
+   FirstSet &, LastSet &) = 0;
+  OccurrenceIndicator occurrenceIndicator_;
+};
+
+class ModelGroup : public ContentToken {
+public:
+  enum Connector { andConnector, orConnector, seqConnector };
+  ModelGroup(NCVector<Owner<ContentToken> > &, OccurrenceIndicator);
+  virtual Connector connector() const = 0;
+  unsigned nMembers() const;
+  void finish(Vector<unsigned> &minAndDepth,
+       Vector<size_t> &elementTransition,
+       Vector<ContentModelAmbiguity> &,
+       Boolean &pcdataUnreachable);
+  ContentToken &member(unsigned i);
+  const ContentToken &member(unsigned i) const;
+  unsigned long grpgtcnt() const;
+  const ModelGroup *asModelGroup() const;
+protected:
+  void setOrGroup();
+private:
+  ModelGroup(const ModelGroup &);
+  void operator=(const ModelGroup &);
+  NCVector<Owner<ContentToken> > members_;
+};
+
+class AndModelGroup : public ModelGroup {
+public:
+  AndModelGroup(NCVector<Owner<ContentToken> > &, OccurrenceIndicator);
+  Connector connector() const;
+  unsigned andDepth() const;
+  unsigned andIndex() const;
+  unsigned andGroupIndex() const;
+  const AndModelGroup *andAncestor() const;
+private:
+  AndModelGroup(const AndModelGroup &);
+  void operator=(const AndModelGroup &);
+  unsigned andDepth_;
+  unsigned andIndex_;
+  unsigned andGroupIndex_;
+  const AndModelGroup *andAncestor_;
+  void analyze1(GroupInfo &, const AndModelGroup *, unsigned,
+  FirstSet &, LastSet &);
+};
+
+class OrModelGroup : public ModelGroup {
+public:
+  OrModelGroup(NCVector<Owner<ContentToken> > &, OccurrenceIndicator);
+  Connector connector() const;
+private:
+  OrModelGroup(const OrModelGroup &);
+  void operator=(const OrModelGroup &);
+  void analyze1(GroupInfo &, const AndModelGroup *, unsigned,
+  FirstSet &, LastSet &);
+};
+
+class SeqModelGroup : public ModelGroup {
+public:
+  SeqModelGroup(NCVector<Owner<ContentToken> > &, OccurrenceIndicator);
+  Connector connector() const;
+private:
+  SeqModelGroup(const SeqModelGroup &);
+  void operator=(const SeqModelGroup &);
+  void analyze1(GroupInfo &, const AndModelGroup *, unsigned,
+  FirstSet &, LastSet &);
+};
+
+class AndState;
+
+class AndInfo {
+public:
+  AndInfo() { }
+  const AndModelGroup *andAncestor;
+  unsigned andGroupIndex;
+  Vector<Transition> follow;
+private:
+  AndInfo(const AndInfo &);
+  void operator=(const AndInfo &);
+};
+
+
+
+
+class LeafContentToken : public ContentToken {
+public:
+  LeafContentToken(const ElementType *, OccurrenceIndicator);
+  unsigned index() const;
+  unsigned typeIndex() const;
+  const ElementType *elementType() const;
+  virtual Boolean isInitial() const;
+  void addTransitions(const FirstSet &to,
+        Boolean maybeRequired,
+        unsigned andClearIndex,
+        unsigned andDepth,
+        Boolean isolated,
+        unsigned requireClear,
+        unsigned toSet);
+  void setFinal();
+  void finish(Vector<unsigned> &minAndDepth,
+       Vector<size_t> &elementTransition,
+       Vector<ContentModelAmbiguity> &,
+       Boolean &pcdataUnreachable);
+  Boolean isFinal() const;
+  Boolean tryTransition(const ElementType *, AndState &,
+   unsigned &minAndDepth,
+   const LeafContentToken *&newpos) const;
+  Boolean tryTransitionPcdata(AndState &, unsigned &minAndDepth,
+         const LeafContentToken *&newpos) const;
+  void possibleTransitions(const AndState &, unsigned minAndDepth, Vector<const ElementType *> &) const;
+  const LeafContentToken *impliedStartTag(const AndState &andpos,
+       unsigned minAndDepth) const;
+  const LeafContentToken *transitionToken(const ElementType *to,
+       const AndState &andState,
+       unsigned minAndDepth) const;
+  void doRequiredTransition(AndState &andState,
+       unsigned &minAndDepth,
+       const LeafContentToken *&newpos) const;
+  unsigned computeMinAndDepth(const AndState&) const;
+  Boolean orGroupMember() const;
+  void setOrGroupMember();
+  const AndModelGroup *andAncestor() const;
+  unsigned andDepth() const;
+  const LeafContentToken *asLeafContentToken() const;
+protected:
+  void analyze1(GroupInfo &, const AndModelGroup *, unsigned,
+  FirstSet &, LastSet &);
+  const ElementType *element_;
+private:
+  LeafContentToken(const LeafContentToken &);
+  void operator=(const LeafContentToken &);
+  void andFinish(Vector<unsigned> &minAndDepth,
+   Vector<size_t> &elementTransition,
+   Vector<ContentModelAmbiguity> &,
+   Boolean &pcdataUnreachable);
+  unsigned computeMinAndDepth1(const AndState&) const;
+  unsigned leafIndex_;
+  unsigned typeIndex_;
+  Vector<LeafContentToken *> follow_;
+  PackedBoolean isFinal_;
+  PackedBoolean orGroupMember_;
+
+  char pcdataTransitionType_;
+  const LeafContentToken *simplePcdataTransition_;
+  size_t requiredIndex_;
+  Owner<AndInfo> andInfo_;
+};
+
+class PcdataToken : public LeafContentToken {
+public:
+  PcdataToken();
+  void analyze1(GroupInfo &, const AndModelGroup *, unsigned,
+  FirstSet &, LastSet &);
+private:
+  PcdataToken(const PcdataToken &);
+  void operator=(const PcdataToken &);
+};
+
+class InitialPseudoToken : public LeafContentToken {
+public:
+  InitialPseudoToken();
+  Boolean isInitial() const;
+private:
+  InitialPseudoToken(const InitialPseudoToken &);
+  void operator=(const InitialPseudoToken &);
+};
+
+class ElementToken : public LeafContentToken {
+public:
+  ElementToken(const ElementType *, OccurrenceIndicator);
+private:
+  ElementToken(const ElementToken &);
+  void operator=(const ElementToken &);
+};
+
+class DataTagGroup : public SeqModelGroup {
+public:
+
+  DataTagGroup(NCVector<Owner<ContentToken> > &, OccurrenceIndicator);
+private:
+  DataTagGroup(const DataTagGroup &);
+  void operator=(const DataTagGroup &);
+};
+
+class DataTagElementToken : public ElementToken {
+public:
+  DataTagElementToken(const ElementType *, Vector<Text> &templates);
+  DataTagElementToken(const ElementType *, Vector<Text> &templates,
+        Text &paddingTemplate);
+private:
+  DataTagElementToken(const DataTagElementToken &);
+  void operator=(const DataTagElementToken &);
+  Vector<Text> templates_;
+  Boolean havePaddingTemplate_;
+  Text paddingTemplate_;
+};
+
+class CompiledModelGroup {
+public:
+  CompiledModelGroup(Owner<ModelGroup> &);
+  void compile(size_t nElementTypeIndex,
+        Vector<ContentModelAmbiguity> &,
+        Boolean &pcdataUnreachable);
+  CompiledModelGroup *copy() const;
+  const LeafContentToken *initial() const;
+  unsigned andStateSize() const;
+  Boolean containsPcdata() const;
+  const ModelGroup *modelGroup() const;
+private:
+  CompiledModelGroup(const CompiledModelGroup &);
+  void operator=(const CompiledModelGroup &);
+  Owner<ModelGroup> modelGroup_;
+  Owner<LeafContentToken> initial_;
+  unsigned andStateSize_;
+  Boolean containsPcdata_;
+};
+
+class AndState {
+public:
+  AndState(unsigned);
+  Boolean isClear(unsigned) const;
+  void clearFrom(unsigned);
+  void set(unsigned);
+  Boolean operator==(const AndState &) const;
+  Boolean operator!=(const AndState &) const;
+private:
+  void clearFrom1(unsigned);
+  unsigned clearFrom_;
+  Vector<PackedBoolean> v_;
+};
+
+class MatchState {
+public:
+  MatchState();
+  MatchState(const CompiledModelGroup *);
+  Boolean tryTransition(const ElementType *);
+  Boolean tryTransitionPcdata();
+  void possibleTransitions(Vector<const ElementType *> &) const;
+  Boolean isFinished() const;
+  const LeafContentToken *impliedStartTag() const;
+  const LeafContentToken *invalidExclusion(const ElementType *) const;
+  void doRequiredTransition();
+  const LeafContentToken *currentPosition() const;
+  Boolean operator==(const MatchState &) const;
+  Boolean operator!=(const MatchState &) const;
+private:
+  const LeafContentToken *pos_;
+  AndState andState_;
+  unsigned minAndDepth_;
+};
+
+inline
+ContentToken::OccurrenceIndicator ContentToken::occurrenceIndicator() const
+{
+  return occurrenceIndicator_;
+}
+
+inline
+unsigned LeafContentToken::index() const
+{
+  return leafIndex_;
+}
+
+inline
+unsigned LeafContentToken::typeIndex() const
+{
+  return typeIndex_;
+}
+
+inline
+Boolean ContentToken::inherentlyOptional() const
+{
+  return inherentlyOptional_;
+}
+
+inline
+const ElementType *LeafContentToken::elementType() const
+{
+  return element_;
+}
+
+inline
+unsigned AndModelGroup::andDepth() const
+{
+  return andDepth_;
+}
+
+inline
+unsigned AndModelGroup::andIndex() const
+{
+  return andIndex_;
+}
+
+inline
+unsigned ModelGroup::nMembers() const
+{
+  return members_.size();
+}
+
+inline
+unsigned ContentToken::andDepth(const AndModelGroup *andAncestor)
+{
+  return andAncestor ? andAncestor->andDepth() + 1 : 0;
+}
+
+inline
+unsigned ContentToken::andIndex(const AndModelGroup *andAncestor)
+{
+  return (andAncestor
+   ? andAncestor->andIndex() + andAncestor->nMembers()
+   : 0);
+}
+
+inline
+ContentToken &ModelGroup::member(unsigned i)
+{
+  return *members_[i];
+}
+
+inline
+const ContentToken &ModelGroup::member(unsigned i) const
+{
+  return *members_[i];
+}
+
+inline
+void LeafContentToken::setFinal()
+{
+  isFinal_ = 1;
+}
+
+inline
+Boolean LeafContentToken::isFinal() const
+{
+  return isFinal_;
+}
+
+inline
+Boolean LeafContentToken::orGroupMember() const
+{
+  return orGroupMember_;
+}
+
+inline
+unsigned CompiledModelGroup::andStateSize() const
+{
+  return andStateSize_;
+}
+
+inline
+Boolean CompiledModelGroup::containsPcdata() const
+{
+  return containsPcdata_;
+}
+
+inline
+const AndModelGroup *AndModelGroup::andAncestor() const
+{
+  return andAncestor_;
+}
+
+inline
+unsigned AndModelGroup::andGroupIndex() const
+{
+  return andGroupIndex_;
+}
+
+inline
+const LeafContentToken *CompiledModelGroup::initial() const
+{
+  return initial_.pointer();
+}
+
+inline
+const ModelGroup *CompiledModelGroup::modelGroup() const
+{
+  return modelGroup_.pointer();
+}
+
+inline
+const AndModelGroup *LeafContentToken::andAncestor() const
+{
+  return andInfo_ ? andInfo_->andAncestor : 0;
+}
+
+inline
+unsigned LeafContentToken::andDepth() const
+{
+  return andInfo_ ? ContentToken::andDepth(andInfo_->andAncestor) : 0;
+}
+
+inline
+unsigned LeafContentToken::computeMinAndDepth(const AndState &andState) const
+{
+  return andInfo_ ? computeMinAndDepth1(andState) : 0;
+}
+
+inline
+Boolean LeafContentToken::tryTransitionPcdata(AndState &andState,
+           unsigned &minAndDepth,
+           const LeafContentToken *&newpos)
+     const
+{
+  if (pcdataTransitionType_ == 1) {
+    newpos = simplePcdataTransition_;
+    return 1;
+  }
+  else if (pcdataTransitionType_ == 0)
+    return 0;
+  else
+    return tryTransition(0, andState, minAndDepth, newpos);
+}
+
+inline
+Boolean MatchState::tryTransition(const ElementType *to)
+{
+  return pos_->tryTransition(to, andState_, minAndDepth_, pos_);
+}
+
+inline
+Boolean MatchState::tryTransitionPcdata()
+{
+  return pos_->tryTransitionPcdata(andState_, minAndDepth_, pos_);
+}
+
+inline
+void MatchState::possibleTransitions(Vector<const ElementType *> &v) const
+{
+  pos_->possibleTransitions(andState_, minAndDepth_, v);
+}
+
+inline
+Boolean MatchState::isFinished() const
+{
+  return pos_->isFinal() && minAndDepth_ == 0;
+}
+
+inline
+const LeafContentToken *
+MatchState::impliedStartTag() const
+{
+  return pos_->impliedStartTag(andState_, minAndDepth_);
+}
+
+inline
+void MatchState::doRequiredTransition()
+{
+  pos_->doRequiredTransition(andState_, minAndDepth_, pos_);
+}
+
+inline
+const LeafContentToken *MatchState::currentPosition() const
+{
+  return pos_;
+}
+
+inline
+Boolean MatchState::operator!=(const MatchState &state) const
+{
+  return !(*this == state);
+}
+
+inline
+Boolean AndState::isClear(unsigned i) const
+{
+  return v_[i] == 0;
+}
+
+inline
+void AndState::set(unsigned i)
+{
+  v_[i] = 1;
+  if (i >= clearFrom_)
+    clearFrom_ = i + 1;
+}
+
+inline
+void AndState::clearFrom(unsigned i)
+{
+  if (i < clearFrom_)
+    clearFrom1(i);
+}
+
+inline
+Boolean AndState::operator!=(const AndState &state) const
+{
+  return !(*this == state);
+}
+
+
+inline
+size_t FirstSet::size() const
+{
+  return v_.size();
+}
+
+inline
+LeafContentToken *FirstSet::token(size_t i) const
+{
+  return v_[i];
+}
+
+inline
+size_t FirstSet::requiredIndex() const
+{
+  return requiredIndex_;
+}
+
+inline
+void FirstSet::setNotRequired()
+{
+  requiredIndex_ = size_t(-1);
+}
+
+
+}
+# 21 "/usr/include/OpenSP/ElementType.h" 2 3 4
+
+
+namespace OpenSP {
+
+
+class ElementType;
+class ShortReferenceMap;
+class RankStem;
+
+class ElementDefinition : public Resource {
+public:
+  enum DeclaredContent { modelGroup, any, cdata, rcdata, empty };
+  enum OmitFlags { omitStart = 01, omitEnd = 02, omitSpec = 04 };
+  enum { undefinedIndex = -1 };
+  ElementDefinition(const Location &location,
+      size_t index,
+      unsigned char omitFlags,
+      DeclaredContent declaredContent,
+      Boolean allowImmediateRecursion = 1);
+  ElementDefinition(const Location &location,
+      size_t index,
+      unsigned char omitFlags,
+      DeclaredContent declaredContent,
+      Owner<CompiledModelGroup> &modelGroup);
+  const CompiledModelGroup *compiledModelGroup() const;
+  DeclaredContent declaredContent() const;
+
+  Boolean omittedTagSpec() const;
+  Boolean canOmitStartTag() const;
+  Boolean canOmitEndTag() const;
+  size_t nRankStems() const;
+  const RankStem *rankStem(size_t i) const;
+  const StringC &rankSuffix() const;
+  size_t nInclusions() const;
+  const ElementType *inclusion(size_t) const;
+  size_t nExclusions() const;
+  const ElementType *exclusion(size_t) const;
+  Boolean undefined() const;
+  Boolean allowImmediateRecursion() const;
+  void setInclusions(Vector<const ElementType *> &inclusions);
+  void setExclusions(Vector<const ElementType *> &exclusions);
+  void setRank(StringC &suffix, Vector<const RankStem *> &rankStems);
+  Mode mode(Boolean netEnabled) const;
+  const Location &location() const;
+private:
+  ElementDefinition(const ElementDefinition &);
+  void operator=(const ElementDefinition &);
+  void computeMode();
+
+  Location location_;
+  size_t index_;
+  unsigned char omitFlags_;
+  DeclaredContent declaredContent_;
+  Boolean allowImmediateRecursion_;
+  Owner<CompiledModelGroup> modelGroup_;
+  Vector<const ElementType *> inclusions_;
+  Vector<const ElementType *> exclusions_;
+
+
+  Vector<const RankStem *> rankStems_;
+  StringC rankSuffix_;
+  Mode mode_;
+  Mode netMode_;
+};
+
+class RankStem : public Named {
+public:
+  RankStem(const StringC &, size_t);
+  size_t index() const;
+  void addDefinition(const ConstPtr<ElementDefinition> &);
+  size_t nDefinitions() const;
+  const ElementDefinition *definition(size_t) const;
+private:
+  RankStem(const RankStem &);
+  void operator=(const RankStem &);
+  size_t index_;
+  Vector<ConstPtr<ElementDefinition> > def_;
+};
+
+class ElementType : public Named, public Attributed {
+public:
+  ElementType(const StringC &, size_t);
+  void setElementDefinition(const ConstPtr<ElementDefinition> &,
+       size_t defIndex);
+  void setMap(const ShortReferenceMap *);
+  void setRankStem(RankStem *);
+  Boolean undefined() const;
+  void setOrigName(StringC &origName);
+  const ElementDefinition *definition() const;
+  Boolean isRankedElement() const;
+  const RankStem *rankedElementRankStem() const;
+  size_t index() const;
+  const ShortReferenceMap *map() const;
+  void swap(ElementType &);
+  const StringC &origName() const;
+private:
+  StringC origName_;
+  ElementType(const ElementType &);
+  void operator=(const ElementType &);
+  size_t index_;
+  size_t defIndex_;
+  ConstPtr<ElementDefinition> def_;
+  const ShortReferenceMap *map_;
+};
+
+inline
+const CompiledModelGroup *ElementDefinition::compiledModelGroup() const
+{
+  return modelGroup_.pointer();
+}
+
+inline
+ElementDefinition::DeclaredContent ElementDefinition::declaredContent() const
+{
+  return declaredContent_;
+}
+
+inline
+Boolean ElementDefinition::canOmitStartTag() const
+{
+  return (omitFlags_ & omitStart) != 0;
+}
+
+inline
+Boolean ElementDefinition::canOmitEndTag() const
+{
+  return (omitFlags_ & omitEnd) != 0;
+}
+
+inline
+Boolean ElementDefinition::omittedTagSpec() const
+{
+  return (omitFlags_ & omitSpec) != 0;
+}
+
+inline
+size_t ElementDefinition::nRankStems() const
+{
+  return rankStems_.size();
+}
+
+inline
+const StringC &ElementDefinition::rankSuffix() const
+{
+  return rankSuffix_;
+}
+
+inline
+const RankStem *ElementDefinition::rankStem(size_t i) const
+{
+  return rankStems_[i];
+}
+
+inline
+const ElementType *ElementDefinition::inclusion(size_t i) const
+{
+  return inclusions_[i];
+}
+
+inline
+size_t ElementDefinition::nInclusions() const
+{
+  return inclusions_.size();
+}
+
+inline
+const ElementType *ElementDefinition::exclusion(size_t i) const
+{
+  return exclusions_[i];
+}
+
+inline
+size_t ElementDefinition::nExclusions() const
+{
+  return exclusions_.size();
+}
+
+inline
+Boolean ElementDefinition::undefined() const
+{
+  return index_ == size_t(undefinedIndex);
+}
+
+inline
+Boolean ElementDefinition::allowImmediateRecursion() const
+{
+  return allowImmediateRecursion_;
+}
+
+inline
+const Location &ElementDefinition::location() const
+{
+  return location_;
+}
+
+inline
+void ElementDefinition::setInclusions(Vector<const ElementType *> &inclusions)
+{
+  inclusions.swap(inclusions_);
+}
+
+inline
+void ElementDefinition::setExclusions(Vector<const ElementType *> &exclusions)
+{
+  exclusions.swap(exclusions_);
+}
+
+inline
+void ElementDefinition::setRank(StringC &rankSuffix,
+    Vector<const RankStem *> &rankStems)
+{
+  rankStems.swap(rankStems_);
+  rankSuffix.swap(rankSuffix_);
+}
+
+inline
+void ElementType::setOrigName(StringC &origName)
+{
+  origName.swap(origName_);
+}
+
+inline
+Boolean ElementType::undefined() const
+{
+  return def_->undefined();
+}
+
+inline
+Boolean ElementType::isRankedElement() const
+{
+  return def_->nRankStems() > 0;
+}
+
+inline
+const ElementDefinition *ElementType::definition() const
+{
+  return def_.pointer();
+}
+
+inline
+void ElementType::setElementDefinition(const ConstPtr<ElementDefinition> &def,
+           size_t defIndex)
+{
+  def_ = def;
+  defIndex_ = defIndex;
+}
+
+inline
+size_t ElementType::index() const
+{
+  return index_;
+}
+
+inline
+const RankStem *ElementType::rankedElementRankStem() const
+{
+  return def_->rankStem(defIndex_);
+}
+
+inline
+void ElementType::setMap(const ShortReferenceMap *map)
+{
+  map_ = map;
+}
+
+inline
+const StringC &ElementType::origName() const
+{
+  return origName_;
+}
+
+inline
+const ShortReferenceMap *ElementType::map() const
+{
+  return map_;
+}
+
+inline
+size_t RankStem::index() const
+{
+  return index_;
+}
+
+inline
+size_t RankStem::nDefinitions() const
+{
+  return def_.size();
+}
+
+inline
+const ElementDefinition *RankStem::definition(size_t i) const
+{
+  return def_[i].pointer();
+}
+
+inline
+Mode ElementDefinition::mode(Boolean netEnabled) const
+{
+  return netEnabled ? netMode_ : mode_;
+}
+
+
+}
+# 13 "/usr/include/OpenSP/Dtd.h" 2 3 4
+
+# 1 "/usr/include/OpenSP/Entity.h" 1 3 4
+
+
+
+
+
+
+#pragma interface
+
+
+
+
+
+
+# 1 "/usr/include/OpenSP/Owner.h" 1 3 4
+# 15 "/usr/include/OpenSP/Entity.h" 2 3 4
+
+
+
+
+
+
+
+# 1 "/usr/include/OpenSP/Markup.h" 1 3 4
+
+
+
+
+
+
+
+#pragma interface
+
+
+
+
+
+# 1 "/usr/include/OpenSP/Vector.h" 1 3 4
+# 15 "/usr/include/OpenSP/Markup.h" 2 3 4
+
+# 1 "/usr/include/OpenSP/SdText.h" 1 3 4
+
+
+
+
+
+
+
+#pragma interface
+
+
+
+# 1 "/usr/include/OpenSP/StringOf.h" 1 3 4
+# 13 "/usr/include/OpenSP/SdText.h" 2 3 4
+# 1 "/usr/include/OpenSP/Vector.h" 1 3 4
+# 14 "/usr/include/OpenSP/SdText.h" 2 3 4
+
+# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
+# 16 "/usr/include/OpenSP/SdText.h" 2 3 4
+
+
+namespace OpenSP {
+
+
+struct SdTextItem {
+  SdTextItem();
+  Location loc;
+  size_t index;
+};
+
+class SdText {
+public:
+  SdText();
+  SdText(const Location &loc, Boolean lita);
+  void swap(SdText &);
+  void addChar(SyntaxChar, const Location &);
+  const String<SyntaxChar> &string() const;
+  Boolean lita() const;
+  Location endDelimLocation() const;
+private:
+  Boolean lita_;
+  String<SyntaxChar> chars_;
+  Vector<SdTextItem> items_;
+  friend class SdTextIter;
+};
+
+class SdTextIter {
+public:
+  SdTextIter(const SdText &);
+  Boolean next(const SyntaxChar *&, size_t &, Location &);
+private:
+  const SdText *ptr_;
+  size_t itemIndex_;
+};
+
+inline
+Boolean SdText::lita() const
+{
+  return lita_;
+}
+
+inline
+const String<SyntaxChar> &SdText::string() const
+{
+  return chars_;
+}
+
+
+}
+# 17 "/usr/include/OpenSP/Markup.h" 2 3 4
+
+
+namespace OpenSP {
+
+
+class EntityOrigin;
+
+struct MarkupItem {
+  MarkupItem();
+  MarkupItem(const MarkupItem &);
+  ~MarkupItem();
+  void operator=(const MarkupItem &);
+  unsigned char type;
+  unsigned char index;
+  union {
+    size_t nChars;
+    ConstPtr<Origin> *origin;
+    Text *text;
+    SdText *sdText;
+  };
+};
+
+class InputSource;
+
+class Markup {
+public:
+  enum Type {
+    reservedName,
+    sdReservedName,
+    name,
+    nameToken,
+    attributeValue,
+    number,
+    comment,
+    s,
+    shortref,
+    delimiter,
+    refEndRe,
+    entityStart,
+    entityEnd,
+    literal,
+    sdLiteral
+  };
+  Markup();
+  size_t size() const;
+  void clear();
+  void resize(size_t);
+  void addDelim(Syntax::DelimGeneral);
+  void addReservedName(Syntax::ReservedName, const InputSource *);
+  void addReservedName(Syntax::ReservedName, const StringC &);
+  void addSdReservedName(Sd::ReservedName, const InputSource *);
+  void addSdReservedName(Sd::ReservedName, const Char *, size_t);
+  void addS(Char);
+  void addS(const InputSource *);
+  void addRefEndRe();
+  void addShortref(const InputSource *);
+  void addCommentStart();
+  void addCommentChar(Char);
+  void addName(const InputSource *);
+  void addName(const Char *, size_t);
+  void addNameToken(const InputSource *);
+  void addNumber(const InputSource *);
+  void addAttributeValue(const InputSource *);
+  void addEntityStart(const Ptr<EntityOrigin> &);
+  void addEntityEnd();
+  void addLiteral(const Text &);
+  void addSdLiteral(const SdText &);
+  void changeToAttributeValue(size_t index);
+  void changeToSdReservedName(size_t index, Sd::ReservedName);
+  void swap(Markup &);
+private:
+  StringC chars_;
+  Vector<MarkupItem> items_;
+  friend class MarkupIter;
+};
+
+class Location;
+
+class MarkupIter {
+public:
+  MarkupIter(const Markup &);
+  Markup::Type type() const;
+  Boolean valid() const;
+  void advance();
+
+  void advance(Location &, const ConstPtr<Syntax> &);
+  size_t index() const;
+  const Char *charsPointer() const;
+  size_t charsLength() const;
+  const Text &text() const;
+  const EntityOrigin *entityOrigin() const;
+  const SdText &sdText() const;
+  Syntax::DelimGeneral delimGeneral() const;
+  Syntax::ReservedName reservedName() const;
+  Sd::ReservedName sdReservedName() const;
+private:
+  const Char *chars_;
+  Vector<MarkupItem>::const_iterator items_;
+  size_t nItems_;
+  size_t index_;
+  size_t charIndex_;
+};
+
+inline
+void Markup::clear()
+{
+  chars_.resize(0);
+  items_.resize(0);
+}
+
+inline
+size_t Markup::size() const
+{
+  return items_.size();
+}
+
+inline
+Boolean MarkupIter::valid() const
+{
+  return index_ < nItems_;
+}
+
+inline
+size_t MarkupIter::index() const
+{
+  return index_;
+}
+
+inline
+Markup::Type MarkupIter::type() const
+{
+  return Markup::Type(items_[index_].type);
+}
+
+inline
+const EntityOrigin *MarkupIter::entityOrigin() const
+{
+  return (*items_[index_].origin)->asEntityOrigin();
+}
+
+inline
+const Char *MarkupIter::charsPointer() const
+{
+  return chars_ + charIndex_;
+}
+
+inline
+size_t MarkupIter::charsLength() const
+{
+  return items_[index_].nChars;
+}
+
+inline
+const Text &MarkupIter::text() const
+{
+  return *items_[index_].text;
+}
+
+inline
+const SdText &MarkupIter::sdText() const
+{
+  return *items_[index_].sdText;
+}
+
+inline
+Syntax::DelimGeneral MarkupIter::delimGeneral() const
+{
+  return Syntax::DelimGeneral(items_[index_].index);
+}
+
+inline
+Syntax::ReservedName MarkupIter::reservedName() const
+{
+  return Syntax::ReservedName(items_[index_].index);
+}
+
+inline
+Sd::ReservedName MarkupIter::sdReservedName() const
+{
+  return Sd::ReservedName(items_[index_].index);
+}
+
+
+}
+# 23 "/usr/include/OpenSP/Entity.h" 2 3 4
+
+
+namespace OpenSP {
+
+
+class Messenger;
+class InputSource;
+class EntityOrigin;
+class ParserState;
+class ExternalEntity;
+class ExternalDataEntity;
+class SubdocEntity;
+class InternalEntity;
+class Notation;
+
+class Entity : public EntityDecl {
+public:
+  Entity(const StringC &name, DeclType declType, DataType dataType,
+  const Location &defLocation);
+
+  virtual void litReference(Text &, ParserState &,
+       const Ptr<EntityOrigin> &,
+       Boolean squeezeSpaces)
+    const;
+
+  virtual void declReference(ParserState &,
+        const Ptr<EntityOrigin> &)
+    const;
+
+  virtual void dsReference(ParserState &,
+      const Ptr<EntityOrigin> &)
+    const;
+
+  virtual void contentReference(ParserState &,
+    const Ptr<EntityOrigin> &)
+    const;
+
+  virtual void rcdataReference(ParserState &,
+          const Ptr<EntityOrigin> &)
+    const;
+
+  virtual Boolean isDataOrSubdoc() const;
+
+  virtual Boolean isCharacterData() const;
+  virtual const ExternalDataEntity *asExternalDataEntity() const;
+  virtual const SubdocEntity *asSubdocEntity() const;
+  virtual const InternalEntity *asInternalEntity() const;
+  virtual const ExternalEntity *asExternalEntity() const;
+
+  virtual Entity *copy() const = 0;
+  virtual void generateSystemId(ParserState &);
+  void setUsed();
+  Boolean used() const;
+  void setDefaulted();
+  Boolean defaulted() const;
+protected:
+  virtual void checkRef(ParserState &) const;
+  static void checkEntlvl(ParserState &);
+  Boolean checkNotOpen(ParserState &) const;
+private:
+  virtual void normalReference(ParserState &,
+          const Ptr<EntityOrigin> &,
+          Boolean generateEvent) const = 0;
+  PackedBoolean used_;
+  PackedBoolean defaulted_;
+};
+
+class InternalEntity : public Entity {
+public:
+  InternalEntity(const StringC &, DeclType declType, DataType dataType,
+   const Location &, Text &);
+  const StringC &string() const;
+  const Text &text() const;
+  const InternalEntity *asInternalEntity() const;
+protected:
+  void checkRef(ParserState &) const;
+  Text text_;
+};
+
+class PiEntity : public InternalEntity {
+public:
+  PiEntity(const StringC &, DeclType, const Location &, Text &);
+  void litReference(Text &, ParserState &,
+      const Ptr<EntityOrigin> &,
+      Boolean) const;
+  void normalReference(ParserState &,
+         const Ptr<EntityOrigin> &,
+         Boolean) const;
+  void declReference(ParserState &,
+       const Ptr<EntityOrigin> &) const;
+  void rcdataReference(ParserState &,
+         const Ptr<EntityOrigin> &) const;
+  Entity *copy() const;
+};
+
+class InternalDataEntity : public InternalEntity {
+public:
+  InternalDataEntity(const StringC &, DataType, const Location &, Text &);
+  void declReference(ParserState &,
+       const Ptr<EntityOrigin> &) const;
+  Boolean isDataOrSubdoc() const;
+};
+
+class InternalCdataEntity : public InternalDataEntity {
+public:
+  InternalCdataEntity(const StringC &, const Location &, Text &);
+  void normalReference(ParserState &,
+         const Ptr<EntityOrigin> &,
+         Boolean) const;
+  void litReference(Text &, ParserState &,
+      const Ptr<EntityOrigin> &,
+      Boolean) const;
+  Entity *copy() const;
+  Boolean isCharacterData() const;
+};
+
+class PredefinedEntity : public InternalCdataEntity {
+public:
+  PredefinedEntity(const StringC &s, const Location &l, Text &t)
+   : InternalCdataEntity(s,l,t) { }
+protected:
+  void checkRef(ParserState &) const;
+};
+
+class InternalSdataEntity : public InternalDataEntity {
+public:
+  InternalSdataEntity(const StringC &, const Location &, Text &);
+  void normalReference(ParserState &,
+         const Ptr<EntityOrigin> &,
+         Boolean) const;
+  void litReference(Text &, ParserState &,
+      const Ptr<EntityOrigin> &,
+      Boolean) const;
+  Entity *copy() const;
+  Boolean isCharacterData() const;
+};
+
+class InternalTextEntity : public InternalEntity {
+public:
+  enum Bracketed {
+    none,
+    starttag,
+    endtag,
+    ms,
+    md
+    };
+  InternalTextEntity(const StringC &, DeclType, const Location &, Text &,
+       Bracketed);
+  Entity *copy() const;
+private:
+  void normalReference(ParserState &,
+         const Ptr<EntityOrigin> &,
+         Boolean) const;
+  void litReference(Text &, ParserState &,
+      const Ptr<EntityOrigin> &,
+      Boolean) const;
+  Bracketed bracketed_;
+};
+
+class ExternalEntity : public Entity {
+public:
+  ExternalEntity(const StringC &, DeclType, DataType, const Location &,
+   const ExternalId &);
+  const ExternalId &externalId() const;
+  const ExternalEntity *asExternalEntity() const;
+  void generateSystemId(ParserState &);
+  const StringC *systemIdPointer() const;
+  const StringC *effectiveSystemIdPointer() const;
+  const StringC *publicIdPointer() const;
+protected:
+  void checkRef(ParserState &) const;
+private:
+  ExternalId externalId_;
+};
+
+class ExternalTextEntity : public ExternalEntity {
+public:
+  ExternalTextEntity(const StringC &, DeclType, const Location &,
+       const ExternalId &);
+  Entity *copy() const;
+private:
+  void normalReference(ParserState &,
+         const Ptr<EntityOrigin> &,
+         Boolean) const;
+  void litReference(Text &, ParserState &,
+      const Ptr<EntityOrigin> &,
+      Boolean) const;
+};
+
+class ExternalNonTextEntity : public ExternalEntity {
+public:
+  ExternalNonTextEntity(const StringC &, DeclType, DataType,
+   const Location &, const ExternalId &);
+  Boolean isDataOrSubdoc() const;
+  void litReference(Text &, ParserState &,
+      const Ptr<EntityOrigin> &,
+      Boolean) const;
+  void rcdataReference(ParserState &,
+         const Ptr<EntityOrigin> &) const;
+  void normalReference(ParserState &,
+         const Ptr<EntityOrigin> &,
+         Boolean) const;
+  void dsReference(ParserState &,
+     const Ptr<EntityOrigin> &) const;
+  Boolean isCharacterData() const;
+};
+
+class ExternalDataEntity : public ExternalNonTextEntity {
+public:
+  ExternalDataEntity(const StringC &, DataType, const Location &,
+       const ExternalId &, const ConstPtr<Notation> &,
+       AttributeList &, DeclType = generalEntity);
+  const AttributeList &attributes() const;
+  const Notation *notation() const;
+  const ExternalDataEntity *asExternalDataEntity() const;
+  Entity *copy() const;
+  void contentReference(ParserState &,
+   const Ptr<EntityOrigin> &) const;
+  void setNotation(const ConstPtr<Notation> &, AttributeList &);
+private:
+  ConstPtr<Notation> notation_;
+  AttributeList attributes_;
+};
+
+class SubdocEntity : public ExternalNonTextEntity {
+public:
+  SubdocEntity(const StringC &, const Location &, const ExternalId &);
+  const SubdocEntity *asSubdocEntity() const;
+  Entity *copy() const;
+  void contentReference(ParserState &,
+   const Ptr<EntityOrigin> &) const;
+private:
+};
+
+class IgnoredEntity : public Entity {
+public:
+  IgnoredEntity(const StringC &, DeclType declType);
+  Entity *copy() const;
+  void litReference(Text &, ParserState &,
+      const Ptr<EntityOrigin> &,
+      Boolean squeezeSpaces) const;
+  void declReference(ParserState &,
+       const Ptr<EntityOrigin> &) const;
+private:
+  void normalReference(ParserState &,
+         const Ptr<EntityOrigin> &,
+         Boolean generateEvent) const;
+};
+
+class EntityOrigin : public InputSourceOrigin {
+public:
+  static EntityOrigin *make(Allocator &, const ConstPtr<Entity> &);
+  static EntityOrigin *make(Allocator &,
+       const ConstPtr<Entity> &,
+       const Location &refLocation);
+  static EntityOrigin *make(Allocator &,
+       const ConstPtr<Entity> &,
+       const Location &refLocation,
+       Index refLength,
+       Owner<Markup> &markup);
+  static EntityOrigin *make(const ConstPtr<Entity> &,
+       const Location &refLocation,
+       Index refLength,
+       Owner<Markup> &markup);
+  static EntityOrigin *make(const ConstPtr<Entity> &,
+       const Location &refLocation);
+  static const size_t allocSize;
+};
+
+inline
+Boolean Entity::used() const
+{
+  return used_;
+}
+
+inline
+void Entity::setUsed()
+{
+  used_ = 1;
+}
+
+inline
+Boolean Entity::defaulted() const
+{
+  return defaulted_;
+}
+
+inline
+void Entity::setDefaulted()
+{
+  defaulted_ = 1;
+}
+
+inline
+const StringC &InternalEntity::string() const
+{
+  return text_.string();
+}
+
+inline
+const Text &InternalEntity::text() const
+{
+  return text_;
+}
+
+inline
+const ExternalId &ExternalEntity::externalId() const
+{
+  return externalId_;
+}
+
+inline
+const AttributeList &ExternalDataEntity::attributes() const
+{
+  return attributes_;
+}
+
+inline
+const Notation *ExternalDataEntity::notation() const
+{
+  return notation_.pointer();
+}
+
+
+
+}
+# 15 "/usr/include/OpenSP/Dtd.h" 2 3 4
+# 1 "/usr/include/OpenSP/ShortReferenceMap.h" 1 3 4
+
+
+
+
+
+
+#pragma interface
+
+
+# 1 "/usr/include/OpenSP/Vector.h" 1 3 4
+# 11 "/usr/include/OpenSP/ShortReferenceMap.h" 2 3 4
+# 1 "/usr/include/OpenSP/Vector.h" 1 3 4
+# 12 "/usr/include/OpenSP/ShortReferenceMap.h" 2 3 4
+
+
+
+
+# 1 "/usr/include/OpenSP/Ptr.h" 1 3 4
+# 17 "/usr/include/OpenSP/ShortReferenceMap.h" 2 3 4
+
+
+namespace OpenSP {
+
+
+class ShortReferenceMap : public Named {
+public:
+  ShortReferenceMap();
+  ShortReferenceMap(const StringC &);
+  Boolean defined() const;
+  void setNameMap(Vector<StringC> &map);
+  void setEntityMap(Vector<ConstPtr<Entity> > &map);
+  Boolean lookup(int i, const StringC *&) const;
+  const StringC *entityName(size_t i) const;
+  const ConstPtr<Entity> &entity(size_t i) const;
+  Boolean used() const;
+  void setUsed();
+  const Location &defLocation() const;
+  void setDefLocation(const Location &);
+private:
+  ShortReferenceMap(const ShortReferenceMap &);
+  void operator=(const ShortReferenceMap &);
+  Vector<StringC> nameMap_;
+  Vector<ConstPtr<Entity> > entityMap_;
+  ConstPtr<Entity> nullEntity_;
+  Boolean used_;
+  Location defLocation_;
+};
+
+inline
+Boolean ShortReferenceMap::defined() const
+{
+  return nameMap_.size() > 0;
+}
+
+inline
+const StringC *ShortReferenceMap::entityName(size_t i) const
+{
+  if (i < nameMap_.size() && nameMap_[i].size() != 0)
+    return &nameMap_[i];
+  else
+    return 0;
+}
+
+inline
+const ConstPtr<Entity> &ShortReferenceMap::entity(size_t i) const
+{
+  if (i < entityMap_.size())
+    return entityMap_[i];
+  else
+    return nullEntity_;
+}
+
+inline
+void ShortReferenceMap::setEntityMap(Vector<ConstPtr<Entity> > &map)
+{
+  map.swap(entityMap_);
+}
+
+inline
+Boolean ShortReferenceMap::used() const
+{
+  return used_;
+}
+
+inline
+void ShortReferenceMap::setUsed()
+{
+  used_ = 1;
+}
+
+inline
+void ShortReferenceMap::setDefLocation(const Location &loc)
+{
+  defLocation_ = loc;
+}
+
+inline
+const Location &ShortReferenceMap::defLocation() const
+{
+  return defLocation_;
+}
+
+
+}
+# 16 "/usr/include/OpenSP/Dtd.h" 2 3 4
+
+
+
+
+# 1 "/usr/include/OpenSP/Vector.h" 1 3 4
+# 21 "/usr/include/OpenSP/Dtd.h" 2 3 4
+# 1 "/usr/include/OpenSP/HashTable.h" 1 3 4
+# 22 "/usr/include/OpenSP/Dtd.h" 2 3 4
+
+
+namespace OpenSP {
+
+
+class Syntax;
+class ParserState;
+
+class Dtd : public Resource {
+public:
+  typedef NamedTableIter<ElementType> ElementTypeIter;
+  typedef ConstNamedTableIter<ElementType> ConstElementTypeIter;
+  typedef NamedTableIter<RankStem> RankStemIter;
+  typedef ConstNamedTableIter<RankStem> ConstRankStemIter;
+  typedef NamedTableIter<ShortReferenceMap> ShortReferenceMapIter;
+  typedef ConstNamedResourceTableIter<Notation> ConstNotationIter;
+  typedef NamedResourceTableIter<Notation> NotationIter;
+  typedef ConstNamedResourceTableIter<Entity> ConstEntityIter;
+  typedef NamedResourceTableIter<Entity> EntityIter;
+  Dtd(const StringC &name, Boolean isBase);
+  ConstPtr<Entity> lookupEntity(Boolean isParameter, const StringC &) const;
+  const Entity *lookupEntityTemp(Boolean isParameter, const StringC &) const;
+  Ptr<Entity> lookupEntity(Boolean isParameter, const StringC &);
+  Ptr<Entity> insertEntity(const Ptr<Entity> &, Boolean replace = 0);
+  Ptr<Entity> removeEntity(Boolean isParameter, const StringC &);
+  ConstEntityIter generalEntityIter() const;
+  EntityIter generalEntityIter();
+  ConstEntityIter parameterEntityIter() const;
+  EntityIter parameterEntityIter();
+
+  ConstPtr<Entity> defaultEntity() const;
+  const Entity *defaultEntityTemp() const;
+  void setDefaultEntity(const Ptr<Entity> &, ParserState &);
+  const ConstPtr<StringResource<Char> > &namePointer() const;
+  const StringC &name() const;
+
+  const ElementType *lookupElementType(const StringC &) const;
+  ElementType *lookupElementType(const StringC &);
+  ElementType *removeElementType(const StringC &);
+  ElementType *insertElementType(ElementType *);
+  size_t nElementTypeIndex() const;
+  size_t allocElementTypeIndex();
+  ConstElementTypeIter elementTypeIter() const;
+  ElementTypeIter elementTypeIter();
+
+  const RankStem *lookupRankStem(const StringC &) const;
+  RankStem *lookupRankStem(const StringC &);
+  RankStem *insertRankStem(RankStem *);
+  size_t nRankStem() const;
+  ConstRankStemIter rankStemIter() const;
+  RankStemIter rankStemIter();
+
+  const ShortReferenceMap *lookupShortReferenceMap(const StringC &) const;
+  ShortReferenceMap *lookupShortReferenceMap(const StringC &);
+  ShortReferenceMap *insertShortReferenceMap(ShortReferenceMap *);
+  ShortReferenceMapIter shortReferenceMapIter();
+
+  Boolean shortrefIndex(const StringC &, const Syntax &, size_t &index);
+  size_t nShortref() const;
+  const StringC &shortref(size_t i) const;
+  void addNeededShortref(const StringC &);
+
+  ConstPtr<Notation> lookupNotation(const StringC &) const;
+  const Notation *lookupNotationTemp(const StringC &) const;
+  Ptr<Notation> lookupNotation(const StringC &);
+  Ptr<Notation> insertNotation(const Ptr<Notation> &);
+  Ptr<Notation> removeNotation(const StringC &);
+  ConstNotationIter notationIter() const;
+  NotationIter notationIter();
+
+  size_t allocCurrentAttributeIndex();
+  size_t nCurrentAttribute() const;
+  size_t allocElementDefinitionIndex();
+  size_t nElementDefinition() const;
+  size_t allocAttributeDefinitionListIndex();
+  size_t nAttributeDefinitionList() const;
+  const ElementType *documentElementType() const;
+  Boolean isBase() const;
+  Boolean isInstantiated() const;
+  void instantiate();
+
+  Ptr<AttributeDefinitionList> &implicitElementAttributeDef();
+  void setImplicitElementAttributeDef(const Ptr<AttributeDefinitionList> &);
+  Ptr<AttributeDefinitionList> &implicitNotationAttributeDef();
+  void setImplicitNotationAttributeDef(const Ptr<AttributeDefinitionList> &);
+private:
+  Dtd(const Dtd &);
+  void operator=(const Dtd &);
+  NamedResourceTable<Entity> generalEntityTable_;
+  NamedResourceTable<Entity> parameterEntityTable_;
+  ConstPtr<Entity> defaultEntity_;
+  ConstPtr<StringResource<Char> > name_;
+  NamedTable<ElementType> elementTypeTable_;
+  NamedTable<RankStem> rankStemTable_;
+  NamedTable<ShortReferenceMap> shortReferenceMapTable_;
+  NamedResourceTable<Notation> notationTable_;
+  size_t nCurrentAttribute_;
+  size_t nElementDefinition_;
+  size_t nAttributeDefinitionList_;
+  size_t nElementType_;
+  ElementType *documentElementType_;
+  Vector<StringC> shortrefs_;
+  HashTable<StringC,int> shortrefTable_;
+  Boolean isBase_;
+  Boolean isInstantitated_;
+  Ptr<AttributeDefinitionList> implicitElementAttributeDef_;
+  Ptr<AttributeDefinitionList> implicitNotationAttributeDef_;
+};
+
+inline
+ConstPtr<Entity> Dtd::lookupEntity(Boolean isParameter, const StringC &name)
+  const
+{
+  return (isParameter
+   ? &parameterEntityTable_
+   : &generalEntityTable_)->lookupConst(name);
+}
+
+inline
+const Entity *Dtd::lookupEntityTemp(Boolean isParameter, const StringC &name)
+  const
+{
+  return (isParameter
+   ? &parameterEntityTable_
+   : &generalEntityTable_)->lookupTemp(name);
+}
+
+inline
+Ptr<Entity> Dtd::lookupEntity(Boolean isParameter, const StringC &name)
+{
+  return (isParameter
+   ? &parameterEntityTable_
+   : &generalEntityTable_)->lookup(name);
+}
+
+inline
+Ptr<Entity>
+Dtd::insertEntity(const Ptr<Entity> &entity, Boolean replace)
+{
+  return ((entity->declType() == Entity::parameterEntity
+    || entity->declType() == Entity::doctype)
+   ? &parameterEntityTable_
+   : &generalEntityTable_)->insert(entity, replace);
+}
+
+inline
+Ptr<Entity> Dtd::removeEntity(Boolean isParameter, const StringC &name)
+{
+  return (isParameter
+   ? &parameterEntityTable_
+   : &generalEntityTable_)->remove(name);
+}
+
+inline
+Dtd::ConstEntityIter Dtd::generalEntityIter() const
+{
+
+  return ConstNamedResourceTableIter<Entity>(generalEntityTable_);
+}
+
+inline
+Dtd::EntityIter Dtd::generalEntityIter()
+{
+
+  return NamedResourceTableIter<Entity>(generalEntityTable_);
+}
+
+inline
+Dtd::ConstEntityIter Dtd::parameterEntityIter() const
+{
+
+  return ConstNamedResourceTableIter<Entity>(parameterEntityTable_);
+}
+
+inline
+Dtd::EntityIter Dtd::parameterEntityIter()
+{
+
+  return NamedResourceTableIter<Entity>(parameterEntityTable_);
+}
+
+inline
+ConstPtr<Entity> Dtd::defaultEntity() const
+{
+  return defaultEntity_;
+}
+
+inline
+const Entity *Dtd::defaultEntityTemp() const
+{
+  return defaultEntity_.pointer();
+}
+
+inline
+const ConstPtr<StringResource<Char> > &Dtd::namePointer() const
+{
+  return name_;
+}
+
+inline
+const StringC &Dtd::name() const
+{
+  return *name_;
+}
+
+inline
+size_t Dtd::allocCurrentAttributeIndex()
+{
+  return nCurrentAttribute_++;
+}
+
+inline
+size_t Dtd::nCurrentAttribute() const
+{
+  return nCurrentAttribute_;
+}
+
+inline
+size_t Dtd::allocElementDefinitionIndex()
+{
+  return nElementDefinition_++;
+}
+
+inline
+size_t Dtd::nElementDefinition() const
+{
+  return nElementDefinition_;
+}
+
+inline
+size_t Dtd::allocAttributeDefinitionListIndex()
+{
+  return nAttributeDefinitionList_++;
+}
+
+inline
+size_t Dtd::nAttributeDefinitionList() const
+{
+  return nAttributeDefinitionList_;
+}
+
+inline
+const ElementType *Dtd::lookupElementType(const StringC &name) const
+{
+  return elementTypeTable_.lookup(name);
+}
+
+inline
+ElementType *Dtd::lookupElementType(const StringC &name)
+{
+  return elementTypeTable_.lookup(name);
+}
+
+inline
+ElementType *Dtd::insertElementType(ElementType *e)
+{
+  return elementTypeTable_.insert(e);
+}
+
+inline
+Dtd::ElementTypeIter Dtd::elementTypeIter()
+{
+
+  return NamedTableIter<ElementType>(elementTypeTable_);
+}
+
+inline
+Dtd::ConstElementTypeIter Dtd::elementTypeIter() const
+{
+
+  return ConstNamedTableIter<ElementType>(elementTypeTable_);
+}
+
+inline
+Dtd::RankStemIter Dtd::rankStemIter()
+{
+
+  return NamedTableIter<RankStem>(rankStemTable_);
+}
+
+inline
+Dtd::ConstRankStemIter Dtd::rankStemIter() const
+{
+
+  return ConstNamedTableIter<RankStem>(rankStemTable_);
+}
+
+inline
+ElementType *Dtd::removeElementType(const StringC &name)
+{
+  return elementTypeTable_.remove(name);
+}
+
+inline
+size_t Dtd::nElementTypeIndex() const
+{
+
+  return 1 + nElementType_;
+}
+
+inline
+size_t Dtd::allocElementTypeIndex()
+{
+  return 1 + nElementType_++;
+}
+
+inline
+const RankStem *Dtd::lookupRankStem(const StringC &name) const
+{
+  return rankStemTable_.lookup(name);
+}
+
+inline
+RankStem *Dtd::lookupRankStem(const StringC &name)
+{
+  return rankStemTable_.lookup(name);
+}
+
+inline
+RankStem *Dtd::insertRankStem(RankStem *e)
+{
+  return rankStemTable_.insert(e);
+}
+
+inline
+size_t Dtd::nRankStem() const
+{
+  return rankStemTable_.count();
+}
+
+inline
+ConstPtr<Notation> Dtd::lookupNotation(const StringC &name) const
+{
+  return notationTable_.lookupConst(name);
+}
+
+inline
+const Notation *Dtd::lookupNotationTemp(const StringC &name) const
+{
+  return notationTable_.lookupTemp(name);
+}
+
+inline
+Ptr<Notation> Dtd::lookupNotation(const StringC &name)
+{
+  return notationTable_.lookup(name);
+}
+
+inline
+Ptr<Notation> Dtd::insertNotation(const Ptr<Notation> &nt)
+{
+  return notationTable_.insert(nt);
+}
+
+inline
+Dtd::ConstNotationIter Dtd::notationIter() const
+{
+
+  return ConstNamedResourceTableIter<Notation>(notationTable_);
+}
+
+inline
+Dtd::NotationIter Dtd::notationIter()
+{
+
+  return NamedResourceTableIter<Notation>(notationTable_);
+}
+
+inline
+Ptr<Notation> Dtd::removeNotation(const StringC &name)
+{
+  return notationTable_.remove(name);
+}
+
+inline
+const ElementType *Dtd::documentElementType() const
+{
+  return documentElementType_;
+}
+
+inline
+const ShortReferenceMap *Dtd::lookupShortReferenceMap(const StringC &name) const
+{
+  return shortReferenceMapTable_.lookup(name);
+}
+
+inline
+ShortReferenceMap *Dtd::lookupShortReferenceMap(const StringC &name)
+{
+  return shortReferenceMapTable_.lookup(name);
+}
+
+inline
+ShortReferenceMap *Dtd::insertShortReferenceMap(ShortReferenceMap *map)
+{
+  return shortReferenceMapTable_.insert(map);
+}
+
+inline
+Dtd::ShortReferenceMapIter Dtd::shortReferenceMapIter()
+{
+
+  return NamedTableIter<ShortReferenceMap>(shortReferenceMapTable_);
+}
+
+inline
+Boolean Dtd::isBase() const
+{
+  return isBase_;
+}
+
+inline
+size_t Dtd::nShortref() const
+{
+  return shortrefs_.size();
+}
+
+inline
+const StringC &Dtd::shortref(size_t i) const
+{
+  return shortrefs_[i];
+}
+
+inline
+Ptr<AttributeDefinitionList> &Dtd::implicitElementAttributeDef()
+{
+  return implicitElementAttributeDef_;
+}
+
+inline
+void Dtd::setImplicitElementAttributeDef(const Ptr<AttributeDefinitionList> &def)
+{
+  implicitElementAttributeDef_ = def;
+}
+
+inline
+Ptr<AttributeDefinitionList> &Dtd::implicitNotationAttributeDef()
+{
+  return implicitNotationAttributeDef_;
+}
+
+inline
+void Dtd::setImplicitNotationAttributeDef(const Ptr<AttributeDefinitionList> &def)
+{
+  implicitNotationAttributeDef_ = def;
+}
+
+inline
+Boolean Dtd::isInstantiated() const
+{
+  return isInstantitated_;
+}
+
+inline
+void Dtd::instantiate()
+{
+  isInstantitated_ = 1;
+}
+
+
+}
+# 23 "/usr/include/OpenSP/Event.h" 2 3 4
+
+
+# 1 "/usr/include/OpenSP/Lpd.h" 1 3 4
+
+
+
+
+
+
+#pragma interface
+
+
+
+
+# 1 "/usr/include/OpenSP/Ptr.h" 1 3 4
+# 13 "/usr/include/OpenSP/Lpd.h" 2 3 4
+# 22 "/usr/include/OpenSP/Lpd.h" 3 4
+namespace OpenSP {
+
+
+class ElementType;
+
+struct ResultElementSpec {
+  ResultElementSpec();
+  const ElementType *elementType;
+  AttributeList attributeList;
+  void swap(ResultElementSpec &);
+};
+
+class Lpd : public Resource {
+public:
+  enum Type { simpleLink, implicitLink, explicitLink };
+  Lpd(const StringC &, Type, const Location &,
+      const Ptr<Dtd> &sourceDtd);
+  virtual ~Lpd();
+  Type type() const;
+  const Location &location() const;
+  const Ptr<Dtd> &sourceDtd();
+  ConstPtr<Dtd> sourceDtd() const;
+  Boolean active() const;
+  void activate();
+  const ConstPtr<StringResource<Char> > &namePointer() const;
+  const StringC &name() const;
+private:
+  Lpd(const Lpd &);
+  void operator=(const Lpd &);
+  Type type_;
+  Location location_;
+  Boolean active_;
+  Ptr<Dtd> sourceDtd_;
+  ConstPtr<StringResource<Char> > name_;
+};
+
+class SimpleLpd : public Lpd, public Attributed {
+public:
+  SimpleLpd(const StringC &, const Location &,
+     const Ptr<Dtd> &sourceDtd);
+private:
+  SimpleLpd(const SimpleLpd &);
+  void operator=(const SimpleLpd &);
+};
+
+class LinkSet;
+
+
+
+class SourceLinkRule {
+public:
+  SourceLinkRule();
+  void setLinkAttributes(AttributeList &);
+  void setResult(const ElementType *, AttributeList &);
+  void setUselink(const LinkSet *);
+  void setPostlink(const LinkSet *);
+  void setPostlinkRestore();
+  void swap(SourceLinkRule &);
+  const AttributeList &attributes() const;
+  const ResultElementSpec &resultElementSpec() const;
+  const LinkSet *uselink() const;
+  const LinkSet *postlink() const;
+  Boolean postlinkRestore() const;
+private:
+  const LinkSet *uselink_;
+  const LinkSet *postlink_;
+  Boolean postlinkRestore_;
+  AttributeList linkAttributes_;
+  ResultElementSpec resultElementSpec_;
+};
+
+class SourceLinkRuleResource : public Resource, public SourceLinkRule {
+public:
+  SourceLinkRuleResource();
+};
+
+class LinkSet : public Named {
+public:
+  LinkSet(const StringC &, const Dtd *);
+  void setDefined();
+  Boolean defined() const;
+  void addImplied(const ElementType *, AttributeList &);
+  size_t nLinkRules(const ElementType *) const;
+  const SourceLinkRule &linkRule(const ElementType *, size_t) const;
+  void addLinkRule(const ElementType *,
+     const ConstPtr<SourceLinkRuleResource> &);
+  size_t nImpliedLinkRules() const;
+  const ResultElementSpec &impliedLinkRule(size_t) const;
+  Boolean impliedResultAttributes(const ElementType *,
+      const AttributeList *&);
+private:
+  LinkSet(const LinkSet &);
+  void operator=(const LinkSet &);
+  Boolean defined_;
+
+  Vector<Vector<ConstPtr<SourceLinkRuleResource> > >
+    linkRules_;
+  Vector<ResultElementSpec> impliedSourceLinkRules_;
+};
+
+class IdLinkRule : public SourceLinkRule {
+public:
+  IdLinkRule();
+  Boolean isAssociatedWith(const ElementType *) const;
+  void setAssocElementTypes(Vector<const ElementType *> &);
+  void swap(IdLinkRule &);
+private:
+  Vector<const ElementType *> assocElementTypes_;
+};
+
+
+
+
+class IdLinkRuleGroup : public Named {
+public:
+  IdLinkRuleGroup(const StringC &);
+  size_t nLinkRules() const;
+  const IdLinkRule &linkRule(size_t) const;
+  void addLinkRule(IdLinkRule &);
+private:
+  IdLinkRuleGroup(const IdLinkRuleGroup &);
+  void operator=(const IdLinkRuleGroup &);
+  Vector<IdLinkRule> linkRules_;
+};
+
+
+
+class ComplexLpd : public Lpd {
+public:
+  typedef ConstNamedTableIter<LinkSet> ConstLinkSetIter;
+  ComplexLpd(const StringC &, Type,
+      const Location &,
+      const Syntax &syntax,
+      const Ptr<Dtd> &sourceDtd,
+      const Ptr<Dtd> &resultDtd);
+  size_t allocAttributeDefinitionListIndex();
+  size_t nAttributeDefinitionList() const;
+  LinkSet *initialLinkSet();
+  const LinkSet *initialLinkSet() const;
+  const LinkSet *emptyLinkSet() const;
+  const LinkSet *lookupLinkSet(const StringC &) const;
+  const IdLinkRuleGroup *lookupIdLink(const StringC &) const;
+  IdLinkRuleGroup *lookupCreateIdLink(const StringC &);
+  void insertIdLink(IdLinkRuleGroup *);
+  ConstLinkSetIter linkSetIter() const;
+  Boolean hadIdLinkSet() const;
+  void setHadIdLinkSet();
+
+  LinkSet *lookupLinkSet(const StringC &);
+  LinkSet *insertLinkSet(LinkSet *);
+  const Ptr<Dtd> &resultDtd();
+  ConstPtr<Dtd> resultDtd() const;
+  const ConstPtr<AttributeDefinitionList> &
+    attributeDef(const ElementType *) const;
+  void setAttributeDef(const ElementType *,
+         const ConstPtr<AttributeDefinitionList> &);
+private:
+  ComplexLpd(const ComplexLpd &);
+  void operator=(const ComplexLpd &);
+  Ptr<Dtd> resultDtd_;
+  Vector<ConstPtr<AttributeDefinitionList> > linkAttributeDefs_;
+  NamedTable<LinkSet> linkSetTable_;
+  LinkSet initialLinkSet_;
+  LinkSet emptyLinkSet_;
+  Boolean hadIdLinkSet_;
+  NamedTable<IdLinkRuleGroup> idLinkTable_;
+  size_t nAttributeDefinitionList_;
+};
+
+inline
+Lpd::Type Lpd::type() const
+{
+  return type_;
+}
+
+inline
+const Location &Lpd::location() const
+{
+  return location_;
+}
+
+inline
+Boolean Lpd::active() const
+{
+  return active_;
+}
+
+inline
+void Lpd::activate()
+{
+  active_ = 1;
+}
+
+inline
+ConstPtr<Dtd> Lpd::sourceDtd() const
+{
+  return sourceDtd_;
+}
+
+inline
+const Ptr<Dtd> &Lpd::sourceDtd()
+{
+  return sourceDtd_;
+}
+
+inline
+const ConstPtr<StringResource<Char> > &Lpd::namePointer() const
+{
+  return name_;
+}
+
+inline
+const StringC &Lpd::name() const
+{
+  return *name_;
+}
+
+inline
+void SourceLinkRule::setLinkAttributes(AttributeList &attributes)
+{
+  attributes.swap(linkAttributes_);
+}
+
+inline
+const AttributeList &SourceLinkRule::attributes() const
+{
+  return linkAttributes_;
+}
+
+inline
+void SourceLinkRule::setResult(const ElementType *element,
+          AttributeList &attributes)
+{
+  resultElementSpec_.elementType = element;
+  attributes.swap(resultElementSpec_.attributeList);
+}
+
+inline
+const ResultElementSpec &SourceLinkRule::resultElementSpec() const
+{
+  return resultElementSpec_;
+}
+
+inline
+void SourceLinkRule::setUselink(const LinkSet *linkSet)
+{
+  uselink_ = linkSet;
+}
+
+inline
+void SourceLinkRule::setPostlink(const LinkSet *linkSet)
+{
+  postlink_ = linkSet;
+}
+
+inline
+void SourceLinkRule::setPostlinkRestore()
+{
+  postlinkRestore_ = 1;
+}
+
+inline
+const LinkSet *SourceLinkRule::uselink() const
+{
+  return uselink_;
+}
+
+inline
+const LinkSet *SourceLinkRule::postlink() const
+{
+  return postlink_;
+}
+
+inline
+Boolean SourceLinkRule::postlinkRestore() const
+{
+  return postlinkRestore_;
+}
+
+inline
+Boolean LinkSet::defined() const
+{
+  return defined_;
+}
+
+inline
+void LinkSet::setDefined()
+{
+  defined_ = 1;
+}
+
+inline
+const SourceLinkRule &LinkSet::linkRule(const ElementType *e, size_t i) const
+{
+  return *linkRules_[e->index()][i];
+}
+
+inline
+size_t LinkSet::nImpliedLinkRules() const
+{
+  return impliedSourceLinkRules_.size();
+}
+
+inline
+const ResultElementSpec &LinkSet::impliedLinkRule(size_t i) const
+{
+  return impliedSourceLinkRules_[i];
+}
+
+inline
+const Ptr<Dtd> &ComplexLpd::resultDtd()
+{
+  return resultDtd_;
+}
+
+inline
+ConstPtr<Dtd> ComplexLpd::resultDtd() const
+{
+  return resultDtd_;
+}
+
+inline
+LinkSet *ComplexLpd::initialLinkSet()
+{
+  return &initialLinkSet_;
+}
+
+inline
+const LinkSet *ComplexLpd::initialLinkSet() const
+{
+  return &initialLinkSet_;
+}
+
+inline
+const LinkSet *ComplexLpd::emptyLinkSet() const
+{
+  return &emptyLinkSet_;
+}
+
+inline
+const LinkSet *ComplexLpd::lookupLinkSet(const StringC &name) const
+{
+  return linkSetTable_.lookup(name);
+}
+
+inline
+LinkSet *ComplexLpd::lookupLinkSet(const StringC &name)
+{
+  return linkSetTable_.lookup(name);
+}
+
+inline
+LinkSet *ComplexLpd::insertLinkSet(LinkSet *e)
+{
+  return linkSetTable_.insert(e);
+}
+
+inline
+size_t ComplexLpd::nAttributeDefinitionList() const
+{
+  return nAttributeDefinitionList_;
+}
+
+inline
+size_t ComplexLpd::allocAttributeDefinitionListIndex()
+{
+  return nAttributeDefinitionList_++;
+}
+
+inline
+ComplexLpd::ConstLinkSetIter ComplexLpd::linkSetIter() const
+{
+
+  return ConstNamedTableIter<LinkSet>(linkSetTable_);
+}
+
+inline
+const ConstPtr<AttributeDefinitionList> &
+ComplexLpd::attributeDef(const ElementType *e) const
+{
+  return linkAttributeDefs_[e->index()];
+}
+
+inline
+void ComplexLpd::setAttributeDef(const ElementType *e,
+     const ConstPtr<AttributeDefinitionList> &attdef)
+{
+  linkAttributeDefs_[e->index()] = attdef;
+}
+
+inline
+Boolean ComplexLpd::hadIdLinkSet() const
+{
+  return hadIdLinkSet_;
+}
+
+inline
+void ComplexLpd::setHadIdLinkSet()
+{
+  hadIdLinkSet_ = 1;
+}
+
+inline
+const IdLinkRuleGroup *ComplexLpd::lookupIdLink(const StringC &id) const
+{
+  return idLinkTable_.lookup(id);
+}
+
+inline
+size_t IdLinkRuleGroup::nLinkRules() const
+{
+  return linkRules_.size();
+}
+
+inline
+const IdLinkRule &IdLinkRuleGroup::linkRule(size_t i) const
+{
+  return linkRules_[i];
+}
+
+
+}
+# 26 "/usr/include/OpenSP/Event.h" 2 3 4
+
+
+
+
+
+namespace OpenSP {
+
+
+class EventHandler;
+
+class Event : public Link {
+public:
+  enum Type {
+    message,
+    characterData,
+    startElement,
+    endElement,
+    pi,
+    sdataEntity,
+    externalDataEntity,
+    subdocEntity,
+    nonSgmlChar,
+    appinfo,
+    startDtd,
+    endDtd,
+    startLpd,
+    endLpd,
+    endProlog,
+    sgmlDecl,
+    uselink,
+    usemap,
+    commentDecl,
+    sSep,
+    ignoredRs,
+    ignoredRe,
+    reOrigin,
+    ignoredChars,
+    markedSectionStart,
+    markedSectionEnd,
+    entityStart,
+    entityEnd,
+    notationDecl,
+    entityDecl,
+    elementDecl,
+    attlistDecl,
+    attlistNotationDecl,
+    linkAttlistDecl,
+    linkDecl,
+    idLinkDecl,
+    shortrefDecl,
+    ignoredMarkup,
+    entityDefaulted,
+    sgmlDeclEntity
+    };
+  Event(Type);
+  virtual void handle(EventHandler &) = 0;
+  virtual void copyData();
+  void *operator new(size_t sz, Allocator &alloc) { return alloc.alloc(sz); }
+  void *operator new(size_t sz) { return Allocator::allocSimple(sz); }
+  void operator delete(void *p) { Allocator::free(p); }
+
+
+
+  Type type() const;
+private:
+  Event(const Event &);
+  void operator=(const Event &);
+  Type type_;
+};
+
+class LocatedEvent : public Event {
+public:
+  LocatedEvent(Type type, const Location &);
+  const Location &location() const;
+private:
+  LocatedEvent(const LocatedEvent &);
+  void operator=(const LocatedEvent &);
+  Location location_;
+};
+
+class MarkupEvent : public LocatedEvent {
+public:
+  MarkupEvent(Type type);
+  MarkupEvent(Type type, const Location &, Markup *);
+  const Markup &markup() const;
+private:
+  MarkupEvent(const MarkupEvent &);
+  void operator=(const MarkupEvent &);
+  Markup markup_;
+};
+
+class MessageEvent : public Event {
+public:
+  MessageEvent(Message &);
+  MessageEvent(const Message &);
+  const Message &message() const;
+  void handle(EventHandler &);
+private:
+  MessageEvent(const MessageEvent &);
+  void operator=(const MessageEvent &);
+  Message message_;
+};
+
+class AttributeList;
+
+class StartElementEvent : public LocatedEvent {
+public:
+  StartElementEvent(const ElementType *,
+      const ConstPtr<Dtd> &,
+      AttributeList *,
+      const Location &,
+      Markup *);
+  ~StartElementEvent();
+  void handle(EventHandler &);
+  Boolean mustOmitEnd() const;
+  void setIncluded();
+  Boolean included() const;
+  const StringC &name() const;
+  const ElementType *elementType() const;
+  const Markup *markupPtr() const;
+  const AttributeList &attributes() const;
+  void copyData();
+private:
+  StartElementEvent(const StartElementEvent &);
+  void operator=(const StartElementEvent &);
+  const ElementType *elementType_;
+  ConstPtr<Dtd> dtd_;
+  PackedBoolean included_;
+  PackedBoolean copied_;
+  Markup *markup_;
+  AttributeList *attributes_;
+};
+
+class EndElementEvent : public LocatedEvent {
+public:
+  EndElementEvent(const ElementType *,
+    const ConstPtr<Dtd> &,
+    const Location &,
+    Markup *);
+  ~EndElementEvent();
+  void handle(EventHandler &);
+  void setIncluded();
+  Boolean included() const;
+  const StringC &name() const;
+  const ElementType *elementType() const;
+  const Markup *markupPtr() const;
+  void copyData();
+private:
+  EndElementEvent(const EndElementEvent &);
+  void operator=(const EndElementEvent &);
+  const ElementType *elementType_;
+  ConstPtr<Dtd> dtd_;
+  PackedBoolean included_;
+  PackedBoolean copied_;
+  Markup *markup_;
+};
+
+class DataEvent : public LocatedEvent {
+public:
+  DataEvent(Type, const Char *, size_t, const Location &);
+  void handle(EventHandler &);
+  const Char *data() const;
+  size_t dataLength() const;
+  virtual Boolean isRe(unsigned long &serial) const;
+  virtual const Entity *entity() const;
+protected:
+  const Char *p_;
+  size_t length_;
+private:
+  DataEvent(const DataEvent &);
+  void operator=(const DataEvent &);
+};
+
+class ImmediateDataEvent : public DataEvent {
+public:
+  ImmediateDataEvent(Type type, const Char *, size_t, const Location &,
+       Boolean copy);
+  ~ImmediateDataEvent();
+  void copyData();
+private:
+  ImmediateDataEvent(const ImmediateDataEvent &);
+  void operator=(const ImmediateDataEvent &);
+  Char *alloc_;
+};
+
+class InternalDataEntity;
+
+class DataEntityEvent : public DataEvent {
+public:
+  DataEntityEvent(Type type, const InternalEntity *,
+    const ConstPtr<Origin> &);
+  const Entity *entity() const;
+private:
+  DataEntityEvent(const DataEntityEvent &);
+  void operator=(const DataEntityEvent &);
+};
+
+class InternalCdataEntity;
+
+class CdataEntityEvent : public DataEntityEvent {
+public:
+  CdataEntityEvent(const InternalEntity *,
+     const ConstPtr<Origin> &);
+private:
+  CdataEntityEvent(const CdataEntityEvent &);
+  void operator=(const CdataEntityEvent &);
+};
+
+class InternalSdataEntity;
+
+class SdataEntityEvent : public DataEntityEvent {
+public:
+  SdataEntityEvent(const InternalEntity *,
+     const ConstPtr<Origin> &);
+  void handle(EventHandler &);
+private:
+  SdataEntityEvent(const SdataEntityEvent &);
+  void operator=(const SdataEntityEvent &);
+};
+
+class PiEntity;
+
+class PiEvent : public LocatedEvent {
+public:
+  PiEvent(const Char *, size_t, const Location &);
+  const Char *data() const;
+  size_t dataLength() const;
+  virtual const Entity *entity() const;
+  void handle(EventHandler &);
+private:
+  PiEvent(const PiEvent &);
+  void operator=(const PiEvent &);
+  const Char *data_;
+  size_t dataLength_;
+};
+
+class ImmediatePiEvent : public PiEvent {
+public:
+  ImmediatePiEvent(StringC &, const Location &);
+private:
+  ImmediatePiEvent(const ImmediatePiEvent &);
+  void operator=(const ImmediatePiEvent &);
+  StringC string_;
+};
+
+class PiEntityEvent : public PiEvent {
+public:
+  PiEntityEvent(const PiEntity *entity,
+  const ConstPtr<Origin> &origin);
+  const Entity *entity() const;
+private:
+  PiEntityEvent(const PiEntityEvent &);
+  void operator=(const PiEntityEvent &);
+};
+
+class ExternalNonTextEntity;
+class ExternalDataEntity;
+class SubdocEntity;
+
+class ExternalEntityEvent : public Event {
+public:
+  ExternalEntityEvent(Type type,
+        const ConstPtr<EntityOrigin> &);
+  const ConstPtr<EntityOrigin> &entityOrigin() const;
+  const Location &location() const;
+private:
+  ExternalEntityEvent(const ExternalEntityEvent &);
+  void operator=(const ExternalEntityEvent &);
+  ConstPtr<EntityOrigin> origin_;
+};
+
+class ExternalDataEntityEvent : public ExternalEntityEvent {
+public:
+  ExternalDataEntityEvent(const ExternalDataEntity *,
+     const ConstPtr<EntityOrigin> &);
+  void handle(EventHandler &);
+  const ExternalDataEntity *entity() const;
+private:
+  ExternalDataEntityEvent(const ExternalDataEntityEvent &);
+  void operator=(const ExternalDataEntityEvent &);
+  const ExternalDataEntity *dataEntity_;
+};
+
+class SubdocEntityEvent : public ExternalEntityEvent {
+public:
+  SubdocEntityEvent(const SubdocEntity *,
+      const ConstPtr<EntityOrigin> &);
+  void handle(EventHandler &);
+  const SubdocEntity *entity() const;
+private:
+  SubdocEntityEvent(const SubdocEntityEvent &);
+  void operator=(const SubdocEntityEvent &);
+  const SubdocEntity *subdocEntity_;
+};
+
+class NonSgmlCharEvent : public LocatedEvent {
+public:
+  NonSgmlCharEvent(Char c, const Location &);
+  Char character() const;
+  void handle(EventHandler &);
+private:
+  NonSgmlCharEvent(const NonSgmlCharEvent &);
+  void operator=(const NonSgmlCharEvent &);
+  Char c_;
+};
+
+class AppinfoEvent : public LocatedEvent {
+public:
+  AppinfoEvent(const Location &);
+  AppinfoEvent(const Text &, const Location &);
+  void handle(EventHandler &);
+  Boolean literal(const StringC *&) const;
+private:
+  AppinfoEvent(const AppinfoEvent &);
+  void operator=(const AppinfoEvent &);
+  Boolean appinfoNone_;
+  Text appinfo_;
+};
+
+class UselinkEvent : public MarkupEvent {
+public:
+  UselinkEvent(const ConstPtr<Lpd> &,
+        const LinkSet *,
+        Boolean restore,
+        const Location &,
+        Markup *);
+  void handle(EventHandler &);
+  const ConstPtr<Lpd> &lpd() const;
+  const LinkSet *linkSet() const;
+  Boolean restore() const;
+private:
+  UselinkEvent(const UselinkEvent &);
+  void operator=(const UselinkEvent &);
+  ConstPtr<Lpd> lpd_;
+  const LinkSet *linkSet_;
+  Boolean restore_;
+};
+
+class UsemapEvent : public MarkupEvent {
+public:
+  UsemapEvent(const ShortReferenceMap *,
+       Vector<const ElementType *> &,
+       const ConstPtr<Dtd> &,
+       const Location &,
+       Markup *);
+  void handle(EventHandler &);
+  const ShortReferenceMap *map() const;
+  const Vector<const ElementType *> &elements() const;
+private:
+  UsemapEvent(const UsemapEvent &);
+  void operator=(const UsemapEvent &);
+  ConstPtr<Dtd> dtd_;
+  Vector<const ElementType *> elements_;
+  const ShortReferenceMap *map_;
+};
+
+class StartSubsetEvent : public MarkupEvent {
+public:
+  StartSubsetEvent(Type,
+     const StringC &,
+     const ConstPtr<Entity> &entity,
+     Boolean hasInternalSubset,
+     const Location &,
+     Markup *);
+  const StringC &name() const;
+  const ConstPtr<Entity> &entity() const;
+  Boolean hasInternalSubset() const;
+private:
+  StartSubsetEvent(const StartSubsetEvent &);
+  void operator=(const StartSubsetEvent &);
+  StringC name_;
+  ConstPtr<Entity> entity_;
+  Boolean hasInternalSubset_;
+};
+
+class StartDtdEvent : public StartSubsetEvent {
+public:
+  StartDtdEvent(const StringC &,
+  const ConstPtr<Entity> &entity,
+  Boolean hasInternalSubset,
+  const Location &,
+  Markup *);
+  void handle(EventHandler &);
+private:
+  StartDtdEvent(const StartDtdEvent &);
+  void operator=(const StartDtdEvent &);
+};
+
+class StartLpdEvent : public StartSubsetEvent {
+public:
+  StartLpdEvent(Boolean active,
+  const StringC &,
+  const ConstPtr<Entity> &entity,
+  Boolean hasInternalSubset,
+  const Location &,
+  Markup *);
+  void handle(EventHandler &);
+  Boolean active() const;
+private:
+  StartLpdEvent(const StartLpdEvent &);
+  void operator=(const StartLpdEvent &);
+  Boolean active_;
+};
+
+class EndDtdEvent : public MarkupEvent {
+public:
+  EndDtdEvent(const ConstPtr<Dtd> &, const Location &,
+       Markup *);
+  void handle(EventHandler &);
+  const Dtd &dtd() const;
+  const ConstPtr<Dtd> &dtdPointer() const;
+private:
+  EndDtdEvent(const EndDtdEvent &);
+  void operator=(const EndDtdEvent &);
+  ConstPtr<Dtd> dtd_;
+};
+
+class EndLpdEvent : public MarkupEvent {
+public:
+  EndLpdEvent(const ConstPtr<Lpd> &, const Location &,
+       Markup *);
+  void handle(EventHandler &);
+  const Lpd &lpd() const;
+  const ConstPtr<Lpd> &lpdPointer() const;
+private:
+  EndLpdEvent(const EndLpdEvent &);
+  void operator=(const EndLpdEvent &);
+  ConstPtr<Lpd> lpd_;
+};
+
+class EndPrologEvent : public LocatedEvent {
+public:
+  EndPrologEvent(const ConstPtr<Dtd> &dtd,
+   const ConstPtr<ComplexLpd> &lpd,
+   Vector<StringC> &simpleLinkNames,
+   Vector<AttributeList> &simpleLinkAttributes,
+   const Location &);
+  EndPrologEvent(const ConstPtr<Dtd> &dtd,
+   const Location &);
+  void handle(EventHandler &);
+  const Dtd &dtd() const;
+  const ConstPtr<Dtd> &dtdPointer() const;
+  const ConstPtr<ComplexLpd> &lpdPointer() const;
+  const Vector<StringC> &simpleLinkNames() const;
+  const Vector<AttributeList> &simpleLinkAttributes() const;
+private:
+  EndPrologEvent(const EndPrologEvent &);
+  void operator=(const EndPrologEvent &);
+  ConstPtr<Dtd> dtd_;
+  ConstPtr<ComplexLpd> lpd_;
+  Vector<StringC> simpleLinkNames_;
+  Vector<AttributeList> simpleLinkAttributes_;
+};
+
+class SgmlDeclEvent : public MarkupEvent {
+public:
+
+  SgmlDeclEvent(const ConstPtr<Sd> &,
+  const ConstPtr<Syntax> &syntax);
+
+  SgmlDeclEvent(const ConstPtr<Sd> &,
+  const ConstPtr<Syntax> &syntax,
+  const ConstPtr<Syntax> &instanceSyntax,
+  const ConstPtr<Sd> &refSd,
+  const ConstPtr<Syntax> &refSyntax,
+  Index nextIndex,
+  const StringC &implySystemId,
+  const Location &,
+  Markup *);
+  void handle(EventHandler &);
+  const Sd &sd() const;
+  const ConstPtr<Sd> &sdPointer() const;
+  const Syntax &prologSyntax() const;
+  const ConstPtr<Syntax> &prologSyntaxPointer() const;
+  const Syntax &instanceSyntax() const;
+  const ConstPtr<Syntax> &instanceSyntaxPointer() const;
+  const ConstPtr<Sd> &refSdPointer() const;
+  const ConstPtr<Syntax> &refSyntaxPointer() const;
+  const StringC &implySystemId() const;
+private:
+  SgmlDeclEvent(const SgmlDeclEvent &);
+  void operator=(const SgmlDeclEvent &);
+  ConstPtr<Sd> sd_;
+  ConstPtr<Syntax> prologSyntax_;
+  ConstPtr<Syntax> instanceSyntax_;
+  ConstPtr<Sd> refSd_;
+  ConstPtr<Syntax> refSyntax_;
+  Index nextIndex_;
+  StringC implySystemId_;
+};
+
+class CommentDeclEvent : public MarkupEvent {
+public:
+  CommentDeclEvent(const Location &, Markup *);
+  void handle(EventHandler &);
+private:
+  CommentDeclEvent(const CommentDeclEvent &);
+  void operator=(const CommentDeclEvent &);
+};
+
+class SSepEvent : public ImmediateDataEvent {
+public:
+  SSepEvent(const Char *, size_t, const Location &, Boolean copy);
+  void handle(EventHandler &);
+private:
+  SSepEvent(const SSepEvent &);
+  void operator=(const SSepEvent &);
+};
+
+class IgnoredRsEvent : public LocatedEvent {
+public:
+  IgnoredRsEvent(Char c, const Location &);
+  void handle(EventHandler &);
+  Char rs() const;
+private:
+  IgnoredRsEvent(const IgnoredRsEvent &);
+  void operator=(const IgnoredRsEvent &);
+  Char c_;
+};
+
+class IgnoredReEvent : public LocatedEvent {
+public:
+  IgnoredReEvent(Char c, const Location &, unsigned long serial);
+  void handle(EventHandler &);
+  Char re() const;
+  unsigned long serial() const;
+private:
+  IgnoredReEvent(const IgnoredReEvent &);
+  void operator=(const IgnoredReEvent &);
+  unsigned long serial_;
+  Char c_;
+};
+
+class ReEvent : public ImmediateDataEvent {
+public:
+  ReEvent(const Char *, const Location &, unsigned long serial);
+  Boolean isRe(unsigned long &serial) const;
+private:
+  ReEvent(const ReEvent &);
+  void operator=(const ReEvent &);
+  unsigned long serial_;
+};
+
+class ReOriginEvent : public LocatedEvent {
+public:
+  ReOriginEvent(Char c, const Location &, unsigned long serial);
+  void handle(EventHandler &);
+  Char re() const;
+  unsigned long serial() const;
+private:
+  ReOriginEvent(const ReOriginEvent &);
+  void operator=(const ReOriginEvent &);
+  unsigned long serial_;
+  Char c_;
+};
+
+class IgnoredCharsEvent : public ImmediateDataEvent {
+public:
+  IgnoredCharsEvent(const Char *, size_t, const Location &, Boolean copy);
+  void handle(EventHandler &);
+private:
+  IgnoredCharsEvent(const IgnoredCharsEvent &);
+  void operator=(const IgnoredCharsEvent &);
+};
+
+class MarkedSectionEvent : public MarkupEvent {
+public:
+  enum Status { include, rcdata, cdata, ignore };
+  MarkedSectionEvent(Type, Status, const Location &, Markup *);
+  Status status() const;
+private:
+  MarkedSectionEvent(const MarkedSectionEvent &);
+  void operator=(const MarkedSectionEvent &);
+  Status status_;
+};
+
+class MarkedSectionStartEvent : public MarkedSectionEvent {
+public:
+  MarkedSectionStartEvent(Status, const Location &, Markup *);
+  void handle(EventHandler &);
+private:
+  MarkedSectionStartEvent(const MarkedSectionStartEvent &);
+  void operator=(const MarkedSectionStartEvent &);
+};
+
+class MarkedSectionEndEvent : public MarkedSectionEvent {
+public:
+  MarkedSectionEndEvent(Status, const Location &, Markup *);
+  void handle(EventHandler &);
+private:
+  MarkedSectionEndEvent(const MarkedSectionEndEvent &);
+  void operator=(const MarkedSectionEndEvent &);
+};
+
+class EntityStartEvent : public Event {
+public:
+  EntityStartEvent(const ConstPtr<EntityOrigin> &origin);
+  void handle(EventHandler &);
+  const Entity *entity() const;
+  const ConstPtr<EntityOrigin> &entityOrigin() const;
+private:
+  EntityStartEvent(const EntityStartEvent &);
+  void operator=(const EntityStartEvent &);
+
+  ConstPtr<EntityOrigin> origin_;
+};
+
+class EntityEndEvent : public LocatedEvent {
+public:
+  EntityEndEvent(const Location &);
+  void handle(EventHandler &);
+private:
+  EntityEndEvent(const EntityEndEvent &);
+  void operator=(const EntityEndEvent &);
+};
+
+class EntityDeclEvent : public MarkupEvent {
+public:
+  EntityDeclEvent(const ConstPtr<Entity> &,
+    Boolean ignored,
+    const Location &,
+    Markup *);
+  void handle(EventHandler &);
+  const Entity &entity() const;
+  const ConstPtr<Entity> &entityPointer() const;
+  Boolean ignored() const;
+
+private:
+  Boolean ignored_;
+
+  ConstPtr<Entity> entity_;
+};
+
+class NotationDeclEvent : public MarkupEvent {
+public:
+  NotationDeclEvent(const ConstPtr<Notation> &,
+      const Location &,
+      Markup *);
+  void handle(EventHandler &);
+  const Notation &notation() const;
+  const ConstPtr<Notation> &notationPointer() const;
+private:
+  NotationDeclEvent(const NotationDeclEvent &);
+  void operator=(const NotationDeclEvent &);
+  ConstPtr<Notation> notation_;
+};
+
+class ElementDeclEvent : public MarkupEvent {
+public:
+  ElementDeclEvent(Vector<const ElementType *> &elements,
+     const ConstPtr<Dtd> &,
+     const Location &,
+     Markup *);
+  void handle(EventHandler &);
+  const Vector<const ElementType *> &elements() const;
+private:
+  ElementDeclEvent(const ElementDeclEvent &);
+  void operator=(const ElementDeclEvent &);
+  Vector<const ElementType *> elements_;
+  ConstPtr<Dtd> dtd_;
+};
+
+class AttlistDeclEvent : public MarkupEvent {
+public:
+  AttlistDeclEvent(Vector<const ElementType *> &elements,
+     const ConstPtr<Dtd> &,
+     const Location &,
+     Markup *);
+  void handle(EventHandler &);
+  const Vector<const ElementType *> &elements() const;
+private:
+  AttlistDeclEvent(const AttlistDeclEvent &);
+  void operator=(const AttlistDeclEvent &);
+  Vector<const ElementType *> elements_;
+  ConstPtr<Dtd> dtd_;
+};
+
+class AttlistNotationDeclEvent : public MarkupEvent {
+public:
+  AttlistNotationDeclEvent(Vector<ConstPtr<Notation> > &notations,
+      const Location &,
+      Markup *);
+  void handle(EventHandler &);
+  const Vector<ConstPtr<Notation> > &notations() const;
+private:
+  AttlistNotationDeclEvent(const AttlistNotationDeclEvent &);
+  void operator=(const AttlistDeclEvent &);
+  Vector<ConstPtr<Notation> > notations_;
+};
+
+class LinkAttlistDeclEvent : public MarkupEvent {
+public:
+  LinkAttlistDeclEvent(Vector<const ElementType *> &elements,
+         const ConstPtr<Lpd> &,
+         const Location &,
+         Markup *);
+  void handle(EventHandler &);
+  const Vector<const ElementType *> &elements() const;
+  const Lpd &lpd() const;
+private:
+  LinkAttlistDeclEvent(const LinkAttlistDeclEvent &);
+  void operator=(const LinkAttlistDeclEvent &);
+  Vector<const ElementType *> elements_;
+  ConstPtr<Lpd> lpd_;
+};
+
+class LinkDeclEvent : public MarkupEvent {
+public:
+  LinkDeclEvent(const LinkSet *linkSet,
+  const ConstPtr<ComplexLpd> &,
+  const Location &,
+  Markup *);
+  void handle(EventHandler &);
+  const LinkSet *linkSet() const;
+  const ComplexLpd &lpd() const;
+private:
+  LinkDeclEvent(const LinkDeclEvent &);
+  void operator=(const LinkDeclEvent &);
+  const LinkSet *linkSet_;
+  ConstPtr<ComplexLpd> lpd_;
+};
+
+class IdLinkDeclEvent : public MarkupEvent {
+public:
+  IdLinkDeclEvent(const ConstPtr<ComplexLpd> &,
+    const Location &,
+    Markup *);
+  void handle(EventHandler &);
+  const ComplexLpd &lpd() const;
+private:
+  IdLinkDeclEvent(const IdLinkDeclEvent &);
+  void operator=(const IdLinkDeclEvent &);
+  ConstPtr<ComplexLpd> lpd_;
+};
+
+class ShortrefDeclEvent : public MarkupEvent {
+public:
+  ShortrefDeclEvent(const ShortReferenceMap *,
+      const ConstPtr<Dtd> &,
+      const Location &,
+      Markup *);
+  void handle(EventHandler &);
+  const ShortReferenceMap *map() const;
+private:
+  ShortrefDeclEvent(const ShortrefDeclEvent &);
+  void operator=(const ShortrefDeclEvent &);
+  const ShortReferenceMap *map_;
+  ConstPtr<Dtd> dtd_;
+};
+
+class IgnoredMarkupEvent : public MarkupEvent {
+public:
+  IgnoredMarkupEvent(const Location &, Markup *);
+  void handle(EventHandler &);
+private:
+  IgnoredMarkupEvent(const IgnoredMarkupEvent &);
+  void operator=(const IgnoredMarkupEvent &);
+};
+
+
+
+
+
+
+class EntityDefaultedEvent : public LocatedEvent {
+public:
+  EntityDefaultedEvent(const ConstPtr<Entity> &,
+         const Location &);
+  void handle(EventHandler &);
+  const Entity &entity() const;
+  const ConstPtr<Entity> &entityPointer() const;
+private:
+  EntityDefaultedEvent(const EntityDefaultedEvent &);
+  void operator=(const EntityDefaultedEvent &);
+  ConstPtr<Entity> entity_;
+};
+
+class SgmlDeclEntityEvent : public LocatedEvent {
+public:
+  SgmlDeclEntityEvent(const PublicId &publicId,
+        PublicId::TextClass entityType,
+        const StringC &effectiveSystemId,
+        const Location &);
+  void handle(EventHandler &);
+  const PublicId &publicId() const;
+  PublicId::TextClass entityType() const;
+  const StringC &effectiveSystemId() const;
+private:
+  SgmlDeclEntityEvent(const SgmlDeclEntityEvent &);
+  void operator=(const SgmlDeclEntityEvent &);
+  PublicId publicId_;
+  PublicId::TextClass entityType_;
+  StringC effectiveSystemId_;
+};
+
+class EventHandler {
+public:
+  virtual ~EventHandler();
+  virtual void message(MessageEvent *) = 0;
+  virtual void data(DataEvent *);
+  virtual void startElement(StartElementEvent *);
+  virtual void endElement(EndElementEvent *);
+  virtual void pi(PiEvent *);
+  virtual void sdataEntity(SdataEntityEvent *);
+  virtual void externalDataEntity(ExternalDataEntityEvent *);
+  virtual void subdocEntity(SubdocEntityEvent *);
+  virtual void nonSgmlChar(NonSgmlCharEvent *);
+  virtual void appinfo(AppinfoEvent *);
+  virtual void uselink(UselinkEvent *);
+  virtual void usemap(UsemapEvent *);
+  virtual void startDtd(StartDtdEvent *);
+  virtual void endDtd(EndDtdEvent *);
+  virtual void startLpd(StartLpdEvent *);
+  virtual void endLpd(EndLpdEvent *);
+  virtual void endProlog(EndPrologEvent *);
+  virtual void sgmlDecl(SgmlDeclEvent *);
+  virtual void commentDecl(CommentDeclEvent *);
+  virtual void sSep(SSepEvent *);
+  virtual void ignoredRs(IgnoredRsEvent *);
+  virtual void ignoredRe(IgnoredReEvent *);
+  virtual void reOrigin(ReOriginEvent *);
+  virtual void ignoredChars(IgnoredCharsEvent *);
+  virtual void markedSectionStart(MarkedSectionStartEvent *);
+  virtual void markedSectionEnd(MarkedSectionEndEvent *);
+  virtual void entityStart(EntityStartEvent *);
+  virtual void entityEnd(EntityEndEvent *);
+  virtual void notationDecl(NotationDeclEvent *);
+  virtual void entityDecl(EntityDeclEvent *);
+  virtual void elementDecl(ElementDeclEvent *);
+  virtual void attlistDecl(AttlistDeclEvent *);
+  virtual void linkAttlistDecl(LinkAttlistDeclEvent *);
+  virtual void attlistNotationDecl(AttlistNotationDeclEvent *);
+  virtual void linkDecl(LinkDeclEvent *);
+  virtual void idLinkDecl(IdLinkDeclEvent *);
+  virtual void shortrefDecl(ShortrefDeclEvent *);
+  virtual void ignoredMarkup(IgnoredMarkupEvent *);
+  virtual void entityDefaulted(EntityDefaultedEvent *);
+  virtual void inputClosed(InputSource *in);
+  virtual void inputOpened(InputSource *in);
+  virtual void sgmlDeclEntity(SgmlDeclEntityEvent *);
+};
+
+inline
+Event::Event(Type type)
+: type_(type)
+{
+}
+
+inline
+Event::Type Event::type() const
+{
+  return type_;
+}
+
+inline
+const Location &LocatedEvent::location() const
+{
+  return location_;
+}
+
+inline
+const Markup &MarkupEvent::markup() const
+{
+  return markup_;
+}
+
+inline
+const Message &MessageEvent::message() const
+{
+  return message_;
+}
+
+inline
+const ElementType *StartElementEvent::elementType() const
+{
+  return elementType_;
+}
+
+inline
+const StringC &StartElementEvent::name() const
+{
+  return elementType_->name();
+}
+
+inline
+void StartElementEvent::setIncluded()
+{
+  included_ = 1;
+}
+
+inline
+Boolean StartElementEvent::included() const
+{
+  return included_;
+}
+
+inline
+const Markup *StartElementEvent::markupPtr() const
+{
+  return markup_;
+}
+
+inline
+const AttributeList &StartElementEvent::attributes() const
+{
+  return *attributes_;
+}
+
+inline
+Boolean StartElementEvent::mustOmitEnd() const
+{
+  return ((elementType()->definition()->declaredContent()
+    == ElementDefinition::empty)
+   || attributes_->conref());
+}
+
+inline
+const ElementType *EndElementEvent::elementType() const
+{
+  return elementType_;
+}
+
+inline
+const StringC &EndElementEvent::name() const
+{
+  return elementType_->name();
+}
+
+inline
+void EndElementEvent::setIncluded()
+{
+  included_ = 1;
+}
+
+inline
+Boolean EndElementEvent::included() const
+{
+  return included_;
+}
+
+inline
+const Markup *EndElementEvent::markupPtr() const
+{
+  return markup_;
+}
+
+inline
+const Char *DataEvent::data() const
+{
+  return p_;
+}
+
+inline
+size_t DataEvent::dataLength() const
+{
+  return length_;
+}
+
+inline
+const Char *PiEvent::data() const
+{
+  return data_;
+}
+
+inline
+size_t PiEvent::dataLength() const
+{
+  return dataLength_;
+}
+
+inline
+const ConstPtr<EntityOrigin> &
+ExternalEntityEvent::entityOrigin() const
+{
+  return origin_;
+}
+
+inline
+const Location &ExternalEntityEvent::location() const
+{
+  return origin_->parent();
+}
+
+inline
+const ExternalDataEntity *ExternalDataEntityEvent::entity() const
+{
+  return dataEntity_;
+}
+
+inline
+const SubdocEntity *SubdocEntityEvent::entity() const
+{
+  return subdocEntity_;
+}
+
+inline
+Char NonSgmlCharEvent::character() const
+{
+  return c_;
+}
+
+inline
+Boolean AppinfoEvent::literal(const StringC *&p) const
+{
+  if (appinfoNone_)
+    return 0;
+  p = &appinfo_.string();
+  return 1;
+}
+
+inline
+const ConstPtr<Lpd> &UselinkEvent::lpd() const
+{
+  return lpd_;
+}
+
+inline
+const LinkSet *UselinkEvent::linkSet() const
+{
+  return linkSet_;
+}
+
+inline
+Boolean UselinkEvent::restore() const
+{
+  return restore_;
+}
+
+inline
+const ShortReferenceMap *UsemapEvent::map() const
+{
+  return map_;
+}
+
+inline
+const StringC &StartSubsetEvent::name() const
+{
+  return name_;
+}
+
+inline
+const ConstPtr<Entity> &StartSubsetEvent::entity() const
+{
+  return entity_;
+}
+
+inline
+Boolean StartSubsetEvent::hasInternalSubset() const
+{
+  return hasInternalSubset_;
+}
+
+inline
+Boolean StartLpdEvent::active() const
+{
+  return active_;
+}
+
+inline
+const Dtd &EndDtdEvent::dtd() const
+{
+  return *dtd_;
+}
+
+inline
+const ConstPtr<Dtd> &EndDtdEvent::dtdPointer() const
+{
+  return dtd_;
+}
+
+inline
+const Lpd &EndLpdEvent::lpd() const
+{
+  return *lpd_;
+}
+
+inline
+const ConstPtr<Lpd> &EndLpdEvent::lpdPointer() const
+{
+  return lpd_;
+}
+
+inline
+const Dtd &EndPrologEvent::dtd() const
+{
+  return *dtd_;
+}
+
+inline
+const ConstPtr<Dtd> &EndPrologEvent::dtdPointer() const
+{
+  return dtd_;
+}
+
+inline
+const ConstPtr<ComplexLpd> &EndPrologEvent::lpdPointer() const
+{
+  return lpd_;
+}
+
+inline
+const Vector<StringC> &EndPrologEvent::simpleLinkNames() const
+{
+  return simpleLinkNames_;
+}
+
+inline
+const Vector<AttributeList> &EndPrologEvent::simpleLinkAttributes() const
+{
+  return simpleLinkAttributes_;
+}
+
+inline
+const Sd &SgmlDeclEvent::sd() const
+{
+  return *sd_;
+}
+
+inline
+const ConstPtr<Sd> &SgmlDeclEvent::sdPointer() const
+{
+  return sd_;
+}
+
+inline
+const ConstPtr<Sd> &SgmlDeclEvent::refSdPointer() const
+{
+  return refSd_;
+}
+
+inline
+const Syntax &SgmlDeclEvent::prologSyntax() const
+{
+  return *prologSyntax_;
+}
+
+inline
+const ConstPtr<Syntax> &SgmlDeclEvent::prologSyntaxPointer() const
+{
+  return prologSyntax_;
+}
+
+inline
+const Syntax &SgmlDeclEvent::instanceSyntax() const
+{
+  return *instanceSyntax_;
+}
+
+inline
+const ConstPtr<Syntax> &SgmlDeclEvent::instanceSyntaxPointer() const
+{
+  return instanceSyntax_;
+}
+
+inline
+const ConstPtr<Syntax> &SgmlDeclEvent::refSyntaxPointer() const
+{
+  return refSyntax_;
+}
+
+inline
+const StringC &SgmlDeclEvent::implySystemId() const
+{
+  return implySystemId_;
+}
+
+inline
+Char IgnoredRsEvent::rs() const
+{
+  return c_;
+}
+
+inline
+Char IgnoredReEvent::re() const
+{
+  return c_;
+}
+
+inline
+unsigned long IgnoredReEvent::serial() const
+{
+  return serial_;
+}
+
+inline
+Char ReOriginEvent::re() const
+{
+  return c_;
+}
+
+inline
+unsigned long ReOriginEvent::serial() const
+{
+  return serial_;
+}
+
+inline
+MarkedSectionEvent::Status MarkedSectionEvent::status() const
+{
+  return status_;
+}
+
+inline
+const Entity *EntityStartEvent::entity() const
+{
+  return origin_->entity();
+}
+
+inline
+const ConstPtr<EntityOrigin> &
+EntityStartEvent::entityOrigin() const
+{
+  return origin_;
+}
+
+inline
+const ConstPtr<Entity> &EntityDeclEvent::entityPointer() const
+{
+  return entity_;
+}
+
+inline
+const Entity &EntityDeclEvent::entity() const
+{
+  return *entity_;
+}
+
+inline
+Boolean EntityDeclEvent::ignored() const
+{
+  return ignored_;
+}
+
+inline
+const Notation &NotationDeclEvent::notation() const
+{
+  return *notation_;
+}
+
+inline
+const ConstPtr<Notation> &NotationDeclEvent::notationPointer() const
+{
+  return notation_;
+}
+
+inline
+const Vector<const ElementType *> &ElementDeclEvent::elements() const
+{
+  return elements_;
+}
+
+inline
+const Vector<const ElementType *> &AttlistDeclEvent::elements() const
+{
+  return elements_;
+}
+
+inline
+const Vector<const ElementType *> &LinkAttlistDeclEvent::elements() const
+{
+  return elements_;
+}
+
+inline
+const Lpd &LinkAttlistDeclEvent::lpd() const
+{
+  return *lpd_;
+}
+
+inline
+const LinkSet *LinkDeclEvent::linkSet() const
+{
+  return linkSet_;
+}
+
+inline
+const ComplexLpd &LinkDeclEvent::lpd() const
+{
+  return *lpd_;
+}
+
+inline
+const ComplexLpd &IdLinkDeclEvent::lpd() const
+{
+  return *lpd_;
+}
+
+inline
+const Vector<ConstPtr<Notation> > &
+AttlistNotationDeclEvent::notations() const
+{
+  return notations_;
+}
+
+inline
+const ShortReferenceMap *ShortrefDeclEvent::map() const
+{
+  return map_;
+}
+
+inline
+const Entity &EntityDefaultedEvent::entity() const
+{
+  return *entity_;
+}
+
+inline
+const ConstPtr<Entity> &EntityDefaultedEvent::entityPointer()
+     const
+{
+  return entity_;
+}
+
+inline
+const PublicId &SgmlDeclEntityEvent::publicId() const
+{
+  return publicId_;
+}
+
+inline
+PublicId::TextClass SgmlDeclEntityEvent::entityType() const
+{
+  return entityType_;
+}
+
+inline
+const StringC &SgmlDeclEntityEvent::effectiveSystemId() const
+{
+  return effectiveSystemId_;
+}
+
+
+}
+# 13 "GroveBuilder.cxx" 2
+# 1 "GroveBuilder.h" 1
+# 21 "GroveBuilder.h"
+namespace OpenSP {
+
+
+class Messenger;
+class ErrorCountEventHandler;
+class MessageFormatter;
+
+class GroveBuilder {
+public:
+  static bool setBlocking(bool);
+  static ErrorCountEventHandler *make(unsigned index,
+          Messenger *,
+          MessageFormatter *,
+          bool validateOnly,
+          OpenJade_Grove:: NodePtr &root);
+  static ErrorCountEventHandler *make(unsigned index,
+          Messenger *,
+          MessageFormatter *,
+          bool validateOnly,
+          const ConstPtr<Sd> &sd,
+          const ConstPtr<Syntax> &prologSyntax,
+          const ConstPtr<Syntax> &instanceSyntax,
+          OpenJade_Grove:: NodePtr &root);
+private:
+  GroveBuilder();
+};
+
+
+}
+# 14 "GroveBuilder.cxx" 2
+# 1 "/usr/include/OpenSP/ErrorCountEventHandler.h" 1 3 4
+
+
+
+
+
+
+
+#pragma interface
+
+
+# 1 "/usr/include/signal.h" 1 3 4
+# 31 "/usr/include/signal.h" 3 4
+extern "C" {
+
+# 1 "/usr/include/bits/sigset.h" 1 3 4
+# 103 "/usr/include/bits/sigset.h" 3 4
+extern int __sigismember (__const __sigset_t *, int);
+extern int __sigaddset (__sigset_t *, int);
+extern int __sigdelset (__sigset_t *, int);
+# 117 "/usr/include/bits/sigset.h" 3 4
+extern __inline int __sigismember (__const __sigset_t *__set, int __sig) { unsigned long int __mask = (((unsigned long int) 1) << (((__sig) - 1) % (8 * sizeof (unsigned long int)))); unsigned long int __word = (((__sig) - 1) / (8 * sizeof (unsigned long int))); return (__set->__val[__word] & __mask) ? 1 : 0; }
+extern __inline int __sigaddset ( __sigset_t *__set, int __sig) { unsigned long int __mask = (((unsigned long int) 1) << (((__sig) - 1) % (8 * sizeof (unsigned long int)))); unsigned long int __word = (((__sig) - 1) / (8 * sizeof (unsigned long int))); return ((__set->__val[__word] |= __mask), 0); }
+extern __inline int __sigdelset ( __sigset_t *__set, int __sig) { unsigned long int __mask = (((unsigned long int) 1) << (((__sig) - 1) % (8 * sizeof (unsigned long int)))); unsigned long int __word = (((__sig) - 1) / (8 * sizeof (unsigned long int))); return ((__set->__val[__word] &= ~__mask), 0); }
+# 34 "/usr/include/signal.h" 2 3 4
+
+
+
+
+
+
+
+typedef __sig_atomic_t sig_atomic_t;
+
+# 58 "/usr/include/signal.h" 3 4
+# 1 "/usr/include/bits/signum.h" 1 3 4
+# 59 "/usr/include/signal.h" 2 3 4
+# 73 "/usr/include/signal.h" 3 4
+typedef void (*__sighandler_t) (int);
+
+
+
+
+extern __sighandler_t __sysv_signal (int __sig, __sighandler_t __handler)
+     throw ();
+
+extern __sighandler_t sysv_signal (int __sig, __sighandler_t __handler)
+     throw ();
+
+
+
+
+
+
+
+extern __sighandler_t signal (int __sig, __sighandler_t __handler) throw ();
+# 102 "/usr/include/signal.h" 3 4
+
+
+
+
+
+extern __sighandler_t bsd_signal (int __sig, __sighandler_t __handler) throw ();
+
+
+
+
+
+
+extern int kill (__pid_t __pid, int __sig) throw ();
+
+
+
+
+
+
+extern int killpg (__pid_t __pgrp, int __sig) throw ();
+
+
+
+
+extern int raise (int __sig) throw ();
+
+
+
+
+extern __sighandler_t ssignal (int __sig, __sighandler_t __handler) throw ();
+extern int gsignal (int __sig) throw ();
+
+
+
+
+extern void psignal (int __sig, __const char *__s);
+# 149 "/usr/include/signal.h" 3 4
+extern int __sigpause (int __sig_or_mask, int __is_sig);
+
+
+
+
+extern int sigpause (int __mask) throw ();
+# 177 "/usr/include/signal.h" 3 4
+extern int sigblock (int __mask) throw ();
+
+
+extern int sigsetmask (int __mask) throw ();
+
+
+extern int siggetmask (void) throw ();
+# 192 "/usr/include/signal.h" 3 4
+typedef __sighandler_t sighandler_t;
+
+
+
+
+typedef __sighandler_t sig_t;
+
+
+
+
+
+
+
+# 1 "/usr/include/time.h" 1 3 4
+# 206 "/usr/include/signal.h" 2 3 4
+
+
+# 1 "/usr/include/bits/siginfo.h" 1 3 4
+# 25 "/usr/include/bits/siginfo.h" 3 4
+# 1 "/usr/include/bits/wordsize.h" 1 3 4
+# 26 "/usr/include/bits/siginfo.h" 2 3 4
+
+
+
+
+
+
+
+typedef union sigval
+  {
+    int sival_int;
+    void *sival_ptr;
+  } sigval_t;
+# 51 "/usr/include/bits/siginfo.h" 3 4
+typedef struct siginfo
+  {
+    int si_signo;
+    int si_errno;
+
+    int si_code;
+
+    union
+      {
+ int _pad[((128 / sizeof (int)) - 3)];
+
+
+ struct
+   {
+     __pid_t si_pid;
+     __uid_t si_uid;
+   } _kill;
+
+
+ struct
+   {
+     int si_tid;
+     int si_overrun;
+     sigval_t si_sigval;
+   } _timer;
+
+
+ struct
+   {
+     __pid_t si_pid;
+     __uid_t si_uid;
+     sigval_t si_sigval;
+   } _rt;
+
+
+ struct
+   {
+     __pid_t si_pid;
+     __uid_t si_uid;
+     int si_status;
+     __clock_t si_utime;
+     __clock_t si_stime;
+   } _sigchld;
+
+
+ struct
+   {
+     void *si_addr;
+   } _sigfault;
+
+
+ struct
+   {
+     long int si_band;
+     int si_fd;
+   } _sigpoll;
+      } _sifields;
+  } siginfo_t;
+# 129 "/usr/include/bits/siginfo.h" 3 4
+enum
+{
+  SI_ASYNCNL = -60,
+
+  SI_TKILL = -6,
+
+  SI_SIGIO,
+
+  SI_ASYNCIO,
+
+  SI_MESGQ,
+
+  SI_TIMER,
+
+  SI_QUEUE,
+
+  SI_USER,
+
+  SI_KERNEL = 0x80
+
+};
+
+
+
+enum
+{
+  ILL_ILLOPC = 1,
+
+  ILL_ILLOPN,
+
+  ILL_ILLADR,
+
+  ILL_ILLTRP,
+
+  ILL_PRVOPC,
+
+  ILL_PRVREG,
+
+  ILL_COPROC,
+
+  ILL_BADSTK
+
+};
+
+
+enum
+{
+  FPE_INTDIV = 1,
+
+  FPE_INTOVF,
+
+  FPE_FLTDIV,
+
+  FPE_FLTOVF,
+
+  FPE_FLTUND,
+
+  FPE_FLTRES,
+
+  FPE_FLTINV,
+
+  FPE_FLTSUB
+
+};
+
+
+enum
+{
+  SEGV_MAPERR = 1,
+
+  SEGV_ACCERR
+
+};
+
+
+enum
+{
+  BUS_ADRALN = 1,
+
+  BUS_ADRERR,
+
+  BUS_OBJERR
+
+};
+
+
+enum
+{
+  TRAP_BRKPT = 1,
+
+  TRAP_TRACE
+
+};
+
+
+enum
+{
+  CLD_EXITED = 1,
+
+  CLD_KILLED,
+
+  CLD_DUMPED,
+
+  CLD_TRAPPED,
+
+  CLD_STOPPED,
+
+  CLD_CONTINUED
+
+};
+
+
+enum
+{
+  POLL_IN = 1,
+
+  POLL_OUT,
+
+  POLL_MSG,
+
+  POLL_ERR,
+
+  POLL_PRI,
+
+  POLL_HUP
+
+};
+# 273 "/usr/include/bits/siginfo.h" 3 4
+typedef struct sigevent
+  {
+    sigval_t sigev_value;
+    int sigev_signo;
+    int sigev_notify;
+
+    union
+      {
+ int _pad[((64 / sizeof (int)) - 3)];
+
+
+
+ __pid_t _tid;
+
+ struct
+   {
+     void (*_function) (sigval_t);
+     void *_attribute;
+   } _sigev_thread;
+      } _sigev_un;
+  } sigevent_t;
+
+
+
+
+
+
+enum
+{
+  SIGEV_SIGNAL = 0,
+
+  SIGEV_NONE,
+
+  SIGEV_THREAD,
+
+
+  SIGEV_THREAD_ID = 4
+
+};
+# 209 "/usr/include/signal.h" 2 3 4
+
+
+
+extern int sigemptyset (sigset_t *__set) throw ();
+
+
+extern int sigfillset (sigset_t *__set) throw ();
+
+
+extern int sigaddset (sigset_t *__set, int __signo) throw ();
+
+
+extern int sigdelset (sigset_t *__set, int __signo) throw ();
+
+
+extern int sigismember (__const sigset_t *__set, int __signo) throw ();
+
+
+
+extern int sigisemptyset (__const sigset_t *__set) throw ();
+
+
+extern int sigandset (sigset_t *__set, __const sigset_t *__left,
+        __const sigset_t *__right) throw ();
+
+
+extern int sigorset (sigset_t *__set, __const sigset_t *__left,
+       __const sigset_t *__right) throw ();
+
+
+
+
+# 1 "/usr/include/bits/sigaction.h" 1 3 4
+# 25 "/usr/include/bits/sigaction.h" 3 4
+struct sigaction
+  {
+
+
+    union
+      {
+
+ __sighandler_t sa_handler;
+
+ void (*sa_sigaction) (int, siginfo_t *, void *);
+      }
+    __sigaction_handler;
+
+
+
+
+
+
+
+    __sigset_t sa_mask;
+
+
+    int sa_flags;
+
+
+    void (*sa_restorer) (void);
+  };
+# 242 "/usr/include/signal.h" 2 3 4
+
+
+extern int sigprocmask (int __how, __const sigset_t *__restrict __set,
+   sigset_t *__restrict __oset) throw ();
+
+
+
+
+
+
+extern int sigsuspend (__const sigset_t *__set);
+
+
+extern int sigaction (int __sig, __const struct sigaction *__restrict __act,
+        struct sigaction *__restrict __oact) throw ();
+
+
+extern int sigpending (sigset_t *__set) throw ();
+
+
+
+
+
+
+extern int sigwait (__const sigset_t *__restrict __set, int *__restrict __sig);
+
+
+
+
+
+
+extern int sigwaitinfo (__const sigset_t *__restrict __set,
+   siginfo_t *__restrict __info);
+
+
+
+
+
+
+extern int sigtimedwait (__const sigset_t *__restrict __set,
+    siginfo_t *__restrict __info,
+    __const struct timespec *__restrict __timeout);
+
+
+
+extern int sigqueue (__pid_t __pid, int __sig, __const union sigval __val)
+     throw ();
+# 297 "/usr/include/signal.h" 3 4
+extern __const char *__const _sys_siglist[65];
+extern __const char *__const sys_siglist[65];
+
+
+struct sigvec
+  {
+    __sighandler_t sv_handler;
+    int sv_mask;
+
+    int sv_flags;
+
+  };
+# 321 "/usr/include/signal.h" 3 4
+extern int sigvec (int __sig, __const struct sigvec *__vec,
+     struct sigvec *__ovec) throw ();
+
+
+
+# 1 "/usr/include/bits/sigcontext.h" 1 3 4
+# 28 "/usr/include/bits/sigcontext.h" 3 4
+# 1 "/usr/include/asm/sigcontext.h" 1 3 4
+
+
+
+# 1 "/usr/include/linux/compiler.h" 1 3 4
+# 5 "/usr/include/asm/sigcontext.h" 2 3 4
+# 20 "/usr/include/asm/sigcontext.h" 3 4
+struct _fpreg {
+ unsigned short significand[4];
+ unsigned short exponent;
+};
+
+struct _fpxreg {
+ unsigned short significand[4];
+ unsigned short exponent;
+ unsigned short padding[3];
+};
+
+struct _xmmreg {
+ unsigned long element[4];
+};
+
+struct _fpstate {
+
+ unsigned long cw;
+ unsigned long sw;
+ unsigned long tag;
+ unsigned long ipoff;
+ unsigned long cssel;
+ unsigned long dataoff;
+ unsigned long datasel;
+ struct _fpreg _st[8];
+ unsigned short status;
+ unsigned short magic;
+
+
+ unsigned long _fxsr_env[6];
+ unsigned long mxcsr;
+ unsigned long reserved;
+ struct _fpxreg _fxsr_st[8];
+ struct _xmmreg _xmm[8];
+ unsigned long padding[56];
+};
+
+
+
+struct sigcontext {
+ unsigned short gs, __gsh;
+ unsigned short fs, __fsh;
+ unsigned short es, __esh;
+ unsigned short ds, __dsh;
+ unsigned long edi;
+ unsigned long esi;
+ unsigned long ebp;
+ unsigned long esp;
+ unsigned long ebx;
+ unsigned long edx;
+ unsigned long ecx;
+ unsigned long eax;
+ unsigned long trapno;
+ unsigned long err;
+ unsigned long eip;
+ unsigned short cs, __csh;
+ unsigned long eflags;
+ unsigned long esp_at_signal;
+ unsigned short ss, __ssh;
+ struct _fpstate * fpstate;
+ unsigned long oldmask;
+ unsigned long cr2;
+};
+# 29 "/usr/include/bits/sigcontext.h" 2 3 4
+# 327 "/usr/include/signal.h" 2 3 4
+
+
+extern int sigreturn (struct sigcontext *__scp) throw ();
+# 339 "/usr/include/signal.h" 3 4
+extern int siginterrupt (int __sig, int __interrupt) throw ();
+
+# 1 "/usr/include/bits/sigstack.h" 1 3 4
+# 26 "/usr/include/bits/sigstack.h" 3 4
+struct sigstack
+  {
+    void *ss_sp;
+    int ss_onstack;
+  };
+
+
+
+enum
+{
+  SS_ONSTACK = 1,
+
+  SS_DISABLE
+
+};
+# 50 "/usr/include/bits/sigstack.h" 3 4
+typedef struct sigaltstack
+  {
+    void *ss_sp;
+    int ss_flags;
+    size_t ss_size;
+  } stack_t;
+# 342 "/usr/include/signal.h" 2 3 4
+
+
+# 1 "/usr/include/sys/ucontext.h" 1 3 4
+# 23 "/usr/include/sys/ucontext.h" 3 4
+# 1 "/usr/include/signal.h" 1 3 4
+# 24 "/usr/include/sys/ucontext.h" 2 3 4
+
+
+
+# 1 "/usr/include/bits/sigcontext.h" 1 3 4
+# 28 "/usr/include/sys/ucontext.h" 2 3 4
+
+
+
+typedef int greg_t;
+
+
+
+
+
+typedef greg_t gregset_t[19];
+
+
+
+enum
+{
+  REG_GS = 0,
+
+  REG_FS,
+
+  REG_ES,
+
+  REG_DS,
+
+  REG_EDI,
+
+  REG_ESI,
+
+  REG_EBP,
+
+  REG_ESP,
+
+  REG_EBX,
+
+  REG_EDX,
+
+  REG_ECX,
+
+  REG_EAX,
+
+  REG_TRAPNO,
+
+  REG_ERR,
+
+  REG_EIP,
+
+  REG_CS,
+
+  REG_EFL,
+
+  REG_UESP,
+
+  REG_SS
+
+};
+
+
+
+struct _libc_fpreg
+{
+  unsigned short int significand[4];
+  unsigned short int exponent;
+};
+
+struct _libc_fpstate
+{
+  unsigned long int cw;
+  unsigned long int sw;
+  unsigned long int tag;
+  unsigned long int ipoff;
+  unsigned long int cssel;
+  unsigned long int dataoff;
+  unsigned long int datasel;
+  struct _libc_fpreg _st[8];
+  unsigned long int status;
+};
+
+
+typedef struct _libc_fpstate *fpregset_t;
+
+
+typedef struct
+  {
+    gregset_t gregs;
+
+
+    fpregset_t fpregs;
+    unsigned long int oldmask;
+    unsigned long int cr2;
+  } mcontext_t;
+
+
+typedef struct ucontext
+  {
+    unsigned long int uc_flags;
+    struct ucontext *uc_link;
+    stack_t uc_stack;
+    mcontext_t uc_mcontext;
+    __sigset_t uc_sigmask;
+    struct _libc_fpstate __fpregs_mem;
+  } ucontext_t;
+# 345 "/usr/include/signal.h" 2 3 4
+
+
+
+
+
+extern int sigstack (struct sigstack *__ss, struct sigstack *__oss) throw ();
+
+
+
+extern int sigaltstack (__const struct sigaltstack *__restrict __ss,
+   struct sigaltstack *__restrict __oss) throw ();
+
+
+
+
+
+
+
+extern int sighold (int __sig) throw ();
+
+
+extern int sigrelse (int __sig) throw ();
+
+
+extern int sigignore (int __sig) throw ();
+
+
+extern __sighandler_t sigset (int __sig, __sighandler_t __disp) throw ();
+
+
+
+
+
+# 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
+# 379 "/usr/include/signal.h" 2 3 4
+# 1 "/usr/include/bits/sigthread.h" 1 3 4
+# 31 "/usr/include/bits/sigthread.h" 3 4
+extern int pthread_sigmask (int __how,
+       __const __sigset_t *__restrict __newmask,
+       __sigset_t *__restrict __oldmask)throw ();
+
+
+extern int pthread_kill (pthread_t __threadid, int __signo) throw ();
+# 380 "/usr/include/signal.h" 2 3 4
+
+
+
+
+
+
+extern int __libc_current_sigrtmin (void) throw ();
+
+extern int __libc_current_sigrtmax (void) throw ();
+
+
+
+}
+# 12 "/usr/include/OpenSP/ErrorCountEventHandler.h" 2 3 4
+# 1 "/usr/include/OpenSP/Event.h" 1 3 4
+# 13 "/usr/include/OpenSP/ErrorCountEventHandler.h" 2 3 4
+
+
+namespace OpenSP {
+
+
+class ErrorCountEventHandler : public EventHandler {
+public:
+  ErrorCountEventHandler(unsigned errorLimit = 0);
+  void setErrorLimit(unsigned maxErrors);
+  const sig_atomic_t *cancelPtr() const;
+  void cancel();
+  Boolean cancelled() const;
+  unsigned errorCount() const;
+  void message(MessageEvent *);
+  void noteMessage(const Message &);
+private:
+  unsigned maxErrors_;
+  unsigned errorCount_;
+  sig_atomic_t cancel_;
+};
+
+inline
+unsigned ErrorCountEventHandler::errorCount() const
+{
+  return errorCount_;
+}
+
+inline
+const sig_atomic_t *ErrorCountEventHandler::cancelPtr() const
+{
+  return &cancel_;
+}
+
+inline
+void ErrorCountEventHandler::cancel()
+{
+  cancel_ = 1;
+}
+
+inline
+void ErrorCountEventHandler::setErrorLimit(unsigned maxErrors)
+{
+  maxErrors_ = maxErrors;
+}
+
+inline
+Boolean ErrorCountEventHandler::cancelled() const
+{
+  return cancel_ != 0;
+}
+
+
+}
+# 15 "GroveBuilder.cxx" 2
+# 1 "/usr/include/OpenSP/OutputCharStream.h" 1 3 4
+
+
+
+
+
+
+
+# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
+# 9 "/usr/include/OpenSP/OutputCharStream.h" 2 3 4
+
+
+# 1 "/usr/include/OpenSP/Owner.h" 1 3 4
+# 12 "/usr/include/OpenSP/OutputCharStream.h" 2 3 4
+# 1 "/usr/include/OpenSP/CodingSystem.h" 1 3 4
+
+
+
+
+
+
+
+#pragma interface
+
+
+
+
+
+# 1 "/usr/include/OpenSP/OutputByteStream.h" 1 3 4
+
+
+
+
+
+
+
+# 1 "/usr/include/OpenSP/StringOf.h" 1 3 4
+# 9 "/usr/include/OpenSP/OutputByteStream.h" 2 3 4
+
+
+
+namespace OpenSP {
+
+
+class OutputByteStream : public Link {
+public:
+  OutputByteStream();
+  virtual ~OutputByteStream();
+  virtual void flush() = 0;
+  void sputc(char c);
+  void sputn(const char *, size_t);
+  OutputByteStream &operator<<(char);
+  OutputByteStream &operator<<(unsigned char);
+  OutputByteStream &operator<<(const char *);
+  OutputByteStream &operator<<(int);
+  OutputByteStream &operator<<(unsigned);
+  OutputByteStream &operator<<(long);
+  OutputByteStream &operator<<(unsigned long);
+  OutputByteStream &operator<<(const String<char> &);
+  char *getBufferPtr() const;
+  size_t getBufferSize() const;
+  void usedBuffer(size_t);
+  virtual void flushBuf(char) = 0;
+protected:
+  char *ptr_;
+  char *end_;
+};
+
+inline
+char *OutputByteStream::getBufferPtr() const
+{
+  return ptr_;
+}
+
+inline
+size_t OutputByteStream::getBufferSize() const
+{
+  return end_ - ptr_;
+}
+
+inline
+void OutputByteStream::usedBuffer(size_t n)
+{
+  ptr_ += n;
+}
+
+inline
+void OutputByteStream::sputc(char c)
+{
+  if (ptr_ < end_)
+    *ptr_++ = c;
+  else
+    flushBuf(c);
+}
+
+inline
+OutputByteStream &OutputByteStream::operator<<(char c)
+{
+  sputc(c);
+  return *this;
+}
+
+inline
+OutputByteStream &OutputByteStream::operator<<(unsigned char c)
+{
+  sputc(char(c));
+  return *this;
+}
+
+inline
+OutputByteStream &OutputByteStream::operator<<(int n)
+{
+  return *this << long(n);
+}
+
+inline
+OutputByteStream &OutputByteStream::operator<<(unsigned n)
+{
+  return *this << (unsigned long)n;
+}
+
+inline
+OutputByteStream &OutputByteStream::operator<<(const String<char> &s)
+{
+  sputn(s.data(), s.size());
+  return *this;
+}
+
+class StrOutputByteStream : public OutputByteStream {
+public:
+  StrOutputByteStream();
+  virtual ~StrOutputByteStream() { };
+  void extractString(String<char> &);
+protected:
+  StrOutputByteStream(const StrOutputByteStream &);
+  void operator=(const StrOutputByteStream &);
+  void flush();
+  void flushBuf(char);
+  String<char> buf_;
+};
+
+class FileOutputByteStream : public OutputByteStream {
+public:
+  FileOutputByteStream();
+  FileOutputByteStream(int fd, Boolean closeFd = 1);
+  virtual ~FileOutputByteStream();
+
+
+
+  Boolean open(const char *);
+
+  Boolean attach(int fd, Boolean closeFd = 1);
+  Boolean close();
+private:
+  FileOutputByteStream(const FileOutputByteStream &);
+  void operator=(const FileOutputByteStream &);
+  void flush();
+  void flushBuf(char);
+  String<char> buf_;
+  int fd_;
+  Boolean closeFd_;
+};
+
+
+}
+# 15 "/usr/include/OpenSP/CodingSystem.h" 2 3 4
+
+# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
+# 17 "/usr/include/OpenSP/CodingSystem.h" 2 3 4
+
+
+
+namespace OpenSP {
+
+
+class Decoder {
+public:
+  Decoder(unsigned minBytesPerChar = 1);
+  virtual ~Decoder();
+  virtual size_t decode(Char *, const char *, size_t, const char **) = 0;
+  virtual Boolean convertOffset(unsigned long &offset) const;
+
+
+  unsigned minBytesPerChar() const;
+protected:
+  unsigned minBytesPerChar_;
+};
+
+
+class Encoder {
+public:
+  class Handler {
+  public:
+    virtual void handleUnencodable(Char, OutputByteStream *) = 0;
+  };
+  Encoder();
+  virtual ~Encoder();
+  virtual void output(const Char *, size_t, OutputByteStream *) = 0;
+
+  virtual void startFile(OutputByteStream *);
+  virtual void output(Char *, size_t, OutputByteStream *);
+  virtual void setUnencodableHandler(Handler *);
+  virtual void handleUnencodable(Char, OutputByteStream *);
+};
+
+class RecoveringEncoder : public Encoder {
+public:
+  RecoveringEncoder();
+  void setUnencodableHandler(Handler *);
+  void handleUnencodable(Char, OutputByteStream *);
+private:
+  Handler *unencodableHandler_;
+};
+
+class InputCodingSystem {
+public:
+  virtual ~InputCodingSystem();
+
+  virtual Decoder *makeDecoder() const { return makeDecoder(1); }
+  virtual Decoder *makeDecoder(Boolean lsbFirst) const { return makeDecoder(lsbFirst,1); }
+  virtual Decoder *makeDecoder(Boolean lsbFirst, Boolean lswFirst) const { return makeDecoder(); }
+  StringC convertIn(const char *) const;
+  virtual Boolean isIdentity() const;
+};
+
+class OutputCodingSystem {
+public:
+  virtual ~OutputCodingSystem();
+  virtual Encoder *makeEncoder() const = 0;
+  virtual unsigned fixedBytesPerChar() const;
+  String<char> convertOut(const StringC &) const;
+};
+
+class CodingSystem : public InputCodingSystem, public OutputCodingSystem {
+};
+
+inline
+unsigned Decoder::minBytesPerChar() const
+{
+  return minBytesPerChar_;
+}
+
+
+}
+# 13 "/usr/include/OpenSP/OutputCharStream.h" 2 3 4
+
+
+
+namespace OpenSP {
+
+
+class OutputCharStream : public Link {
+public:
+  enum Newline { newline };
+  typedef void (*Escaper)(OutputCharStream &, Char);
+  OutputCharStream();
+  virtual ~OutputCharStream();
+  OutputCharStream &put(Char);
+  OutputCharStream &write(const Char *, size_t);
+  virtual void flush() = 0;
+  virtual void setEscaper(Escaper);
+
+  OutputCharStream &operator<<(char);
+  OutputCharStream &operator<<(const char *);
+  OutputCharStream &operator<<(const StringC &);
+  OutputCharStream &operator<<(unsigned long);
+  OutputCharStream &operator<<(int);
+  OutputCharStream &operator<<(Newline);
+private:
+  OutputCharStream(const OutputCharStream &);
+  void operator=(const OutputCharStream &);
+
+  virtual void flushBuf(Char) = 0;
+protected:
+  Char *ptr_;
+  Char *end_;
+};
+
+class EncodeOutputCharStream : public OutputCharStream,
+                            private Encoder::Handler {
+public:
+  EncodeOutputCharStream();
+
+  EncodeOutputCharStream(OutputByteStream *, const OutputCodingSystem *);
+  ~EncodeOutputCharStream();
+  void open(OutputByteStream *, const OutputCodingSystem *);
+  void flush();
+  void setEscaper(Escaper);
+private:
+  EncodeOutputCharStream(const EncodeOutputCharStream &);
+  void operator=(const EncodeOutputCharStream &);
+  EncodeOutputCharStream(OutputByteStream *, Encoder *);
+  void allocBuf(int bytesPerChar);
+  void flushBuf(Char);
+  void handleUnencodable(Char c, OutputByteStream *);
+  Char *buf_;
+  OutputByteStream *byteStream_;
+  Encoder *encoder_;
+  Owner<Encoder> ownedEncoder_;
+  Escaper escaper_;
+};
+
+class StrOutputCharStream : public OutputCharStream {
+public:
+  StrOutputCharStream();
+  ~StrOutputCharStream();
+  void extractString(StringC &);
+  void flush();
+private:
+  void flushBuf(Char);
+  void sync(size_t);
+  StrOutputCharStream(const StrOutputCharStream &);
+  void operator=(const StrOutputCharStream &);
+  Char *buf_;
+  size_t bufSize_;
+};
+
+class RecordOutputCharStream : public OutputCharStream {
+public:
+  RecordOutputCharStream(OutputCharStream *);
+  ~RecordOutputCharStream();
+  void flush();
+  void setEscaper(Escaper);
+private:
+  RecordOutputCharStream(const RecordOutputCharStream &);
+  void operator=(const RecordOutputCharStream &);
+  void flushBuf(Char);
+  void outputBuf();
+
+  OutputCharStream *os_;
+  enum { bufSize_ = 1024 };
+  Char buf_[bufSize_];
+};
+
+inline
+OutputCharStream &OutputCharStream::put(Char c)
+{
+  if (ptr_ < end_)
+    *ptr_++ = c;
+  else
+    flushBuf(c);
+  return *this;
+}
+
+inline
+OutputCharStream &OutputCharStream::operator<<(char c)
+{
+  return put(Char(c));
+}
+
+inline
+OutputCharStream &OutputCharStream::operator<<(Newline)
+{
+  put(Char('\n'));
+
+
+
+  return *this;
+}
+
+inline
+OutputCharStream &OutputCharStream::operator<<(const StringC &str)
+{
+  return write(str.data(), str.size());
+}
+
+
+}
+# 16 "GroveBuilder.cxx" 2
+# 1 "/usr/include/OpenSP/MessageFormatter.h" 1 3 4
+
+
+
+
+
+
+
+#pragma interface
+
+
+
+# 1 "/usr/include/OpenSP/MessageBuilder.h" 1 3 4
+
+
+
+
+
+
+# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
+# 8 "/usr/include/OpenSP/MessageBuilder.h" 2 3 4
+
+
+
+namespace OpenSP {
+
+
+class OtherMessageArg;
+class MessageFragment;
+
+class MessageBuilder {
+public:
+  virtual void appendNumber(unsigned long) = 0;
+  virtual void appendOrdinal(unsigned long) = 0;
+  virtual void appendChars(const Char *, size_t) = 0;
+  virtual void appendOther(const OtherMessageArg *) = 0;
+  virtual void appendFragment(const MessageFragment &) = 0;
+};
+
+
+}
+# 13 "/usr/include/OpenSP/MessageFormatter.h" 2 3 4
+
+
+
+
+# 1 "/usr/include/OpenSP/OutputCharStream.h" 1 3 4
+# 18 "/usr/include/OpenSP/MessageFormatter.h" 2 3 4
+
+
+namespace OpenSP {
+
+
+class MessageFormatter {
+public:
+  MessageFormatter();
+  virtual void formatMessage(const MessageFragment &,
+       const Vector<CopyOwner<MessageArg> > &args,
+       OutputCharStream &, bool noquote = 0);
+  virtual void formatOpenElements(const Vector<OpenElementInfo> &openElementInfo,
+     OutputCharStream &os);
+  virtual Boolean getMessageText(const MessageFragment &, StringC &) = 0;
+  virtual Boolean formatFragment(const MessageFragment &, OutputCharStream &);
+private:
+  MessageFormatter(const MessageFormatter &);
+  void operator=(const MessageFormatter &);
+protected:
+  class Builder : public MessageBuilder {
+  public:
+    Builder(MessageFormatter *formatter, OutputCharStream &os, bool b)
+      : formatter_(formatter), os_(&os), argIsCompleteMessage_(b) { }
+    void appendNumber(unsigned long);
+    void appendOrdinal(unsigned long);
+    void appendChars(const Char *, size_t);
+    void appendOther(const OtherMessageArg *);
+    void appendFragment(const MessageFragment &);
+  private:
+    OutputCharStream &os() { return *os_; }
+    OutputCharStream *os_;
+    MessageFormatter *formatter_;
+    bool argIsCompleteMessage_;
+  };
+};
+
+
+}
+# 17 "GroveBuilder.cxx" 2
+# 1 "/usr/include/OpenSP/Dtd.h" 1 3 4
+# 18 "GroveBuilder.cxx" 2
+# 1 "/usr/include/OpenSP/Syntax.h" 1 3 4
+# 19 "GroveBuilder.cxx" 2
+# 1 "/usr/include/OpenSP/Attribute.h" 1 3 4
+# 20 "GroveBuilder.cxx" 2
+# 1 "/usr/include/OpenSP/Vector.h" 1 3 4
+# 21 "GroveBuilder.cxx" 2
+# 1 "../grove/LocNode.h" 1
+
+
+
+
+
+
+
+# 1 "../grove/Node.h" 1
+# 9 "../grove/LocNode.h" 2
+
+
+namespace OpenSP {
+
+
+class Location;
+
+
+
+
+
+
+
+class LocNode {
+public:
+  virtual OpenJade_Grove:: AccessResult getLocation(Location &) const = 0;
+  static const OpenJade_Grove:: Node::IID iid;
+  static const LocNode *convert(const OpenJade_Grove:: NodePtr &nd) {
+    const void *p;
+    if (nd && nd->queryInterface(iid, p))
+      return (const LocNode *)p;
+    else
+      return 0;
+  }
+};
+
+
+
+
+}
+# 22 "GroveBuilder.cxx" 2
+# 1 "SdNode.h" 1
+# 9 "SdNode.h"
+# 1 "/usr/include/OpenSP/Sd.h" 1 3 4
+# 10 "SdNode.h" 2
+
+
+
+
+namespace OpenSP {
+# 23 "SdNode.h"
+class SdNode {
+public:
+  virtual OpenJade_Grove:: AccessResult
+    getSd(ConstPtr<Sd> &sd,
+          ConstPtr<Syntax> &prologSyntax,
+  ConstPtr<Syntax> &instanceSyntax) const = 0;
+  static const OpenJade_Grove:: Node::IID iid;
+  static const SdNode *convert(const OpenJade_Grove:: NodePtr &nd) {
+    const void *p;
+    if (nd && nd->queryInterface(iid, p))
+      return (const SdNode *)p;
+    else
+      return 0;
+  }
+};
+
+
+
+
+}
+# 23 "GroveBuilder.cxx" 2
+# 1 "threads.h" 1
+# 472 "threads.h"
+class Thread {
+public:
+  Thread(int (*func)(void *), void *args) : ret_((*func)(args)) { }
+  int wait() { return ret_; }
+private:
+  int ret_;
+};
+
+class RefCount {
+public:
+  RefCount() : count_(0) { }
+  void operator++() { ++count_; }
+  bool operator--() { return --count_ != 0; }
+  operator unsigned long() const { return count_; }
+private:
+  unsigned long count_;
+};
+
+class Mutex {
+public:
+  class Lock {
+  public:
+    Lock(Mutex *) { }
+  };
+  Mutex() { }
+};
+
+
+
+
+
+class Condition {
+public:
+  Condition() { }
+  void pulse() { }
+  void set() { }
+  bool wait() const { return 0; }
+};
+# 24 "GroveBuilder.cxx" 2
+# 1 "/usr/include/OpenSP/macros.h" 1 3 4
+# 35 "/usr/include/OpenSP/macros.h" 3 4
+# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/../../../../include/c++/4.0.1/cassert" 1 3 4
+# 46 "/usr/lib/gcc/i486-linux-gnu/4.0.1/../../../../include/c++/4.0.1/cassert" 3 4
+       
+# 47 "/usr/lib/gcc/i486-linux-gnu/4.0.1/../../../../include/c++/4.0.1/cassert" 3
+
+# 1 "/usr/include/assert.h" 1 3 4
+# 67 "/usr/include/assert.h" 3 4
+extern "C" {
+
+
+extern void __assert_fail (__const char *__assertion, __const char *__file,
+      unsigned int __line, __const char *__function)
+     throw () __attribute__ ((__noreturn__));
+
+
+extern void __assert_perror_fail (int __errnum, __const char *__file,
+      unsigned int __line,
+      __const char *__function)
+     throw () __attribute__ ((__noreturn__));
+
+
+
+
+extern void __assert (const char *__assertion, const char *__file, int __line)
+     throw () __attribute__ ((__noreturn__));
+
+
+}
+# 48 "/usr/lib/gcc/i486-linux-gnu/4.0.1/../../../../include/c++/4.0.1/cassert" 2 3
+# 36 "/usr/include/OpenSP/macros.h" 2 3 4
+# 25 "GroveBuilder.cxx" 2
+
+
+
+
+
+# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
+# 31 "GroveBuilder.cxx" 2
+
+
+
+namespace OpenSP {
+
+
+
+using namespace OpenJade_Grove;
+
+
+static bool blockingAccess = 1;
+
+size_t initialBlockSize = 8192;
+unsigned maxBlocksPerSize = 20;
+
+struct Chunk;
+struct ParentChunk;
+class ElementChunk;
+struct SgmlDocumentChunk;
+class DataChunk;
+class GroveImpl;
+class BaseNode;
+class ChunkNode;
+class ElementNode;
+class DataNode;
+class CdataAttributeValueNode;
+class AttributeValueTokenNode;
+class AttributeAsgnNode;
+class AttributeDefNode;
+class EntityNode;
+class NotationNode;
+class ExternalIdNode;
+class FormalPublicIdNode;
+class DocumentTypeNode;
+class SgmlConstantsNode;
+class MessageNode;
+class ElementTypeNode;
+class RankStemNode;
+class ModelGroupNode;
+class ElementTokenNode;
+class PcdataTokenNode;
+class DefaultEntityNode;
+
+struct Chunk {
+
+
+  virtual AccessResult setNodePtrFirst(NodePtr &ptr,
+           const BaseNode *) const = 0;
+  virtual AccessResult setNodePtrFirst(NodePtr &ptr,
+           const ElementNode *node) const;
+  virtual AccessResult setNodePtrFirst(NodePtr &ptr,
+           const DataNode *node) const;
+  virtual const Chunk *after() const = 0;
+  virtual AccessResult getFollowing(const GroveImpl *,
+                                    const Chunk *&, unsigned long &nNodes)
+    const;
+  virtual AccessResult getFirstSibling(const GroveImpl *, const Chunk *&) const;
+  virtual const StringC *id() const;
+  virtual Boolean getLocOrigin(const Origin *&) const;
+  ParentChunk *origin;
+};
+
+struct LocChunk : public Chunk {
+  Index locIndex;
+};
+
+struct ParentChunk : public LocChunk {
+  ParentChunk() : nextSibling(0) { }
+  Chunk *nextSibling;
+};
+
+class ElementChunk : public ParentChunk {
+public:
+  virtual const AttributeValue *
+    attributeValue(size_t attIndex, const GroveImpl &grove) const;
+  virtual Boolean mustOmitEndTag() const;
+  virtual Boolean included() const;
+  const AttributeDefinitionList *attDefList() const;
+  AccessResult setNodePtrFirst(NodePtr &ptr, const BaseNode *node) const;
+  AccessResult setNodePtrFirst(NodePtr &ptr, const DataNode *node) const;
+  AccessResult setNodePtrFirst(NodePtr &ptr, const ElementNode *node) const;
+  static const StringC &key(const ElementChunk &chunk) { return *chunk.id(); }
+  const Chunk *after() const;
+  AccessResult getFollowing(const GroveImpl *, const Chunk *&, unsigned long &nNodes)
+    const;
+  const ElementType *elementType() const { return type; }
+private:
+  friend class ElementNode;
+  const ElementType *type;
+public:
+  unsigned long elementIndex;
+};
+
+inline
+const AttributeDefinitionList *ElementChunk::attDefList() const
+{
+  return type->attributeDefTemp();
+}
+
+class LocOriginChunk : public Chunk {
+public:
+  LocOriginChunk(const Origin *lo) : locOrigin(lo) { }
+  AccessResult setNodePtrFirst(NodePtr &ptr, const BaseNode *) const;
+  AccessResult setNodePtrFirst(NodePtr &ptr, const ElementNode *node) const;
+  AccessResult setNodePtrFirst(NodePtr &ptr, const DataNode *node) const;
+  const Chunk *after() const;
+  AccessResult getFollowing(const GroveImpl *,
+                            const Chunk *&, unsigned long &nNodes)
+    const;
+  Boolean getLocOrigin(const Origin *&) const;
+private:
+  const Origin *locOrigin;
+};
+
+class MessageItem {
+public:
+  MessageItem(Node::Severity severity, const StringC &text, const Location &loc)
+    : severity_(severity), text_(text), loc_(loc), next_(0) { }
+  Node::Severity severity() const { return severity_; }
+  const Location &loc() const { return loc_; }
+  const StringC &text() const { return text_; }
+  const MessageItem *next() const { return next_; }
+  MessageItem **nextP() { return &next_; }
+private:
+  Node::Severity severity_;
+  StringC text_;
+  Location loc_;
+  MessageItem *next_;
+};
+
+
+
+class GroveImpl {
+public:
+  GroveImpl(unsigned groveIndex);
+
+
+  void addRef() const { ++(((GroveImpl *)this)->refCount_); }
+  void release() const {
+    if (!--(((GroveImpl *)this)->refCount_))
+      delete (GroveImpl *)this;
+  }
+  unsigned groveIndex() const { return groveIndex_; }
+  const SgmlDocumentChunk *root() const { return root_; }
+  const AttributeValue *impliedAttributeValue() const {
+    return impliedAttributeValue_.pointer();
+  }
+
+  Boolean getAppinfo(const StringC *&) const;
+  const SubstTable *generalSubstTable() const {
+    return instanceSyntax_.isNull() ? 0 : instanceSyntax_->generalSubstTable();
+  }
+  const SubstTable *entitySubstTable() const {
+    return instanceSyntax_.isNull() ? 0 : instanceSyntax_->entitySubstTable();
+  }
+
+  const Dtd *governingDtd() const { return dtd_.pointer(); }
+  const Dtd *lookupDtd(const StringC &) const;
+  const Dtd *lookupDtd(const ElementType &) const;
+  const Dtd *lookupDtd(const RankStem &) const;
+  const Dtd *firstDtd() const { return allDtds_.size() == 0 ? 0 : allDtds_.begin()->pointer(); }
+  const Dtd *nextDtd(const Dtd *) const;
+
+  Dtd::ConstEntityIter defaultedEntityIter() const;
+  const Entity *lookupDefaultedEntity(const StringC &) const;
+  const ElementChunk *lookupElement(const StringC &) const;
+  typedef PointerTableIter<ElementChunk *,StringC,Hash,ElementChunk> ElementIter;
+
+  ElementIter elementIter() const;
+  Boolean complete() const { return complete_; }
+  const void *completeLimit() const { return completeLimit_; }
+  const void *completeLimitWithLocChunkAfter() const {
+    return completeLimitWithLocChunkAfter_;
+  }
+  const Origin *currentLocOrigin() const { return currentLocOrigin_; }
+  Boolean hasDefaultEntity() const { return hasDefaultEntity_; }
+  Boolean maybeMoreSiblings(const ParentChunk *chunk) const;
+
+  Boolean waitForMoreNodes() const;
+  AccessResult proxifyLocation(const Location &, Location &) const;
+  const MessageItem *messageList() const { return messageList_; }
+
+  void getSd(ConstPtr<Sd> &, ConstPtr<Syntax> &, ConstPtr<Syntax> &) const;
+
+  void *allocChunk(size_t);
+  void appendSibling(Chunk *);
+  void appendSibling(DataChunk *);
+  Boolean tryExtend(size_t n) {
+    if (n <= nFree_) {
+      nFree_ -= n;
+      freePtr_ += n;
+      return 1;
+    }
+    else
+      return 0;
+  }
+  DataChunk *pendingData() { return pendingData_; }
+  void push(ElementChunk *, Boolean hasId);
+  void pop();
+  void setAppinfo(const StringC &);
+  void setGoverningDtd(const ConstPtr<Dtd> &dtd);
+  void addDtd(const ConstPtr<Dtd> &dtd);
+  void setSd(const ConstPtr<Sd> &, const ConstPtr<Syntax> &, const ConstPtr<Syntax> &);
+  void storeAttributeValue(const ConstPtr<AttributeValue> &value) {
+    values_.push_back(value);
+  }
+  void addDefaultedEntity(const ConstPtr<Entity> &);
+  void setComplete();
+  Boolean haveRootOrigin();
+  void setLocOrigin(const ConstPtr<Origin> &);
+  void appendMessage(MessageItem *);
+private:
+  GroveImpl(const GroveImpl &);
+  void operator=(const GroveImpl &);
+  ~GroveImpl();
+
+  Boolean maybeMoreSiblings1(const ParentChunk *) const;
+  void *allocFinish(size_t);
+  void pulse();
+  void maybePulse();
+  void finishDocumentElement();
+  void finishProlog();
+  void addBarrier();
+  void storeLocOrigin(const ConstPtr<Origin> &);
+
+  struct BlockHeader {
+    BlockHeader() : next(0) { }
+    BlockHeader *next;
+  };
+  unsigned groveIndex_;
+  SgmlDocumentChunk *root_;
+  ParentChunk *origin_;
+  DataChunk *pendingData_;
+  Chunk **tailPtr_;
+  ConstPtr<Dtd> dtd_;
+  Vector<ConstPtr<Dtd> > allDtds_;
+  ConstPtr<Sd> sd_;
+  ConstPtr<Syntax> prologSyntax_;
+  ConstPtr<Syntax> instanceSyntax_;
+  ConstPtr<AttributeValue> impliedAttributeValue_;
+  Vector<ConstPtr<AttributeValue> > values_;
+  Vector<ConstPtr<Origin> > origins_;
+  NamedResourceTable<Entity> defaultedEntityTable_;
+  PointerTable<ElementChunk *,StringC,Hash,ElementChunk> idTable_;
+  Boolean hasDefaultEntity_;
+  Boolean haveAppinfo_;
+  StringC appinfo_;
+  const Origin *currentLocOrigin_;
+
+  Boolean complete_;
+  const void *completeLimit_;
+  const void *completeLimitWithLocChunkAfter_;
+
+  char *freePtr_;
+
+
+  size_t nFree_;
+
+  BlockHeader *blocks_;
+
+  BlockHeader **blockTailPtr_;
+
+  size_t blockAllocSize_;
+
+  size_t nBlocksThisSizeAlloced_;
+  RefCount refCount_;
+  Condition moreNodesCondition_;
+  Mutex mutex_;
+  Mutex *mutexPtr_;
+  unsigned pulseStep_;
+  unsigned long nEvents_;
+  unsigned long nElements_;
+  enum { maxChunksWithoutLocOrigin = 100 };
+  unsigned nChunksSinceLocOrigin_;
+  MessageItem *messageList_;
+  MessageItem **messageListTailP_;
+};
+
+class GroveImplPtr {
+public:
+  GroveImplPtr(const GroveImpl *grove) : grove_(grove) { grove_->addRef(); }
+  ~GroveImplPtr() { grove_->release(); }
+  const GroveImpl *operator->() const { return grove_; }
+  operator const GroveImpl *() const { return grove_; }
+private:
+  GroveImplPtr(const GroveImplPtr &);
+  void operator=(const GroveImplPtr &);
+  const GroveImpl *grove_;
+};
+
+class GroveImplProxyOrigin : public ProxyOrigin {
+public:
+  GroveImplProxyOrigin(const GroveImpl *grove, const Origin *origin)
+    : grove_(grove), ProxyOrigin(origin) { }
+private:
+  GroveImplPtr grove_;
+};
+
+class GroveBuilderMessageEventHandler : public ErrorCountEventHandler {
+public:
+  GroveBuilderMessageEventHandler(unsigned groveIndex, Messenger *mgr, MessageFormatter *msgFmt_);
+  ~GroveBuilderMessageEventHandler();
+  void message(MessageEvent *);
+  void sgmlDecl(SgmlDeclEvent *);
+  void makeInitialRoot(NodePtr &);
+  void setSd(const ConstPtr<Sd> &, const ConstPtr<Syntax> &, const ConstPtr<Syntax> &);
+protected:
+  GroveImpl *grove_;
+private:
+  Messenger *mgr_;
+  MessageFormatter *msgFmt_;
+};
+
+class GroveBuilderEventHandler : public GroveBuilderMessageEventHandler {
+public:
+  GroveBuilderEventHandler(unsigned groveIndex, Messenger *mgr, MessageFormatter *msgFmt_);
+  void appinfo(AppinfoEvent *);
+  void startElement(StartElementEvent *);
+  void endElement(EndElementEvent *);
+  void data(DataEvent *);
+  void sdataEntity(SdataEntityEvent *);
+  void nonSgmlChar(NonSgmlCharEvent *);
+  void externalDataEntity(ExternalDataEntityEvent *);
+  void subdocEntity(SubdocEntityEvent *);
+  void pi(PiEvent *);
+  void endProlog(EndPrologEvent *);
+  void endDtd(EndDtdEvent *);
+  void entityDefaulted(EntityDefaultedEvent *);
+};
+
+inline
+void setString(GroveString &to, const StringC &from)
+{
+  to.assign(from.data(), from.size());
+}
+
+inline
+bool operator==(const StringC &str1, const GroveString &str2)
+{
+  return (str1.size() == str2.size()
+          && memcmp(str1.data(), str2.data(), str1.size()*sizeof(Char)) == 0);
+}
+
+inline
+bool operator!=(const StringC &str1, const GroveString &str2)
+{
+  return !(str1 == str2);
+}
+
+inline
+size_t roundUp(size_t n)
+{
+  return (n + (sizeof(void *) - 1)) & ~(sizeof(void *) - 1);
+}
+
+
+
+class BaseNode : public Node, public LocNode {
+public:
+  BaseNode(const GroveImpl *grove);
+  virtual ~BaseNode();
+  void addRef();
+  void release();
+  bool canReuse(NodePtr &ptr) const;
+  unsigned groveIndex() const;
+  bool operator==(const Node &node) const;
+
+  virtual bool same(const BaseNode &) const = 0;
+
+  virtual bool same2(const ChunkNode *) const;
+  virtual bool same2(const DataNode *) const;
+  virtual bool same2(const AttributeAsgnNode *) const;
+  virtual bool same2(const AttributeValueTokenNode *) const;
+  virtual bool same2(const CdataAttributeValueNode *) const;
+  virtual bool same2(const EntityNode *) const;
+  virtual bool same2(const NotationNode *) const;
+  virtual bool same2(const ExternalIdNode *) const;
+  virtual bool same2(const FormalPublicIdNode *) const;
+  virtual bool same2(const DocumentTypeNode *) const;
+  virtual bool same2(const SgmlConstantsNode *) const;
+  virtual bool same2(const MessageNode *) const;
+  virtual bool same2(const ElementTypeNode *) const;
+  virtual bool same2(const RankStemNode *) const;
+  virtual bool same2(const ModelGroupNode *) const;
+  virtual bool same2(const ElementTokenNode *) const;
+  virtual bool same2(const PcdataTokenNode *) const;
+  virtual bool same2(const AttributeDefNode *) const;
+  virtual bool same2(const DefaultEntityNode *) const;
+  const GroveImpl *grove() const { return grove_; }
+  AccessResult nextSibling(NodePtr &ptr) const;
+  AccessResult nextChunkSibling(NodePtr &ptr) const;
+  AccessResult follow(NodeListPtr &ptr) const;
+  AccessResult children(NodeListPtr &) const;
+  AccessResult getOrigin(NodePtr &ptr) const;
+  AccessResult getGroveRoot(NodePtr &ptr) const;
+  AccessResult getLocation(Location &) const;
+  bool queryInterface(IID, const void *&) const;
+  bool chunkContains(const Node &) const;
+  bool inChunk(const DataNode *node) const;
+  bool inChunk(const CdataAttributeValueNode *) const;
+protected:
+  static unsigned long secondHash(unsigned long n) {
+    return n * 1001;
+  }
+private:
+  unsigned refCount_;
+  GroveImplPtr grove_;
+};
+
+inline
+BaseNode::BaseNode(const GroveImpl *grove)
+: grove_(grove), refCount_(0)
+{
+}
+
+inline
+bool BaseNode::canReuse(NodePtr &ptr) const
+{
+  const Node *tem = &*ptr;
+  return tem == this && refCount_ == 1;
+}
+
+struct ForwardingChunk : Chunk {
+  ForwardingChunk(const Chunk *to, ParentChunk *p)
+    : forwardTo(to) { origin = p; }
+  AccessResult setNodePtrFirst(NodePtr &ptr, const BaseNode *node) const;
+  AccessResult getFollowing(const GroveImpl *,
+                            const Chunk *&, unsigned long &nNodes)
+    const;
+  const Chunk *after() const { return forwardTo; }
+  const Chunk *forwardTo;
+};
+
+class ChunkNode : public BaseNode {
+public:
+  ChunkNode(const GroveImpl *grove, const LocChunk *chunk);
+  const LocChunk *chunk() const { return chunk_; }
+  bool same(const BaseNode &node) const;
+  bool same2(const ChunkNode *node) const;
+  unsigned long hash() const;
+  AccessResult getParent(NodePtr &ptr) const;
+  AccessResult getTreeRoot(NodePtr &ptr) const;
+  AccessResult getOrigin(NodePtr &) const;
+  AccessResult getOriginToSubnodeRelPropertyName(ComponentName::Id &) const;
+  AccessResult nextChunkSibling(NodePtr &) const;
+  AccessResult nextChunkAfter(NodePtr &) const;
+  AccessResult firstSibling(NodePtr &) const;
+  AccessResult siblingsIndex(unsigned long &) const;
+  AccessResult followSiblingRef(unsigned long, NodePtr &) const;
+  AccessResult getLocation(Location &) const;
+protected:
+  const LocChunk *chunk_;
+};
+
+inline
+ChunkNode::ChunkNode(const GroveImpl *grove, const LocChunk *chunk)
+: BaseNode(grove), chunk_(chunk)
+{
+}
+
+class SgmlDocumentNode;
+
+struct SgmlDocumentChunk : public ParentChunk {
+  SgmlDocumentChunk() : prolog(0), documentElement(0), epilog(0) { }
+  Chunk *prolog;
+  Chunk *documentElement;
+  Chunk *epilog;
+  AccessResult setNodePtrFirst(NodePtr &ptr, const BaseNode *node) const;
+  const Chunk *after() const { return this + 1; }
+};
+
+class SgmlDocumentNode : public ChunkNode, public SdNode {
+public:
+  SgmlDocumentNode(const GroveImpl *grove,
+     const SgmlDocumentChunk *chunk);
+  void accept(NodeVisitor &visitor);
+  const ClassDef &classDef() const { return ClassDef::sgmlDocument; }
+  AccessResult getDocumentElement(NodePtr &ptr) const;
+  AccessResult getElements(NamedNodeListPtr &ptr) const;
+  AccessResult getEntities(NamedNodeListPtr &ptr) const;
+  AccessResult getDefaultedEntities(NamedNodeListPtr &ptr) const;
+  AccessResult getGoverningDoctype(NodePtr &ptr) const;
+  AccessResult getDoctypesAndLinktypes(NamedNodeListPtr &ptr) const;
+  AccessResult getProlog(NodeListPtr &ptr) const;
+  AccessResult getEpilog(NodeListPtr &ptr) const;
+  AccessResult getSgmlConstants(NodePtr &) const;
+  AccessResult getApplicationInfo(GroveString &str) const;
+  AccessResult getMessages(NodeListPtr &ptr) const;
+  AccessResult nextChunkSibling(NodePtr &) const { return accessNotInClass; }
+  AccessResult firstSibling(NodePtr &) const { return accessNotInClass; }
+  AccessResult siblingsIndex(unsigned long &) const { return accessNotInClass; }
+  AccessResult getOriginToSubnodeRelPropertyName(ComponentName::Id &) const { return accessNull; }
+  AccessResult getSd(ConstPtr<Sd> &sd,
+       ConstPtr<Syntax> &prologSyntax,
+       ConstPtr<Syntax> &instanceSyntax) const;
+private:
+  const SgmlDocumentChunk *chunk() const {
+    return (const SgmlDocumentChunk *)ChunkNode::chunk();
+  }
+};
+
+inline
+SgmlDocumentNode::SgmlDocumentNode(const GroveImpl *grove,
+       const SgmlDocumentChunk *chunk)
+: ChunkNode(grove, chunk)
+{
+}
+
+
+
+class AttElementChunk : private ElementChunk {
+protected:
+  AttElementChunk(size_t n) : nAtts(n) { }
+  friend class ElementNode;
+private:
+  const AttributeValue *
+    attributeValue(size_t attIndex, const GroveImpl &) const;
+  Boolean mustOmitEndTag() const;
+  const Chunk *after() const;
+  const StringC *id() const;
+  size_t nAtts;
+};
+
+class IncludedElementChunk : public ElementChunk {
+  friend class ElementNode;
+  Boolean included() const;
+};
+
+class IncludedAttElementChunk : public AttElementChunk {
+  IncludedAttElementChunk(size_t n) : AttElementChunk(n) { }
+  friend class ElementNode;
+  Boolean included() const;
+};
+
+class ElementNode : public ChunkNode {
+public:
+  friend class ElementChunk;
+  ElementNode(const GroveImpl *grove, const ElementChunk *chunk)
+    : ChunkNode(grove, chunk) { }
+  AccessResult attributeRef(unsigned long i, NodePtr &ptr) const;
+  AccessResult nextChunkSibling(NodePtr &ptr) const;
+  AccessResult nextChunkAfter(NodePtr &) const;
+  AccessResult firstChild(NodePtr &ptr) const;
+  AccessResult getAttributes(NamedNodeListPtr &ptr) const;
+  AccessResult getGi(GroveString &str) const;
+  bool hasGi(GroveString) const;
+  AccessResult getId(GroveString &str) const;
+  AccessResult getContent(NodeListPtr &ptr) const;
+  AccessResult getMustOmitEndTag(bool &) const;
+  AccessResult getIncluded(bool &) const;
+  AccessResult elementIndex(unsigned long &) const;
+  AccessResult getElementType(NodePtr &) const;
+  void accept(NodeVisitor &visitor);
+  const ClassDef &classDef() const { return ClassDef::element; }
+  static void add(GroveImpl &grove, const StartElementEvent &event);
+private:
+  static
+    ElementChunk *makeAttElementChunk(GroveImpl &grove,
+          const StartElementEvent &,
+          Boolean &hasId);
+  const ElementChunk *chunk() const {
+    return (const ElementChunk *)ChunkNode::chunk();
+  }
+  void reuseFor(const ElementChunk *chunk) { chunk_ = chunk; }
+};
+
+class CharsChunk : public LocChunk {
+public:
+  const Chunk *after() const {
+    return (const Chunk *)((char *)this + allocSize(size));
+  }
+  const Char *data() const { return (const Char *)(this + 1); }
+  size_t size;
+  static size_t allocSize(size_t nChars) {
+    return roundUp(sizeof(CharsChunk) + nChars*sizeof(Char));
+  }
+};
+
+
+class DataChunk : public CharsChunk {
+private:
+  friend class DataNode;
+  AccessResult setNodePtrFirst(NodePtr &ptr, const BaseNode *node) const;
+  AccessResult setNodePtrFirst(NodePtr &ptr, const ElementNode *node) const;
+  AccessResult setNodePtrFirst(NodePtr &ptr, const DataNode *node) const;
+  AccessResult getFollowing(const GroveImpl *, const Chunk *&, unsigned long &) const;
+};
+
+class DataNode : public ChunkNode {
+public:
+  friend class DataChunk;
+  DataNode(const GroveImpl *, const DataChunk *chunk, size_t index);
+  bool same(const BaseNode &node) const;
+  bool same2(const DataNode *node) const;
+  AccessResult nextSibling(NodePtr &ptr) const;
+  AccessResult nextChunkSibling(NodePtr &ptr) const;
+  AccessResult nextChunkAfter(NodePtr &) const;
+  AccessResult siblingsIndex(unsigned long &) const;
+  AccessResult followSiblingRef(unsigned long, NodePtr &) const;
+  AccessResult charChunk(const SdataMapper &, GroveString &) const;
+  bool chunkContains(const Node &) const;
+  bool inChunk(const DataNode *node) const;
+  AccessResult getNonSgml(unsigned long &) const;
+  AccessResult getLocation(Location &) const;
+  void accept(NodeVisitor &visitor);
+  const ClassDef &classDef() const { return ClassDef::dataChar; }
+  unsigned long hash() const;
+  static void add(GroveImpl &grove, const DataEvent &event);
+private:
+  const DataChunk *chunk() const {
+    return (const DataChunk *)ChunkNode::chunk();
+  }
+  void reuseFor(const DataChunk *chunk, size_t index);
+  size_t index_;
+};
+
+inline
+DataNode::DataNode(const GroveImpl *grove,
+     const DataChunk *chunk, size_t index)
+: ChunkNode(grove, chunk), index_(index)
+{
+}
+
+class PiChunk : private CharsChunk {
+  friend class PiNode;
+  AccessResult setNodePtrFirst(NodePtr &ptr, const BaseNode *node) const;
+};
+
+class PrologPiChunk : public PiChunk {
+  AccessResult getFirstSibling(const GroveImpl *, const struct Chunk *&) const;
+};
+
+class EpilogPiChunk : public PiChunk {
+  AccessResult getFirstSibling(const GroveImpl *, const struct Chunk *&) const;
+};
+
+class PiNode : public ChunkNode {
+public:
+  PiNode(const GroveImpl *grove, const PiChunk *chunk)
+    : ChunkNode(grove, chunk) {}
+  AccessResult getSystemData(GroveString &) const;
+  AccessResult getEntityName(GroveString &) const{ return accessNull; }
+  AccessResult getEntity(NodePtr &) const { return accessNull; }
+  void accept(NodeVisitor &visitor) { visitor.pi(*this); }
+  const ClassDef &classDef() const { return ClassDef::pi; }
+  static void add(GroveImpl &grove, const PiEvent &);
+private:
+  const PiChunk *chunk() const {
+    return (const PiChunk *)ChunkNode::chunk();
+  }
+};
+
+class EntityRefChunk : public LocChunk {
+public:
+  const Entity *entity;
+  const Chunk *after() const { return this + 1; }
+};
+
+class EntityRefNode : public ChunkNode {
+public:
+  EntityRefNode(const GroveImpl *grove, const EntityRefChunk *chunk)
+    : ChunkNode(grove, chunk) { }
+  AccessResult getEntity(NodePtr &) const;
+  AccessResult getEntityName(GroveString &) const;
+protected:
+  const EntityRefChunk *chunk() const {
+    return (const EntityRefChunk *)ChunkNode::chunk();
+  }
+};
+
+class SdataNode;
+
+class SdataChunk : private EntityRefChunk {
+  friend class SdataNode;
+  AccessResult setNodePtrFirst(NodePtr &ptr, const BaseNode *node) const;
+};
+
+class SdataNode : public EntityRefNode {
+public:
+  SdataNode(const GroveImpl *grove, const SdataChunk *chunk)
+    : EntityRefNode(grove, chunk) { }
+  AccessResult charChunk(const SdataMapper &, GroveString &) const;
+  AccessResult getSystemData(GroveString &str) const;
+  void accept(NodeVisitor &visitor) { visitor.sdata(*this); }
+  const ClassDef &classDef() const { return ClassDef::sdata; }
+  static void add(GroveImpl &grove, const SdataEntityEvent &event);
+private:
+  Char c_;
+};
+
+class NonSgmlNode;
+
+class NonSgmlChunk : public LocChunk {
+public:
+  Char c;
+  AccessResult setNodePtrFirst(NodePtr &ptr, const BaseNode *node) const;
+  const Chunk *after() const { return this + 1; }
+};
+
+class NonSgmlNode : public ChunkNode {
+public:
+  NonSgmlNode(const GroveImpl *grove, const NonSgmlChunk *chunk)
+    : ChunkNode(grove, chunk) { }
+  AccessResult charChunk(const SdataMapper &, GroveString &) const;
+  AccessResult getNonSgml(unsigned long &) const;
+  void accept(NodeVisitor &visitor) { visitor.nonSgml(*this); }
+  const ClassDef &classDef() const { return ClassDef::nonSgml; }
+  static void add(GroveImpl &grove, const NonSgmlCharEvent &event);
+protected:
+  const NonSgmlChunk *chunk() const {
+    return (const NonSgmlChunk *)ChunkNode::chunk();
+  }
+};
+
+class ExternalDataNode;
+
+class ExternalDataChunk : private EntityRefChunk {
+  friend class ExternalDataNode;
+  AccessResult setNodePtrFirst(NodePtr &ptr, const BaseNode *node) const;
+};
+
+class ExternalDataNode : public EntityRefNode {
+public:
+  ExternalDataNode(const GroveImpl *grove, const ExternalDataChunk *chunk)
+    : EntityRefNode(grove, chunk) { }
+  void accept(NodeVisitor &visitor) { visitor.externalData(*this); }
+  const ClassDef &classDef() const { return ClassDef::externalData; }
+  static void add(GroveImpl &grove, const ExternalDataEntityEvent &event);
+};
+
+class SubdocChunk : private EntityRefChunk {
+  friend class SubdocNode;
+  AccessResult setNodePtrFirst(NodePtr &ptr, const BaseNode *node) const;
+};
+
+class SubdocNode : public EntityRefNode {
+public:
+  SubdocNode(const GroveImpl *grove, const SubdocChunk *chunk)
+    : EntityRefNode(grove, chunk) { }
+  void accept(NodeVisitor &visitor) { visitor.subdocument(*this); }
+  const ClassDef &classDef() const { return ClassDef::subdocument; }
+  static void add(GroveImpl &grove, const SubdocEntityEvent &event);
+};
+
+class PiEntityChunk : private EntityRefChunk {
+  friend class PiEntityNode;
+  AccessResult setNodePtrFirst(NodePtr &ptr, const BaseNode *node) const;
+};
+
+class PiEntityNode : public EntityRefNode {
+public:
+  PiEntityNode(const GroveImpl *grove, const PiEntityChunk *chunk)
+    : EntityRefNode(grove, chunk) { }
+  AccessResult getSystemData(GroveString &) const;
+  void accept(NodeVisitor &visitor) { visitor.pi(*this); }
+  const ClassDef &classDef() const { return ClassDef::pi; }
+  static void add(GroveImpl &grove, const Entity *, const Location &);
+};
+
+struct AttributeDefOrigin {
+  AttributeDefOrigin(size_t attIndex = 0) : attIndex_(attIndex) { }
+  virtual const AttributeDefinitionList *attDefList() const = 0;
+  virtual Node *makeCdataAttributeValueNode(const GroveImpl *grove,
+         const AttributeValue *value,
+         size_t attIndex,
+         const TextIter &iter,
+         size_t charIndex = 0) const = 0;
+  virtual Node *makeAttributeValueTokenNode(const GroveImpl *grove,
+         const TokenizedAttributeValue *value,
+         size_t attIndex,
+         size_t tokenIndex) const = 0;
+  virtual Node *makeOriginNode(const GroveImpl *grove, size_t attIndex) const = 0;
+  virtual AccessResult makeAttributeValueNode(const GroveImpl *grove,
+                                              NodePtr &ptr,
+                                              const AttributeValue *value) const;
+  virtual AccessResult makeAttributeValueNodeList(const GroveImpl *grove,
+                                                  NodeListPtr &ptr,
+                                                  const AttributeValue *value) const;
+  virtual AccessResult makeAttributeDefNode(const GroveImpl *grove,
+                                            NodePtr &ptr,
+                                            size_t attributeDefIdx) const = 0;
+  virtual AccessResult makeAttributeDefList(const GroveImpl *,
+                                            NodeListPtr &,
+                                            size_t) const {
+    return accessNull;
+  }
+  AccessResult makeAttributeDefNode(const GroveImpl *grove,
+                                    NodePtr &ptr,
+                                    const StringC &name) const;
+  virtual const void *attributeOriginId() const = 0;
+  const size_t attIndex() const { return attIndex_; }
+protected:
+  size_t attIndex_;
+};
+
+struct AttributeOrigin : public virtual AttributeDefOrigin {
+  virtual const AttributeValue *
+    attributeValue(size_t attIndex, const GroveImpl &grove) const = 0;
+  virtual AccessResult
+    setNodePtrAttributeOrigin(NodePtr &, const BaseNode *) const = 0;
+  virtual Node *makeAttributeAsgnNode(const GroveImpl *grove,
+          size_t attIndex) const = 0;
+};
+
+class ElementAttributeOrigin : public virtual AttributeOrigin {
+public:
+  ElementAttributeOrigin(const ElementChunk *);
+  const AttributeDefinitionList *attDefList() const;
+  const AttributeValue *
+    attributeValue(size_t attIndex, const GroveImpl &grove) const;
+  AccessResult setNodePtrAttributeOrigin(NodePtr &, const BaseNode *) const;
+  Node *makeCdataAttributeValueNode(const GroveImpl *grove,
+        const AttributeValue *value,
+        size_t attIndex,
+        const TextIter &iter,
+        size_t charIndex) const;
+  Node *makeAttributeValueTokenNode(const GroveImpl *grove,
+        const TokenizedAttributeValue *value,
+        size_t attIndex,
+        size_t tokenIndex) const;
+  Node *makeAttributeAsgnNode(const GroveImpl *grove,
+         size_t attIndex) const;
+  virtual Node *makeOriginNode(const GroveImpl *grove, size_t attIndex) const;
+  virtual AccessResult makeAttributeDefNode(const GroveImpl *grove,
+                                            NodePtr &ptr,
+                                            size_t attributeDefIdx) const;
+  const void *attributeOriginId() const;
+private:
+  const ElementChunk *chunk_;
+};
+
+class EntityAttributeOrigin : public virtual AttributeOrigin {
+public:
+  EntityAttributeOrigin(const ExternalDataEntity *);
+  const AttributeDefinitionList *attDefList() const;
+  const AttributeValue *
+    attributeValue(size_t attIndex, const GroveImpl &grove) const;
+  AccessResult setNodePtrAttributeOrigin(NodePtr &, const BaseNode *) const;
+  Node *makeCdataAttributeValueNode(const GroveImpl *grove,
+        const AttributeValue *value,
+        size_t attIndex,
+        const TextIter &iter,
+        size_t charIndex) const;
+  Node *makeAttributeValueTokenNode(const GroveImpl *grove,
+        const TokenizedAttributeValue *value,
+        size_t attIndex,
+        size_t tokenIndex) const;
+  Node *makeAttributeAsgnNode(const GroveImpl *grove,
+         size_t attIndex) const;
+  virtual AccessResult makeAttributeDefNode(const GroveImpl *grove,
+                                            NodePtr &ptr,
+                                            size_t attributeDefIdx) const;
+  virtual Node *makeOriginNode(const GroveImpl *grove, size_t attIndex) const;
+  const void *attributeOriginId() const;
+private:
+  const ExternalDataEntity *entity_;
+};
+
+
+class ElementTypeAttributeDefOrigin : public virtual AttributeDefOrigin {
+public:
+  ElementTypeAttributeDefOrigin(const ElementType *);
+  const AttributeDefinitionList *attDefList() const;
+  Node *makeCdataAttributeValueNode(const GroveImpl *grove,
+        const AttributeValue *value,
+        size_t attIndex,
+        const TextIter &iter,
+        size_t charIndex) const;
+  Node *makeAttributeValueTokenNode(const GroveImpl *grove,
+        const TokenizedAttributeValue *value,
+        size_t attIndex,
+        size_t tokenIndex) const;
+  virtual AccessResult makeAttributeDefNode(const GroveImpl *grove,
+                                            NodePtr &ptr,
+                                            size_t attributeDefIdx) const;
+  virtual AccessResult makeAttributeDefList(const GroveImpl *grove,
+                                            NodeListPtr &ptr,
+                                            size_t firstAttDefIdx) const;
+  virtual Node *makeOriginNode(const GroveImpl *grove, size_t attIndex) const;
+  virtual const void *attributeOriginId() const;
+protected:
+  const ElementType *elementType_;
+};
+
+
+class NotationAttributeDefOrigin : public virtual AttributeDefOrigin {
+public:
+  NotationAttributeDefOrigin(const Notation *);
+  virtual const AttributeDefinitionList *attDefList() const;
+  Node *makeCdataAttributeValueNode(const GroveImpl *grove,
+        const AttributeValue *value,
+        size_t attIndex,
+        const TextIter &iter,
+        size_t charIndex) const;
+  Node *makeAttributeValueTokenNode(const GroveImpl *grove,
+        const TokenizedAttributeValue *value,
+        size_t attIndex,
+        size_t tokenIndex) const;
+  virtual AccessResult makeAttributeDefNode(const GroveImpl *grove,
+                                            NodePtr &ptr,
+                                            size_t attributeDefIdx) const;
+  virtual AccessResult makeAttributeDefList(const GroveImpl *grove,
+                                            NodeListPtr &ptr,
+                                            size_t firstAttDefIdx) const;
+  virtual Node *makeOriginNode(const GroveImpl *grove, size_t attIndex) const;
+  virtual const void *attributeOriginId() const;
+protected:
+  const Notation *notation_;
+};
+
+class AttributeAsgnNode : public BaseNode, public virtual AttributeOrigin {
+public:
+  AttributeAsgnNode(const GroveImpl *grove, size_t attIndex);
+  AccessResult getOrigin(NodePtr &ptr) const;
+  AccessResult getName(GroveString &str) const;
+  AccessResult getImplied(bool &implied) const;
+  AccessResult getValue(NodeListPtr &ptr) const;
+  AccessResult children(NodeListPtr &ptr) const;
+  AccessResult firstChild(NodePtr &ptr) const;
+  AccessResult nextChunkSibling(NodePtr &ptr) const;
+  AccessResult followSiblingRef(unsigned long, NodePtr &) const;
+  AccessResult firstSibling(NodePtr &) const;
+  AccessResult siblingsIndex(unsigned long &) const;
+  AccessResult getTokenSep(Char &) const;
+  AccessResult tokens(GroveString &) const;
+  AccessResult getAttributeDef(NodePtr &) const;
+  void accept(NodeVisitor &visitor);
+  const ClassDef &classDef() const { return ClassDef::attributeAssignment; }
+  AccessResult getOriginToSubnodeRelPropertyName(ComponentName::Id &name) const {
+    name = ComponentName::idAttributes;
+    return accessOK;
+  }
+  bool same(const BaseNode &node) const;
+  bool same2(const AttributeAsgnNode *node) const;
+  unsigned long hash() const;
+};
+
+class ElementAttributeAsgnNode
+: public AttributeAsgnNode, public ElementAttributeOrigin {
+public:
+  ElementAttributeAsgnNode(const GroveImpl *grove, size_t attIndex,
+      const ElementChunk *);
+};
+
+class EntityAttributeAsgnNode
+: public AttributeAsgnNode, public EntityAttributeOrigin {
+public:
+  EntityAttributeAsgnNode(const GroveImpl *grove, size_t attIndex,
+      const ExternalDataEntity *);
+};
+
+class AttributeValueTokenNode
+: public BaseNode, public virtual AttributeDefOrigin {
+public:
+  AttributeValueTokenNode(const GroveImpl *grove,
+     const TokenizedAttributeValue *value,
+                          size_t attIndex,
+     size_t tokenIndex);
+  AccessResult getParent(NodePtr &ptr) const;
+  AccessResult nextChunkSibling(NodePtr &ptr) const;
+  AccessResult followSiblingRef(unsigned long, NodePtr &ptr) const;
+  AccessResult firstSibling(NodePtr &) const;
+  AccessResult siblingsIndex(unsigned long &) const;
+  AccessResult getToken(GroveString &str) const;
+  AccessResult getEntity(NodePtr &ptr) const;
+  AccessResult getNotation(NodePtr &ptr) const;
+  AccessResult getReferent(NodePtr &ptr) const;
+  AccessResult getLocation(Location &) const;
+  void accept(NodeVisitor &visitor);
+  const ClassDef &classDef() const { return ClassDef::attributeValueToken; }
+  AccessResult getOriginToSubnodeRelPropertyName(ComponentName::Id &name) const {
+    name = ComponentName::idValue;
+    return accessOK;
+  }
+  bool same(const BaseNode &node) const;
+  bool same2(const AttributeValueTokenNode *node) const;
+  unsigned long hash() const;
+private:
+  const TokenizedAttributeValue *value_;
+  size_t tokenIndex_;
+};
+
+class ElementAttributeValueTokenNode
+: public AttributeValueTokenNode, public ElementAttributeOrigin {
+public:
+  ElementAttributeValueTokenNode(const GroveImpl *grove,
+     const TokenizedAttributeValue *value,
+     size_t attIndex,
+     size_t tokenIndex,
+     const ElementChunk *);
+};
+
+class EntityAttributeValueTokenNode
+: public AttributeValueTokenNode, public EntityAttributeOrigin {
+public:
+  EntityAttributeValueTokenNode(const GroveImpl *grove,
+    const TokenizedAttributeValue *value,
+    size_t attIndex,
+    size_t tokenIndex,
+    const ExternalDataEntity *);
+};
+
+class ElementTypeAttributeValueTokenNode
+: public AttributeValueTokenNode, public ElementTypeAttributeDefOrigin {
+public:
+  ElementTypeAttributeValueTokenNode(const GroveImpl *grove,
+               const TokenizedAttributeValue *value,
+         size_t attIndex,
+         size_t tokenIndex,
+         const ElementType *);
+  AccessResult getOriginToSubnodeRelPropertyName(ComponentName::Id &name) const {
+    name = ComponentName::idDefaultValue;
+    return accessOK;
+  }
+};
+
+class NotationAttributeValueTokenNode
+: public AttributeValueTokenNode, public NotationAttributeDefOrigin {
+public:
+  NotationAttributeValueTokenNode(const GroveImpl *grove,
+           const TokenizedAttributeValue *value,
+      size_t attIndex,
+      size_t tokenIndex,
+      const Notation *);
+  AccessResult getOriginToSubnodeRelPropertyName(ComponentName::Id &name) const {
+    name = ComponentName::idDefaultValue;
+    return accessOK;
+  }
+};
+
+class CdataAttributeValueNode
+: public BaseNode, public virtual AttributeDefOrigin {
+public:
+  static bool skipBoring(TextIter &iter);
+  CdataAttributeValueNode(const GroveImpl *grove,
+     const AttributeValue *value,
+     size_t attIndex,
+     const TextIter &iter,
+     size_t charIndex);
+  AccessResult getParent(NodePtr &ptr) const;
+  AccessResult charChunk(const SdataMapper &, GroveString &) const;
+  bool chunkContains(const Node &) const;
+  bool inChunk(const CdataAttributeValueNode *) const;
+  AccessResult getEntity(NodePtr &) const;
+  AccessResult getEntityName(GroveString &) const;
+  AccessResult getSystemData(GroveString &str) const;
+  AccessResult nextSibling(NodePtr &ptr) const;
+  AccessResult nextChunkSibling(NodePtr &ptr) const;
+  AccessResult firstSibling(NodePtr &) const;
+  AccessResult siblingsIndex(unsigned long &) const;
+  AccessResult getLocation(Location &) const;
+  void accept(NodeVisitor &visitor);
+  const ClassDef &classDef() const;
+  AccessResult getOriginToSubnodeRelPropertyName(ComponentName::Id &name) const {
+    name = ComponentName::idValue;
+    return accessOK;
+  }
+  bool same(const BaseNode &node) const;
+  bool same2(const CdataAttributeValueNode *node) const;
+  unsigned long hash() const;
+private:
+  const AttributeValue *value_;
+  TextIter iter_;
+  size_t charIndex_;
+  Char c_;
+};
+
+class ElementCdataAttributeValueNode
+: public CdataAttributeValueNode, public ElementAttributeOrigin {
+public:
+  ElementCdataAttributeValueNode(const GroveImpl *grove,
+     const AttributeValue *value,
+     size_t attIndex,
+     const TextIter &iter,
+     size_t charIndex,
+     const ElementChunk *);
+};
+
+class EntityCdataAttributeValueNode
+: public CdataAttributeValueNode, public EntityAttributeOrigin {
+public:
+  EntityCdataAttributeValueNode(const GroveImpl *grove,
+    const AttributeValue *value,
+    size_t attIndex,
+    const TextIter &iter,
+    size_t charIndex,
+    const ExternalDataEntity *);
+};
+
+class ElementTypeCdataAttributeValueNode
+: public CdataAttributeValueNode, public ElementTypeAttributeDefOrigin {
+public:
+  ElementTypeCdataAttributeValueNode(const GroveImpl *grove,
+                       const AttributeValue *value,
+         size_t attIndex,
+         const TextIter &iter,
+         size_t charIndex,
+         const ElementType *);
+  AccessResult getOriginToSubnodeRelPropertyName(ComponentName::Id &name) const {
+    name = ComponentName::idDefaultValue;
+    return accessOK;
+  }
+};
+
+class NotationCdataAttributeValueNode
+: public CdataAttributeValueNode, public NotationAttributeDefOrigin {
+public:
+  NotationCdataAttributeValueNode(const GroveImpl *grove,
+        const AttributeValue *value,
+      size_t attIndex,
+      const TextIter &iter,
+      size_t charIndex,
+      const Notation *);
+  AccessResult getOriginToSubnodeRelPropertyName(ComponentName::Id &name) const {
+    name = ComponentName::idDefaultValue;
+    return accessOK;
+  }
+};
+
+class EntityNodeBase : public BaseNode {
+public:
+  EntityNodeBase(const GroveImpl *grove, const Entity *entity)
+   : BaseNode(grove), entity_(entity) {}
+  AccessResult getName(GroveString &str) const;
+  AccessResult getExternalId(NodePtr &ptr) const;
+  AccessResult getNotation(NodePtr &) const;
+  AccessResult getNotationName(GroveString &) const;
+  AccessResult getText(GroveString &) const;
+  AccessResult getEntityType(Node::EntityType::Enum &) const;
+  AccessResult getAttributes(NamedNodeListPtr &) const;
+  AccessResult attributeRef(unsigned long i, NodePtr &ptr) const;
+  AccessResult getLocation(Location &) const;
+  unsigned long hash() const;
+protected:
+  const Entity *entity_;
+};
+
+class EntityNode : public EntityNodeBase {
+public:
+  EntityNode(const GroveImpl *grove, const Entity *entity);
+  AccessResult getOrigin(NodePtr &ptr) const;
+  AccessResult getOriginToSubnodeRelPropertyName(ComponentName::Id &) const;
+  AccessResult getDefaulted(bool &) const;
+  bool same(const BaseNode &) const;
+  bool same2(const EntityNode *) const;
+  void accept(NodeVisitor &);
+  const ClassDef &classDef() const { return ClassDef::entity; }
+};
+
+class DefaultEntityNode : public EntityNodeBase {
+public:
+  DefaultEntityNode(const GroveImpl *grove, const Entity *entity);
+  AccessResult getOrigin(NodePtr &ptr) const;
+  AccessResult getOriginToSubnodeRelPropertyName(ComponentName::Id &) const;
+  bool same(const BaseNode &) const;
+  bool same2(const DefaultEntityNode *) const;
+  void accept(NodeVisitor &);
+  const ClassDef &classDef() const { return ClassDef::defaultEntity; }
+};
+
+class NotationNode : public BaseNode {
+public:
+  NotationNode(const GroveImpl *grove, const Notation *notation);
+  AccessResult getOrigin(NodePtr &ptr) const;
+  AccessResult getOriginToSubnodeRelPropertyName(ComponentName::Id &name) const {
+    name = ComponentName::idNotations;
+    return accessOK;
+  }
+  AccessResult getName(GroveString &str) const;
+  AccessResult getExternalId(NodePtr &ptr) const;
+  AccessResult getAttributeDefs(NamedNodeListPtr &) const;
+  bool same(const BaseNode &) const;
+  bool same2(const NotationNode *) const;
+  AccessResult getLocation(Location &) const;
+  void accept(NodeVisitor &);
+  const ClassDef &classDef() const { return ClassDef::notation; }
+  unsigned long hash() const;
+private:
+  const Notation *notation_;
+};
+
+class FormalPublicIdNode : public BaseNode {
+public:
+  FormalPublicIdNode(const GroveImpl *, const PublicId *);
+  AccessResult getOwnerType(OwnerType::Enum &) const;
+  AccessResult getOwnerId(GroveString &) const;
+  AccessResult getTextClass(TextClass::Enum &) const;
+  AccessResult getUnavailable(bool &) const;
+  AccessResult getTextDescription(GroveString &) const;
+  AccessResult getTextLanguage(GroveString &) const;
+  AccessResult getTextDesignatingSequence(GroveString &) const;
+  AccessResult getTextDisplayVersion(GroveString &) const;
+  void accept(NodeVisitor &);
+  const ClassDef &classDef() const { return ClassDef::formalPublicId; }
+  AccessResult getOriginToSubnodeRelPropertyName(ComponentName::Id &name) const {
+    name = ComponentName::idFormalPublicId;
+    return accessOK;
+  }
+  bool same(const BaseNode &) const;
+  bool same2(const FormalPublicIdNode *) const;
+private:
+  const PublicId *pubid_;
+  mutable StringC owner_;
+  mutable StringC desc_;
+  mutable StringC lang_;
+  mutable StringC dseq_;
+  mutable StringC dver_;
+};
+
+class ExternalIdNode : public BaseNode {
+public:
+  ExternalIdNode(const GroveImpl *grove);
+  virtual const ExternalId &externalId() const = 0;
+  AccessResult getPublicId(GroveString &) const;
+  AccessResult getFormalPublicId(NodePtr &) const;
+  AccessResult getSystemId(GroveString &) const;
+  AccessResult getGeneratedSystemId(GroveString &) const;
+  void accept(NodeVisitor &);
+  const ClassDef &classDef() const { return ClassDef::externalId; }
+  AccessResult getOriginToSubnodeRelPropertyName(ComponentName::Id &name) const {
+    name = ComponentName::idExternalId;
+    return accessOK;
+  }
+  bool same(const BaseNode &) const;
+  bool same2(const ExternalIdNode *) const;
+};
+
+class EntityExternalIdNode : public ExternalIdNode {
+public:
+  EntityExternalIdNode(const GroveImpl *grove,
+         const ExternalEntity *entity);
+  const ExternalId &externalId() const;
+  AccessResult getOrigin(NodePtr &ptr) const;
+  unsigned long hash() const;
+private:
+  const ExternalEntity *entity_;
+};
+
+class NotationExternalIdNode : public ExternalIdNode {
+public:
+  NotationExternalIdNode(const GroveImpl *grove,
+    const Notation *notation);
+  const ExternalId &externalId() const;
+  AccessResult getOrigin(NodePtr &ptr) const;
+  unsigned long hash() const;
+private:
+  const Notation *notation_;
+};
+
+class DocumentTypeNode : public BaseNode {
+public:
+  DocumentTypeNode(const GroveImpl *grove, const Dtd *);
+  AccessResult getName(GroveString &) const;
+  AccessResult getGoverning(bool &) const;
+  AccessResult getGeneralEntities(NamedNodeListPtr &) const;
+  AccessResult getNotations(NamedNodeListPtr &) const;
+  AccessResult getElementTypes(NamedNodeListPtr &) const;
+  AccessResult getDefaultEntity(NodePtr &) const;
+  AccessResult getParameterEntities(NamedNodeListPtr &) const;
+  AccessResult getOrigin(NodePtr &) const;
+  AccessResult getOriginToSubnodeRelPropertyName(ComponentName::Id &name) const {
+    name = ComponentName::idDoctypesAndLinktypes;
+    return accessOK;
+  }
+  AccessResult nextChunkSibling(NodePtr &) const;
+  void accept(NodeVisitor &);
+  const ClassDef &classDef() const { return ClassDef::documentType; }
+  bool same(const BaseNode &) const;
+  bool same2(const DocumentTypeNode *) const;
+private:
+  const Dtd *dtd_;
+};
+
+class SgmlConstantsNode : public BaseNode {
+public:
+  SgmlConstantsNode(const GroveImpl *);
+  AccessResult getOrigin(NodePtr &) const;
+  void accept(NodeVisitor &);
+  const ClassDef &classDef() const { return ClassDef::sgmlConstants; }
+  AccessResult getOriginToSubnodeRelPropertyName(ComponentName::Id &name) const {
+    name = ComponentName::idSgmlConstants;
+    return accessOK;
+  }
+  bool same(const BaseNode &) const;
+  bool same2(const SgmlConstantsNode *) const;
+};
+
+class MessageNode : public BaseNode {
+public:
+  MessageNode(const GroveImpl *, const MessageItem *);
+  AccessResult getOrigin(NodePtr &) const;
+  AccessResult getOriginToSubnodeRelPropertyName(ComponentName::Id &name) const {
+    name = ComponentName::noId;
+    return accessOK;
+  }
+  AccessResult nextChunkSibling(NodePtr &) const;
+  AccessResult firstSibling(NodePtr &) const;
+  AccessResult siblingsIndex(unsigned long &) const;
+  void accept(NodeVisitor &);
+  const ClassDef &classDef() const { return ClassDef::message; }
+  bool same(const BaseNode &) const;
+  bool same2(const MessageNode *) const;
+  AccessResult getLocation(Location &) const;
+  AccessResult getText(GroveString &) const;
+  AccessResult getSeverity(Severity &) const;
+private:
+  const MessageItem *item_;
+};
+
+
+class RankStemNode : public BaseNode {
+public:
+  RankStemNode(const GroveImpl *grove, const RankStem &rankStem, const Dtd::ConstElementTypeIter &iter)
+   : BaseNode(grove), rankStem_(rankStem), iter_(iter) {};
+  AccessResult getOrigin(NodePtr &) const;
+  const ClassDef &classDef() const { return ClassDef::rankStem; }
+  AccessResult getOriginToSubnodeRelPropertyName(ComponentName::Id &name) const {
+    name = ComponentName::idElementTypes;
+    return accessOK;
+}
+  AccessResult getStem(GroveString &) const;
+  AccessResult getElementTypes(NodeListPtr &) const;
+  bool same(const BaseNode &) const;
+  bool same2(const RankStemNode *) const;
+  void accept(NodeVisitor &);
+  unsigned long hash() const;
+  const RankStem &rankStem() const { return rankStem_; }
+protected:
+  const RankStem &rankStem_;
+  Dtd::ConstElementTypeIter iter_;
+};
+
+
+class ElementTypeNode : public BaseNode {
+public:
+  ElementTypeNode(const GroveImpl *grove, const ElementType &elementType)
+    : BaseNode(grove), elementType_(elementType) {};
+  AccessResult getOrigin(NodePtr &) const;
+  const ClassDef &classDef() const { return ClassDef::elementType; }
+  AccessResult getOriginToSubnodeRelPropertyName(ComponentName::Id &name) const {
+    name = ComponentName::idElementTypes;
+    return accessOK;
+  }
+  AccessResult getGi(GroveString &str) const;
+  AccessResult getAttributeDefs(NamedNodeListPtr &) const;
+  AccessResult getContentType(Node::ContentType::Enum &) const;
+  AccessResult getExclusions(GroveStringListPtr &) const;
+  AccessResult getInclusions(GroveStringListPtr &) const;
+  AccessResult getModelGroup(NodePtr &) const;
+  AccessResult getOmitEndTag(bool &) const;
+  AccessResult getOmitStartTag(bool &) const;
+  AccessResult getRankGroup(GroveStringListPtr &) const;
+  AccessResult getRankStem(GroveString &) const;
+  AccessResult getRankSuffix(GroveString &) const;
+  AccessResult getLocation(Location &) const;
+  bool same(const BaseNode &) const;
+  bool same2(const ElementTypeNode *) const;
+  void accept(NodeVisitor &);
+  unsigned long hash() const;
+  const ElementType &elementType() const { return elementType_; }
+protected:
+  const ElementType &elementType_;
+};
+
+
+class ModelGroupNode;
+class ContentTokenNodeBase : public BaseNode {
+public:
+  ContentTokenNodeBase(const GroveImpl *grove,
+                       const ElementType &elementType,
+                       ModelGroupNode *parentModelGroupNode = 0);
+  ~ContentTokenNodeBase();
+  AccessResult getOriginToSubnodeRelPropertyName(ComponentName::Id &name) const {
+    name = ComponentName::idContentTokens;
+    return accessOK;
+  }
+  AccessResult getOrigin(NodePtr &) const;
+  AccessResult getLocation(Location &) const;
+  const ElementType &elementType() const { return elementType_; }
+protected:
+  ModelGroupNode *parentModelGroupNode_;
+  const ElementType &elementType_;
+};
+
+
+class ElementTokenNode : public ContentTokenNodeBase {
+public:
+  ElementTokenNode(const GroveImpl *grove,
+                   const ElementType &elementType,
+                   const ElementToken &elementToken,
+                   ModelGroupNode *parentModelGroupNode)
+   : ContentTokenNodeBase(grove, elementType, parentModelGroupNode),
+     elementToken_(elementToken) {}
+  const ClassDef &classDef() const { return ClassDef::elementToken; }
+  AccessResult getGi(GroveString &str) const;
+  AccessResult getOccurIndicator(Node::OccurIndicator::Enum &) const;
+  bool same(const BaseNode &) const;
+  bool same2(const ElementTokenNode *) const;
+  void accept(NodeVisitor &);
+  unsigned long hash() const;
+  const ElementToken &elementToken() const { return elementToken_; }
+protected:
+  const ElementToken &elementToken_;
+};
+
+
+class PcdataTokenNode : public ContentTokenNodeBase {
+public:
+  PcdataTokenNode(const GroveImpl *grove,
+                  const ElementType &elementType,
+                  const PcdataToken &pcdataToken,
+                  ModelGroupNode *parentModelGroupNode)
+   : ContentTokenNodeBase(grove, elementType, parentModelGroupNode),
+     pcdataToken_(pcdataToken) {}
+  const ClassDef &classDef() const { return ClassDef::pcdataToken; }
+  bool same(const BaseNode &) const;
+  bool same2(const PcdataTokenNode *) const;
+  void accept(NodeVisitor &);
+  unsigned long hash() const;
+  const PcdataToken &pcdataToken() const { return pcdataToken_; }
+protected:
+  const PcdataToken &pcdataToken_;
+};
+
+
+class ModelGroupNode : public ContentTokenNodeBase {
+public:
+  ModelGroupNode(const GroveImpl *grove,
+                 const ElementType &elementType,
+                 const ModelGroup &modelGroup,
+                 ModelGroupNode *parentModelGroupNode = 0)
+   : ContentTokenNodeBase(grove, elementType, parentModelGroupNode),
+     modelGroup_(modelGroup) {}
+  const ClassDef &classDef() const { return ClassDef::modelGroup; }
+  AccessResult getOriginToSubnodeRelPropertyName(ComponentName::Id &name) const;
+  AccessResult getConnector(Node::Connector::Enum &con) const;
+  AccessResult getOccurIndicator(Node::OccurIndicator::Enum &occur) const;
+  AccessResult getContentTokens(NodeListPtr &) const;
+  bool same(const BaseNode &) const;
+  bool same2(const ModelGroupNode *) const;
+  void accept(NodeVisitor &);
+  unsigned long hash() const;
+  void makeNode(NodePtr &ptr, unsigned contentTokenIdx);
+  const ModelGroup &modelGroup() const { return modelGroup_; }
+private:
+  const ModelGroup &modelGroup_;
+};
+
+
+class AttributeDefNode : public BaseNode, public virtual AttributeDefOrigin {
+public:
+  AttributeDefNode(const GroveImpl *grove, size_t attIndex)
+   : BaseNode(grove), AttributeDefOrigin(attIndex) {}
+  const ClassDef &classDef() const { return ClassDef::attributeDef; }
+  AccessResult getName(GroveString &) const;
+  AccessResult getDeclValueType(Node::DeclValueType::Enum &) const;
+  AccessResult getDefaultValueType(Node::DefaultValueType::Enum &) const;
+  AccessResult getTokens(GroveStringListPtr &) const;
+  AccessResult getCurrentAttributeIndex(long &) const;
+  void accept(NodeVisitor &visitor);
+  bool same(const BaseNode &node) const;
+  bool same2(const AttributeDefNode *node) const;
+  unsigned long hash() const;
+protected:
+};
+
+
+class ElementTypeAttributeDefNode
+: public AttributeDefNode, public ElementTypeAttributeDefOrigin {
+public:
+  ElementTypeAttributeDefNode(const GroveImpl *grove,
+                              const ElementType &elementType,
+                              size_t attributeDefIdx)
+   : AttributeDefNode(grove, attributeDefIdx),
+     ElementTypeAttributeDefOrigin(&elementType),
+     AttributeDefOrigin(attributeDefIdx) {}
+  AccessResult getOrigin(NodePtr &ptr) const;
+  AccessResult getOriginToSubnodeRelPropertyName(ComponentName::Id &name) const {
+    name = ComponentName::idAttributeDefs;
+    return accessOK;
+  }
+  AccessResult getCurrentGroup(NodeListPtr &) const;
+  AccessResult getLocation(Location &) const;
+  AccessResult getDefaultValue(NodeListPtr &) const;
+};
+
+
+class NotationAttributeDefNode
+: public AttributeDefNode, public NotationAttributeDefOrigin {
+public:
+  NotationAttributeDefNode(const GroveImpl *grove,
+                           const Notation &notation,
+                           size_t attributeDefIdx)
+   : AttributeDefNode(grove, attributeDefIdx),
+     NotationAttributeDefOrigin(&notation),
+     AttributeDefOrigin(attributeDefIdx) {};
+  AccessResult getOrigin(NodePtr &ptr) const;
+  AccessResult getOriginToSubnodeRelPropertyName(ComponentName::Id &name) const {
+    name = ComponentName::idAttributeDefs;
+    return accessOK;
+  }
+  AccessResult getCurrentGroup(NodeListPtr &) const;
+  AccessResult getLocation(Location &) const;
+  AccessResult getDefaultValue(NodeListPtr &) const;
+};
+
+class BaseNodeList : public NodeList {
+public:
+  BaseNodeList() : refCount_(0) { }
+  virtual ~BaseNodeList() { }
+  void addRef() { ++refCount_; }
+  bool canReuse(NodeListPtr &ptr) const {
+    const NodeList *tem = &*ptr;
+    return tem == this && refCount_ == 1;
+  }
+  void release() {
+    (static_cast<void> (__builtin_expect (!!(refCount_ != 0), 1) ? 0 : (__assert_fail ("refCount_ != 0", "GroveBuilder.cxx", 1547, __PRETTY_FUNCTION__), 0)));
+    if (--refCount_ == 0) delete this;
+  }
+  AccessResult first(NodePtr &) const { return accessNull; }
+  AccessResult rest(NodeListPtr &ptr) const { return chunkRest(ptr); }
+  AccessResult chunkRest(NodeListPtr &) const { return accessNull; }
+private:
+  unsigned refCount_;
+};
+
+class SiblingNodeList : public BaseNodeList {
+public:
+  SiblingNodeList(const NodePtr &first) : first_(first) { }
+  AccessResult first(NodePtr &ptr) const {
+    ptr = first_;
+    return accessOK;
+  }
+  AccessResult rest(NodeListPtr &ptr) const {
+    AccessResult ret;
+    if (canReuse(ptr)) {
+      ret = ((SiblingNodeList *)this)->first_.assignNextSibling();
+      if (ret == accessOK)
+ return ret;
+    }
+    else {
+      NodePtr next;
+      ret = first_->nextSibling(next);
+      if (ret == accessOK) {
+ ptr.assign(new SiblingNodeList(next));
+ return ret;
+      }
+    }
+    if (ret == accessNull) {
+      ptr.assign(new BaseNodeList);
+      return accessOK;
+    }
+    return ret;
+  }
+  AccessResult chunkRest(NodeListPtr &ptr) const {
+    AccessResult ret;
+    if (canReuse(ptr)) {
+      ret = ((SiblingNodeList *)this)->first_.assignNextChunkSibling();
+      if (ret == accessOK)
+ return ret;
+    }
+    else {
+      NodePtr next;
+      ret = first_->nextChunkSibling(next);
+      if (ret == accessOK) {
+ ptr.assign(new SiblingNodeList(next));
+ return ret;
+      }
+    }
+    if (ret == accessNull) {
+      ptr.assign(new BaseNodeList);
+      return accessOK;
+    }
+    return ret;
+  }
+  AccessResult ref(unsigned long i, NodePtr &ptr) const {
+    if (i == 0) {
+      ptr = first_;
+      return accessOK;
+    }
+    return first_->followSiblingRef(i - 1, ptr);
+  }
+private:
+  NodePtr first_;
+};
+
+class BaseNamedNodeList : public NamedNodeList {
+public:
+  BaseNamedNodeList(const GroveImpl *grove,
+      const SubstTable *substTable)
+  : grove_(grove), substTable_(substTable), refCount_(0) { }
+  virtual ~BaseNamedNodeList() { }
+  void addRef() { ++refCount_; }
+  bool canReuse(NamedNodeListPtr &ptr) const {
+    const NamedNodeList *tem = &*ptr;
+    return tem == this && refCount_ == 1;
+  }
+  void release() {
+    (static_cast<void> (__builtin_expect (!!(refCount_ != 0), 1) ? 0 : (__assert_fail ("refCount_ != 0", "GroveBuilder.cxx", 1629, __PRETTY_FUNCTION__), 0)));
+    if (--refCount_ == 0) delete this;
+  }
+  size_t normalize(GroveChar *s, size_t n) const {
+    if (substTable_) {
+      for (size_t i = 0; i < n; i++)
+ substTable_->subst(s[i]);
+    }
+    return n;
+  }
+  const GroveImpl *grove() const { return grove_; }
+  AccessResult namedNode(GroveString str, NodePtr &node) const {
+    StringC tem(str.data(), str.size());
+    normalize(&tem[0], tem.size());
+    return namedNodeU(tem, node);
+  }
+  virtual AccessResult namedNodeU(const StringC &, NodePtr &) const = 0;
+private:
+  GroveImplPtr grove_;
+  const SubstTable *substTable_;
+  unsigned refCount_;
+};
+
+class AttributesNamedNodeList
+: public BaseNamedNodeList, public virtual AttributeOrigin {
+public:
+  AttributesNamedNodeList(const GroveImpl *grove)
+   : BaseNamedNodeList(grove, grove->generalSubstTable()) { }
+  NodeListPtr nodeList() const;
+  AccessResult namedNodeU(const StringC &, NodePtr &) const;
+  Type type() const { return attributes; }
+};
+
+class ElementAttributesNamedNodeList
+: public AttributesNamedNodeList, public ElementAttributeOrigin {
+public:
+  ElementAttributesNamedNodeList(const GroveImpl *grove,
+     const ElementChunk *chunk)
+   : AttributesNamedNodeList(grove), ElementAttributeOrigin(chunk) { }
+};
+
+class EntityAttributesNamedNodeList
+: public AttributesNamedNodeList, public EntityAttributeOrigin {
+public:
+  EntityAttributesNamedNodeList(const GroveImpl *grove,
+    const ExternalDataEntity *entity)
+   : AttributesNamedNodeList(grove), EntityAttributeOrigin(entity) { }
+};
+
+class ElementsNamedNodeList : public BaseNamedNodeList {
+public:
+  ElementsNamedNodeList(const GroveImpl *grove)
+    : BaseNamedNodeList(grove, grove->generalSubstTable()) { }
+  NodeListPtr nodeList() const;
+  AccessResult namedNodeU(const StringC &, NodePtr &) const;
+  Type type() const { return elements; }
+};
+
+class DocEntitiesNamedNodeList : public BaseNamedNodeList {
+public:
+  DocEntitiesNamedNodeList(const GroveImpl *grove)
+   : BaseNamedNodeList(grove, grove->entitySubstTable()) { }
+  NodeListPtr nodeList() const;
+  AccessResult namedNodeU(const StringC &, NodePtr &) const;
+  Type type() const { return entities; }
+};
+
+class DefaultedEntitiesNamedNodeList : public BaseNamedNodeList {
+public:
+  DefaultedEntitiesNamedNodeList(const GroveImpl *grove)
+   : BaseNamedNodeList(grove, grove->entitySubstTable()) { }
+  NodeListPtr nodeList() const;
+  AccessResult namedNodeU(const StringC &, NodePtr &) const;
+  Type type() const { return entities; }
+};
+
+class GeneralEntitiesNamedNodeList : public BaseNamedNodeList {
+public:
+  GeneralEntitiesNamedNodeList(const GroveImpl *, const Dtd *);
+  NodeListPtr nodeList() const;
+  AccessResult namedNodeU(const StringC &, NodePtr &) const;
+  Type type() const { return entities; }
+private:
+  const Dtd *dtd_;
+};
+
+class ParameterEntitiesNamedNodeList : public BaseNamedNodeList {
+public:
+  ParameterEntitiesNamedNodeList(const GroveImpl *, const Dtd *);
+  NodeListPtr nodeList() const;
+  AccessResult namedNodeU(const StringC &, NodePtr &) const;
+  Type type() const { return entities; }
+private:
+  const Dtd *dtd_;
+};
+
+class NotationsNamedNodeList : public BaseNamedNodeList {
+public:
+  NotationsNamedNodeList(const GroveImpl *, const Dtd *);
+  NodeListPtr nodeList() const;
+  AccessResult namedNodeU(const StringC &, NodePtr &) const;
+  Type type() const { return notations; }
+private:
+  const Dtd *dtd_;
+};
+
+class DoctypesAndLinktypesNamedNodeList : public BaseNamedNodeList {
+public:
+  DoctypesAndLinktypesNamedNodeList(const GroveImpl *);
+  NodeListPtr nodeList() const;
+  AccessResult namedNodeU(const StringC &, NodePtr &) const;
+  Type type() const { return doctypesAndLinktypes; }
+};
+
+class ElementsNodeList : public BaseNodeList {
+public:
+  ElementsNodeList(const GroveImpl *grove,
+                   const Chunk *head);
+  AccessResult first(NodePtr &) const;
+  AccessResult chunkRest(NodeListPtr &) const;
+public:
+  GroveImplPtr grove_;
+  const Chunk *first_;
+};
+
+class EntitiesNodeList : public BaseNodeList {
+public:
+  EntitiesNodeList(const GroveImpl *grove,
+     const Dtd::ConstEntityIter &iter);
+  AccessResult first(NodePtr &) const;
+  AccessResult chunkRest(NodeListPtr &) const;
+protected:
+  const GroveImpl *grove() const { return grove_; }
+public:
+  GroveImplPtr grove_;
+  Dtd::ConstEntityIter iter_;
+};
+
+class DocEntitiesNodeList : public EntitiesNodeList {
+public:
+  DocEntitiesNodeList(const GroveImpl *grove);
+  AccessResult first(NodePtr &) const;
+  AccessResult chunkRest(NodeListPtr &) const;
+};
+
+class NotationsNodeList : public BaseNodeList {
+public:
+  NotationsNodeList(const GroveImpl *grove,
+                    const Dtd::ConstNotationIter &iter);
+  AccessResult first(NodePtr &) const;
+  AccessResult chunkRest(NodeListPtr &) const;
+public:
+  GroveImplPtr grove_;
+  Dtd::ConstNotationIter iter_;
+};
+
+
+class RankStemElementTypesNodeList : public BaseNodeList {
+public:
+  RankStemElementTypesNodeList(const GroveImpl *,
+                               const RankStem &,
+                               const Dtd::ConstElementTypeIter &);
+  AccessResult first(NodePtr &) const;
+  AccessResult chunkRest(NodeListPtr &) const;
+protected:
+  GroveImplPtr grove_;
+  const RankStem &rankStem_;
+  Dtd::ConstElementTypeIter iter_;
+};
+
+
+class ElementTypesNodeList : public BaseNodeList {
+public:
+  ElementTypesNodeList( const GroveImpl *,
+                        const Dtd *,
+                        const Dtd::ConstElementTypeIter &,
+                        const Dtd::ConstRankStemIter &);
+  AccessResult first(NodePtr &) const;
+  AccessResult chunkRest(NodeListPtr &) const;
+protected:
+  GroveImplPtr grove_;
+  const Dtd *dtd_;
+  Dtd::ConstElementTypeIter elementTypeIter_;
+  Dtd::ConstRankStemIter rankStemIter_;
+};
+
+
+class ElementTypesNamedNodeList : public BaseNamedNodeList {
+public:
+  ElementTypesNamedNodeList(const GroveImpl *, const Dtd *);
+  NodeListPtr nodeList() const;
+  AccessResult namedNodeU(const StringC &, NodePtr &) const;
+  Type type() const { return elementTypes; }
+protected:
+  const Dtd *dtd_;
+};
+
+
+class ContentTokenNodeList : public BaseNodeList {
+public:
+  ContentTokenNodeList(const GroveImpl *grove,
+                       ModelGroupNode &modelGroupNode,
+                       unsigned firstTokenIdx = 0);
+  AccessResult first(NodePtr &) const;
+  AccessResult chunkRest(NodeListPtr &) const;
+  unsigned firstTokenIdx() const { return firstTokenIdx_; }
+  AccessResult next();
+protected:
+  GroveImplPtr grove_;
+  ModelGroupNode &modelGroupNode_;
+  unsigned firstTokenIdx_;
+};
+
+
+class AttributeDefsNodeList
+ : public BaseNodeList, public virtual AttributeDefOrigin {
+public:
+  AttributeDefsNodeList(const GroveImpl *grove,
+                        size_t firstAttIndex)
+   : grove_(grove), AttributeDefOrigin(firstAttIndex) {}
+  AccessResult first(NodePtr &) const;
+  AccessResult chunkRest(NodeListPtr &) const;
+  bool inList(size_t attIndex) const;
+protected:
+  GroveImplPtr grove_;
+};
+
+
+class ElementTypeAttributeDefsNodeList
+ : public AttributeDefsNodeList, public ElementTypeAttributeDefOrigin {
+public:
+  ElementTypeAttributeDefsNodeList(const GroveImpl *grove,
+                                   const ElementType &elementType,
+                                   size_t firstAttIndex)
+   : AttributeDefsNodeList(grove, firstAttIndex),
+     ElementTypeAttributeDefOrigin(&elementType),
+     AttributeDefOrigin(firstAttIndex) {}
+};
+
+
+class NotationAttributeDefsNodeList
+ : public AttributeDefsNodeList, public NotationAttributeDefOrigin {
+public:
+  NotationAttributeDefsNodeList(const GroveImpl *grove,
+                                const Notation &notation,
+                                size_t firstAttIndex)
+   : AttributeDefsNodeList(grove, firstAttIndex),
+     NotationAttributeDefOrigin(&notation),
+     AttributeDefOrigin(firstAttIndex) {}
+};
+
+
+class AttributeDefsNamedNodeList
+ : public BaseNamedNodeList, public virtual AttributeDefOrigin {
+public:
+  AttributeDefsNamedNodeList(const GroveImpl *grove)
+   : BaseNamedNodeList(grove, grove->generalSubstTable()) { }
+  NodeListPtr nodeList() const;
+  AccessResult namedNodeU(const StringC &, NodePtr &) const;
+  Type type() const { return attributeDefs; }
+};
+
+
+class ElementTypeAttributeDefsNamedNodeList
+ : public AttributeDefsNamedNodeList, public ElementTypeAttributeDefOrigin {
+public:
+  ElementTypeAttributeDefsNamedNodeList(const GroveImpl *grove,
+                  const ElementType &elementType)
+   : AttributeDefsNamedNodeList(grove), ElementTypeAttributeDefOrigin(&elementType) { }
+};
+
+
+class NotationAttributeDefsNamedNodeList
+ : public AttributeDefsNamedNodeList, public NotationAttributeDefOrigin {
+public:
+  NotationAttributeDefsNamedNodeList(const GroveImpl *grove,
+            const Notation &notation)
+   : AttributeDefsNamedNodeList(grove), NotationAttributeDefOrigin(&notation) { }
+};
+
+
+
+class ElementTypeCurrentGroupAttributeDefsNodeList
+: public BaseNodeList {
+public:
+  ElementTypeCurrentGroupAttributeDefsNodeList(const GroveImpl *grove,
+                                               const Dtd::ConstElementTypeIter &iter,
+                                               size_t currentGroupIndex);
+  ElementTypeCurrentGroupAttributeDefsNodeList(const GroveImpl *grove,
+                                               const Dtd::ConstElementTypeIter &iter,
+                                               const ElementType *elementType,
+                                               size_t firstAttIndex,
+                                               size_t currentGroupIndex)
+   : grove_(grove), iter_(iter), elementType_(elementType), attIndex_(firstAttIndex),
+     currentGroupIndex_(currentGroupIndex) {}
+  AccessResult first(NodePtr &) const;
+  AccessResult chunkRest(NodeListPtr &) const;
+  bool next(Dtd::ConstElementTypeIter &iter,
+            const ElementType *&elementType,
+            size_t &attIndex,
+            bool incrementFirst = true) const;
+  bool next(bool incrementFirst = true) {
+    return next(iter_, elementType_, attIndex_, incrementFirst); }
+protected:
+  GroveImplPtr grove_;
+  Dtd::ConstElementTypeIter iter_;
+  const ElementType *elementType_;
+  size_t currentGroupIndex_;
+  size_t attIndex_;
+};
+
+inline
+Boolean GroveImpl::waitForMoreNodes() const
+{
+  if (blockingAccess)
+    return moreNodesCondition_.wait();
+  else
+    return 0;
+}
+
+inline
+void GroveImpl::pulse()
+{
+  moreNodesCondition_.pulse();
+}
+
+inline
+void GroveImpl::maybePulse()
+{
+
+
+
+  if ((++nEvents_ & ~(~unsigned(0) << pulseStep_)) == 0) {
+    pulse();
+    if (pulseStep_ < 8 && nEvents_ > (1 << (pulseStep_ + 10)))
+      pulseStep_++;
+  }
+}
+
+inline
+void GroveImpl::appendSibling(Chunk *chunk)
+{
+  if (pendingData_) {
+    if (tailPtr_) {
+
+      completeLimit_ = pendingData_->after();
+      *tailPtr_ = pendingData_;
+      tailPtr_ = 0;
+    }
+    pendingData_ = 0;
+  }
+
+  chunk->origin = origin_;
+
+  completeLimit_ = freePtr_;
+  if (tailPtr_) {
+    *tailPtr_ = chunk;
+    tailPtr_ = 0;
+  }
+  pendingData_ = 0;
+  maybePulse();
+}
+
+inline
+void GroveImpl::appendSibling(DataChunk *chunk)
+{
+
+
+
+  if (pendingData_) {
+
+    completeLimit_ = pendingData_->after();
+    if (tailPtr_) {
+      *tailPtr_ = pendingData_;
+      tailPtr_ = 0;
+    }
+  }
+  chunk->origin = origin_;
+  pendingData_ = chunk;
+  maybePulse();
+}
+
+inline
+void GroveImpl::push(ElementChunk *chunk, Boolean hasId)
+{
+  if (pendingData_) {
+    if (tailPtr_) {
+
+      completeLimit_ = pendingData_->after();
+      *tailPtr_ = pendingData_;
+      tailPtr_ = 0;
+    }
+    pendingData_ = 0;
+  }
+  chunk->elementIndex = nElements_++;
+  chunk->origin = origin_;
+
+
+
+
+
+  origin_ = chunk;
+  completeLimit_ = freePtr_;
+
+
+  if ((const Chunk *)chunk->origin == root_ && root_->documentElement == 0)
+    root_->documentElement = chunk;
+  else if (tailPtr_) {
+    *tailPtr_ = chunk;
+    tailPtr_ = 0;
+  }
+  if (hasId) {
+    Mutex::Lock lock(mutexPtr_);
+    idTable_.insert(chunk);
+  }
+  maybePulse();
+}
+
+inline
+void GroveImpl::pop()
+{
+  if (pendingData_) {
+
+    completeLimit_ = pendingData_->after();
+    if (tailPtr_) {
+      *tailPtr_ = pendingData_;
+      tailPtr_ = 0;
+    }
+    pendingData_ = 0;
+  }
+  tailPtr_ = &origin_->nextSibling;
+  origin_ = origin_->origin;
+  if ((const Chunk *)origin_ == root_)
+    finishDocumentElement();
+  maybePulse();
+}
+
+inline
+Boolean GroveImpl::haveRootOrigin()
+{
+  return (const Chunk *)origin_ == root_;
+}
+
+inline
+void GroveImpl::setGoverningDtd(const ConstPtr<Dtd> &dtd)
+{
+  dtd_ = dtd;
+  hasDefaultEntity_ = !dtd_->defaultEntity().isNull();
+  finishProlog();
+  pulse();
+}
+
+inline
+void GroveImpl::addDtd(const ConstPtr<Dtd> &dtd)
+{
+  allDtds_.push_back(dtd);
+}
+
+const Dtd *GroveImpl::lookupDtd(const StringC &name) const
+{
+  for (size_t i = 0; i < allDtds_.size(); i++)
+    if (allDtds_[i]->name() == name)
+      return allDtds_[i].pointer();
+  return 0;
+}
+
+const Dtd *GroveImpl::lookupDtd(const ElementType &et) const
+{
+  for (size_t i = 0; i < allDtds_.size(); i++)
+    if (allDtds_[i]->lookupElementType(et.name()) == &et)
+      return allDtds_[i].pointer();
+  return 0;
+}
+
+const Dtd *GroveImpl::lookupDtd(const RankStem &rs) const
+{
+  for (size_t i = 0; i < allDtds_.size(); i++)
+    if (allDtds_[i]->lookupRankStem(rs.name()) == &rs)
+      return allDtds_[i].pointer();
+  return 0;
+}
+
+const Dtd *GroveImpl::nextDtd(const Dtd *dtd) const
+{
+  for (size_t i = 0; i < allDtds_.size() - 1; i++)
+    if (allDtds_[i].pointer() == dtd)
+      return allDtds_[i+1].pointer();
+  return 0;
+}
+
+inline
+const ElementChunk *GroveImpl::lookupElement(const StringC &id) const
+{
+  Mutex::Lock lock(mutexPtr_);
+  return idTable_.lookup(id);
+}
+
+inline
+GroveImpl::ElementIter GroveImpl::elementIter() const
+{
+  (static_cast<void> (__builtin_expect (!!(complete()), 1) ? 0 : (__assert_fail ("complete()", "GroveBuilder.cxx", 2129, __PRETTY_FUNCTION__), 0)));
+  return ElementIter(idTable_);
+}
+
+inline
+Boolean GroveImpl::maybeMoreSiblings(const ParentChunk *chunk) const
+{
+  return (complete_
+          ? chunk->nextSibling != 0
+   : (origin_ == chunk
+       || &chunk->nextSibling == tailPtr_
+       || maybeMoreSiblings1(chunk)));
+}
+
+inline
+void *GroveImpl::allocChunk(size_t n)
+{
+  nChunksSinceLocOrigin_++;
+  if (n <= nFree_) {
+    void *p = freePtr_;
+    freePtr_ += n;
+    nFree_ -= n;
+    return p;
+  }
+  else
+    return allocFinish(n);
+}
+
+inline
+void GroveImpl::setLocOrigin(const ConstPtr<Origin> &locOrigin)
+{
+  if (locOrigin.pointer() != currentLocOrigin_
+      || nChunksSinceLocOrigin_ >= maxChunksWithoutLocOrigin)
+    storeLocOrigin(locOrigin);
+}
+
+inline
+void GroveImpl::appendMessage(MessageItem *item)
+{
+  *messageListTailP_ = item;
+  messageListTailP_ = item->nextP();
+  pulse();
+}
+
+inline
+void ElementNode::add(GroveImpl &grove, const StartElementEvent &event)
+{
+  grove.setLocOrigin(event.location().origin());
+  ElementChunk *chunk;
+  const AttributeList &atts = event.attributes();
+  Boolean hasId;
+  if (atts.nSpec() == 0 && !atts.anyCurrent()) {
+    void *mem = grove.allocChunk(sizeof(ElementChunk));
+    if (event.included())
+      chunk = new (mem) IncludedElementChunk;
+    else
+      chunk = new (mem) ElementChunk;
+    hasId = 0;
+  }
+  else
+    chunk = makeAttElementChunk(grove, event, hasId);
+  chunk->type = event.elementType();
+  chunk->locIndex = event.location().index();
+  grove.push(chunk, hasId);
+}
+
+
+
+inline
+AccessResult DataNode::nextChunkSibling(NodePtr &ptr) const
+{
+
+
+  const Chunk *p = chunk_->after();
+  while (p == grove()->completeLimit())
+    if (!grove()->waitForMoreNodes())
+      return accessTimeout;
+  if (p->origin != chunk_->origin)
+    return accessNull;
+  return p->setNodePtrFirst(ptr, this);
+}
+
+inline
+void DataNode::reuseFor(const DataChunk *chunk, size_t index)
+{
+  chunk_ = chunk;
+  index_ = index;
+}
+
+inline
+void DataNode::add(GroveImpl &grove, const DataEvent &event)
+{
+  size_t dataLen = event.dataLength();
+  if (dataLen) {
+   DataChunk *chunk = grove.pendingData();
+   if (chunk
+       && event.location().origin().pointer() == grove.currentLocOrigin()
+       && event.location().index() == chunk->locIndex + chunk->size
+       && grove.tryExtend(CharsChunk::allocSize(chunk->size + dataLen)
+                          - CharsChunk::allocSize(chunk->size))) {
+     memcpy((Char *)(chunk + 1) + chunk->size,
+     event.data(),
+     dataLen * sizeof(Char));
+     chunk->size += dataLen;
+   }
+   else {
+     grove.setLocOrigin(event.location().origin());
+     chunk = new (grove.allocChunk(CharsChunk::allocSize(dataLen))) DataChunk;
+     chunk->size = dataLen;
+     chunk->locIndex = event.location().index();
+     memcpy(chunk + 1, event.data(), dataLen * sizeof(Char));
+     grove.appendSibling(chunk);
+   }
+ }
+}
+
+GroveBuilderMessageEventHandler::GroveBuilderMessageEventHandler(unsigned groveIndex,
+         Messenger *mgr,
+         MessageFormatter *msgFmt)
+: mgr_(mgr), grove_(new GroveImpl(groveIndex)), msgFmt_(msgFmt)
+{
+  grove_->addRef();
+}
+
+GroveBuilderMessageEventHandler::~GroveBuilderMessageEventHandler()
+{
+  grove_->setComplete();
+  grove_->release();
+}
+
+void GroveBuilderMessageEventHandler::makeInitialRoot(NodePtr &root)
+{
+  root.assign(new SgmlDocumentNode(grove_, grove_->root()));
+}
+
+void GroveBuilderMessageEventHandler::message(MessageEvent *event)
+{
+  mgr_->dispatchMessage(event->message());
+  const Message &msg = event->message();
+  StrOutputCharStream os;
+  msgFmt_->formatMessage(*msg.type, msg.args, os);
+  StringC tem;
+  os.extractString(tem);
+  Node::Severity severity;
+  switch (msg.type->severity()) {
+  case MessageType::info:
+    severity = Node::info;
+    break;
+  case MessageType::warning:
+    severity = Node::warning;
+    break;
+  default:
+    severity = Node::error;
+    break;
+  }
+  grove_->appendMessage(new MessageItem(severity, tem, msg.loc));
+  if (!msg.auxLoc.origin().isNull()) {
+    msgFmt_->formatMessage(msg.type->auxFragment(), msg.args, os);
+    os.extractString(tem);
+    grove_->appendMessage(new MessageItem(Node::info, tem, msg.auxLoc));
+  }
+  ErrorCountEventHandler::message(event);
+}
+
+void GroveBuilderMessageEventHandler::sgmlDecl(SgmlDeclEvent *event)
+{
+  grove_->setSd(event->sdPointer(), event->prologSyntaxPointer(), event->instanceSyntaxPointer());
+  delete event;
+}
+
+void GroveBuilderMessageEventHandler::setSd(const ConstPtr<Sd> &sd, const ConstPtr<Syntax> &prologSyntax, const ConstPtr<Syntax> &instanceSyntax)
+{
+  grove_->setSd(sd, prologSyntax, instanceSyntax);
+}
+
+GroveBuilderEventHandler::GroveBuilderEventHandler(unsigned groveIndex,
+         Messenger *mgr,
+         MessageFormatter *msgFmt)
+: GroveBuilderMessageEventHandler(groveIndex, mgr, msgFmt)
+{
+}
+
+void GroveBuilderEventHandler::appinfo(AppinfoEvent *event)
+{
+  const StringC *appinfo;
+  if (event->literal(appinfo))
+    grove_->setAppinfo(*appinfo);
+  delete event;
+}
+
+void GroveBuilderEventHandler::endProlog(EndPrologEvent *event)
+{
+  grove_->setGoverningDtd(event->dtdPointer());
+  delete event;
+}
+
+void GroveBuilderEventHandler::endDtd(EndDtdEvent *event)
+{
+  grove_->addDtd(event->dtdPointer());
+  delete event;
+}
+
+void GroveBuilderEventHandler::startElement(StartElementEvent *event)
+{
+  ElementNode::add(*grove_, *event);
+  delete event;
+}
+
+void GroveBuilderEventHandler::endElement(EndElementEvent *event)
+{
+  grove_->pop();
+  delete event;
+}
+
+void GroveBuilderEventHandler::data(DataEvent *event)
+{
+  DataNode::add(*grove_, *event);
+  delete event;
+}
+
+void GroveBuilderEventHandler::sdataEntity(SdataEntityEvent *event)
+{
+  SdataNode::add(*grove_, *event);
+  delete event;
+}
+
+void GroveBuilderEventHandler::nonSgmlChar(NonSgmlCharEvent *event)
+{
+  NonSgmlNode::add(*grove_, *event);
+  delete event;
+}
+
+void GroveBuilderEventHandler::externalDataEntity(ExternalDataEntityEvent *event)
+{
+  ExternalDataNode::add(*grove_, *event);
+  delete event;
+}
+
+void GroveBuilderEventHandler::subdocEntity(SubdocEntityEvent *event)
+{
+  SubdocNode::add(*grove_, *event);
+  delete event;
+}
+
+void GroveBuilderEventHandler::pi(PiEvent *event)
+{
+  PiNode::add(*grove_, *event);
+  delete event;
+}
+
+void GroveBuilderEventHandler::entityDefaulted(EntityDefaultedEvent *event)
+{
+  grove_->addDefaultedEntity(event->entityPointer());
+  delete event;
+}
+
+ErrorCountEventHandler *GroveBuilder::make(unsigned index,
+        Messenger *mgr,
+        MessageFormatter *msgFmt,
+        bool validateOnly,
+        NodePtr &root)
+{
+  GroveBuilderMessageEventHandler *eh;
+  if (validateOnly)
+    eh = new GroveBuilderMessageEventHandler(index, mgr, msgFmt);
+  else
+    eh = new GroveBuilderEventHandler(index, mgr, msgFmt);
+  eh->makeInitialRoot(root);
+  return eh;
+}
+
+ErrorCountEventHandler *GroveBuilder::make(unsigned index,
+        Messenger *mgr,
+        MessageFormatter *msgFmt,
+        bool validateOnly,
+        const ConstPtr<Sd> &sd,
+        const ConstPtr<Syntax> &prologSyntax,
+        const ConstPtr<Syntax> &instanceSyntax,
+        NodePtr &root)
+{
+  GroveBuilderMessageEventHandler *eh;
+  if (validateOnly)
+    eh = new GroveBuilderMessageEventHandler(index, mgr, msgFmt);
+  else
+    eh = new GroveBuilderEventHandler(index, mgr, msgFmt);
+  eh->makeInitialRoot(root);
+  eh->setSd(sd, prologSyntax, instanceSyntax);
+  return eh;
+}
+
+bool GroveBuilder::setBlocking(bool b)
+{
+  bool prev = blockingAccess;
+  blockingAccess = b;
+  return prev;
+}
+
+GroveImpl::GroveImpl(unsigned groveIndex)
+: groveIndex_(groveIndex),
+  root_(0),
+  impliedAttributeValue_(new ImpliedAttributeValue),
+  tailPtr_(0),
+  freePtr_(0),
+  nFree_(0),
+  blocks_(0),
+  blockTailPtr_(&blocks_),
+  blockAllocSize_(initialBlockSize),
+  nBlocksThisSizeAlloced_(0),
+  complete_(0),
+  mutexPtr_(&mutex_),
+  pulseStep_(0),
+  nEvents_(0),
+  haveAppinfo_(0),
+  pendingData_(0),
+  nElements_(0),
+  currentLocOrigin_(0),
+  completeLimitWithLocChunkAfter_(0),
+  nChunksSinceLocOrigin_(0),
+  messageList_(0),
+  messageListTailP_(&messageList_)
+{
+  root_ = new (allocChunk(sizeof(SgmlDocumentChunk))) SgmlDocumentChunk;
+  root_->origin = 0;
+  root_->locIndex = 0;
+  completeLimit_ = freePtr_;
+  origin_ = root_;
+  tailPtr_ = &root_->prolog;
+}
+
+GroveImpl::~GroveImpl()
+{
+  while (blocks_) {
+    BlockHeader *tem = blocks_;
+    blocks_ = blocks_->next;
+    ::operator delete(tem);
+  }
+  while (messageList_) {
+    MessageItem *tem = messageList_;
+    messageList_ = *messageList_->nextP();
+    delete tem;
+  }
+}
+
+void GroveImpl::setAppinfo(const StringC &appinfo)
+{
+  appinfo_ = appinfo;
+  haveAppinfo_ = 1;
+}
+
+Boolean GroveImpl::getAppinfo(const StringC *&appinfo) const
+{
+  if (!haveAppinfo_) {
+    if (!complete_ && sd_.isNull())
+      return 0;
+    appinfo = 0;
+  }
+  else
+    appinfo = &appinfo_;
+  return 1;
+}
+
+void GroveImpl::setSd(const ConstPtr<Sd> &sd, const ConstPtr<Syntax> &prologSyntax, const ConstPtr<Syntax> &instanceSyntax)
+{
+  instanceSyntax_ = instanceSyntax;
+  prologSyntax_ = prologSyntax;
+  sd_ = sd;
+}
+
+void GroveImpl::getSd(ConstPtr<Sd> &sd, ConstPtr<Syntax> &prologSyntax, ConstPtr<Syntax> &instanceSyntax) const
+{
+  instanceSyntax = instanceSyntax_;
+  prologSyntax = prologSyntax_;
+  sd = sd_;
+}
+
+void GroveImpl::finishProlog()
+{
+  if (root_->prolog)
+    addBarrier();
+  tailPtr_ = 0;
+}
+
+void GroveImpl::finishDocumentElement()
+{
+
+  if (root_->epilog == 0) {
+    addBarrier();
+    tailPtr_ = &root_->epilog;
+  }
+}
+
+void GroveImpl::addBarrier()
+{
+  if (freePtr_) {
+    (void) new (freePtr_) ForwardingChunk(0, 0);
+    if (nFree_ <= sizeof(ForwardingChunk)) {
+      nFree_ = 0;
+      freePtr_ = 0;
+    }
+    else {
+      nFree_ -= sizeof(ForwardingChunk);
+      freePtr_ += sizeof(ForwardingChunk);
+    }
+  }
+}
+
+void GroveImpl::setComplete()
+{
+  addBarrier();
+  mutexPtr_ = 0;
+  completeLimit_ = 0;
+  completeLimitWithLocChunkAfter_ = 0;
+  if (pendingData_ && tailPtr_)
+    *tailPtr_ = pendingData_;
+  tailPtr_ = 0;
+  pendingData_ = 0;
+  complete_ = 1;
+  moreNodesCondition_.set();
+}
+
+void GroveImpl::addDefaultedEntity(const ConstPtr<Entity> &entity)
+{
+  Mutex::Lock lock(mutexPtr_);
+
+  defaultedEntityTable_.insert((Entity *)entity.pointer());
+}
+
+const Entity *GroveImpl::lookupDefaultedEntity(const StringC &name) const
+{
+  Mutex::Lock lock(mutexPtr_);
+  return defaultedEntityTable_.lookupTemp(name);
+}
+
+Dtd::ConstEntityIter GroveImpl::defaultedEntityIter() const
+{
+  (static_cast<void> (__builtin_expect (!!(complete()), 1) ? 0 : (__assert_fail ("complete()", "GroveBuilder.cxx", 2564, __PRETTY_FUNCTION__), 0)));
+  return Dtd::ConstEntityIter(defaultedEntityTable_);
+}
+
+Boolean GroveImpl::maybeMoreSiblings1(const ParentChunk *chunk) const
+{
+  for (const ParentChunk *open = origin_; open; open = open->origin)
+    if (open == chunk)
+      return 1;
+
+  return tailPtr_ == &chunk->nextSibling || chunk->nextSibling != 0;
+}
+
+void *GroveImpl::allocFinish(size_t n)
+{
+  if (++nBlocksThisSizeAlloced_ >= maxBlocksPerSize) {
+     blockAllocSize_ *= 2;
+     nBlocksThisSizeAlloced_ = 0;
+  }
+  size_t allocSize = n + (sizeof(ForwardingChunk) + sizeof(BlockHeader));
+  if (allocSize < blockAllocSize_) {
+    nFree_ = blockAllocSize_ - allocSize;
+    allocSize = blockAllocSize_;
+  }
+  else
+    nFree_ = 0;
+  *blockTailPtr_ = new (::operator new(allocSize)) BlockHeader;
+  char *chunkStart = (char *)(*blockTailPtr_ + 1);
+  blockTailPtr_ = &(*blockTailPtr_)->next;
+  if (freePtr_)
+    (void)new (freePtr_) ForwardingChunk((const Chunk *)chunkStart, origin_);
+  freePtr_ = chunkStart + n;
+  return chunkStart;
+}
+
+AccessResult ChunkNode::getLocation(Location &loc) const
+{
+  const Origin *origin = grove()->currentLocOrigin();
+  for (const Chunk *p = chunk_->after(); p; p = p->after()) {
+    if (p == grove()->completeLimitWithLocChunkAfter()) {
+      while (!p->getLocOrigin(origin)) {
+ p = p->after();
+ (static_cast<void> (__builtin_expect (!!(p != 0), 1) ? 0 : (__assert_fail ("p != 0", "GroveBuilder.cxx", 2606, __PRETTY_FUNCTION__), 0)));
+      }
+      break;
+    }
+    if (p == grove()->completeLimit() || p->getLocOrigin(origin))
+      break;
+  }
+  if (!origin)
+    return accessNull;
+  loc = Location(new GroveImplProxyOrigin(grove(), origin), chunk_->locIndex);
+  return accessOK;
+}
+
+void GroveImpl::storeLocOrigin(const ConstPtr<Origin> &locOrigin)
+{
+  LocOriginChunk *chunk
+    = new (allocChunk(sizeof(LocOriginChunk)))
+   LocOriginChunk(currentLocOrigin_);
+  chunk->origin = origin_;
+  completeLimitWithLocChunkAfter_ = completeLimit_;
+  nChunksSinceLocOrigin_ = 0;
+  if (locOrigin.pointer() == currentLocOrigin_)
+    return;
+  if (currentLocOrigin_
+      && locOrigin == currentLocOrigin_->parent().origin()) {
+
+    currentLocOrigin_ = locOrigin.pointer();
+    return;
+  }
+  currentLocOrigin_ = locOrigin.pointer();
+  if (locOrigin.isNull())
+    return;
+  origins_.push_back(locOrigin);
+}
+
+AccessResult GroveImpl::proxifyLocation(const Location &loc, Location &ret) const
+{
+  if (loc.origin().isNull())
+    return accessNull;
+  ret = Location(new GroveImplProxyOrigin(this, loc.origin().pointer()),
+   loc.index());
+  return accessOK;
+}
+
+NodeListPtr AttributesNamedNodeList::nodeList() const
+{
+  const AttributeDefinitionList *defList = attDefList();
+  if (!defList || defList->size() == 0)
+    return new BaseNodeList;
+  else
+    return new SiblingNodeList(makeAttributeAsgnNode(grove(), 0));
+}
+
+AccessResult
+AttributesNamedNodeList::namedNodeU(const StringC &str, NodePtr &ptr) const
+{
+  const AttributeDefinitionList *defList = attDefList();
+  if (defList) {
+    for (size_t i = 0; i < defList->size(); i++)
+      if (defList->def(i)->name() == str) {
+        ptr.assign(makeAttributeAsgnNode(grove(), i));
+ return accessOK;
+      }
+  }
+  return accessNull;
+}
+
+void SgmlDocumentNode::accept(NodeVisitor &visitor)
+{
+  visitor.sgmlDocument(*this);
+}
+
+AccessResult SgmlDocumentNode::getSgmlConstants(NodePtr &ptr) const
+{
+  ptr.assign(new SgmlConstantsNode(grove()));
+  return accessOK;
+}
+
+AccessResult SgmlDocumentNode::getApplicationInfo(GroveString &str) const
+{
+  const StringC *appinfo;
+  while (!grove()->getAppinfo(appinfo))
+    if (!grove()->waitForMoreNodes())
+      return accessTimeout;
+  if (!appinfo)
+    return accessNull;
+  setString(str, *appinfo);
+  return accessOK;
+}
+
+AccessResult SgmlDocumentNode::getDocumentElement(NodePtr &ptr) const
+{
+  while (chunk()->documentElement == 0) {
+    if (grove()->complete()) {
+
+      if (chunk()->documentElement)
+ break;
+      return accessNull;
+    }
+    if (!grove()->waitForMoreNodes())
+      return accessTimeout;
+  }
+  return chunk()->documentElement->setNodePtrFirst(ptr, this);
+}
+
+AccessResult SgmlDocumentNode::getProlog(NodeListPtr &ptr) const
+{
+  while (chunk()->prolog == 0) {
+    if (chunk()->documentElement || grove()->complete())
+      break;
+    if (!grove()->waitForMoreNodes())
+      return accessTimeout;
+  }
+  if (chunk()->prolog == 0)
+    ptr.assign(new BaseNodeList);
+  else {
+    NodePtr tem;
+    chunk()->prolog->setNodePtrFirst(tem, this);
+    ptr.assign(new SiblingNodeList(tem));
+  }
+  return accessOK;
+}
+
+AccessResult SgmlDocumentNode::getEpilog(NodeListPtr &ptr) const
+{
+  while (chunk()->epilog == 0) {
+    if (grove()->complete())
+      break;
+    if (!grove()->waitForMoreNodes())
+      return accessTimeout;
+  }
+  if (chunk()->epilog == 0)
+    ptr.assign(new BaseNodeList);
+  else {
+    NodePtr tem;
+    chunk()->epilog->setNodePtrFirst(tem, this);
+    ptr.assign(new SiblingNodeList(tem));
+  }
+  return accessOK;
+}
+
+AccessResult SgmlDocumentNode::getElements(NamedNodeListPtr &ptr) const
+{
+  while (!grove()->root()->documentElement) {
+    if (grove()->complete()) {
+      if (grove()->root()->documentElement)
+ break;
+      return accessNull;
+    }
+    if (!grove()->waitForMoreNodes())
+      return accessTimeout;
+  }
+  if (!grove()->generalSubstTable())
+    return accessNull;
+  ptr.assign(new ElementsNamedNodeList(grove()));
+  return accessOK;
+}
+
+AccessResult SgmlDocumentNode::getEntities(NamedNodeListPtr &ptr) const
+{
+  while (!grove()->governingDtd()) {
+    if (grove()->complete()) {
+      if (grove()->governingDtd())
+ break;
+      return accessNull;
+    }
+    if (!grove()->waitForMoreNodes())
+      return accessTimeout;
+  }
+  ptr.assign(new DocEntitiesNamedNodeList(grove()));
+  return accessOK;
+}
+
+AccessResult SgmlDocumentNode::getDefaultedEntities(NamedNodeListPtr &ptr) const
+{
+  while (!grove()->complete())
+    if (!grove()->waitForMoreNodes())
+      return accessTimeout;
+  ptr.assign(new DefaultedEntitiesNamedNodeList(grove()));
+  return accessOK;
+}
+
+AccessResult SgmlDocumentNode::getGoverningDoctype(NodePtr &ptr) const
+{
+  while (!grove()->governingDtd()) {
+    if (grove()->complete()) {
+      if (grove()->governingDtd())
+ break;
+      return accessNull;
+    }
+    if (!grove()->waitForMoreNodes())
+      return accessTimeout;
+  }
+  ptr.assign(new DocumentTypeNode(grove(), grove()->governingDtd()));
+  return accessOK;
+}
+
+AccessResult SgmlDocumentNode::getDoctypesAndLinktypes(NamedNodeListPtr &ptr) const
+{
+  while (!grove()->governingDtd()) {
+    if (grove()->complete()) {
+      if (grove()->governingDtd())
+ break;
+      return accessNull;
+    }
+    if (!grove()->waitForMoreNodes())
+      return accessTimeout;
+  }
+  ptr.assign(new DoctypesAndLinktypesNamedNodeList(grove()));
+  return accessOK;
+}
+
+AccessResult SgmlDocumentNode::getMessages(NodeListPtr &ptr) const
+{
+  while (grove()->messageList() == 0) {
+    if (grove()->complete())
+      break;
+    if (!grove()->waitForMoreNodes())
+      return accessTimeout;
+  }
+  if (grove()->messageList()) {
+    NodePtr tem(new MessageNode(grove(), grove()->messageList()));
+    ptr.assign(new SiblingNodeList(tem));
+  }
+  else
+    ptr.assign(new BaseNodeList);
+  return accessOK;
+}
+
+AccessResult SgmlDocumentNode::getSd(ConstPtr<Sd> &sd,
+         ConstPtr<Syntax> &prologSyntax,
+         ConstPtr<Syntax> &instanceSyntax) const
+{
+  while (!grove()->complete()) {
+    if (!grove()->waitForMoreNodes())
+      return accessTimeout;
+  }
+  grove()->getSd(sd, prologSyntax, instanceSyntax);
+  if (!sd.isNull() && !prologSyntax.isNull() && !instanceSyntax.isNull())
+    return accessOK;
+  return accessNull;
+}
+
+AccessResult
+SgmlDocumentChunk::setNodePtrFirst(NodePtr &ptr, const BaseNode *node) const
+{
+  ptr.assign(new SgmlDocumentNode(node->grove(), this));
+  return accessOK;
+}
+
+DocumentTypeNode::DocumentTypeNode(const GroveImpl *grove, const Dtd *dtd)
+: BaseNode(grove), dtd_(dtd)
+{
+}
+
+AccessResult DocumentTypeNode::nextChunkSibling(NodePtr &ptr) const
+{
+  const Dtd *next = grove()->nextDtd(dtd_);
+  if (!next)
+    return accessNull;
+  ptr.assign(new DocumentTypeNode(grove(), next));
+  return accessOK;
+}
+
+AccessResult DocumentTypeNode::getName(GroveString &str) const
+{
+  setString(str, dtd_->name());
+  return accessOK;
+}
+
+AccessResult DocumentTypeNode::getGoverning(bool &governing) const
+{
+  governing = dtd_->isBase();
+  return accessOK;
+}
+
+AccessResult DocumentTypeNode::getGeneralEntities(NamedNodeListPtr &ptr) const
+{
+  ptr.assign(new GeneralEntitiesNamedNodeList(grove(), dtd_));
+  return accessOK;
+}
+
+AccessResult DocumentTypeNode::getParameterEntities(NamedNodeListPtr &ptr) const
+{
+  ptr.assign(new ParameterEntitiesNamedNodeList(grove(), dtd_));
+  return accessOK;
+}
+
+AccessResult DocumentTypeNode::getNotations(NamedNodeListPtr &ptr) const
+{
+  ptr.assign(new NotationsNamedNodeList(grove(), dtd_));
+  return accessOK;
+}
+
+AccessResult DocumentTypeNode::getElementTypes(NamedNodeListPtr &ptr) const
+{
+  ptr.assign(new ElementTypesNamedNodeList(grove(), dtd_));
+  return accessOK;
+}
+
+AccessResult DocumentTypeNode::getDefaultEntity(NodePtr &ptr) const
+{
+  const Entity *entity = dtd_->defaultEntityTemp();
+  if (entity == 0)
+    return accessNull;
+  ptr.assign(new DefaultEntityNode(grove(), entity));
+  return accessOK;
+}
+
+AccessResult DocumentTypeNode::getOrigin(NodePtr &ptr) const
+{
+  ptr.assign(new SgmlDocumentNode(grove(), grove()->root()));
+  return accessOK;
+}
+
+void DocumentTypeNode::accept(NodeVisitor &visitor)
+{
+  visitor.documentType(*this);
+}
+
+bool DocumentTypeNode::same(const BaseNode &node) const
+{
+  return node.same2(this);
+}
+
+bool DocumentTypeNode::same2(const DocumentTypeNode *node) const
+{
+  return dtd_ == node->dtd_;
+}
+
+SgmlConstantsNode::SgmlConstantsNode(const GroveImpl *grove)
+: BaseNode(grove)
+{
+}
+
+AccessResult SgmlConstantsNode::getOrigin(NodePtr &ptr) const
+{
+  ptr.assign(new SgmlDocumentNode(grove(), grove()->root()));
+  return accessOK;
+}
+
+void SgmlConstantsNode::accept(NodeVisitor &visitor)
+{
+  visitor.sgmlConstants(*this);
+}
+
+bool SgmlConstantsNode::same(const BaseNode &node) const
+{
+  return node.same2(this);
+}
+
+bool SgmlConstantsNode::same2(const SgmlConstantsNode *) const
+{
+  return 1;
+}
+
+MessageNode::MessageNode(const GroveImpl *grove, const MessageItem *item)
+: BaseNode(grove), item_(item)
+{
+}
+
+AccessResult MessageNode::getOrigin(NodePtr &ptr) const
+{
+  ptr.assign(new SgmlDocumentNode(grove(), grove()->root()));
+  return accessOK;
+}
+
+AccessResult MessageNode::nextChunkSibling(NodePtr &ptr) const
+{
+  while (!item_->next()) {
+    if (grove()->complete()) {
+      if (item_->next())
+ break;
+      return accessNull;
+    }
+    if (!grove()->waitForMoreNodes())
+      return accessTimeout;
+  }
+  const MessageItem *p = item_->next();
+  if (!p)
+    return accessNull;
+  ptr.assign(new MessageNode(grove(), p));
+  return accessOK;
+}
+
+AccessResult MessageNode::firstSibling(NodePtr &ptr) const
+{
+  ptr.assign(new MessageNode(grove(), grove()->messageList()));
+  return accessOK;
+}
+
+AccessResult MessageNode::siblingsIndex(unsigned long &n) const
+{
+  n = 0;
+  for (const MessageItem *p = grove()->messageList(); p != item_; p = p->next())
+    n++;
+  return accessOK;
+}
+
+void MessageNode::accept(NodeVisitor &visitor)
+{
+  visitor.message(*this);
+}
+
+bool MessageNode::same(const BaseNode &node) const
+{
+  return node.same2(this);
+}
+
+bool MessageNode::same2(const MessageNode *node) const
+{
+  return item_ == node->item_;
+}
+
+AccessResult MessageNode::getLocation(Location &loc) const
+{
+  return grove()->proxifyLocation(item_->loc(), loc);
+}
+
+AccessResult MessageNode::getText(GroveString &str) const
+{
+  setString(str, item_->text());
+  return accessOK;
+}
+
+AccessResult MessageNode::getSeverity(Severity &severity) const
+{
+  severity = item_->severity();
+  return accessOK;
+}
+
+AccessResult ElementNode::nextChunkSibling(NodePtr &ptr) const
+{
+  while (!chunk()->nextSibling) {
+    if (!grove()->maybeMoreSiblings(chunk())) {
+
+      if ((const Chunk *)chunk() == grove()->root()->documentElement)
+ return accessNotInClass;
+      else
+        return accessNull;
+    }
+    if (!grove()->waitForMoreNodes())
+      return accessTimeout;
+  }
+  return chunk()->nextSibling->setNodePtrFirst(ptr, this);
+}
+
+
+
+
+AccessResult ElementNode::nextChunkAfter(NodePtr &nd) const
+{
+  const Chunk *p = chunk_->after();
+  while (p == grove()->completeLimit())
+    if (!grove()->waitForMoreNodes())
+      return accessTimeout;
+  return p->setNodePtrFirst(nd, this);
+}
+
+AccessResult ElementChunk::getFollowing(const GroveImpl *grove,
+     const Chunk *&f,
+     unsigned long &n) const
+{
+  while (!nextSibling) {
+    if (!grove->maybeMoreSiblings(this)) {
+      if ((const Chunk *)origin == grove->root())
+ return accessNotInClass;
+      else
+        return accessNull;
+    }
+    if (!grove->waitForMoreNodes())
+      return accessTimeout;
+  }
+  f = nextSibling;
+  n = 1;
+  return accessOK;
+}
+
+AccessResult ElementNode::firstChild(NodePtr &ptr) const
+{
+  const Chunk *p = chunk()->after();
+  while (p == grove()->completeLimit()) {
+    if (!grove()->waitForMoreNodes())
+      return accessTimeout;
+  }
+  if ((const Chunk *)(p->origin) == chunk())
+    return p->setNodePtrFirst(ptr, this);
+  return accessNull;
+}
+
+AccessResult ElementNode::attributeRef(unsigned long n, NodePtr &ptr) const
+{
+  const AttributeDefinitionList *defList = chunk()->attDefList();
+  if (!defList || n >= defList->size())
+    return accessNull;
+  ptr.assign(new ElementAttributeAsgnNode(grove(), size_t(n), chunk()));
+  return accessOK;
+}
+
+AccessResult ElementNode::getAttributes(NamedNodeListPtr &ptr) const
+{
+  ptr.assign(new ElementAttributesNamedNodeList(grove(), chunk()));
+  return accessOK;
+}
+
+AccessResult ElementNode::getGi(GroveString &str) const
+{
+  setString(str, chunk()->type->name());
+  return accessOK;
+}
+
+bool ElementNode::hasGi(GroveString str) const
+{
+  const StringC &gi = chunk()->type->name();
+  size_t len = gi.size();
+  if (len != str.size())
+    return 0;
+  const SubstTable *subst = grove()->generalSubstTable();
+  if (!subst)
+    return 0;
+  for (size_t i = 0; i < len; i++)
+    if ((*subst)[str[i]] != gi[i])
+      return 0;
+  return 1;
+}
+
+AccessResult ElementNode::getId(GroveString &str) const
+{
+  const StringC *id = chunk()->id();
+  if (!id)
+    return accessNull;
+  setString(str, *id);
+  return accessOK;
+}
+
+AccessResult ElementNode::elementIndex(unsigned long &i) const
+{
+  i = chunk()->elementIndex;
+  return accessOK;
+}
+
+AccessResult ElementNode::getElementType(NodePtr &ptr) const
+{
+  if (chunk()->elementType() == 0)
+    return accessNull;
+  ptr.assign(new ElementTypeNode(grove(), *(chunk()->elementType())));
+  return accessOK;
+}
+
+AccessResult ElementNode::getContent(NodeListPtr &ptr) const
+{
+  return children(ptr);
+}
+
+AccessResult ElementNode::getMustOmitEndTag(bool &b) const
+{
+  b = chunk()->mustOmitEndTag();
+  return accessOK;
+}
+
+AccessResult ElementNode::getIncluded(bool &b) const
+{
+  b = chunk()->included();
+  return accessOK;
+}
+
+void ElementNode::accept(NodeVisitor &visitor)
+{
+  visitor.element(*this);
+}
+
+ElementChunk *
+ElementNode::makeAttElementChunk(GroveImpl &grove,
+     const StartElementEvent &event,
+     Boolean &hasId)
+{
+  const AttributeList &atts = event.attributes();
+  size_t nAtts = atts.size();
+  while (nAtts > 0 && !atts.specified(nAtts - 1) && !atts.current(nAtts - 1))
+    nAtts--;
+  ElementChunk *chunk;
+  void *mem
+    = grove.allocChunk(sizeof(AttElementChunk) + nAtts * sizeof(AttributeValue *));
+  if (event.included()) {
+
+    AttElementChunk *tem = new (mem) IncludedAttElementChunk(nAtts);
+    chunk = tem;
+  }
+  else
+    chunk = new (mem) AttElementChunk(nAtts);
+  const AttributeValue **values
+    = (const AttributeValue **)(((AttElementChunk *)chunk) + 1);
+  const AttributeDefinitionList *defList
+    = event.elementType()->attributeDef().pointer();
+  unsigned idIndex;
+  if (atts.idIndex(idIndex) && atts.specified(idIndex) && atts.value(idIndex))
+    hasId = 1;
+  else
+    hasId = 0;
+  for (size_t i = 0; i < nAtts; i++) {
+    if (atts.specified(i) || atts.current(i)) {
+      grove.storeAttributeValue(atts.valuePointer(i));
+      values[i] = atts.value(i);
+    }
+    else {
+
+
+
+
+      values[i] = defList->def(i)->defaultValue(grove.impliedAttributeValue());
+    }
+  }
+  return chunk;
+}
+
+const Chunk *AttElementChunk::after() const
+{
+  return (const Chunk *)((char *)(this + 1)
+    + (sizeof(const AttributeValue *) * nAtts));
+}
+
+const AttributeValue *
+AttElementChunk::attributeValue(size_t attIndex, const GroveImpl &grove) const
+{
+  if (attIndex < nAtts)
+    return ((const AttributeValue **)(this + 1))[attIndex];
+  else
+    return ElementChunk::attributeValue(attIndex, grove);
+}
+
+const StringC *AttElementChunk::id() const
+{
+  size_t i = ElementChunk::attDefList()->idIndex();
+  if (i == size_t(-1) || i >= nAtts)
+    return 0;
+  const AttributeValue *av = ((const AttributeValue **)(this + 1))[i];
+  if (!av)
+    return 0;
+  const Text *t = av->text();
+  if (!t)
+    return 0;
+  return &t->string();
+}
+
+Boolean AttElementChunk::mustOmitEndTag() const
+{
+  if (ElementChunk::mustOmitEndTag())
+    return 1;
+  const AttributeDefinitionList *adl = ElementChunk::attDefList();
+  size_t nAtts = adl->size();
+  const AttributeValue **atts = (const AttributeValue **)(this + 1);
+  for (size_t i = 0; i < nAtts; i++)
+    if (adl->def(i)->isConref() && atts[i] && atts[i]->text())
+      return 1;
+  return 0;
+}
+
+const Chunk *ElementChunk::after() const
+{
+  return this + 1;
+}
+
+const AttributeValue *
+ElementChunk::attributeValue(size_t attIndex, const GroveImpl &grove) const
+{
+  return attDefList()->def(attIndex)->defaultValue(grove.impliedAttributeValue());
+}
+
+Boolean ElementChunk::mustOmitEndTag() const
+{
+  return type->definition()->declaredContent() == ElementDefinition::empty;
+}
+
+Boolean IncludedElementChunk::included() const
+{
+  return 1;
+}
+
+Boolean IncludedAttElementChunk::included() const
+{
+  return 1;
+}
+
+Boolean ElementChunk::included() const
+{
+  return 0;
+}
+
+AccessResult
+ElementChunk::setNodePtrFirst(NodePtr &ptr, const BaseNode *node) const
+{
+  ptr.assign(new ElementNode(node->grove(), this));
+  return accessOK;
+}
+
+AccessResult
+ElementChunk::setNodePtrFirst(NodePtr &ptr, const ElementNode *node) const
+{
+  if (node->canReuse(ptr))
+    ((ElementNode *)node)->reuseFor(this);
+  else
+    ptr.assign(new ElementNode(node->grove(), this));
+  return accessOK;
+}
+
+AccessResult
+ElementChunk::setNodePtrFirst(NodePtr &ptr, const DataNode *node) const
+{
+  ptr.assign(new ElementNode(node->grove(), this));
+  return accessOK;
+}
+
+ElementAttributeOrigin::ElementAttributeOrigin(const ElementChunk *chunk)
+: chunk_(chunk)
+{
+}
+
+const AttributeDefinitionList *ElementAttributeOrigin::attDefList() const
+{
+  return chunk_->attDefList();
+}
+
+
+const AttributeValue *
+ElementAttributeOrigin::attributeValue(size_t attIndex, const GroveImpl &grove) const
+{
+  return chunk_->attributeValue(attIndex, grove);
+}
+
+
+AccessResult
+ElementAttributeOrigin::setNodePtrAttributeOrigin(NodePtr &ptr,
+        const BaseNode *node) const
+{
+  return chunk_->setNodePtrFirst(ptr, node);
+}
+
+
+Node *ElementAttributeOrigin
+::makeCdataAttributeValueNode(const GroveImpl *grove,
+         const AttributeValue *value,
+         size_t attIndex,
+         const TextIter &iter,
+         size_t charIndex) const
+{
+  return new ElementCdataAttributeValueNode(grove, value, attIndex, iter,
+         charIndex, chunk_);
+}
+
+
+Node *ElementAttributeOrigin
+::makeAttributeValueTokenNode(const GroveImpl *grove,
+         const TokenizedAttributeValue *value,
+         size_t attIndex,
+         size_t tokenIndex) const
+{
+  return new ElementAttributeValueTokenNode(grove, value, attIndex,
+         tokenIndex, chunk_);
+}
+
+Node *ElementAttributeOrigin
+::makeAttributeAsgnNode(const GroveImpl *grove,
+   size_t attIndex) const
+{
+  return new ElementAttributeAsgnNode(grove, attIndex, chunk_);
+}
+
+AccessResult ElementAttributeOrigin
+::makeAttributeDefNode(const GroveImpl *grove,
+                       NodePtr &ptr,
+                       size_t attributeDefIdx) const
+{
+  if (chunk_->elementType() == 0)
+    return accessNull;
+  ptr.assign(new ElementTypeAttributeDefNode(grove,
+                                             *(chunk_->elementType()),
+                                             attributeDefIdx));
+  return accessOK;
+}
+
+Node *ElementAttributeOrigin::makeOriginNode(const GroveImpl *grove, size_t attIndex) const
+{
+  return makeAttributeAsgnNode(grove, attIndex);
+}
+
+const void *ElementAttributeOrigin::attributeOriginId() const
+{
+  return chunk_;
+}
+
+bool DataNode::same(const BaseNode &node) const
+{
+  return node.same2(this);
+}
+
+bool DataNode::same2(const DataNode *node) const
+{
+  return chunk_ == node->chunk_ && index_ == node->index_;
+}
+
+bool DataNode::chunkContains(const Node &node) const
+{
+  if (!sameGrove(node))
+    return 0;
+  return ((const BaseNode &)node).inChunk(this);
+}
+
+bool DataNode::inChunk(const DataNode *node) const
+{
+  return chunk_ == node->chunk_ && index_ >= node->index_;
+}
+
+AccessResult DataNode::charChunk(const SdataMapper &, GroveString &str) const
+{
+  str.assign(chunk()->data() + index_, chunk()->size - index_);
+  return accessOK;
+}
+
+void DataNode::accept(NodeVisitor &visitor)
+{
+  visitor.dataChar(*this);
+}
+
+unsigned long DataNode::hash() const
+{
+  return secondHash(ChunkNode::hash() + index_);
+}
+
+AccessResult DataNode::getNonSgml(unsigned long &) const
+{
+  return accessNull;
+}
+
+AccessResult DataNode::nextSibling(NodePtr &ptr) const
+{
+  if (index_ + 1 < chunk()->size) {
+    if (canReuse(ptr))
+      ((DataNode *)this)->index_ += 1;
+    else
+      ptr.assign(new DataNode(grove(), chunk(), index_ + 1));
+    return accessOK;
+  }
+  return DataNode::nextChunkSibling(ptr);
+}
+
+AccessResult DataNode::nextChunkAfter(NodePtr &nd) const
+{
+  const Chunk *p = chunk_->after();
+  while (p == grove()->completeLimit())
+    if (!grove()->waitForMoreNodes())
+      return accessTimeout;
+  return p->setNodePtrFirst(nd, this);
+}
+
+AccessResult DataNode::followSiblingRef(unsigned long i, NodePtr &ptr) const
+{
+  if (i < chunk()->size - index_ - 1) {
+    if (canReuse(ptr))
+      ((DataNode *)this)->index_ += 1 + size_t(i);
+    else
+      ptr.assign(new DataNode(grove(), chunk(), index_ + size_t(i) + 1));
+    return accessOK;
+  }
+  return ChunkNode::followSiblingRef(i - (chunk()->size - index_ - 1), ptr);
+}
+
+AccessResult DataNode::siblingsIndex(unsigned long &i) const
+{
+  AccessResult ret = ChunkNode::siblingsIndex(i);
+  if (ret == accessOK)
+    i += index_;
+  return ret;
+}
+
+AccessResult DataNode::getLocation(Location &loc) const
+{
+  AccessResult ret = ChunkNode::getLocation(loc);
+  if (ret == accessOK)
+    loc += index_;
+  return ret;
+}
+
+AccessResult DataChunk::getFollowing(const GroveImpl *grove,
+         const Chunk *&f,
+         unsigned long &i) const
+{
+
+
+
+  const Chunk *p = CharsChunk::after();
+  while (p == grove->completeLimit())
+    if (!grove->waitForMoreNodes())
+      return accessTimeout;
+  if (p->origin != origin)
+    return accessNull;
+  i = size;
+  f = p;
+  return accessOK;
+}
+
+AccessResult DataChunk::setNodePtrFirst(NodePtr &ptr,
+     const BaseNode *node) const
+{
+  ptr.assign(new DataNode(node->grove(), this, 0));
+  return accessOK;
+}
+
+
+AccessResult DataChunk::setNodePtrFirst(NodePtr &ptr,
+     const ElementNode *node) const
+{
+  ptr.assign(new DataNode(node->grove(), this, 0));
+  return accessOK;
+}
+
+AccessResult DataChunk::setNodePtrFirst(NodePtr &ptr, const DataNode *node)
+     const
+{
+  if (node->canReuse(ptr))
+    ((DataNode *)node)->reuseFor(this, 0);
+  else
+    ptr.assign(new DataNode(node->grove(), this, 0));
+  return accessOK;
+}
+
+AccessResult PiNode::getSystemData(GroveString &str) const
+{
+  str.assign(chunk()->data(), chunk()->size);
+  return accessOK;
+}
+
+void PiNode::add(GroveImpl &grove, const PiEvent &event)
+{
+  const Entity *entity = event.entity();
+  if (entity)
+    PiEntityNode::add(grove, entity, event.location());
+  else {
+    grove.setLocOrigin(event.location().origin());
+    size_t dataLen = event.dataLength();
+    void *mem = grove.allocChunk(CharsChunk::allocSize(dataLen));
+    PiChunk *chunk;
+    if (grove.haveRootOrigin()) {
+      if (grove.root()->documentElement)
+ chunk = new (mem) EpilogPiChunk;
+      else
+ chunk = new (mem) PrologPiChunk;
+    }
+    else
+      chunk = new (mem) PiChunk;
+    chunk->size = dataLen;
+    chunk->locIndex = event.location().index();
+    memcpy(chunk + 1, event.data(), dataLen * sizeof(Char));
+    grove.appendSibling(chunk);
+  }
+}
+
+AccessResult PiChunk::setNodePtrFirst(NodePtr &ptr, const BaseNode *node) const
+{
+  ptr.assign(new PiNode(node->grove(), this));
+  return accessOK;
+}
+
+AccessResult PrologPiChunk::getFirstSibling(const GroveImpl *grove, const struct Chunk *&p) const
+{
+  p = grove->root()->prolog;
+  return accessOK;
+}
+
+AccessResult EpilogPiChunk::getFirstSibling(const GroveImpl *grove, const struct Chunk *&p) const
+{
+  p = grove->root()->epilog;
+  return accessOK;
+}
+
+AccessResult SdataNode::charChunk(const SdataMapper &mapper, GroveString &str) const
+{
+  const StringC &name = chunk()->entity->name();
+  const StringC &text = chunk()->entity->asInternalEntity()->string();
+  Char *cp = (Char *)&c_;
+  if (mapper.sdataMap(GroveString(name.data(), name.size()), GroveString(text.data(), text.size()), *cp)) {
+    str.assign(&c_, 1);
+    return accessOK;
+  }
+  else
+    return accessNull;
+}
+
+AccessResult SdataNode::getSystemData(GroveString &str) const
+{
+  setString(str, chunk()->entity->asInternalEntity()->string());
+  return accessOK;
+}
+
+void SdataNode::add(GroveImpl &grove, const SdataEntityEvent &event)
+{
+  const Location &loc = event.location().origin()->parent();
+  grove.setLocOrigin(loc.origin());
+  SdataChunk *chunk = new (grove.allocChunk(sizeof(SdataChunk))) SdataChunk;
+  chunk->entity = event.entity();
+  chunk->locIndex = loc.index();
+  grove.appendSibling(chunk);
+}
+
+AccessResult SdataChunk::setNodePtrFirst(NodePtr &ptr, const BaseNode *node)
+     const
+{
+  ptr.assign(new SdataNode(node->grove(), this));
+  return accessOK;
+}
+
+AccessResult NonSgmlChunk::setNodePtrFirst(NodePtr &ptr, const BaseNode *node)
+     const
+{
+  ptr.assign(new NonSgmlNode(node->grove(), this));
+  return accessOK;
+}
+
+AccessResult NonSgmlNode::getNonSgml(unsigned long &n) const
+{
+  n = chunk()->c;
+  return accessOK;
+}
+
+AccessResult NonSgmlNode::charChunk(const SdataMapper &, GroveString &) const
+{
+  return accessNull;
+}
+
+void NonSgmlNode::add(GroveImpl &grove, const NonSgmlCharEvent &event)
+{
+  grove.setLocOrigin(event.location().origin());
+  NonSgmlChunk *chunk = new (grove.allocChunk(sizeof(NonSgmlChunk))) NonSgmlChunk;
+  chunk->c = event.character();
+  chunk->locIndex = event.location().index();
+  grove.appendSibling(chunk);
+}
+
+void ExternalDataNode::add(GroveImpl &grove, const ExternalDataEntityEvent &event)
+{
+  grove.setLocOrigin(event.location().origin());
+  ExternalDataChunk *chunk = new (grove.allocChunk(sizeof(ExternalDataChunk))) ExternalDataChunk;
+  chunk->entity = event.entity();
+  chunk->locIndex = event.location().index();
+  grove.appendSibling(chunk);
+}
+
+AccessResult ExternalDataChunk::setNodePtrFirst(NodePtr &ptr, const BaseNode *node)
+     const
+{
+  ptr.assign(new ExternalDataNode(node->grove(), this));
+  return accessOK;
+}
+
+void SubdocNode::add(GroveImpl &grove, const SubdocEntityEvent &event)
+{
+  grove.setLocOrigin(event.location().origin());
+  SubdocChunk *chunk = new (grove.allocChunk(sizeof(SubdocChunk))) SubdocChunk;
+  chunk->entity = event.entity();
+  chunk->locIndex = event.location().index();
+  grove.appendSibling(chunk);
+}
+
+AccessResult SubdocChunk::setNodePtrFirst(NodePtr &ptr, const BaseNode *node)
+     const
+{
+  ptr.assign(new SubdocNode(node->grove(), this));
+  return accessOK;
+}
+
+AccessResult PiEntityNode::getSystemData(GroveString &str) const
+{
+  setString(str, chunk()->entity->asInternalEntity()->string());
+  return accessOK;
+}
+
+void PiEntityNode::add(GroveImpl &grove, const Entity *entity,
+         const Location &loc)
+{
+
+  grove.setLocOrigin(loc.origin());
+  PiEntityChunk *chunk = new (grove.allocChunk(sizeof(PiEntityChunk))) PiEntityChunk;
+  chunk->entity = entity;
+  chunk->locIndex = loc.index();
+  grove.appendSibling(chunk);
+}
+
+AccessResult PiEntityChunk::setNodePtrFirst(NodePtr &ptr, const BaseNode *node)
+ const
+{
+  ptr.assign(new PiEntityNode(node->grove(), this));
+  return accessOK;
+}
+
+AccessResult EntityRefNode::getEntity(NodePtr &ptr) const
+{
+  ptr.assign(new EntityNode(grove(), chunk()->entity));
+  return accessOK;
+}
+
+AccessResult EntityRefNode::getEntityName(GroveString &str) const
+{
+  setString(str, chunk()->entity->name());
+  return accessOK;
+}
+
+AttributeAsgnNode::AttributeAsgnNode(const GroveImpl *grove,
+         size_t attIndex)
+: BaseNode(grove), AttributeDefOrigin(attIndex)
+{
+}
+
+AccessResult ChunkNode::nextChunkSibling(NodePtr &ptr) const
+{
+
+
+  const Chunk *p = chunk_->after();
+  while (p == grove()->completeLimit())
+    if (!grove()->waitForMoreNodes())
+      return accessTimeout;
+  if (p->origin != chunk_->origin)
+    return accessNull;
+  return p->setNodePtrFirst(ptr, this);
+}
+
+AccessResult ChunkNode::nextChunkAfter(NodePtr &nd) const
+{
+  const Chunk *p = chunk_->after();
+  while (p == grove()->completeLimit())
+    if (!grove()->waitForMoreNodes())
+      return accessTimeout;
+  return p->setNodePtrFirst(nd, this);
+}
+
+AccessResult ChunkNode::firstSibling(NodePtr &ptr) const
+{
+  const Chunk *first;
+  AccessResult ret = chunk_->getFirstSibling(grove(), first);
+  if (ret != accessOK)
+    return ret;
+  return first->setNodePtrFirst(ptr, this);
+}
+
+AccessResult ChunkNode::siblingsIndex(unsigned long &i) const
+{
+  const Chunk *p;
+  AccessResult ret = chunk_->getFirstSibling(grove(), p);
+  if (ret != accessOK)
+    return ret;
+  i = 0;
+  while (p != chunk_) {
+    unsigned long tem;
+    if (p->getFollowing(grove(), p, tem) != accessOK)
+      (static_cast<void> (__builtin_expect (!!(0), 1) ? 0 : (__assert_fail ("0", "GroveBuilder.cxx", 3758, __PRETTY_FUNCTION__), 0)));
+    i += tem;
+  }
+  return accessOK;
+}
+
+AccessResult ChunkNode::followSiblingRef(unsigned long i, NodePtr &ptr) const
+{
+  const Chunk *p;
+  unsigned long count;
+  AccessResult ret = chunk()->getFollowing(grove(), p, count);
+  if (ret != accessOK)
+    return ret;
+  while (i > 0) {
+    const Chunk *lastP = p;
+    ret = p->getFollowing(grove(), p, count);
+    if (ret == accessOK && count <= i)
+      i -= count;
+    else if (ret == accessOK || ret == accessNull) {
+      lastP->setNodePtrFirst(ptr, this);
+      return ptr->followSiblingRef(i - 1, ptr);
+    }
+    else
+      return ret;
+  }
+  return p->setNodePtrFirst(ptr, this);
+}
+
+AccessResult AttributeAsgnNode::getOrigin(NodePtr &ptr) const
+{
+  return setNodePtrAttributeOrigin(ptr, this);
+}
+
+AccessResult AttributeAsgnNode::getName(GroveString &str) const
+{
+  setString(str, attDefList()->def(attIndex_)->name());
+  return accessOK;
+}
+
+AccessResult AttributeAsgnNode::getImplied(bool &implied) const
+{
+  const AttributeValue *value = attributeValue(attIndex_, *grove());
+  implied = (value != 0 && value->text() == 0);
+  return accessOK;
+}
+
+AccessResult AttributeAsgnNode::getValue(NodeListPtr &ptr) const
+{
+  return children(ptr);
+}
+
+AccessResult AttributeAsgnNode::nextChunkSibling(NodePtr &ptr) const
+{
+  return followSiblingRef(0, ptr);
+}
+
+AccessResult AttributeAsgnNode::followSiblingRef(unsigned long i, NodePtr &ptr) const
+{
+
+  if (i >= attDefList()->size() - attIndex_ - 1)
+    return accessNull;
+  if (canReuse(ptr))
+    ((AttributeAsgnNode *)this)->attIndex_ += size_t(i) + 1;
+  else
+    ptr.assign(makeAttributeAsgnNode(grove(), attIndex_ + 1 + size_t(i)));
+  return accessOK;
+}
+
+AccessResult AttributeAsgnNode::firstSibling(NodePtr &ptr) const
+{
+  if (canReuse(ptr))
+    ((AttributeAsgnNode *)this)->attIndex_ = 0;
+  else
+    ptr.assign(makeAttributeAsgnNode(grove(), 0));
+  return accessOK;
+}
+
+AccessResult AttributeAsgnNode::siblingsIndex(unsigned long &i) const
+{
+  i = attIndex_;
+  return accessOK;
+}
+
+void AttributeAsgnNode::accept(NodeVisitor &visitor)
+{
+  visitor.attributeAssignment(*this);
+}
+
+AccessResult AttributeAsgnNode::firstChild(NodePtr &ptr) const
+{
+  const AttributeValue *value = attributeValue(attIndex_, *grove());
+  return makeAttributeValueNode(grove(), ptr, value);
+}
+
+AccessResult AttributeAsgnNode::children(NodeListPtr &ptr) const
+{
+  const AttributeValue *value = attributeValue(attIndex_, *grove());
+  return makeAttributeValueNodeList(grove(), ptr, value);
+}
+
+AccessResult AttributeAsgnNode::getTokenSep(Char &ch) const
+{
+  const AttributeValue *value = attributeValue(attIndex_, *grove());
+  if (!value)
+    return accessNull;
+  const Text *text;
+  const StringC *str;
+  if (value->info(text, str) != AttributeValue::tokenized)
+    return accessNull;
+  const TokenizedAttributeValue *tValue =
+    (const TokenizedAttributeValue *)value;
+  if (tValue->nTokens() <= 1)
+    return accessNull;
+  const Char *ptr;
+  size_t len;
+  tValue->token(0, ptr, len);
+
+  ch = ptr[len];
+  return accessOK;
+}
+
+AccessResult AttributeAsgnNode::tokens(GroveString &s) const
+{
+  const AttributeValue *value = attributeValue(attIndex_, *grove());
+  if (!value)
+    return accessNull;
+  const Text *text;
+  const StringC *str;
+  if (value->info(text, str) != AttributeValue::tokenized)
+    return accessNull;
+  setString(s, *str);
+  return accessOK;
+}
+
+AccessResult AttributeAsgnNode::getAttributeDef(NodePtr &ptr) const
+{
+  return makeAttributeDefNode(grove(), ptr, attIndex_);
+}
+
+bool AttributeAsgnNode::same(const BaseNode &node) const
+{
+  return node.same2(this);
+}
+
+bool AttributeAsgnNode::same2(const AttributeAsgnNode *node)
+ const
+{
+  return (attributeOriginId() == node->attributeOriginId()
+   && attIndex_ == node->attIndex_);
+}
+
+unsigned long AttributeAsgnNode::hash() const
+{
+  unsigned long n = (unsigned long)attributeOriginId();
+  return secondHash(n + attIndex_);
+}
+
+ElementAttributeAsgnNode
+::ElementAttributeAsgnNode(const GroveImpl *grove, size_t attIndex,
+      const ElementChunk *chunk)
+: AttributeAsgnNode(grove, attIndex),
+  ElementAttributeOrigin(chunk),
+  AttributeDefOrigin(attIndex)
+{
+}
+
+EntityAttributeAsgnNode
+::EntityAttributeAsgnNode(const GroveImpl *grove, size_t attIndex,
+     const ExternalDataEntity *entity)
+: AttributeAsgnNode(grove, attIndex),
+  EntityAttributeOrigin(entity),
+  AttributeDefOrigin(attIndex)
+{
+}
+
+CdataAttributeValueNode
+::CdataAttributeValueNode(const GroveImpl *grove,
+     const AttributeValue *value,
+     size_t attIndex,
+     const TextIter &iter,
+     size_t charIndex)
+: BaseNode(grove),
+  AttributeDefOrigin(attIndex),
+  value_(value),
+  iter_(iter),
+  charIndex_(charIndex)
+{
+}
+
+bool CdataAttributeValueNode::skipBoring(TextIter &iter)
+{
+  while (iter.valid()) {
+    switch (iter.type()) {
+    case TextItem::data:
+    case TextItem::cdata:
+    case TextItem::sdata:
+      {
+ size_t length;
+ iter.chars(length);
+ if (length > 0)
+   return 1;
+      }
+
+    default:
+      iter.advance();
+      break;
+    }
+  }
+  return 0;
+}
+
+AccessResult CdataAttributeValueNode::getParent(NodePtr &ptr) const
+{
+  ptr.assign(makeOriginNode(grove(), attIndex_));
+  return accessOK;
+}
+
+AccessResult CdataAttributeValueNode::charChunk(const SdataMapper &mapper, GroveString &str) const
+{
+  if (iter_.type() == TextItem::sdata) {
+    const Entity *entity = iter_.location().origin()->asEntityOrigin()->entity();
+    const StringC &name = entity->name();
+    const StringC &text = entity->asInternalEntity()->string();
+    Char *cp = (Char *)&c_;
+    if (mapper.sdataMap(GroveString(name.data(), name.size()), GroveString(text.data(), text.size()), *cp)) {
+      str.assign(&c_, 1);
+      return accessOK;
+    }
+    else
+      return accessNull;
+  }
+  size_t len;
+  const Char *s = iter_.chars(len);
+  str.assign(s + charIndex_, len - charIndex_);
+  return accessOK;
+}
+
+AccessResult CdataAttributeValueNode::siblingsIndex(unsigned long &n) const
+{
+  TextIter copy(iter_);
+  size_t tem;
+  const Char *iterChars = iter_.chars(tem);
+  copy.rewind();
+  skipBoring(copy);
+  n = 0;
+  while (copy.chars(tem) != iterChars) {
+    if (copy.type() == TextItem::sdata)
+      n += 1;
+    else
+      n += tem;
+    copy.advance();
+    skipBoring(copy);
+  }
+  n += charIndex_;
+  return accessOK;
+}
+
+AccessResult CdataAttributeValueNode::getEntity(NodePtr &ptr) const
+{
+  if (iter_.type() != TextItem::sdata)
+    return accessNotInClass;
+  const Entity *entity
+    = iter_.location().origin()->asEntityOrigin()->entity();
+  ptr.assign(new EntityNode(grove(), entity));
+  return accessOK;
+}
+
+AccessResult CdataAttributeValueNode::getEntityName(GroveString &str) const
+{
+  if (iter_.type() != TextItem::sdata)
+    return accessNotInClass;
+  const Entity *entity
+    = iter_.location().origin()->asEntityOrigin()->entity();
+  setString(str, entity->name());
+  return accessOK;
+}
+
+AccessResult CdataAttributeValueNode::getSystemData(GroveString &str) const
+{
+  if (iter_.type() != TextItem::sdata)
+    return accessNotInClass;
+  size_t len;
+  const Char *ptr = iter_.chars(len);
+  str.assign(ptr, len);
+  return accessOK;
+}
+
+AccessResult CdataAttributeValueNode::firstSibling(NodePtr &ptr) const
+{
+  TextIter copy(iter_);
+  copy.rewind();
+  skipBoring(copy);
+  if (canReuse(ptr)) {
+    CdataAttributeValueNode *node = (CdataAttributeValueNode *)this;
+    node->iter_ = copy;
+    node->charIndex_ = 0;
+  }
+  else
+    ptr.assign(makeCdataAttributeValueNode(grove(), value_, attIndex_, copy));
+  return accessOK;
+}
+
+AccessResult CdataAttributeValueNode::nextChunkSibling(NodePtr &ptr) const
+{
+  TextIter copy(iter_);
+  copy.advance();
+  if (!skipBoring(copy))
+    return accessNull;
+  if (canReuse(ptr)) {
+    CdataAttributeValueNode *node = (CdataAttributeValueNode *)this;
+    node->iter_ = copy;
+    node->charIndex_ = 0;
+  }
+  else
+    ptr.assign(makeCdataAttributeValueNode(grove(), value_, attIndex_, copy));
+  return accessOK;
+}
+
+AccessResult CdataAttributeValueNode::nextSibling(NodePtr &ptr) const
+{
+  if (iter_.type() != TextItem::sdata) {
+    size_t length;
+    iter_.chars(length);
+    if (charIndex_ + 1 < length) {
+      if (canReuse(ptr))
+ ((CdataAttributeValueNode *)this)->charIndex_ += 1;
+      else
+ ptr.assign(makeCdataAttributeValueNode(grove(), value_,
+            attIndex_, iter_,
+            charIndex_ + 1));
+      return accessOK;
+    }
+  }
+  return CdataAttributeValueNode::nextChunkSibling(ptr);
+}
+
+AccessResult CdataAttributeValueNode::getLocation(Location &loc) const
+{
+  if (iter_.type() == TextItem::sdata)
+    return grove()->proxifyLocation(iter_.location().origin()->parent(), loc);
+  else
+    return grove()->proxifyLocation(iter_.location(), loc);
+}
+
+void CdataAttributeValueNode::accept(NodeVisitor &visitor)
+{
+  if (iter_.type() == TextItem::sdata)
+    visitor.sdata(*this);
+  else
+    visitor.dataChar(*this);
+}
+
+unsigned long CdataAttributeValueNode::hash() const
+{
+  unsigned long n;
+  CdataAttributeValueNode::siblingsIndex(n);
+  return secondHash(secondHash((unsigned long)attributeOriginId() + attIndex_) + n);
+}
+
+const ClassDef &CdataAttributeValueNode::classDef() const
+{
+  if (iter_.type() == TextItem::sdata)
+    return ClassDef::sdata;
+  else
+    return ClassDef::dataChar;
+}
+
+bool CdataAttributeValueNode::same(const BaseNode &node) const
+{
+  return node.same2(this);
+}
+
+bool CdataAttributeValueNode::same2(const CdataAttributeValueNode *node)
+     const
+{
+  size_t tem;
+  return (attributeOriginId() == node->attributeOriginId()
+   && attIndex_ == node->attIndex_
+   && charIndex_ == node->charIndex_
+   && iter_.chars(tem) == node->iter_.chars(tem));
+}
+
+bool CdataAttributeValueNode::chunkContains(const Node &node) const
+{
+  if (!sameGrove(node))
+    return 0;
+  return ((const BaseNode &)node).inChunk(this);
+}
+
+bool CdataAttributeValueNode::inChunk(const CdataAttributeValueNode *node) const
+{
+  size_t tem;
+  return (attributeOriginId() == node->attributeOriginId()
+          && attIndex_ == node->attIndex_
+   && iter_.chars(tem) == node->iter_.chars(tem)
+   && charIndex_ >= node->charIndex_);
+}
+
+ElementCdataAttributeValueNode
+::ElementCdataAttributeValueNode(const GroveImpl *grove,
+     const AttributeValue *value,
+     size_t attIndex,
+     const TextIter &iter,
+     size_t charIndex,
+     const ElementChunk *chunk)
+: CdataAttributeValueNode(grove, value, attIndex, iter, charIndex),
+  ElementAttributeOrigin(chunk), AttributeDefOrigin(attIndex)
+{
+}
+
+EntityCdataAttributeValueNode
+::EntityCdataAttributeValueNode(const GroveImpl *grove,
+    const AttributeValue *value,
+    size_t attIndex,
+    const TextIter &iter,
+    size_t charIndex,
+    const ExternalDataEntity *entity)
+: CdataAttributeValueNode(grove, value, attIndex, iter, charIndex),
+  EntityAttributeOrigin(entity), AttributeDefOrigin(attIndex)
+{
+}
+
+ElementTypeCdataAttributeValueNode
+::ElementTypeCdataAttributeValueNode(const GroveImpl *grove,
+         const AttributeValue *value,
+         size_t attIndex,
+         const TextIter &iter,
+         size_t charIndex,
+         const ElementType *elementType)
+: CdataAttributeValueNode(grove, value, attIndex, iter, charIndex),
+  ElementTypeAttributeDefOrigin(elementType), AttributeDefOrigin(attIndex)
+{
+}
+
+NotationCdataAttributeValueNode
+::NotationCdataAttributeValueNode(const GroveImpl *grove,
+      const AttributeValue *value,
+      size_t attIndex,
+      const TextIter &iter,
+      size_t charIndex,
+      const Notation *notation)
+: CdataAttributeValueNode(grove, value, attIndex, iter, charIndex),
+  NotationAttributeDefOrigin(notation), AttributeDefOrigin(attIndex)
+{
+}
+
+AttributeValueTokenNode
+::AttributeValueTokenNode(const GroveImpl *grove,
+     const TokenizedAttributeValue *value,
+     size_t attIndex, size_t tokenIndex)
+: BaseNode(grove),
+  AttributeDefOrigin(attIndex),
+  value_(value),
+  tokenIndex_(tokenIndex)
+{
+}
+
+AccessResult AttributeValueTokenNode::getParent(NodePtr &ptr) const
+{
+  ptr.assign(makeOriginNode(grove(), attIndex_));
+  return accessOK;
+}
+
+AccessResult AttributeValueTokenNode::nextChunkSibling(NodePtr &ptr) const
+{
+  return followSiblingRef(0, ptr);
+}
+
+AccessResult AttributeValueTokenNode::followSiblingRef(unsigned long i, NodePtr &ptr) const
+{
+
+  if (i >= value_->nTokens() - tokenIndex_ - 1)
+    return accessNull;
+  if (canReuse(ptr)) {
+    AttributeValueTokenNode *node = (AttributeValueTokenNode *)this;
+    node->tokenIndex_ += size_t(i) + 1;
+  }
+  else
+    ptr.assign(makeAttributeValueTokenNode(grove(), value_, attIndex_,
+        tokenIndex_ + size_t(i) + 1));
+  return accessOK;
+}
+
+AccessResult AttributeValueTokenNode::firstSibling(NodePtr &ptr) const
+{
+  if (canReuse(ptr))
+    ((AttributeValueTokenNode *)this)->tokenIndex_ = 0;
+  else
+    ptr.assign(makeAttributeValueTokenNode(grove(), value_, attIndex_, 0));
+  return accessOK;
+}
+
+AccessResult AttributeValueTokenNode::siblingsIndex(unsigned long &i) const
+{
+  i = tokenIndex_;
+  return accessOK;
+}
+
+AccessResult AttributeValueTokenNode::getToken(GroveString &str) const
+{
+  const Char *ptr;
+  size_t len;
+  value_->token(tokenIndex_, ptr, len);
+  str.assign(ptr, len);
+  return accessOK;
+}
+
+AccessResult AttributeValueTokenNode::getEntity(NodePtr &ptr) const
+{
+   if (!attDefList()->def(attIndex_)->isEntity())
+    return accessNull;
+  StringC token(value_->token(tokenIndex_));
+  const Entity *entity = grove()->governingDtd()->lookupEntityTemp(0, token);
+  if (!entity) {
+    entity = grove()->lookupDefaultedEntity(token);
+    if (!entity)
+      return accessNull;
+  }
+  ptr.assign(new EntityNode(grove(), entity));
+  return accessOK;
+}
+
+AccessResult AttributeValueTokenNode::getNotation(NodePtr &ptr) const
+{
+  if (!attDefList()->def(attIndex_)->isNotation())
+    return accessNull;
+  StringC token(value_->token(tokenIndex_));
+  const Notation *notation = grove()->governingDtd()->lookupNotationTemp(token);
+  if (!notation)
+    return accessNull;
+  ptr.assign(new NotationNode(grove(), notation));
+  return accessOK;
+}
+
+AccessResult AttributeValueTokenNode::getReferent(NodePtr &ptr) const
+{
+  if (!attDefList()->def(attIndex_)->isIdref())
+    return accessNull;
+  StringC token(value_->token(tokenIndex_));
+  for (;;) {
+    Boolean complete = grove()->complete();
+    const ElementChunk *element = grove()->lookupElement(token);
+    if (element) {
+      ptr.assign(new ElementNode(grove(), element));
+      break;
+    }
+    if (complete)
+      return accessNull;
+    if (!grove()->waitForMoreNodes())
+      return accessTimeout;
+  }
+  return accessOK;
+}
+
+void AttributeValueTokenNode::accept(NodeVisitor &visitor)
+{
+  visitor.attributeValueToken(*this);
+}
+
+unsigned long AttributeValueTokenNode::hash() const
+{
+  return secondHash(secondHash((unsigned long)attributeOriginId() + attIndex_) + tokenIndex_);
+}
+
+bool AttributeValueTokenNode::same(const BaseNode &node) const
+{
+  return node.same2(this);
+}
+
+bool AttributeValueTokenNode::same2(const AttributeValueTokenNode *node) const
+{
+  return (attributeOriginId() == node->attributeOriginId()
+   && attIndex_ == node->attIndex_
+   && tokenIndex_ == node->tokenIndex_);
+}
+
+AccessResult AttributeValueTokenNode::getLocation(Location &loc) const
+{
+  const ConstPtr<Origin> *originP;
+  Index index;
+  if (!value_->tokenLocation(tokenIndex_, originP, index)
+      && originP->pointer()) {
+    loc = Location(new GroveImplProxyOrigin(grove(), originP->pointer()), index);
+    return accessOK;
+  }
+  return accessNull;
+}
+
+ElementAttributeValueTokenNode
+::ElementAttributeValueTokenNode(const GroveImpl *grove,
+     const TokenizedAttributeValue *value,
+     size_t attIndex,
+     size_t tokenIndex,
+     const ElementChunk *chunk)
+: AttributeValueTokenNode(grove, value, attIndex, tokenIndex),
+  ElementAttributeOrigin(chunk), AttributeDefOrigin(attIndex)
+{
+}
+
+EntityAttributeValueTokenNode
+::EntityAttributeValueTokenNode(const GroveImpl *grove,
+    const TokenizedAttributeValue *value,
+    size_t attIndex,
+    size_t tokenIndex,
+    const ExternalDataEntity *entity)
+: AttributeValueTokenNode(grove, value, attIndex, tokenIndex),
+  EntityAttributeOrigin(entity), AttributeDefOrigin(attIndex)
+{
+}
+
+ElementTypeAttributeValueTokenNode
+::ElementTypeAttributeValueTokenNode(const GroveImpl *grove,
+               const TokenizedAttributeValue *value,
+         size_t attIndex,
+         size_t tokenIndex,
+         const ElementType *elementType)
+: AttributeValueTokenNode(grove, value, attIndex, tokenIndex),
+  ElementTypeAttributeDefOrigin(elementType), AttributeDefOrigin(attIndex)
+{
+}
+
+NotationAttributeValueTokenNode
+::NotationAttributeValueTokenNode(const GroveImpl *grove,
+        const TokenizedAttributeValue *value,
+      size_t attIndex,
+      size_t tokenIndex,
+      const Notation *notation)
+: AttributeValueTokenNode(grove, value, attIndex, tokenIndex),
+  NotationAttributeDefOrigin(notation), AttributeDefOrigin(attIndex)
+{
+}
+
+EntityNode::EntityNode(const GroveImpl *grove, const Entity *entity)
+: EntityNodeBase(grove, entity)
+{
+}
+
+DefaultEntityNode::DefaultEntityNode(const GroveImpl *grove, const Entity *entity)
+: EntityNodeBase(grove, entity)
+{
+}
+
+AccessResult EntityNode::getOrigin(NodePtr &ptr) const
+{
+  if (entity_->defaulted() && grove()->lookupDefaultedEntity(entity_->name()))
+    ptr.assign(new SgmlDocumentNode(grove(), grove()->root()));
+  else
+    ptr.assign(new DocumentTypeNode(grove(),
+       grove()->lookupDtd(*(entity_->declInDtdNamePointer()))));
+  return accessOK;
+}
+
+AccessResult DefaultEntityNode::getOrigin(NodePtr &ptr) const
+{
+  ptr.assign(new DocumentTypeNode(grove(),
+            grove()->lookupDtd(*(entity_->declInDtdNamePointer()))));
+  return accessOK;
+}
+
+AccessResult EntityNode::getOriginToSubnodeRelPropertyName(ComponentName::Id &name) const
+{
+  if (entity_->defaulted() && grove()->lookupDefaultedEntity(entity_->name()))
+    name = ComponentName::idDefaultedEntities;
+  else if (entity_->declType() == EntityDecl::parameterEntity)
+    name = ComponentName::idParameterEntities;
+  else
+    name = ComponentName::idGeneralEntities;
+  return accessOK;
+}
+
+AccessResult DefaultEntityNode::getOriginToSubnodeRelPropertyName(ComponentName::Id &name) const
+{
+  name = ComponentName::idDefaultEntity;
+  return accessOK;
+}
+
+AccessResult EntityNodeBase::getName(GroveString &str) const
+{
+  setString(str, entity_->name());
+  return accessOK;
+}
+
+AccessResult EntityNodeBase::getExternalId(NodePtr &ptr) const
+{
+  const ExternalEntity *x = entity_->asExternalEntity();
+  if (!x)
+    return accessNull;
+  ptr.assign(new EntityExternalIdNode(grove(), x));
+  return accessOK;
+}
+
+AccessResult EntityNodeBase::getNotation(NodePtr &ptr) const
+{
+  const ExternalDataEntity *x = entity_->asExternalDataEntity();
+  if (!x || !x->notation())
+    return accessNull;
+  ptr.assign(new NotationNode(grove(), x->notation()));
+  return accessOK;
+}
+
+AccessResult EntityNodeBase::getNotationName(GroveString &str) const
+{
+  const ExternalDataEntity *x = entity_->asExternalDataEntity();
+  if (!x || !x->notation())
+    return accessNull;
+  setString(str, x->notation()->name());
+  return accessOK;
+}
+
+AccessResult EntityNodeBase::getText(GroveString &str) const
+{
+  const InternalEntity *i = entity_->asInternalEntity();
+  if (!i)
+    return accessNull;
+  setString(str, i->string());
+  return accessOK;
+}
+
+AccessResult EntityNodeBase::getEntityType(Node::EntityType::Enum &entityType) const
+{
+  switch (entity_->dataType()) {
+  case EntityDecl::sgmlText:
+    entityType = EntityType::text;
+    break;
+  case EntityDecl::pi:
+    entityType = EntityType::pi;
+    break;
+  case EntityDecl::cdata:
+    entityType = EntityType::cdata;
+    break;
+  case EntityDecl::sdata:
+    entityType = EntityType::sdata;
+    break;
+  case EntityDecl::ndata:
+    entityType = EntityType::ndata;
+    break;
+  case EntityDecl::subdoc:
+    entityType = EntityType::subdocument;
+    break;
+  default:
+    (static_cast<void> (__builtin_expect (!!(0), 1) ? 0 : (__assert_fail ("0", "GroveBuilder.cxx", 4498, __PRETTY_FUNCTION__), 0)));
+  }
+  return accessOK;
+}
+
+AccessResult EntityNode::getDefaulted(bool &dflted) const
+{
+  dflted = entity_->defaulted();
+  return accessOK;
+}
+
+AccessResult EntityNodeBase::getAttributes(NamedNodeListPtr &ptr) const
+{
+  const ExternalDataEntity *x = entity_->asExternalDataEntity();
+  if (!x)
+    return accessNull;
+  ptr.assign(new EntityAttributesNamedNodeList(grove(), x));
+  return accessOK;
+}
+
+AccessResult EntityNodeBase::attributeRef(unsigned long i, NodePtr &ptr) const
+{
+  const ExternalDataEntity *x = entity_->asExternalDataEntity();
+  if (!x || i >= x->attributes().size())
+    return accessNull;
+  ptr.assign(new EntityAttributeAsgnNode(grove(), size_t(i), x));
+  return accessOK;
+}
+
+AccessResult EntityNodeBase::getLocation(Location &loc) const
+{
+  return grove()->proxifyLocation(entity_->defLocation(), loc);
+}
+
+bool EntityNode::same(const BaseNode &node) const
+{
+  return node.same2(this);
+}
+
+bool DefaultEntityNode::same(const BaseNode &node) const
+{
+  return node.same2(this);
+}
+
+bool EntityNode::same2(const EntityNode *node) const
+{
+  return entity_ == node->entity_;
+}
+
+bool DefaultEntityNode::same2(const DefaultEntityNode *node) const
+{
+  return entity_ == node->entity_;
+}
+
+void EntityNode::accept(NodeVisitor &visitor)
+{
+  visitor.entity(*this);
+}
+
+void DefaultEntityNode::accept(NodeVisitor &visitor)
+{
+  visitor.defaultEntity(*this);
+}
+
+unsigned long EntityNodeBase::hash() const
+{
+  return (unsigned long)entity_;
+}
+
+EntityAttributeOrigin
+::EntityAttributeOrigin(const ExternalDataEntity *entity)
+: entity_(entity)
+{
+}
+
+const AttributeDefinitionList *
+EntityAttributeOrigin::attDefList() const
+{
+  return entity_->notation()->attributeDefTemp();
+}
+
+
+const AttributeValue *
+EntityAttributeOrigin::attributeValue(size_t attIndex, const GroveImpl &) const
+{
+  return entity_->attributes().value(attIndex);
+}
+
+AccessResult
+EntityAttributeOrigin::setNodePtrAttributeOrigin(NodePtr &ptr,
+       const BaseNode *node) const
+{
+  ptr.assign(new EntityNode(node->grove(), entity_));
+  return accessOK;
+}
+
+Node *EntityAttributeOrigin
+::makeCdataAttributeValueNode(const GroveImpl *grove,
+         const AttributeValue *value,
+         size_t attIndex,
+         const TextIter &iter,
+         size_t charIndex) const
+{
+  return new EntityCdataAttributeValueNode(grove, value, attIndex, iter,
+        charIndex, entity_);
+}
+
+
+Node *EntityAttributeOrigin
+::makeAttributeValueTokenNode(const GroveImpl *grove,
+         const TokenizedAttributeValue *value,
+         size_t attIndex,
+         size_t tokenIndex) const
+{
+  return new EntityAttributeValueTokenNode(grove, value, attIndex,
+        tokenIndex, entity_);
+}
+
+Node *EntityAttributeOrigin
+::makeAttributeAsgnNode(const GroveImpl *grove,
+   size_t attIndex) const
+{
+  return new EntityAttributeAsgnNode(grove, attIndex, entity_);
+}
+
+AccessResult EntityAttributeOrigin
+::makeAttributeDefNode(const GroveImpl *grove,
+                       NodePtr &ptr,
+                       size_t attributeDefIdx) const
+{
+  if (entity_->notation() == 0)
+    return accessNull;
+  ptr.assign(new NotationAttributeDefNode(grove,
+                                          *(entity_->notation()),
+                                          attributeDefIdx));
+  return accessOK;
+}
+
+Node *EntityAttributeOrigin::makeOriginNode(const GroveImpl *grove, size_t attIndex) const
+{
+  return makeAttributeAsgnNode(grove, attIndex);
+}
+
+const void *EntityAttributeOrigin::attributeOriginId() const
+{
+  return entity_;
+}
+
+DoctypesAndLinktypesNamedNodeList
+::DoctypesAndLinktypesNamedNodeList(const GroveImpl *grove)
+: BaseNamedNodeList(grove, grove->generalSubstTable())
+{
+}
+
+NodeListPtr DoctypesAndLinktypesNamedNodeList::nodeList() const
+{
+  NodePtr tem(new DocumentTypeNode(grove(), grove()->firstDtd()));
+  return new SiblingNodeList(tem);
+}
+
+AccessResult
+DoctypesAndLinktypesNamedNodeList
+::namedNodeU(const StringC &str, NodePtr &ptr) const
+{
+  const Dtd *dtd = grove()->lookupDtd(str);
+  if (!dtd)
+    return accessNull;
+  ptr.assign(new DocumentTypeNode(grove(), dtd));
+  return accessOK;
+}
+
+GeneralEntitiesNamedNodeList
+::GeneralEntitiesNamedNodeList(const GroveImpl *grove, const Dtd *dtd)
+: BaseNamedNodeList(grove, grove->entitySubstTable()), dtd_(dtd)
+{
+}
+
+NodeListPtr GeneralEntitiesNamedNodeList::nodeList() const
+{
+  return new EntitiesNodeList(grove(),
+         dtd_->generalEntityIter());
+}
+
+AccessResult
+GeneralEntitiesNamedNodeList::namedNodeU(const StringC &str, NodePtr &ptr) const
+{
+  const Entity *entity
+   = dtd_->lookupEntityTemp(0, str);
+  if (!entity)
+    return accessNull;
+  ptr.assign(new EntityNode(grove(), entity));
+  return accessOK;
+}
+
+ParameterEntitiesNamedNodeList
+::ParameterEntitiesNamedNodeList(const GroveImpl *grove, const Dtd *dtd)
+: BaseNamedNodeList(grove, grove->entitySubstTable()), dtd_(dtd)
+{
+}
+
+NodeListPtr ParameterEntitiesNamedNodeList::nodeList() const
+{
+  return new EntitiesNodeList(grove(),
+         dtd_->parameterEntityIter());
+}
+
+AccessResult
+ParameterEntitiesNamedNodeList::namedNodeU(const StringC &str, NodePtr &ptr) const
+{
+  const Entity *entity
+   = dtd_->lookupEntityTemp(1, str);
+  if (!entity)
+    return accessNull;
+  ptr.assign(new EntityNode(grove(), entity));
+  return accessOK;
+}
+
+AccessResult
+DefaultedEntitiesNamedNodeList::namedNodeU(const StringC &str, NodePtr &ptr) const
+{
+  const Entity *entity
+   = grove()->lookupDefaultedEntity(str);
+  if (!entity)
+    return accessNull;
+  ptr.assign(new EntityNode(grove(), entity));
+  return accessOK;
+}
+
+NodeListPtr
+DefaultedEntitiesNamedNodeList::nodeList() const
+{
+  return new EntitiesNodeList(grove(), grove()->defaultedEntityIter());
+}
+
+NodeListPtr DocEntitiesNamedNodeList::nodeList() const
+{
+  return new DocEntitiesNodeList(grove());
+}
+
+AccessResult
+DocEntitiesNamedNodeList::namedNodeU(const StringC &str, NodePtr &ptr) const
+{
+  const Entity *entity
+   = grove()->governingDtd()->lookupEntityTemp(0, str);
+
+  while (!entity) {
+    if (!grove()->hasDefaultEntity())
+      return accessNull;
+
+
+
+    Boolean complete = grove()->complete();
+    entity = grove()->lookupDefaultedEntity(str);
+    if (entity)
+      break;
+    if (complete)
+      return accessNull;
+    if (!grove()->waitForMoreNodes())
+      return accessTimeout;
+  }
+  ptr.assign(new EntityNode(grove(), entity));
+  return accessOK;
+}
+
+AccessResult
+ElementsNamedNodeList::namedNodeU(const StringC &str, NodePtr &ptr) const
+{
+  for (;;) {
+    Boolean complete = grove()->complete();
+    const ElementChunk *element = grove()->lookupElement(str);
+    if (element) {
+      ptr.assign(new ElementNode(grove(), element));
+      break;
+    }
+    if (complete)
+      return accessNull;
+    if (!grove()->waitForMoreNodes())
+      return accessTimeout;
+  }
+  return accessOK;
+}
+
+NodeListPtr ElementsNamedNodeList::nodeList() const
+{
+  return new ElementsNodeList(grove(), grove()->root()->documentElement);
+}
+
+ElementsNodeList::ElementsNodeList(const GroveImpl *grove,
+       const Chunk *first)
+: grove_(grove), first_(first)
+{
+}
+
+AccessResult ElementsNodeList::first(NodePtr &ptr) const
+{
+  const Chunk *p = first_;
+  while (p) {
+    while (p == grove_->completeLimit()) {
+      if (!grove_->waitForMoreNodes())
+ return accessTimeout;
+    }
+    if (p->id()) {
+      ((ElementsNodeList *)this)->first_ = p;
+      ptr.assign(new ElementNode(grove_, (const ElementChunk *)p));
+      return accessOK;
+    }
+    p = p->after();
+  }
+  return accessNull;
+}
+
+AccessResult ElementsNodeList::chunkRest(NodeListPtr &ptr) const
+{
+  const Chunk *p = first_;
+  while (p) {
+    while (p == grove_->completeLimit()) {
+      if (!grove_->waitForMoreNodes())
+ return accessTimeout;
+    }
+    if (p->id()) {
+      if (canReuse(ptr))
+ ((ElementsNodeList *)this)->first_ = p->after();
+      else
+ ptr.assign(new ElementsNodeList(grove_, p->after()));
+      return accessOK;
+    }
+    p = p->after();
+ }
+ return accessNull;
+}
+
+
+
+EntitiesNodeList::EntitiesNodeList(const GroveImpl *grove,
+       const Dtd::ConstEntityIter &iter)
+: grove_(grove), iter_(iter)
+{
+}
+
+AccessResult EntitiesNodeList::first(NodePtr &ptr) const
+{
+  Dtd::ConstEntityIter tem(iter_);
+  const Entity *entity = tem.nextTemp();
+  if (!entity)
+    return accessNull;
+  ptr.assign(new EntityNode(grove_, entity));
+  return accessOK;
+}
+
+AccessResult EntitiesNodeList::chunkRest(NodeListPtr &ptr) const
+{
+  if (canReuse(ptr)) {
+    EntitiesNodeList *list = (EntitiesNodeList *)this;
+    if (list->iter_.nextTemp() == 0)
+      return accessNull;
+    return accessOK;
+  }
+  Dtd::ConstEntityIter tem(iter_);
+  if (tem.nextTemp() == 0)
+    return accessNull;
+  ptr.assign(new EntitiesNodeList(grove_, tem));
+  return accessOK;
+}
+
+DocEntitiesNodeList::DocEntitiesNodeList(const GroveImpl *grove)
+: EntitiesNodeList(grove, grove->governingDtd()->generalEntityIter())
+{
+}
+
+AccessResult DocEntitiesNodeList::first(NodePtr &ptr) const
+{
+  AccessResult ret = EntitiesNodeList::first(ptr);
+  if (ret != accessNull || !grove()->hasDefaultEntity())
+    return ret;
+  while (!grove()->complete())
+    if (!grove()->waitForMoreNodes())
+      return accessTimeout;
+  Dtd::ConstEntityIter tem(grove()->defaultedEntityIter());
+  const Entity *entity = tem.nextTemp();
+  if (!entity)
+    return accessNull;
+  ptr.assign(new EntityNode(grove(), entity));
+  return accessOK;
+}
+
+AccessResult DocEntitiesNodeList::chunkRest(NodeListPtr &ptr) const
+{
+  AccessResult ret = EntitiesNodeList::chunkRest(ptr);
+  if (ret != accessNull || !grove()->hasDefaultEntity())
+    return ret;
+  while (!grove()->complete())
+    if (!grove()->waitForMoreNodes())
+      return accessTimeout;
+  Dtd::ConstEntityIter tem(grove()->defaultedEntityIter());
+  const Entity *entity = tem.nextTemp();
+  if (!entity)
+    return accessNull;
+  ptr.assign(new EntitiesNodeList(grove(), tem));
+  return accessOK;
+}
+
+NotationsNamedNodeList
+::NotationsNamedNodeList(const GroveImpl *grove, const Dtd *dtd)
+: BaseNamedNodeList(grove, grove->generalSubstTable()), dtd_(dtd)
+{
+}
+
+NodeListPtr NotationsNamedNodeList::nodeList() const
+{
+  return new NotationsNodeList(grove(),
+          dtd_->notationIter());
+}
+
+AccessResult
+NotationsNamedNodeList::namedNodeU(const StringC &str, NodePtr &ptr) const
+{
+  const Notation *notation
+   = dtd_->lookupNotationTemp(str);
+  if (!notation)
+    return accessNull;
+  ptr.assign(new NotationNode(grove(), notation));
+  return accessOK;
+}
+
+
+
+
+NotationsNodeList::NotationsNodeList(const GroveImpl *grove,
+         const Dtd::ConstNotationIter &iter)
+: grove_(grove), iter_(iter)
+{
+}
+
+AccessResult NotationsNodeList::first(NodePtr &ptr) const
+{
+  Dtd::ConstNotationIter tem(iter_);
+  const Notation *notation = tem.nextTemp();
+  if (!notation)
+    return accessNull;
+  ptr.assign(new NotationNode(grove_, notation));
+  return accessOK;
+}
+
+AccessResult NotationsNodeList::chunkRest(NodeListPtr &ptr) const
+{
+  if (canReuse(ptr)) {
+    NotationsNodeList *list = (NotationsNodeList *)this;
+    if (list->iter_.next().isNull())
+      return accessNull;
+    return accessOK;
+  }
+  Dtd::ConstNotationIter tem(iter_);
+  if (tem.nextTemp() == 0)
+    return accessNull;
+  ptr.assign(new NotationsNodeList(grove_, tem));
+  return accessOK;
+}
+
+NotationNode::NotationNode(const GroveImpl *grove,
+      const Notation *notation)
+: BaseNode(grove), notation_(notation)
+{
+}
+
+AccessResult NotationNode::getOrigin(NodePtr &ptr) const
+{
+  ptr.assign(new DocumentTypeNode(grove(),
+                   grove()->lookupDtd(*(notation_->declInDtdNamePointer()))));
+  return accessOK;
+}
+
+AccessResult NotationNode::getName(GroveString &str) const
+{
+  setString(str, notation_->name());
+  return accessOK;
+}
+
+AccessResult NotationNode::getExternalId(NodePtr &ptr) const
+{
+  ptr.assign(new NotationExternalIdNode(grove(), notation_));
+  return accessOK;
+}
+
+AccessResult NotationNode::getAttributeDefs(NamedNodeListPtr &ptr) const
+{
+  ptr.assign(new NotationAttributeDefsNamedNodeList(grove(), *notation_));
+  return accessOK;
+}
+
+AccessResult NotationNode::getLocation(Location &loc) const
+{
+  return grove()->proxifyLocation(notation_->defLocation(), loc);
+}
+
+bool NotationNode::same(const BaseNode &node) const
+{
+  return node.same2(this);
+}
+
+bool NotationNode::same2(const NotationNode *node) const
+{
+  return notation_ == node->notation_;
+}
+
+void NotationNode::accept(NodeVisitor &visitor)
+{
+  visitor.notation(*this);
+}
+
+unsigned long NotationNode::hash() const
+{
+  return (unsigned long)notation_;
+}
+
+FormalPublicIdNode::FormalPublicIdNode(const GroveImpl *grove, const PublicId *pubid)
+: BaseNode(grove), pubid_(pubid)
+{
+}
+
+AccessResult FormalPublicIdNode::getOwnerType(OwnerType::Enum &type) const
+{
+  PublicId::OwnerType otp;
+  if (!pubid_->getOwnerType(otp))
+    return accessNull;
+  switch (otp) {
+  case PublicId::ISO:
+    type = OwnerType::iso;
+    break;
+  case PublicId::registered:
+    type = OwnerType::registered;
+    break;
+  case PublicId::unregistered:
+    type = OwnerType::unregistered;
+    break;
+  }
+  return accessOK;
+}
+
+AccessResult FormalPublicIdNode::getOwnerId(GroveString &str) const
+{
+  if (!pubid_->getOwner(
+
+
+
+     owner_))
+    return accessNull;
+  setString(str, owner_);
+  return accessOK;
+}
+
+AccessResult FormalPublicIdNode::getTextClass(TextClass::Enum &tc) const
+{
+  PublicId::TextClass text;
+  if (!pubid_->getTextClass(text))
+    return accessNull;
+  switch (text) {
+  case PublicId::CAPACITY:
+    tc = TextClass::capacity;
+    break;
+  case PublicId::CHARSET:
+    tc = TextClass::charset;
+    break;
+  case PublicId::DOCUMENT:
+    tc = TextClass::document;
+    break;
+  case PublicId::DTD:
+    tc = TextClass::dtd;
+    break;
+  case PublicId::ELEMENTS:
+    tc = TextClass::elements;
+    break;
+  case PublicId::ENTITIES:
+    tc = TextClass::entities;
+    break;
+  case PublicId::LPD:
+    tc = TextClass::lpd;
+    break;
+  case PublicId::NONSGML:
+    tc = TextClass::nonsgml;
+    break;
+  case PublicId::NOTATION:
+    tc = TextClass::notation;
+    break;
+  case PublicId::SHORTREF:
+    tc = TextClass::shortref;
+    break;
+  case PublicId::SUBDOC:
+    tc = TextClass::subdoc;
+    break;
+  case PublicId::SYNTAX:
+    tc = TextClass::syntax;
+    break;
+  case PublicId::TEXT:
+    tc = TextClass::text;
+    break;
+  default:
+    return accessNull;
+  }
+  return accessOK;
+}
+
+AccessResult FormalPublicIdNode::getUnavailable(bool &u) const
+{
+  if (!pubid_->getUnavailable(u))
+    return accessNull;
+  return accessOK;
+}
+
+AccessResult FormalPublicIdNode::getTextDescription(GroveString &str) const
+{
+  if (!pubid_->getDescription(
+
+
+
+       desc_))
+    return accessNull;
+  setString(str, desc_);
+  return accessOK;
+}
+
+AccessResult FormalPublicIdNode::getTextLanguage(GroveString &str) const
+{
+  if (!pubid_->getLanguage(
+
+
+
+      lang_))
+    return accessNull;
+  setString(str, lang_);
+  return accessOK;
+}
+
+AccessResult FormalPublicIdNode::getTextDesignatingSequence(GroveString &str) const
+{
+  if (!pubid_->getDesignatingSequence(
+
+
+
+       dseq_))
+    return accessNull;
+  setString(str, dseq_);
+  return accessOK;
+}
+
+AccessResult FormalPublicIdNode::getTextDisplayVersion(GroveString &str) const
+{
+  if (!pubid_->getDisplayVersion(
+
+
+
+      dver_))
+    return accessNull;
+  setString(str, dver_);
+  return accessOK;
+}
+
+void FormalPublicIdNode::accept(NodeVisitor &visitor)
+{
+  visitor.formalPublicId(*this);
+}
+
+bool FormalPublicIdNode::same(const BaseNode &node) const
+{
+  return node.same2(this);
+}
+
+bool FormalPublicIdNode::same2(const FormalPublicIdNode *node) const
+{
+  return pubid_ == node->pubid_;
+}
+
+ExternalIdNode::ExternalIdNode(const GroveImpl *grove)
+: BaseNode(grove)
+{
+}
+
+AccessResult ExternalIdNode::getPublicId(GroveString &str) const
+{
+  const StringC *s = externalId().publicIdString();
+  if (!s)
+    return accessNull;
+  setString(str, *s);
+  return accessOK;
+}
+
+AccessResult ExternalIdNode::getFormalPublicId(NodePtr &ptr) const
+{
+  const PublicId *pubid = externalId().publicId();
+  if (!pubid || pubid->type() != PublicId::fpi)
+    return accessNull;
+  ptr.assign(new FormalPublicIdNode(grove(), pubid));
+  return accessOK;
+}
+
+AccessResult ExternalIdNode::getSystemId(GroveString &str) const
+{
+  const StringC *s = externalId().systemIdString();
+  if (!s)
+    return accessNull;
+  setString(str, *s);
+  return accessOK;
+}
+
+AccessResult ExternalIdNode::getGeneratedSystemId(GroveString &str) const
+{
+  const StringC &s = externalId().effectiveSystemId();
+  if (!s.size())
+    return accessNull;
+  setString(str, s);
+  return accessOK;
+}
+
+void ExternalIdNode::accept(NodeVisitor &visitor)
+{
+  visitor.externalId(*this);
+}
+
+bool ExternalIdNode::same(const BaseNode &node) const
+{
+  return node.same2(this);
+}
+
+bool ExternalIdNode::same2(const ExternalIdNode *node) const
+{
+  return &externalId() == &node->externalId();
+}
+
+EntityExternalIdNode::EntityExternalIdNode(const GroveImpl *grove,
+        const ExternalEntity *entity)
+: ExternalIdNode(grove), entity_(entity)
+{
+}
+
+const ExternalId &EntityExternalIdNode::externalId() const
+{
+  return entity_->externalId();
+}
+
+AccessResult EntityExternalIdNode::getOrigin(NodePtr &ptr) const
+{
+  ptr.assign(new EntityNode(grove(), entity_));
+  return accessOK;
+}
+
+unsigned long EntityExternalIdNode::hash() const
+{
+  return secondHash((unsigned long)entity_);
+}
+
+NotationExternalIdNode::NotationExternalIdNode(const GroveImpl *grove,
+            const Notation *notation)
+: ExternalIdNode(grove), notation_(notation)
+{
+}
+
+const ExternalId &NotationExternalIdNode::externalId() const
+{
+  return notation_->externalId();
+}
+
+AccessResult NotationExternalIdNode::getOrigin(NodePtr &ptr) const
+{
+  ptr.assign(new NotationNode(grove(), notation_));
+  return accessOK;
+}
+
+unsigned long NotationExternalIdNode::hash() const
+{
+  return secondHash((unsigned long)notation_);
+}
+
+AccessResult ChunkNode::getParent(NodePtr &ptr) const
+{
+  if (!chunk_->origin)
+    return accessNull;
+
+
+
+  if ((const Chunk *)chunk()->origin == grove()->root())
+    return accessNull;
+  chunk_->origin->setNodePtrFirst(ptr, this);
+  return accessOK;
+}
+
+AccessResult ChunkNode::getTreeRoot(NodePtr &ptr) const
+{
+  if (chunk()->origin
+      && (const Chunk *)chunk()->origin != grove()->root()
+
+      && !grove()->root()->epilog
+      && grove()->root()->documentElement)
+    return grove()->root()->documentElement->setNodePtrFirst(ptr, this);
+  return Node::getTreeRoot(ptr);
+}
+
+AccessResult ChunkNode::getOrigin(NodePtr &ptr) const
+{
+  if (!chunk_->origin)
+    return accessNull;
+  chunk_->origin->setNodePtrFirst(ptr, this);
+  return accessOK;
+}
+
+AccessResult ChunkNode::getOriginToSubnodeRelPropertyName(ComponentName::Id &name) const
+{
+  if ((const Chunk *)chunk()->origin != grove()->root())
+    name = ComponentName::idContent;
+  else if ((const Chunk *)chunk() == grove()->root()->documentElement)
+    name = ComponentName::idDocumentElement;
+  else {
+    const Chunk *tem;
+    if (chunk()->getFirstSibling(grove(), tem) == accessOK && tem == grove()->root()->prolog)
+      name = ComponentName::idProlog;
+    else
+      name = ComponentName::idEpilog;
+  }
+  return accessOK;
+}
+
+unsigned long ChunkNode::hash() const
+{
+  return (unsigned long)chunk_;
+}
+
+bool ChunkNode::same(const BaseNode &node) const
+{
+  return node.same2(this);
+}
+
+bool ChunkNode::same2(const ChunkNode *node) const
+{
+  return chunk_ == node->chunk_;
+}
+
+BaseNode::~BaseNode()
+{
+}
+
+void BaseNode::addRef()
+{
+  ++refCount_;
+}
+
+void BaseNode::release()
+{
+  (static_cast<void> (__builtin_expect (!!(refCount_ != 0), 1) ? 0 : (__assert_fail ("refCount_ != 0", "GroveBuilder.cxx", 5343, __PRETTY_FUNCTION__), 0)));
+  if (--refCount_ == 0)
+    delete this;
+}
+
+unsigned BaseNode::groveIndex() const
+{
+  return grove_->groveIndex();
+}
+
+bool BaseNode::operator==(const Node &node) const
+{
+  if (!sameGrove(node))
+    return 0;
+  return same((const BaseNode &)node);
+}
+
+bool BaseNode::chunkContains(const Node &node) const
+{
+  if (!sameGrove(node))
+    return 0;
+  return same((const BaseNode &)node);
+}
+
+bool BaseNode::inChunk(const DataNode *) const
+{
+  return 0;
+}
+
+bool BaseNode::inChunk(const CdataAttributeValueNode *) const
+{
+  return 0;
+}
+
+bool BaseNode::same2(const ChunkNode *) const
+{
+  return 0;
+}
+
+bool BaseNode::same2(const DataNode *) const
+{
+  return 0;
+}
+
+bool BaseNode::same2(const AttributeAsgnNode *) const
+{
+  return 0;
+}
+
+bool BaseNode::same2(const AttributeValueTokenNode *) const
+{
+  return 0;
+}
+
+bool BaseNode::same2(const CdataAttributeValueNode *) const
+{
+  return 0;
+}
+
+bool BaseNode::same2(const EntityNode *) const
+{
+  return 0;
+}
+
+bool BaseNode::same2(const NotationNode *) const
+{
+  return 0;
+}
+
+bool BaseNode::same2(const ExternalIdNode *) const
+{
+  return 0;
+}
+
+bool BaseNode::same2(const FormalPublicIdNode *) const
+{
+  return 0;
+}
+
+bool BaseNode::same2(const DocumentTypeNode *) const
+{
+  return 0;
+}
+
+bool BaseNode::same2(const SgmlConstantsNode *) const
+{
+  return 0;
+}
+
+bool BaseNode::same2(const MessageNode *) const
+{
+  return 0;
+}
+
+bool BaseNode::same2(const ElementTypeNode *) const
+{
+  return 0;
+}
+
+bool BaseNode::same2(const RankStemNode *) const
+{
+  return 0;
+}
+
+bool BaseNode::same2(const ModelGroupNode *) const
+{
+  return 0;
+}
+
+bool BaseNode::same2(const ElementTokenNode *) const
+{
+  return 0;
+}
+
+bool BaseNode::same2(const PcdataTokenNode *) const
+{
+  return 0;
+}
+
+bool BaseNode::same2(const AttributeDefNode *) const
+{
+  return 0;
+}
+
+bool BaseNode::same2(const DefaultEntityNode *) const
+{
+  return 0;
+}
+
+AccessResult BaseNode::nextSibling(NodePtr &ptr) const
+{
+  return nextChunkSibling(ptr);
+}
+
+class NodalPropertyValue : public PropertyValue {
+public:
+NodePtr nd;
+NodeListPtr nl;
+NamedNodeListPtr nnl;
+void set(const NodePtr &x) { nd = x; }
+void set(const NodeListPtr &x) { nl = x; }
+void set(const NamedNodeListPtr &x) { nnl = x; }
+void set(bool) { (static_cast<void> (__builtin_expect (!!(0), 1) ? 0 : (__assert_fail ("0", "GroveBuilder.cxx", 5485, __PRETTY_FUNCTION__), 0))); }
+void set(GroveChar) { (static_cast<void> (__builtin_expect (!!(0), 1) ? 0 : (__assert_fail ("0", "GroveBuilder.cxx", 5486, __PRETTY_FUNCTION__), 0))); }
+void set(GroveString) { (static_cast<void> (__builtin_expect (!!(0), 1) ? 0 : (__assert_fail ("0", "GroveBuilder.cxx", 5487, __PRETTY_FUNCTION__), 0))); }
+void set(ComponentName::Id) { (static_cast<void> (__builtin_expect (!!(0), 1) ? 0 : (__assert_fail ("0", "GroveBuilder.cxx", 5488, __PRETTY_FUNCTION__), 0))); }
+void set(const GroveStringListPtr &) { (static_cast<void> (__builtin_expect (!!(0), 1) ? 0 : (__assert_fail ("0", "GroveBuilder.cxx", 5489, __PRETTY_FUNCTION__), 0))); }
+void set(const ComponentName::Id *) { (static_cast<void> (__builtin_expect (!!(0), 1) ? 0 : (__assert_fail ("0", "GroveBuilder.cxx", 5490, __PRETTY_FUNCTION__), 0))); }
+void set(long) { (static_cast<void> (__builtin_expect (!!(0), 1) ? 0 : (__assert_fail ("0", "GroveBuilder.cxx", 5491, __PRETTY_FUNCTION__), 0))); }
+};
+
+AccessResult BaseNode::nextChunkSibling(NodePtr &ptr) const
+{
+  NodePtr origin;
+  ComponentName::Id id;
+  NodalPropertyValue pv;
+  SdataMapper sm;
+  NodeListPtr nl;
+  if (getOrigin(origin) != accessOK
+      || getOriginToSubnodeRelPropertyName(id) != accessOK
+      || origin->property(id, sm, pv) != accessOK)
+    return accessNull;
+  if (pv.nd)
+    return accessNull;
+  nl = pv.nl ? pv.nl : pv.nnl->nodeList();
+  for (;;) {
+    NodePtr nd;
+    if (nl->first(nd) != accessOK
+       || nl->rest(nl) != accessOK)
+      return accessNull;
+    if (*nd == *ptr)
+      break;
+  }
+  if (nl->first(ptr) != accessOK)
+    return accessNull;
+  return accessOK;
+}
+
+AccessResult BaseNode::follow(NodeListPtr &ptr) const
+{
+  NodePtr nd;
+  AccessResult ret = nextSibling(nd);
+  switch (ret) {
+  case accessOK:
+    ptr.assign(new SiblingNodeList(nd));
+    break;
+  case accessNull:
+    ptr.assign(new BaseNodeList);
+    ret = accessOK;
+    break;
+  default:
+    break;
+  }
+  return ret;
+}
+
+AccessResult BaseNode::children(NodeListPtr &ptr) const
+{
+  NodePtr head;
+  AccessResult ret = firstChild(head);
+  switch (ret) {
+  case accessOK:
+    ptr.assign(new SiblingNodeList(head));
+    break;
+  case accessNull:
+    ptr.assign(new BaseNodeList);
+    ret = accessOK;
+    break;
+  default:
+    break;
+  }
+  return ret;
+}
+
+AccessResult BaseNode::getOrigin(NodePtr &ptr) const
+{
+  return getParent(ptr);
+}
+
+AccessResult BaseNode::getGroveRoot(NodePtr &ptr) const
+{
+  ptr.assign(new SgmlDocumentNode(grove(), grove()->root()));
+  return accessOK;
+}
+
+AccessResult BaseNode::getLocation(Location &) const
+{
+  return accessNull;
+}
+
+bool BaseNode::queryInterface(IID iid, const void *&p) const
+{
+  if (iid == LocNode::iid) {
+    const LocNode *ip = this;
+    p = ip;
+    return 1;
+  }
+  return 0;
+}
+
+AccessResult
+ForwardingChunk::setNodePtrFirst(NodePtr &ptr, const BaseNode *node) const
+{
+  if (forwardTo == 0)
+    return accessNull;
+  (static_cast<void> (__builtin_expect (!!(origin == forwardTo->origin), 1) ? 0 : (__assert_fail ("origin == forwardTo->origin", "GroveBuilder.cxx", 5588, __PRETTY_FUNCTION__), 0)));
+  return forwardTo->setNodePtrFirst(ptr, node);
+}
+
+AccessResult
+ForwardingChunk::getFollowing(const GroveImpl *grove,
+                              const Chunk *&p, unsigned long &nNodes)
+    const
+{
+  AccessResult ret = Chunk::getFollowing(grove, p, nNodes);
+  if (ret == accessOK)
+    nNodes = 0;
+  return ret;
+}
+
+AccessResult
+LocOriginChunk::getFollowing(const GroveImpl *grove,
+                             const Chunk *&p, unsigned long &nNodes)
+    const
+{
+  AccessResult ret = Chunk::getFollowing(grove, p, nNodes);
+  if (ret == accessOK)
+    nNodes = 0;
+  return ret;
+}
+
+AccessResult LocOriginChunk::setNodePtrFirst(NodePtr &ptr, const BaseNode *node) const
+{
+  return ((const Chunk *)(this + 1))->setNodePtrFirst(ptr, node);
+}
+
+AccessResult LocOriginChunk::setNodePtrFirst(NodePtr &ptr, const ElementNode *node) const
+{
+  return ((const Chunk *)(this + 1))->setNodePtrFirst(ptr, node);
+}
+
+AccessResult LocOriginChunk::setNodePtrFirst(NodePtr &ptr, const DataNode *node) const
+{
+  return ((const Chunk *)(this + 1))->setNodePtrFirst(ptr, node);
+}
+
+const Chunk *LocOriginChunk::after() const
+{
+  return this + 1;
+}
+
+Boolean LocOriginChunk::getLocOrigin(const Origin *&ret) const
+{
+  ret = locOrigin;
+  return 1;
+}
+
+AccessResult
+Chunk::setNodePtrFirst(NodePtr &ptr, const ElementNode *node) const
+{
+  return setNodePtrFirst(ptr, (const BaseNode *)node);
+}
+
+AccessResult
+Chunk::setNodePtrFirst(NodePtr &ptr, const DataNode *node) const
+{
+  return setNodePtrFirst(ptr, (const BaseNode *)node);
+}
+
+const StringC *Chunk::id() const
+{
+  return 0;
+}
+
+AccessResult Chunk::getFollowing(const GroveImpl *grove,
+            const Chunk *&f, unsigned long &n) const
+{
+  const Chunk *p = after();
+  while (p == grove->completeLimit())
+    if (!grove->waitForMoreNodes())
+      return accessTimeout;
+  if (p->origin != origin)
+    return accessNull;
+  n = 1;
+  f = p;
+  return accessOK;
+}
+
+AccessResult Chunk::getFirstSibling(const GroveImpl *grove,
+        const Chunk *&p) const
+{
+  if ((const Chunk *)origin == grove->root())
+    return accessNotInClass;
+  p = origin->after();
+  return accessOK;
+}
+
+Boolean Chunk::getLocOrigin(const Origin *&) const
+{
+  return 0;
+}
+
+
+
+
+
+AccessResult RankStemNode::getOrigin(NodePtr &ptr) const
+{
+  ptr.assign(new DocumentTypeNode(grove(),
+                 grove()->lookupDtd(rankStem_)));
+  return accessOK;
+}
+
+AccessResult RankStemNode::getStem(GroveString &str) const
+{
+  setString(str, rankStem_.name());
+  return accessOK;
+}
+
+AccessResult RankStemNode::getElementTypes(NodeListPtr &ptr) const
+{
+  ptr.assign(new RankStemElementTypesNodeList(grove(), rankStem_, iter_));
+  return accessOK;
+}
+
+bool RankStemNode::same(const BaseNode &node) const
+{
+  return node.same2(this);
+}
+
+bool RankStemNode::same2(const RankStemNode *node) const
+{
+  return &rankStem_ == &(node->rankStem());
+}
+
+void RankStemNode::accept(NodeVisitor &visitor)
+{
+  visitor.rankStem(*this);
+}
+
+unsigned long RankStemNode::hash() const
+{
+  return (unsigned long)&rankStem_;
+}
+
+
+
+AccessResult ElementTypeNode::getOrigin(NodePtr &ptr) const
+{
+  ptr.assign(new DocumentTypeNode(grove(),
+                 grove()->lookupDtd(elementType_)));
+  return accessOK;
+}
+
+AccessResult ElementTypeNode::getLocation(Location &loc) const
+{
+  const ElementDefinition *def = elementType_.definition();
+  if (def == 0)
+    return accessNull;
+  return grove()->proxifyLocation(def->location(), loc);
+}
+
+AccessResult ElementTypeNode::getGi(GroveString &str) const
+{
+  setString(str, elementType_.name());
+  return accessOK;
+}
+
+AccessResult ElementTypeNode::getModelGroup(NodePtr &ptr) const
+{
+  const ElementDefinition *def = elementType_.definition();
+  if (def == 0 || def->declaredContent() != ElementDefinition::modelGroup)
+    return accessNull;
+  ptr.assign(new ModelGroupNode(grove(),
+                                elementType_,
+                                *(def->compiledModelGroup()->modelGroup())));
+  return accessOK;
+}
+
+AccessResult ElementTypeNode::getContentType(Node::ContentType::Enum &enumId) const
+{
+  const ElementDefinition *def = elementType_.definition();
+  if (def == 0)
+    return accessNull;
+  switch (def->declaredContent() ) {
+    case ElementDefinition::modelGroup:
+      enumId = ContentType::modelgrp;
+      break;
+    case ElementDefinition::any:
+      enumId = ContentType::any;
+      break;
+    case ElementDefinition::cdata:
+      enumId = ContentType::cdata;
+      break;
+    case ElementDefinition::rcdata:
+      enumId = ContentType::rcdata;
+      break;
+    case ElementDefinition::empty:
+      enumId = ContentType::empty;
+      break;
+    default:
+      (static_cast<void> (__builtin_expect (!!(0), 1) ? 0 : (__assert_fail ("0", "GroveBuilder.cxx", 5784, __PRETTY_FUNCTION__), 0)));
+  }
+  return accessOK;
+}
+
+AccessResult ElementTypeNode::getExclusions(GroveStringListPtr &sl) const
+{
+  const ElementDefinition *def = elementType_.definition();
+  if (def == 0
+      || (def->declaredContent() != ElementDefinition::modelGroup
+          && def->declaredContent() != ElementDefinition::any))
+    return accessNull;
+  sl.assign(new GroveStringList);
+  GroveString str;
+  for (size_t i = 0; i < def->nExclusions(); i++ ) {
+    setString(str, def->exclusion(i)->name());
+    sl->append(str);
+  }
+  return accessOK;
+}
+
+AccessResult ElementTypeNode::getInclusions(GroveStringListPtr &sl) const
+{
+  const ElementDefinition *def = elementType_.definition();
+  if (def == 0
+      || (def->declaredContent() != ElementDefinition::modelGroup
+          && def->declaredContent() != ElementDefinition::any))
+    return accessNull;
+  sl.assign(new GroveStringList);
+  GroveString str;
+  for (size_t i = 0; i < def->nInclusions(); i++ ) {
+    setString(str, def->inclusion(i)->name());
+    sl->append(str);
+  }
+  return accessOK;
+}
+
+AccessResult ElementTypeNode::getOmitEndTag(bool &f) const
+{
+  const ElementDefinition *def = elementType_.definition();
+  if (def == 0 || !def->omittedTagSpec())
+    return accessNull;
+  f = def->canOmitEndTag();
+  return accessOK;
+}
+
+AccessResult ElementTypeNode::getOmitStartTag(bool &f) const
+{
+  const ElementDefinition *def = elementType_.definition();
+  if (def == 0 || !def->omittedTagSpec())
+    return accessNull;
+  f = def->canOmitStartTag();
+  return accessOK;
+}
+
+AccessResult ElementTypeNode::getRankGroup(GroveStringListPtr &stems) const
+{
+
+  const ElementDefinition *def = elementType_.definition();
+  if (def == 0 || !def->nRankStems() <= 1)
+    return accessNull;
+  stems.assign(new GroveStringList);
+  GroveString str;
+  for (size_t i = 0; i < def->nRankStems(); i++)
+  {
+    setString(str, def->rankStem(i)->name());
+    stems->append(str);
+  }
+  return accessOK;
+}
+
+AccessResult ElementTypeNode::getRankStem(GroveString &str) const
+{
+  const ElementDefinition *def = elementType_.definition();
+  if (def == 0 || def->nRankStems() != 1)
+    return accessNull;
+  setString(str, def->rankStem(0)->name());
+  return accessOK;
+}
+
+AccessResult ElementTypeNode::getRankSuffix(GroveString &str) const
+{
+  const ElementDefinition *def = elementType_.definition();
+  if (def == 0 || def->rankSuffix().size() == 0)
+    return accessNull;
+  setString(str, def->rankSuffix());
+  return accessOK;
+}
+
+AccessResult ElementTypeNode::getAttributeDefs(NamedNodeListPtr &ptr) const
+{
+  ptr.assign(new ElementTypeAttributeDefsNamedNodeList(grove(), elementType_));
+  return accessOK;
+}
+
+bool ElementTypeNode::same(const BaseNode &node) const
+{
+  return node.same2(this);
+}
+
+bool ElementTypeNode::same2(const ElementTypeNode *node) const
+{
+  return &elementType_ == &(node->elementType());
+}
+
+void ElementTypeNode::accept(NodeVisitor &visitor)
+{
+  visitor.elementType(*this);
+}
+
+unsigned long ElementTypeNode::hash() const
+{
+  return (unsigned long)&elementType_;
+}
+
+
+
+RankStemElementTypesNodeList::RankStemElementTypesNodeList(const GroveImpl *grove,
+                                           const RankStem &rankStem,
+                                           const Dtd::ConstElementTypeIter &iter)
+
+ : grove_(grove), rankStem_(rankStem), iter_(iter)
+{
+}
+
+AccessResult RankStemElementTypesNodeList::first(NodePtr &ptr) const
+{
+  RankStemElementTypesNodeList *list = (RankStemElementTypesNodeList *)this;
+  for (;;) {
+    Dtd::ConstElementTypeIter tem(iter_);
+    const ElementType *elementType = tem.next();
+    if (elementType == 0)
+      return accessNull;
+    if (elementType->isRankedElement()
+        && elementType->rankedElementRankStem() == &rankStem_) {
+      ptr.assign(new ElementTypeNode(grove_, *elementType));
+      return accessOK;
+    }
+    list->iter_.next();
+  }
+}
+
+AccessResult RankStemElementTypesNodeList::chunkRest(NodeListPtr &ptr) const
+{
+  NodePtr tem;
+  if (first(tem) == accessNull)
+    return accessNull;
+  if (canReuse(ptr)) {
+    ((RankStemElementTypesNodeList *)this)->iter_.next();
+    return first(tem);
+  }
+  Dtd::ConstElementTypeIter iter(iter_);
+  iter.next();
+  ptr.assign(new RankStemElementTypesNodeList(grove_, rankStem_, iter));
+  return ptr->first(tem);
+}
+
+
+
+ElementTypesNodeList::ElementTypesNodeList(const GroveImpl *grove,
+                                           const Dtd *dtd,
+                                           const Dtd::ConstElementTypeIter &elementTypeIter,
+                                           const Dtd::ConstRankStemIter &rankStemIter)
+
+ : grove_(grove), dtd_(dtd), elementTypeIter_(elementTypeIter),
+rankStemIter_(rankStemIter)
+{
+}
+
+AccessResult ElementTypesNodeList::first(NodePtr &ptr) const
+{
+  Dtd::ConstElementTypeIter elementTypeIter(elementTypeIter_);
+  const ElementType *elementType = elementTypeIter.next();
+  if (elementType) {
+    ptr.assign(new ElementTypeNode(grove_, *elementType));
+    return accessOK;
+  }
+  Dtd::ConstRankStemIter rankStemIter(rankStemIter_);
+  const RankStem *rankStem = rankStemIter.next();
+  if (rankStem) {
+    ptr.assign(new RankStemNode(grove_, *rankStem, dtd_->elementTypeIter()));
+    return accessOK;
+  }
+  return accessNull;
+}
+
+AccessResult ElementTypesNodeList::chunkRest(NodeListPtr &ptr) const
+{
+  if (canReuse(ptr)) {
+    ElementTypesNodeList *list = (ElementTypesNodeList *)this;
+    if (list->elementTypeIter_.next() == 0)
+      if (list->rankStemIter_.next() == 0)
+        return accessNull;
+    return accessOK;
+  }
+  Dtd::ConstElementTypeIter elementTypeIter(elementTypeIter_);
+  Dtd::ConstRankStemIter rankStemIter(rankStemIter_);
+  if (elementTypeIter.next() == 0)
+    if (rankStemIter.next() == 0)
+      return accessNull;
+  ptr.assign(new ElementTypesNodeList(grove_, dtd_, elementTypeIter, rankStemIter));
+  return accessOK;
+}
+
+
+
+ElementTypesNamedNodeList::ElementTypesNamedNodeList(const GroveImpl *grove, const Dtd *dtd)
+ : BaseNamedNodeList( grove, grove->generalSubstTable() ), dtd_(dtd)
+{
+}
+
+NodeListPtr ElementTypesNamedNodeList::nodeList() const
+{
+  return new ElementTypesNodeList(grove(), dtd_, dtd_->elementTypeIter(), dtd_->rankStemIter());
+}
+
+AccessResult ElementTypesNamedNodeList::namedNodeU(const StringC &str, NodePtr &ptr) const
+{
+  const ElementType *elementType = dtd_->lookupElementType(str);
+  if (elementType) {
+    ptr.assign(new ElementTypeNode(grove(), *elementType));
+    return accessOK;
+  }
+  const RankStem *rankStem = dtd_->lookupRankStem(str);
+  if (rankStem) {
+    ptr.assign(new RankStemNode(grove(), *rankStem, dtd_->elementTypeIter()));
+    return accessOK;
+  }
+  return accessNull;
+}
+
+
+
+ContentTokenNodeBase::ContentTokenNodeBase(const GroveImpl *grove,
+                                           const ElementType &elementType,
+                                           ModelGroupNode *parentModelGroupNode)
+ : BaseNode(grove), elementType_(elementType), parentModelGroupNode_(parentModelGroupNode)
+{
+  if (parentModelGroupNode_ != 0)
+    parentModelGroupNode_->addRef();
+}
+
+ContentTokenNodeBase::~ContentTokenNodeBase()
+{
+  if (parentModelGroupNode_ != 0)
+    parentModelGroupNode_->release();
+}
+
+AccessResult ContentTokenNodeBase::getOrigin(NodePtr &ptr) const
+{
+  if (parentModelGroupNode_ != 0)
+    ptr.assign(parentModelGroupNode_);
+  else
+    ptr.assign(new ElementTypeNode(grove(), elementType_));
+  return accessOK;
+}
+
+AccessResult ContentTokenNodeBase::getLocation(Location &loc) const
+{
+  const ElementDefinition *def = elementType_.definition();
+  if (def == 0)
+    return accessNull;
+  return grove()->proxifyLocation(def->location(), loc);
+}
+
+
+
+AccessResult ElementTokenNode::getGi(GroveString &str) const
+{
+  (static_cast<void> (__builtin_expect (!!(elementToken_.elementType() != 0), 1) ? 0 : (__assert_fail ("elementToken_.elementType() != 0", "GroveBuilder.cxx", 6053, __PRETTY_FUNCTION__), 0)));
+  setString(str, elementToken_.elementType()->name());
+  return accessOK;
+}
+
+AccessResult ElementTokenNode::getOccurIndicator(Node::OccurIndicator::Enum &occur) const
+{
+  switch (elementToken_.occurrenceIndicator())
+  {
+    case ContentToken::opt:
+      occur = OccurIndicator::opt;
+      break;
+    case ContentToken::plus:
+      occur = OccurIndicator::plus;
+      break;
+    case ContentToken::rep:
+      occur = OccurIndicator::rep;
+      break;
+    case ContentToken::none:
+      return accessNull;
+    default:
+      (static_cast<void> (__builtin_expect (!!(0), 1) ? 0 : (__assert_fail ("0", "GroveBuilder.cxx", 6074, __PRETTY_FUNCTION__), 0)));
+  }
+  return accessOK;
+}
+
+bool ElementTokenNode::same(const BaseNode &node) const
+{
+  return node.same2(this);
+}
+
+bool ElementTokenNode::same2(const ElementTokenNode *node) const
+{
+  return &elementToken_ == &(node->elementToken());
+}
+
+void ElementTokenNode::accept(NodeVisitor &visitor)
+{
+  visitor.elementToken(*this);
+}
+
+unsigned long ElementTokenNode::hash() const
+{
+  return (unsigned long)&elementToken_;
+}
+
+
+
+bool PcdataTokenNode::same(const BaseNode &node) const
+{
+  return node.same2(this);
+}
+
+bool PcdataTokenNode::same2(const PcdataTokenNode *node) const
+{
+  return &pcdataToken_ == &(node->pcdataToken());
+}
+
+void PcdataTokenNode::accept(NodeVisitor &visitor)
+{
+  visitor.pcdataToken(*this);
+}
+
+unsigned long PcdataTokenNode::hash() const
+{
+  return (unsigned long)&pcdataToken_;
+}
+
+
+
+AccessResult ModelGroupNode::getOriginToSubnodeRelPropertyName(ComponentName::Id &name) const
+{
+  name = parentModelGroupNode_ == 0
+          ? ComponentName::idModelGroup
+          : ComponentName::idContentTokens;
+  return accessOK;
+}
+
+AccessResult ModelGroupNode::getConnector(Node::Connector::Enum &conn) const
+{
+  switch (modelGroup_.connector())
+  {
+    case ModelGroup::andConnector:
+      conn = Connector::and_;
+      break;
+    case ModelGroup::orConnector:
+      conn = Connector::or_;
+      break;
+    case ModelGroup::seqConnector:
+      conn = Connector::seq;
+      break;
+    default:
+      (static_cast<void> (__builtin_expect (!!(0), 1) ? 0 : (__assert_fail ("0", "GroveBuilder.cxx", 6145, __PRETTY_FUNCTION__), 0)));
+  }
+  return accessOK;
+}
+
+AccessResult ModelGroupNode::getOccurIndicator(Node::OccurIndicator::Enum &occur) const
+{
+  switch (modelGroup_.occurrenceIndicator()) {
+    case ContentToken::opt:
+      occur = OccurIndicator::opt;
+      break;
+    case ContentToken::plus:
+      occur = OccurIndicator::plus;
+      break;
+    case ContentToken::rep:
+      occur = OccurIndicator::rep;
+      break;
+    case ContentToken::none:
+      return accessNull;
+    default:
+      (static_cast<void> (__builtin_expect (!!(0), 1) ? 0 : (__assert_fail ("0", "GroveBuilder.cxx", 6165, __PRETTY_FUNCTION__), 0)));
+  }
+  return accessOK;
+}
+
+AccessResult ModelGroupNode::getContentTokens(NodeListPtr &ptr) const
+{
+  ptr.assign(new ContentTokenNodeList(grove(), *(ModelGroupNode *)this));
+  return accessOK;
+}
+
+void ModelGroupNode::makeNode(NodePtr &ptr, unsigned contentTokenIdx)
+{
+  (static_cast<void> (__builtin_expect (!!(contentTokenIdx < modelGroup_.nMembers()), 1) ? 0 : (__assert_fail ("contentTokenIdx < modelGroup_.nMembers()", "GroveBuilder.cxx", 6178, __PRETTY_FUNCTION__), 0)));
+  const ContentToken &contentToken = modelGroup_.member(contentTokenIdx);
+  const ModelGroup *asModelGroup = contentToken.asModelGroup();
+  if (asModelGroup != 0)
+    ptr.assign(new ModelGroupNode(grove(),
+                                  elementType_,
+                                  *asModelGroup,
+                                  this));
+  else
+  {
+    const LeafContentToken *asLeafContentToken = contentToken.asLeafContentToken();
+    if (asLeafContentToken != 0)
+      if (asLeafContentToken->elementType() != 0)
+        ptr.assign(new ElementTokenNode(grove(),
+                                        elementType_,
+                                        *(const ElementToken*)asLeafContentToken,
+                                        this));
+      else if (asLeafContentToken->occurrenceIndicator() == ContentToken::rep)
+        ptr.assign(new PcdataTokenNode(grove(),
+                                       elementType_,
+                                       *(const PcdataToken*)asLeafContentToken,
+                                       this));
+      else
+        (static_cast<void> (__builtin_expect (!!(0), 1) ? 0 : (__assert_fail ("0", "GroveBuilder.cxx", 6201, __PRETTY_FUNCTION__), 0)));
+  }
+}
+
+bool ModelGroupNode::same(const BaseNode &node) const
+{
+  return node.same2(this);
+}
+
+bool ModelGroupNode::same2(const ModelGroupNode *node) const
+{
+  return &modelGroup_ == &(node->modelGroup());
+}
+
+void ModelGroupNode::accept(NodeVisitor &visitor)
+{
+  visitor.modelGroup(*this);
+}
+
+unsigned long ModelGroupNode::hash() const
+{
+  return (unsigned long)&modelGroup_;
+}
+
+
+
+ContentTokenNodeList::ContentTokenNodeList(const GroveImpl *grove,
+               ModelGroupNode &modelGroupNode,
+                                           unsigned firstTokenIdx)
+ : grove_(grove), modelGroupNode_(modelGroupNode), firstTokenIdx_(firstTokenIdx)
+{
+}
+
+AccessResult ContentTokenNodeList::next()
+{
+  if (++firstTokenIdx_ >= modelGroupNode_.modelGroup().nMembers())
+    return accessNull;
+  return accessOK;
+}
+
+AccessResult ContentTokenNodeList::first(NodePtr &ptr) const
+{
+  if (firstTokenIdx_ < modelGroupNode_.modelGroup().nMembers())
+    modelGroupNode_.makeNode(ptr, firstTokenIdx_);
+  else
+    return accessNull;
+  return accessOK;
+}
+
+AccessResult ContentTokenNodeList::chunkRest(NodeListPtr &ptr) const
+{
+  if (canReuse(ptr)) {
+    ContentTokenNodeList *list = (ContentTokenNodeList *)this;
+    return list->next();
+  }
+  unsigned firstTokenIdx = firstTokenIdx_;
+  if (++firstTokenIdx >= modelGroupNode_.modelGroup().nMembers())
+    return accessNull;
+  ptr.assign(new ContentTokenNodeList(grove_, modelGroupNode_, firstTokenIdx));
+  return accessOK;
+}
+
+
+
+AccessResult
+AttributeDefOrigin::makeAttributeValueNode(const GroveImpl *grove,
+                                           NodePtr &ptr,
+                                           const AttributeValue *value) const
+{
+  if (value) {
+    const Text *text;
+    const StringC *str;
+    switch (value->info(text, str)) {
+    case AttributeValue::tokenized:
+        ptr.assign(makeAttributeValueTokenNode(grove,
+                                               (const TokenizedAttributeValue *)value,
+                                 attIndex_, 0));
+      return accessOK;
+    case AttributeValue::cdata:
+      {
+ TextIter iter(*text);
+ if (!CdataAttributeValueNode::skipBoring(iter)) {
+          ptr.assign(0);
+     return accessNull;
+        }
+ else {
+   ptr.assign(makeCdataAttributeValueNode(grove, value,
+               attIndex_, iter));
+     return accessOK;
+        }
+      }
+    default:
+      break;
+    }
+  }
+  return accessNull;
+}
+
+AccessResult
+AttributeDefOrigin::makeAttributeValueNodeList(const GroveImpl *grove,
+                                               NodeListPtr &ptr,
+                                               const AttributeValue *value = 0) const
+{
+  NodePtr nodePtr;
+  AccessResult result;
+  result = makeAttributeValueNode(grove, nodePtr, value);
+  if (result == accessOK)
+    ptr.assign(nodePtr.operator->() == 0 ? new BaseNodeList : new SiblingNodeList(nodePtr));
+  return result;
+}
+
+AccessResult AttributeDefOrigin::makeAttributeDefNode(const GroveImpl *grove,
+                                                      NodePtr &ptr,
+                                                      const StringC &name) const
+{
+  if (attDefList() == 0)
+    return accessNull;
+  for (size_t i = 0; i < attDefList()->size(); i++)
+    if (attDefList()->def(i)->name() == name)
+    {
+      return makeAttributeDefNode(grove, ptr, i);
+      break;
+    }
+  return accessNull;
+}
+
+
+
+ElementTypeAttributeDefOrigin::ElementTypeAttributeDefOrigin(const ElementType *elementType)
+: elementType_(elementType)
+{
+}
+
+const AttributeDefinitionList *ElementTypeAttributeDefOrigin::attDefList() const
+{
+  return elementType_->attributeDefTemp();
+}
+
+AccessResult ElementTypeAttributeDefOrigin::makeAttributeDefNode(const GroveImpl *grove,
+                                                                 NodePtr &ptr,
+                                                                 size_t attributeDefIdx) const
+{
+  ptr.assign(new ElementTypeAttributeDefNode(grove, *elementType_, attributeDefIdx));
+  return accessOK;
+}
+
+AccessResult ElementTypeAttributeDefOrigin::makeAttributeDefList(const GroveImpl *grove,
+                                                                 NodeListPtr &ptr,
+                                                                 size_t firstAttDefIdx) const
+{
+  ptr.assign(new ElementTypeAttributeDefsNodeList(grove,
+                                                  *elementType_,
+                                                  firstAttDefIdx));
+  return accessOK;
+}
+
+Node *ElementTypeAttributeDefOrigin
+::makeCdataAttributeValueNode(const GroveImpl *grove,
+         const AttributeValue *value,
+         size_t attIndex,
+         const TextIter &iter,
+         size_t charIndex) const
+{
+  return new ElementTypeCdataAttributeValueNode(grove, value, attIndex, iter,
+                       charIndex, elementType_);
+}
+
+
+Node *ElementTypeAttributeDefOrigin
+::makeAttributeValueTokenNode(const GroveImpl *grove,
+         const TokenizedAttributeValue *value,
+         size_t attIndex,
+         size_t tokenIndex) const
+{
+  return new ElementTypeAttributeValueTokenNode(grove, value, attIndex,
+                                  tokenIndex, elementType_);
+}
+
+Node *ElementTypeAttributeDefOrigin::makeOriginNode(const GroveImpl *grove, size_t) const
+{
+  return new ElementTypeAttributeDefNode(grove, *elementType_, attIndex_);
+}
+
+const void *ElementTypeAttributeDefOrigin::attributeOriginId() const
+{
+  return elementType_;
+}
+
+
+
+NotationAttributeDefOrigin::NotationAttributeDefOrigin(const Notation *notation)
+: notation_(notation)
+{
+}
+
+const AttributeDefinitionList *NotationAttributeDefOrigin::attDefList() const
+{
+  return notation_->attributeDefTemp();
+}
+
+AccessResult NotationAttributeDefOrigin::makeAttributeDefNode(const GroveImpl *grove,
+                                                              NodePtr &ptr,
+                                                              size_t attributeDefIdx) const
+{
+  ptr.assign(new NotationAttributeDefNode(grove, *notation_, attributeDefIdx));
+  return accessOK;
+}
+
+AccessResult NotationAttributeDefOrigin::makeAttributeDefList(const GroveImpl *grove,
+                                                              NodeListPtr &ptr,
+                                                              size_t firstAttDefIdx) const
+{
+  ptr.assign(new NotationAttributeDefsNodeList(grove,
+                                               *notation_,
+                                               firstAttDefIdx));
+  return accessOK;
+}
+
+Node *NotationAttributeDefOrigin
+::makeCdataAttributeValueNode(const GroveImpl *grove,
+         const AttributeValue *value,
+         size_t attIndex,
+         const TextIter &iter,
+         size_t charIndex) const
+{
+  return new NotationCdataAttributeValueNode(grove, value, attIndex, iter,
+                    charIndex, notation_);
+}
+
+
+Node *NotationAttributeDefOrigin
+::makeAttributeValueTokenNode(const GroveImpl *grove,
+         const TokenizedAttributeValue *value,
+         size_t attIndex,
+         size_t tokenIndex) const
+{
+  return new NotationAttributeValueTokenNode(grove, value, attIndex,
+                               tokenIndex, notation_);
+}
+
+Node *NotationAttributeDefOrigin::makeOriginNode(const GroveImpl *grove, size_t) const
+{
+  return new NotationAttributeDefNode(grove, *notation_, attIndex_);
+}
+
+const void *NotationAttributeDefOrigin::attributeOriginId() const
+{
+  return notation_;
+}
+
+
+
+AccessResult AttributeDefNode::getName(GroveString &str) const
+{
+  setString(str, attDefList()->def(attIndex_)->name());
+  return accessOK;
+}
+
+AccessResult AttributeDefNode::getDeclValueType(Node::DeclValueType::Enum &dvt) const
+{
+  AttributeDefinitionDesc desc;
+  attDefList()->def(attIndex_)->getDesc(desc);
+  switch (desc.declaredValue)
+  {
+    case AttributeDefinitionDesc::cdata:
+      dvt = DeclValueType::cdata;
+      break;
+    case AttributeDefinitionDesc::name:
+      dvt = DeclValueType::name;
+      break;
+    case AttributeDefinitionDesc::number:
+      dvt = DeclValueType::number;
+      break;
+    case AttributeDefinitionDesc::nmtoken:
+      dvt = DeclValueType::nmtoken;
+      break;
+    case AttributeDefinitionDesc::nutoken:
+      dvt = DeclValueType::nutoken;
+      break;
+    case AttributeDefinitionDesc::entity:
+      dvt = DeclValueType::entity;
+      break;
+    case AttributeDefinitionDesc::idref:
+      dvt = DeclValueType::idref;
+      break;
+    case AttributeDefinitionDesc::names:
+      dvt = DeclValueType::names;
+      break;
+    case AttributeDefinitionDesc::numbers:
+      dvt = DeclValueType::numbers;
+      break;
+    case AttributeDefinitionDesc::nmtokens:
+      dvt = DeclValueType::nmtokens;
+      break;
+    case AttributeDefinitionDesc::nutokens:
+      dvt = DeclValueType::nutokens;
+      break;
+    case AttributeDefinitionDesc::entities:
+      dvt = DeclValueType::entities;
+      break;
+    case AttributeDefinitionDesc::idrefs:
+      dvt = DeclValueType::idrefs;
+      break;
+    case AttributeDefinitionDesc::id:
+      dvt = DeclValueType::id;
+      break;
+    case AttributeDefinitionDesc::notation:
+      dvt = DeclValueType::notation;
+      break;
+    case AttributeDefinitionDesc::nameTokenGroup:
+      dvt = DeclValueType::nmtkgrp;
+      break;
+    default:
+      (static_cast<void> (__builtin_expect (!!(0), 1) ? 0 : (__assert_fail ("0", "GroveBuilder.cxx", 6514, __PRETTY_FUNCTION__), 0)));
+  }
+  return accessOK;
+}
+
+AccessResult AttributeDefNode::getDefaultValueType(Node::DefaultValueType::Enum &dvt) const
+{
+  AttributeDefinitionDesc desc;
+  attDefList()->def(attIndex_)->getDesc(desc);
+  switch (desc.defaultValueType)
+  {
+    case AttributeDefinitionDesc::required:
+      dvt = DefaultValueType::required;
+      break;
+    case AttributeDefinitionDesc::current:
+      dvt = DefaultValueType::current;
+      break;
+    case AttributeDefinitionDesc::implied:
+      dvt = DefaultValueType::implied;
+      break;
+    case AttributeDefinitionDesc::conref:
+      dvt = DefaultValueType::conref;
+      break;
+    case AttributeDefinitionDesc::defaulted:
+      dvt = DefaultValueType::value;
+      break;
+    case AttributeDefinitionDesc::fixed:
+      dvt = DefaultValueType::fixed;
+      break;
+    default:
+      (static_cast<void> (__builtin_expect (!!(0), 1) ? 0 : (__assert_fail ("0", "GroveBuilder.cxx", 6544, __PRETTY_FUNCTION__), 0)));
+  }
+  return accessOK;
+}
+
+AccessResult AttributeDefNode::getTokens(GroveStringListPtr &tokens) const
+{
+  AttributeDefinitionDesc desc;
+  attDefList()->def(attIndex_)->getDesc(desc);
+  if (desc.declaredValue != AttributeDefinitionDesc::notation
+       && desc.declaredValue != AttributeDefinitionDesc::nameTokenGroup)
+    return accessNull;
+  tokens.assign(new GroveStringList);
+  GroveString str;
+  for (size_t i = 0; i < desc.allowedValues.size(); i++)
+  {
+    setString(str, desc.allowedValues[i]);
+    tokens->append(str);
+  }
+  return accessOK;
+}
+
+AccessResult AttributeDefNode::getCurrentAttributeIndex(long &index) const
+{
+  AttributeDefinitionDesc desc;
+  attDefList()->def(attIndex_)->getDesc(desc);
+  if (desc.defaultValueType != AttributeDefinitionDesc::current)
+    return accessNull;
+  index = desc.currentIndex;
+  return accessOK;
+}
+
+void AttributeDefNode::accept(NodeVisitor &visitor)
+{
+  visitor.attributeDef(*this);
+}
+
+bool AttributeDefNode::same(const BaseNode &node) const
+{
+  return node.same2(this);
+}
+
+bool AttributeDefNode::same2(const AttributeDefNode *node) const
+{
+  return (attributeOriginId() == node->attributeOriginId()
+          && attIndex_ == node->attIndex());
+}
+
+unsigned long AttributeDefNode::hash() const
+{
+  unsigned long n = (unsigned long)attributeOriginId();
+  return secondHash(n + attIndex_);
+}
+
+
+
+AccessResult ElementTypeAttributeDefNode::getOrigin(NodePtr &ptr) const
+{
+  ptr.assign(new ElementTypeNode(grove(), *elementType_));
+  return accessOK;
+}
+
+AccessResult ElementTypeAttributeDefNode::getCurrentGroup(NodeListPtr &ptr) const
+{
+  AttributeDefinitionDesc desc;
+  attDefList()->def(attIndex_)->getDesc(desc);
+  if (desc.defaultValueType != AttributeDefinitionDesc::current)
+    return accessNull;
+  ptr.assign(
+   new ElementTypeCurrentGroupAttributeDefsNodeList(grove(),
+                                                    grove()->governingDtd()->elementTypeIter(),
+                                                    desc.currentIndex));
+  return accessOK;
+}
+
+AccessResult ElementTypeAttributeDefNode::getLocation(Location &loc) const
+{
+  const ElementDefinition *def = elementType_->definition();
+  if (def == 0)
+    return accessNull;
+  return grove()->proxifyLocation(def->location(), loc);
+}
+
+AccessResult ElementTypeAttributeDefNode::getDefaultValue(NodeListPtr &ptr) const
+{
+  AttributeDefinitionDesc desc;
+  attDefList()->def(attIndex_)->getDesc(desc);
+  const AttributeValue *value = desc.defaultValue.pointer();
+  return makeAttributeValueNodeList(grove(), ptr, value);
+}
+
+
+
+AccessResult NotationAttributeDefNode::getOrigin(NodePtr &ptr) const
+{
+  ptr.assign(new NotationNode(grove(), notation_));
+  return accessOK;
+}
+
+AccessResult NotationAttributeDefNode::getCurrentGroup(NodeListPtr &ptr) const
+{
+  AttributeDefinitionDesc desc;
+  attDefList()->def(attIndex_)->getDesc(desc);
+  if (desc.defaultValueType != AttributeDefinitionDesc::current)
+    return accessNull;
+  NodePtr nodePtr;
+  nodePtr.assign(new NotationAttributeDefNode(grove(), *notation_, attIndex_));
+  ptr.assign(new SiblingNodeList(nodePtr));
+  return accessOK;
+}
+
+AccessResult NotationAttributeDefNode::getLocation(Location &loc) const
+{
+  return grove()->proxifyLocation(notation_->defLocation(), loc);
+}
+
+AccessResult NotationAttributeDefNode::getDefaultValue(NodeListPtr &ptr) const
+{
+  AttributeDefinitionDesc desc;
+  attDefList()->def(attIndex_)->getDesc(desc);
+  const AttributeValue *value = desc.defaultValue.pointer();
+  return makeAttributeValueNodeList(grove(), ptr, value);
+}
+
+
+
+bool AttributeDefsNodeList::inList(size_t attIndex) const
+{
+  if (attDefList() == 0 || attIndex >= attDefList()->size())
+    return false;
+  return true;
+}
+
+AccessResult AttributeDefsNodeList::first(NodePtr &ptr) const
+{
+  return inList(attIndex_)
+          ? makeAttributeDefNode(grove_, ptr, attIndex_)
+          : accessNull;
+}
+
+AccessResult AttributeDefsNodeList::chunkRest(NodeListPtr &ptr) const
+{
+  if (canReuse(ptr)) {
+    AttributeDefsNodeList *list = (AttributeDefsNodeList *)this;
+    if (list->inList(list->attIndex_)) {
+      ++(list->attIndex_);
+      return accessOK;
+    }
+    return accessNull;
+  }
+  return inList(attIndex_)
+          ? makeAttributeDefList(grove_, ptr, attIndex_+1)
+          : accessNull;
+}
+
+
+
+NodeListPtr AttributeDefsNamedNodeList::nodeList() const
+{
+  NodeListPtr ptr;
+  makeAttributeDefList(grove(), ptr, 0);
+  return ptr;
+}
+
+AccessResult AttributeDefsNamedNodeList::namedNodeU(const StringC &str, NodePtr &ptr) const
+{
+  return makeAttributeDefNode(grove(), ptr, str);
+}
+
+
+
+ElementTypeCurrentGroupAttributeDefsNodeList
+ ::ElementTypeCurrentGroupAttributeDefsNodeList(const GroveImpl *grove,
+                                                const Dtd::ConstElementTypeIter &iter,
+                                                size_t currentGroupIndex)
+   : grove_(grove), iter_(iter), currentGroupIndex_(currentGroupIndex), attIndex_(0)
+{
+  elementType_ = iter_.next();
+  next(false);
+}
+
+bool ElementTypeCurrentGroupAttributeDefsNodeList::next(Dtd::ConstElementTypeIter &iter,
+                                                        const ElementType *&elementType,
+                                                        size_t &attIndex,
+                                                        bool incrementFirst) const
+{
+  if (incrementFirst)
+    attIndex++;
+  while (elementType != 0) {
+    if (attIndex >= elementType->attributeDefTemp()->size() ) {
+      do {
+        elementType = iter.next();
+      } while(elementType != 0 && !elementType->attributeDefTemp()->anyCurrent());
+      attIndex = 0;
+    }
+    else {
+      if (elementType->attributeDefTemp()->def(attIndex)->isCurrent()) {
+        AttributeDefinitionDesc desc;
+        elementType->attributeDefTemp()->def(attIndex)->getDesc(desc);
+        if (desc.currentIndex == currentGroupIndex_)
+          break;
+      }
+      attIndex++;
+    }
+  }
+  return elementType != 0 ? true : false;
+}
+
+AccessResult ElementTypeCurrentGroupAttributeDefsNodeList::first(NodePtr &ptr) const
+{
+  if (elementType_ == 0)
+    return accessNull;
+  ptr.assign(new ElementTypeAttributeDefNode(grove_,
+                                             *elementType_,
+                                             attIndex_));
+  return accessOK;
+}
+
+AccessResult ElementTypeCurrentGroupAttributeDefsNodeList::chunkRest(NodeListPtr &ptr) const
+{
+  if (elementType_ == 0)
+    return accessNull;
+  if (canReuse(ptr)) {
+    ElementTypeCurrentGroupAttributeDefsNodeList *list
+     = (ElementTypeCurrentGroupAttributeDefsNodeList *)this;
+    list->next();
+    return accessOK;
+  } else {
+    Dtd::ConstElementTypeIter iter(iter_);
+    const ElementType *elementType = elementType_;
+    size_t attIndex = attIndex_;
+    next(iter, elementType, attIndex);
+    ptr.assign(new ElementTypeCurrentGroupAttributeDefsNodeList(grove_,
+                                                                iter,
+                                                                elementType,
+                                                                attIndex,
+                                                                currentGroupIndex_));
+  }
+  return accessOK;
+}
+
+
+
+
+}
+
+
+# 1 "grove_inst.cxx" 1
+
+namespace OpenSP {
+
+
+
+
+}
+
+
+
+
+# 1 "../config.h" 1
+
+
+
+
+
+
+# 1 "/usr/include/OpenSP/config.h" 1 3 4
+# 8 "../config.h" 2
+# 13 "grove_inst.cxx" 2
+# 6791 "GroveBuilder.cxx" 2
--- openjade-1.4devel1.orig/spgrove/Makefile.am
+++ openjade-1.4devel1/spgrove/Makefile.am
@@ -2,19 +2,21 @@
 
 lib_LTLIBRARIES = libospgrove.la
 
-libospgrove_la_LDFLAGS = -version-info 0:0:0
+libospgrove_la_LDFLAGS = -version-info 1:0:0
 
 libospgrove_la_SOURCES = GroveApp.cxx GroveApp.h GroveBuilder.cxx \
 	GroveBuilder.h SdNode.cxx SdNode.h threads.h
 
 pkginclude_HEADERS = GroveApp.h GroveBuilder.h
 
-INCLUDES = -I$(top_srcdir)/grove
+AM_CPPFLAGS = -I$(top_srcdir)/grove
 
 EXTRA_DIST = grove_inst.m4 grove_inst.cxx spgrove.dsp
 
 BUILT_SOURCES = grove_inst.cxx
 
+MAINTAINERCLEANFILES = Makefile.in
+
 SUFFIXES = .m4 
 
 .m4.cxx:
--- openjade-1.4devel1.orig/style/DssslApp.cxx
+++ openjade-1.4devel1/style/DssslApp.cxx
@@ -89,7 +89,7 @@
   // Since we use strtod(), must have C numeric
   setlocale(LC_NUMERIC, "C");
 #endif
-  MessageTable::instance()->registerMessageDomain(MessageFragment::xModule,
+  MessageTable::instance()->registerMessageDomain(jstyleModule,
                                                   OPENJADE_MESSAGE_DOMAIN,
 						  OPENJADE_LOCALE_DIR);
   return ret;
--- openjade-1.4devel1.orig/style/DssslSpecEventHandler.cxx
+++ openjade-1.4devel1/style/DssslSpecEventHandler.cxx
@@ -104,7 +104,8 @@
 
 
 EventHandler *
-DssslSpecEventHandler::arcEventHandler(const Notation *notation,
+DssslSpecEventHandler::arcEventHandler(const StringC *,
+				       const Notation *notation,
 				       const Vector<StringC> &,
 				       const SubstTable *)
 {
--- openjade-1.4devel1.orig/style/DssslSpecEventHandler.h
+++ openjade-1.4devel1/style/DssslSpecEventHandler.h
@@ -193,7 +193,8 @@
   void data(DataEvent *);
   void message(MessageEvent *);
   void endProlog(EndPrologEvent *);
-  EventHandler *arcEventHandler(const Notation *,
+  EventHandler *arcEventHandler(const StringC *,
+				const Notation *,
 				const Vector<StringC> &,
 				const SubstTable *);
   void loadDoc(SgmlParser &, Doc &);
--- openjade-1.4devel1.orig/style/ELObj.cxx
+++ openjade-1.4devel1/style/ELObj.cxx
@@ -96,6 +96,11 @@
   return 0;
 }
 
+AppendSosofoObj *ELObj::asAppendSosofo()
+{
+  return 0;
+}
+
 ColorObj *ELObj::asColor()
 {
   return 0;
--- openjade-1.4devel1.orig/style/ELObj.h
+++ openjade-1.4devel1/style/ELObj.h
@@ -28,6 +28,7 @@
 class BoxObj;
 class StringObj;
 class SosofoObj;
+class AppendSosofoObj;
 class ColorObj;
 class ColorSpaceObj;
 class StyleObj;
@@ -66,6 +67,7 @@
   virtual KeywordObj *asKeyword();
   virtual FunctionObj *asFunction();
   virtual SosofoObj *asSosofo();
+  virtual AppendSosofoObj *asAppendSosofo();
   virtual ColorObj *asColor();
   virtual ColorSpaceObj *asColorSpace();
   virtual StyleObj *asStyle();
--- openjade-1.4devel1.orig/style/FlowObj.cxx
+++ openjade-1.4devel1/style/FlowObj.cxx
@@ -1401,8 +1401,8 @@
   FOTBuilder &fotb = context.currentFOTBuilder();
   fotb.startBox(*nic_);
   context.pushPrincipalPort(nic_->isDisplay
-			    ? new DisplayValidator
-			    : new InlineValidator);
+			    ? (ProcessContext::Validator*) new DisplayValidator
+			    : (ProcessContext::Validator*) new InlineValidator);
   CompoundFlowObj::processInner(context);
   context.popPrincipalPort();
   fotb.endBox();
@@ -2604,6 +2604,11 @@
     case sColumn:
       if (af & FlowObj::afTableColumn)
 	return true;
+      /* Debian Bug#108414 -- untested patch! */
+      if (af & (FlowObj::afTableRow | FlowObj::afTableCell)) {
+	s_ = sContent;
+	return true;
+      }
       s_ = sBadColumn;
       break;
     case sBadContent:
@@ -3574,7 +3579,7 @@
 #define FLOW_OBJ(name, string, feature) \
 { FlowObj *tem = new (*this) name; \
   /* Temporary debugging check.*/ \
-  ASSERT(sizeof(name) <= 32); \
+  /* ASSERT(sizeof(name) <= 32); */ \
   makePermanent(tem); \
   Identifier *ident = lookup(makeStringC(string)); \
   ident->setFlowObj(tem); \
--- openjade-1.4devel1.orig/style/Interpreter.cxx
+++ openjade-1.4devel1/style/Interpreter.cxx
@@ -2636,13 +2636,13 @@
 {
   ValT_ v(map_[ch]);
   if (v.hasValue_)
-    return v.b_ ? interp.makeTrue() : interp.makeFalse();
+    return v.b_ ? (ELObj *) interp.makeTrue() : (ELObj *) interp.makeFalse();
   return 0;
 }
 
 ELObj *BooleanCharPropValues::defaultValue(Interpreter &interp) const
 {
-  return def_ ? interp.makeTrue() : interp.makeFalse();
+  return def_ ? (ELObj *) interp.makeTrue() : (ELObj *) interp.makeFalse();
 }
 
 bool PublicIdCharPropValues::setDefault(const StringC &name,
--- openjade-1.4devel1.orig/style/InterpreterMessages.msg
+++ openjade-1.4devel1/style/InterpreterMessages.msg
@@ -34,6 +34,7 @@
 E3+notAString++%2 argument for primitive %1 of wrong type: %3 not a string
 E3+notAStringOrSymbol++%2 argument for primitive %1 of wrong type: %3 not a string or symbol
 E3+notAChar++%2 argument for primitive %1 of wrong type: %3 not a char
+E3+notATimeString++%2 argument for primitive %1 of wrong type: %3 not an ISO8601 time string
 E3+notAStyle++%2 argument for primitive %1 of wrong type: %3 not a style
 E3+notAnExactInteger++%2 argument for primitive %1 of wrong type: %3 not an exact integer
 E3+notAQuantity++%2 argument for primitive %1 of wrong type: %3 not a quantity
--- openjade-1.4devel1.orig/style/InterpreterMessages.rc
+++ openjade-1.4devel1/style/InterpreterMessages.rc
@@ -35,170 +35,171 @@
   34, "%2 argument for primitive %1 of wrong type: %3 not a string"
   35, "%2 argument for primitive %1 of wrong type: %3 not a string or symbol"
   36, "%2 argument for primitive %1 of wrong type: %3 not a char"
-  37, "%2 argument for primitive %1 of wrong type: %3 not a style"
-  38, "%2 argument for primitive %1 of wrong type: %3 not an exact integer"
-  39, "%2 argument for primitive %1 of wrong type: %3 not a quantity"
-  40, "%2 argument for primitive %1 of wrong type: %3 not a color-space"
-  41, "%2 argument for primitive %1 of wrong type: %3 not a number"
-  42, "%2 argument for primitive %1 of wrong type: %3 not a sosofo"
-  43, "%2 argument for primitive %1 of wrong type: %3 not an optional singleton node list"
-  44, "%2 argument for primitive %1 of wrong type: %3 not a singleton node list"
-  45, "%2 argument for primitive %1 of wrong type: %3 not a node list"
-  46, "%2 argument for primitive %1 of wrong type: %3 not a named node list"
-  47, "%2 argument for primitive %1 of wrong type: %3 not a length or length-spec"
-  48, "%2 argument for primitive %1 of wrong type: %3 not a quantity or length-spec"
-  49, "%2 argument for primitive %1 of wrong type: %3 not an integer or the symbol ""force"""
-  51, "%2 argument for primitive %1 of wrong type: %3 not an address"
-  52, "%2 argument for primitive %1 of wrong type: %3 not a glyph-id"
-  53, "%2 argument for primitive %1 of wrong type: %3 not a glyph-subst-table"
-  54, "%2 argument for primitive %1 of wrong type: %3 not a list of pairs of glyph-ids"
-  55, "%2 argument for primitive %1 of wrong type: %3 not a procedure"
-  56, "%2 argument for primitive %1 of wrong type: %3 not a vector"
-  57, "root rule already defined in same part with same importance"
-  58, "first definition was here"
-  59, "initial value already declared for characteristic %1 in same part"
-  60, "first declaration was here"
-  61, "%1 is not a valid keyword in a style expression"
-  62, "%1 is not a valid keyword in a make expression for flow object class %2"
-  63, "%1 is not the name of any flow object class"
-  64, "content expression cannot be specified in make expression for atomic flow object class %1"
-  65, "value for ""label:"" not a symbol"
-  66, "no port for label %1"
-  67, "invalid content map"
-  68, "content map references non-existent port %1"
-  69, "invalid value for %1 characteristic"
-  70, "no clause in cond expression matched"
-  71, "no clause in case expression matched %1"
-  72, "expected ""else"" not %1"
-  73, "sorry, cannot handle unresolvable quantities in datums in case expression"
-  74, "%1"
-  75, "division by zero"
-  76, "procedure does not have %1 keyword argument"
-  77, "argument not a keyword"
-  79, "specification document does not have the DSSSL architecture as a base architecture"
-  80, "specification document did not contain a style-specification-body element"
-  81, "unknown character name %1"
-  82, "attempt to use current node when there is none"
-  83, "attempt to process node in illegal context"
-  84, "radix must be 2, 8, 10 or 16"
-  85, "this context requires a sosofo"
-  86, "this context requires a style object"
-  87, "procedure can only be used in evaluation of characteristic value"
-  89, "%1 color requires three arguments"
-  90, "arguments for %1 color must be numbers"
-  91, "arguments for %1 color must be in the range 0 to 1"
-  92, "result of procedure in %1 color must be a number"
-  93, "unknown color-space family %1"
-  94, "%1 color-space family does not take any arguments"
-  95, "invalid parameters for %1 color-space family"
-  96, "%1 is not a pre-defined inherited characteristic"
-  97, "invalid number format %1"
-  98, "invalid character %1 in public identifier"
-  99, "debug %1"
-  100, "circular use of specification parts"
-  101, "no style-specification or external-specification with ID %1"
-  102, "document did not contain any style-specifications or external-specifications"
-  103, "table-cell flow object not inside a table"
-  104, "table-row flow object not inside a table"
-  105, "no value for node property %1"
-  106, "value returned by procedure was not a node-list"
-  107, "called from here"
-  108, "called from here...(%1 calls omitted)"
-  109, "node processing loop detected"
-  110, "unquote-splicing expression does not evaluate to a list"
-  111, "object is read-only"
-  112, "assignment to top-level variable %1"
-  113, "invalid call to continuation"
-  114, "empty generic identifier in pattern"
-  115, "pattern is not a list"
-  116, "%1 cannot be used as a generic identifier in a pattern"
-  117, "%1 cannot occur in a pattern"
-  118, "value missing for qualifier in pattern"
-  119, "unknown pattern qualifier %1"
-  120, "bad value %1 for %2 qualifier in pattern"
-  121, "repeat qualifier not allowed inside children qualifier"
-  122, "bad value for attributes qualifier in pattern"
-  123, "characteristic %1 applied in style rule with same specificity"
-  124, "other style rule is here"
-  125, "node matches more than one pattern with the same specificity"
-  126, "reference to uninitialized variable %1"
-  127, "circular use of actual value of characteristic %1"
-  128, "characteristic %1 already defined in same part"
-  129, "first definition was here"
-  130, "flow object class %1 already defined in same part"
-  131, "first definition was here"
-  132, "mode %1 not defined"
-  133, "duplicate character name %1"
-  134, "duplicate SDATA entity name %1"
-  135, "duplicate SDATA entity text %1"
-  136, "unsupported declaration will be ignored"
-  137, "unsupported character repertoire %1 will be ignored"
-  138, "error in declaration element"
-  140, "%1 is not a valid identifier"
-  141, "error in language definition"
-  142, "no current language"
-  143, "%2 argument for primitive %1 of wrong type: %3 not a language"
-  144, "%2 argument for primitive %1 of wrong type: %3 not a positive integer"
-  145, "%2 argument for primitive %1 of wrong type: %3 not an integer"
-  146, "%2 argument for primitive %1 of wrong type: %3 not a keyword"
-  147, "%2 argument for primitive %1 of wrong type: %3 not an alist"
-  148, "%2 argument for primitive %1 of wrong type: %3 not a list of characters"
-  149, "%2 argument for primitive %1 has wrong length"
-  150, "quantity %1 can't be represented exactly"
-  151, "default language already declared in this part"
-  152, "first declaration was here"
-  153, "%1 not a language as required in a default-language-declaration"
-  154, "%1 not a valid unit name"
-  155, "%1 not a valid character name"
-  156, "%1 not a valid character number"
-  157, "unknown character property %1"
-  158, "error in character property declaration"
-  159, "character property %1 already declared in same part"
-  160, "first declaration was here"
-  161, "added value for character property %1 already declared in same part"
-  162, "previous declaration was here"
-  163, "value returned by procedure was not a sosofo"
-  164, "loop in specification of value of character property %1"
-  165, "value for character property %1 of wrong type: %2 not an integer"
-  166, "value for character property %1 of wrong type: %2 not an integer or the value ""#f"""
-  167, "%1 not a style or transformation language feature"
-  168, "undeclared use of feature %1"
-  169, "feature %1 not supported"
-  170, "feature %1 only partially supported"
-  171, "only allowed in style language"
-  172, "only allowed in transformation language"
-  173, "style and transformation language parts mixed"
-  174, "specification is marked as partial"
-  175, "grove plan excluding module %1 not supported"
-  176, "grove plan including module %1 not supported"
-  177, "%1 not an SGML property set module"
-  178, "Function for char-map characteristic returned non-char object %2 for character %1"
-  179, "value for character property %1 of wrong type: %2 not a public identifier or the value ""#f"""
-  180, "variable %1 occurs more than once in bindings"
-  181, "exactly one of node:, subgrove: and class: needed"
-  182, "add:, null:, remove:, children:, sub: make no sense with subgrove:"
-  183, "remove: makes no sense with class:"
-  184, "%2 argument for primitive %1 of wrong type: %3 not a subgrove-spec"
-  185, "wrong type: %1 not a list of create-specs"
-  186, "wrong type: %1 not a create-spec or list of create-specs"
-  187, "query expression: %1 not a node list"
-  188, "priority expression: %1 not an exact integer"
-  189, "flow objects at the root must be all of class scroll or all of class page-sequence or simple-page-sequence"
-  190, "current flow parent has no principal port"
-  191, "this flow object requires a paragraph as an ancestor flow object"
-  192, "flow object not accepted by port; only inline flow objects accepted"
-  193, "flow object not accepted by port; only display flow objects accepted"
-  194, "flow object not accepted by port; only display or inline flow objects accepted"
-  195, "flow object not accepted in a paragraph; only inline, display or paragraph-break flow objects accepted"
-  196, "a side-by-side flow object only accepts side-by-side-item flow objects as children"
-  197, "flow object not accepted by port; only math-sequence, unmath, subscript, superscript, script, mark, fence, fraction, radical, math-operator, grid, character and alignment-point flow objects accepted"
-  198, "flow object not accepted by port; must be grid-cell"
-  199, "flow object not accepted by port; only a single character flow object accepted"
-  200, "flow object not accepted by port; in a table, only either table-part flow objects or table-column flow objects followed by table-row or table-cell flow objects are allowed"
-  201, "flow object not accepted by port; only table-row or table-cell flow objects accepted"
-  202, "flow object not accepted by port; only table-column flow objects followed by table-row or table-cell flow objects allowd"
-  203, "flow object not accepted by port; only table-cell flow objects accepted"
-  204, "priority-expression must be a number"
-  205, "query-expression must be a node-list"
-  206, "Sorry, non-integral priorities not implemented"
+  37, "%2 argument for primitive %1 of wrong type: %3 not an ISO8601 time string"
+  38, "%2 argument for primitive %1 of wrong type: %3 not a style"
+  39, "%2 argument for primitive %1 of wrong type: %3 not an exact integer"
+  40, "%2 argument for primitive %1 of wrong type: %3 not a quantity"
+  41, "%2 argument for primitive %1 of wrong type: %3 not a color-space"
+  42, "%2 argument for primitive %1 of wrong type: %3 not a number"
+  43, "%2 argument for primitive %1 of wrong type: %3 not a sosofo"
+  44, "%2 argument for primitive %1 of wrong type: %3 not an optional singleton node list"
+  45, "%2 argument for primitive %1 of wrong type: %3 not a singleton node list"
+  46, "%2 argument for primitive %1 of wrong type: %3 not a node list"
+  47, "%2 argument for primitive %1 of wrong type: %3 not a named node list"
+  48, "%2 argument for primitive %1 of wrong type: %3 not a length or length-spec"
+  49, "%2 argument for primitive %1 of wrong type: %3 not a quantity or length-spec"
+  50, "%2 argument for primitive %1 of wrong type: %3 not an integer or the symbol ""force"""
+  52, "%2 argument for primitive %1 of wrong type: %3 not an address"
+  53, "%2 argument for primitive %1 of wrong type: %3 not a glyph-id"
+  54, "%2 argument for primitive %1 of wrong type: %3 not a glyph-subst-table"
+  55, "%2 argument for primitive %1 of wrong type: %3 not a list of pairs of glyph-ids"
+  56, "%2 argument for primitive %1 of wrong type: %3 not a procedure"
+  57, "%2 argument for primitive %1 of wrong type: %3 not a vector"
+  58, "root rule already defined in same part with same importance"
+  59, "first definition was here"
+  60, "initial value already declared for characteristic %1 in same part"
+  61, "first declaration was here"
+  62, "%1 is not a valid keyword in a style expression"
+  63, "%1 is not a valid keyword in a make expression for flow object class %2"
+  64, "%1 is not the name of any flow object class"
+  65, "content expression cannot be specified in make expression for atomic flow object class %1"
+  66, "value for ""label:"" not a symbol"
+  67, "no port for label %1"
+  68, "invalid content map"
+  69, "content map references non-existent port %1"
+  70, "invalid value for %1 characteristic"
+  71, "no clause in cond expression matched"
+  72, "no clause in case expression matched %1"
+  73, "expected ""else"" not %1"
+  74, "sorry, cannot handle unresolvable quantities in datums in case expression"
+  75, "%1"
+  76, "division by zero"
+  77, "procedure does not have %1 keyword argument"
+  78, "argument not a keyword"
+  80, "specification document does not have the DSSSL architecture as a base architecture"
+  81, "specification document did not contain a style-specification-body element"
+  82, "unknown character name %1"
+  83, "attempt to use current node when there is none"
+  84, "attempt to process node in illegal context"
+  85, "radix must be 2, 8, 10 or 16"
+  86, "this context requires a sosofo"
+  87, "this context requires a style object"
+  88, "procedure can only be used in evaluation of characteristic value"
+  90, "%1 color requires three arguments"
+  91, "arguments for %1 color must be numbers"
+  92, "arguments for %1 color must be in the range 0 to 1"
+  93, "result of procedure in %1 color must be a number"
+  94, "unknown color-space family %1"
+  95, "%1 color-space family does not take any arguments"
+  96, "invalid parameters for %1 color-space family"
+  97, "%1 is not a pre-defined inherited characteristic"
+  98, "invalid number format %1"
+  99, "invalid character %1 in public identifier"
+  100, "debug %1"
+  101, "circular use of specification parts"
+  102, "no style-specification or external-specification with ID %1"
+  103, "document did not contain any style-specifications or external-specifications"
+  104, "table-cell flow object not inside a table"
+  105, "table-row flow object not inside a table"
+  106, "no value for node property %1"
+  107, "value returned by procedure was not a node-list"
+  108, "called from here"
+  109, "called from here...(%1 calls omitted)"
+  110, "node processing loop detected"
+  111, "unquote-splicing expression does not evaluate to a list"
+  112, "object is read-only"
+  113, "assignment to top-level variable %1"
+  114, "invalid call to continuation"
+  115, "empty generic identifier in pattern"
+  116, "pattern is not a list"
+  117, "%1 cannot be used as a generic identifier in a pattern"
+  118, "%1 cannot occur in a pattern"
+  119, "value missing for qualifier in pattern"
+  120, "unknown pattern qualifier %1"
+  121, "bad value %1 for %2 qualifier in pattern"
+  122, "repeat qualifier not allowed inside children qualifier"
+  123, "bad value for attributes qualifier in pattern"
+  124, "characteristic %1 applied in style rule with same specificity"
+  125, "other style rule is here"
+  126, "node matches more than one pattern with the same specificity"
+  127, "reference to uninitialized variable %1"
+  128, "circular use of actual value of characteristic %1"
+  129, "characteristic %1 already defined in same part"
+  130, "first definition was here"
+  131, "flow object class %1 already defined in same part"
+  132, "first definition was here"
+  133, "mode %1 not defined"
+  134, "duplicate character name %1"
+  135, "duplicate SDATA entity name %1"
+  136, "duplicate SDATA entity text %1"
+  137, "unsupported declaration will be ignored"
+  138, "unsupported character repertoire %1 will be ignored"
+  139, "error in declaration element"
+  141, "%1 is not a valid identifier"
+  142, "error in language definition"
+  143, "no current language"
+  144, "%2 argument for primitive %1 of wrong type: %3 not a language"
+  145, "%2 argument for primitive %1 of wrong type: %3 not a positive integer"
+  146, "%2 argument for primitive %1 of wrong type: %3 not an integer"
+  147, "%2 argument for primitive %1 of wrong type: %3 not a keyword"
+  148, "%2 argument for primitive %1 of wrong type: %3 not an alist"
+  149, "%2 argument for primitive %1 of wrong type: %3 not a list of characters"
+  150, "%2 argument for primitive %1 has wrong length"
+  151, "quantity %1 can't be represented exactly"
+  152, "default language already declared in this part"
+  153, "first declaration was here"
+  154, "%1 not a language as required in a default-language-declaration"
+  155, "%1 not a valid unit name"
+  156, "%1 not a valid character name"
+  157, "%1 not a valid character number"
+  158, "unknown character property %1"
+  159, "error in character property declaration"
+  160, "character property %1 already declared in same part"
+  161, "first declaration was here"
+  162, "added value for character property %1 already declared in same part"
+  163, "previous declaration was here"
+  164, "value returned by procedure was not a sosofo"
+  165, "loop in specification of value of character property %1"
+  166, "value for character property %1 of wrong type: %2 not an integer"
+  167, "value for character property %1 of wrong type: %2 not an integer or the value ""#f"""
+  168, "%1 not a style or transformation language feature"
+  169, "undeclared use of feature %1"
+  170, "feature %1 not supported"
+  171, "feature %1 only partially supported"
+  172, "only allowed in style language"
+  173, "only allowed in transformation language"
+  174, "style and transformation language parts mixed"
+  175, "specification is marked as partial"
+  176, "grove plan excluding module %1 not supported"
+  177, "grove plan including module %1 not supported"
+  178, "%1 not an SGML property set module"
+  179, "Function for char-map characteristic returned non-char object %2 for character %1"
+  180, "value for character property %1 of wrong type: %2 not a public identifier or the value ""#f"""
+  181, "variable %1 occurs more than once in bindings"
+  182, "exactly one of node:, subgrove: and class: needed"
+  183, "add:, null:, remove:, children:, sub: make no sense with subgrove:"
+  184, "remove: makes no sense with class:"
+  185, "%2 argument for primitive %1 of wrong type: %3 not a subgrove-spec"
+  186, "wrong type: %1 not a list of create-specs"
+  187, "wrong type: %1 not a create-spec or list of create-specs"
+  188, "query expression: %1 not a node list"
+  189, "priority expression: %1 not an exact integer"
+  190, "flow objects at the root must be all of class scroll or all of class page-sequence or simple-page-sequence"
+  191, "current flow parent has no principal port"
+  192, "this flow object requires a paragraph as an ancestor flow object"
+  193, "flow object not accepted by port; only inline flow objects accepted"
+  194, "flow object not accepted by port; only display flow objects accepted"
+  195, "flow object not accepted by port; only display or inline flow objects accepted"
+  196, "flow object not accepted in a paragraph; only inline, display or paragraph-break flow objects accepted"
+  197, "a side-by-side flow object only accepts side-by-side-item flow objects as children"
+  198, "flow object not accepted by port; only math-sequence, unmath, subscript, superscript, script, mark, fence, fraction, radical, math-operator, grid, character and alignment-point flow objects accepted"
+  199, "flow object not accepted by port; must be grid-cell"
+  200, "flow object not accepted by port; only a single character flow object accepted"
+  201, "flow object not accepted by port; in a table, only either table-part flow objects or table-column flow objects followed by table-row or table-cell flow objects are allowed"
+  202, "flow object not accepted by port; only table-row or table-cell flow objects accepted"
+  203, "flow object not accepted by port; only table-column flow objects followed by table-row or table-cell flow objects allowd"
+  204, "flow object not accepted by port; only table-cell flow objects accepted"
+  205, "priority-expression must be a number"
+  206, "query-expression must be a node-list"
+  207, "Sorry, non-integral priorities not implemented"
 END
--- openjade-1.4devel1.orig/style/Makefile.am
+++ openjade-1.4devel1/style/Makefile.am
@@ -2,7 +2,7 @@
 
 lib_LTLIBRARIES = libostyle.la
 
-libostyle_la_LDFLAGS = -version-info 0:0:0
+libostyle_la_LDFLAGS = -version-info 1:0:0
 
 libostyle_la_SOURCES = Collector.cxx Collector.h DssslApp.cxx \
 	DssslApp.h DssslAppMessages.h DssslSpecEventHandler.cxx \
@@ -19,13 +19,13 @@
 	charProps.h dsssl_ns.h primitive.cxx primitive.h \
 	sdata.h style_inst.cxx style_pch.h stylelib.cxx \
 	stylelib.h TransformationMode.h TransformationMode.cxx \
-	DocumentGenerator.h DocumentGenerator.cxx
+	DocumentGenerator.h DocumentGenerator.cxx MessageModule.cxx
 
 # We install the headers needed to create a new application based on
 # the DssslApp class.
 pkginclude_HEADERS = FOTBuilder.h dsssl_ns.h DssslApp.h GroveManager.h
 
-INCLUDES = -I$(top_srcdir)/grove -I$(top_srcdir)/spgrove
+AM_CPPFLAGS = -I$(top_srcdir)/grove -I$(top_srcdir)/spgrove
 
 EXTRA_DIST = FlowObj_inst.cxx primitive_inst.cxx \
 	style_inst.m4 FlowObj_inst.m4 primitive_inst.m4 \
@@ -37,7 +37,9 @@
 	InterpreterMessages.h InterpreterMessages.cxx \
 	InterpreterMessages.rc DssslAppMessages.h DssslAppMessages.rc 
 
-MSGGENFLAGS = -l xModule 
+MAINTAINERCLEANFILES = Makefile.in
+
+MSGGENFLAGS = -l jstyleModule 
 
 SUFFIXES = .m4 .msg .rc
 
@@ -45,5 +47,5 @@
 	$(PERL) $(top_srcdir)/instmac.pl $< >$@
 
 %.h %.cxx %.rc: %.msg
-	$(PERL) -w $(top_builddir)/msggen.pl $(MSGGENFLAGS) $<
+	[ ! -f $(top_srcdir)/msggen.pl ] || $(PERL) -w $(top_srcdir)/msggen.pl $(MSGGENFLAGS) $<
 
--- openjade-1.4devel1.orig/style/MessageModule.cxx
+++ openjade-1.4devel1/style/MessageModule.cxx
@@ -0,0 +1,24 @@
+// Copyright (c) 2002 Ian Castle
+// See the file COPYING for copying permission.
+
+#ifdef __GNUG__
+#pragma implementation
+#endif
+
+// #include "splib.h"
+// #include "MessageTable.h"
+
+#include "stylelib.h"
+
+#include <OpenSP/MessageModule.h>
+
+#ifdef SP_NAMESPACE
+namespace SP_NAMESPACE {
+#endif
+
+MessageModule jstyleModule;
+
+#ifdef SP_NAMESPACE
+}
+#endif
+
--- openjade-1.4devel1.orig/style/ProcessContext.cxx
+++ openjade-1.4devel1/style/ProcessContext.cxx
@@ -762,6 +762,11 @@
   return 0;
 }
 
+AppendSosofoObj *AppendSosofoObj::asAppendSosofo()
+{
+  return this;
+}
+
 void AppendSosofoObj::process(ProcessContext &context)
 {
   for (size_t i = 0; i < v_.size(); i++)
--- openjade-1.4devel1.orig/style/SosofoObj.h
+++ openjade-1.4devel1/style/SosofoObj.h
@@ -77,6 +77,7 @@
     return c.allocateObject(1);
   }
   AppendSosofoObj() { hasSubObjects_ = 1; }
+  AppendSosofoObj *asAppendSosofo();
   void process(ProcessContext &);
   void append(SosofoObj *);
   void traceSubObjects(Collector &) const;
--- openjade-1.4devel1.orig/style/common_inst.m4
+++ openjade-1.4devel1/style/common_inst.m4
@@ -0,0 +1,86 @@
+// Copyright (c) 1996 James Clark
+// See the file copying.txt for copying permission.
+
+// Copyright (c) 1996 James Clark
+// See the file COPYING for copying permission.
+
+#include "stylelib.h"
+
+#ifdef SP_MANUAL_INST
+
+#define SP_DEFINE_TEMPLATES
+#include <OpenSP/StringOf.h>
+#include <OpenSP/Vector.h>
+#include <OpenSP/XcharMap.h>
+#include <OpenSP/CharMap.h>
+#include <OpenSP/Ptr.h>
+#include <OpenSP/PointerTable.h>
+#include <OpenSP/OwnerTable.h>
+#include <OpenSP/HashTable.h>
+#include <OpenSP/HashTableItemBase.h>
+#include <OpenSP/SubstTable.h>
+#include <OpenSP/ISet.h>
+#include <OpenSP/Owner.h>
+#undef SP_DEFINE_TEMPLATES
+
+#include <OpenSP/types.h>
+#include <OpenSP/Entity.h>
+#include <OpenSP/Syntax.h>
+#include <OpenSP/ExtendEntityManager.h>
+#include <OpenSP/Event.h>
+#include <OpenSP/CmdLineApp.h>
+
+#ifdef SP_NAMESPACE
+namespace SP_NAMESPACE {
+#endif
+
+__instantiate(Vector<const CmdLineApp::AppChar *>)
+__instantiate(Ptr<CodingSystemKit>)
+__instantiate(Ptr<Sd>)
+__instantiate(Ptr<InputSourceOrigin>)
+__instantiate(Vector<ParsedSystemId::Map>)
+__instantiate(Vector<size_t>)
+__instantiate(String<Char>)
+__instantiate(Vector<String<Char> >)
+__instantiate(Ptr<StringResource<Char> >)
+__instantiate(String<char>)
+__instantiate(`OwnerTable<Named,StringC,Hash,NamedTableKeyFunction>')
+__instantiate(`OwnerTableIter<Named,StringC,Hash,NamedTableKeyFunction>')
+__instantiate(XcharMap<PackedBoolean>)
+__instantiate(SharedXcharMap<PackedBoolean>)
+__instantiate(Ptr<SharedXcharMap<PackedBoolean> >)
+__instantiate(ConstPtr<SharedXcharMap<PackedBoolean> >)
+__instantiate(`PointerTableIter<Named*,StringC,Hash,NamedTableKeyFunction>')
+__instantiate(`PointerTable<Named*,StringC,Hash,NamedTableKeyFunction>')
+__instantiate(HashTableItemBase<String<Char> >)
+__instantiate(`OwnerTable<HashTableItemBase<String<Char> >,String<Char>,Hash,HashTableKeyFunction<String<Char> > >')
+__instantiate(`CopyOwnerTable<HashTableItemBase<String<Char> >,String<Char>,Hash,HashTableKeyFunction<String<Char> > >')
+__instantiate(`OwnerTableIter<HashTableItemBase<String<Char> >, String<Char>, Hash, HashTableKeyFunction<String<Char> > >')
+__instantiate(`PointerTable<HashTableItemBase<String<Char> >*,String<Char>,Hash,HashTableKeyFunction<String<Char> > >')
+__instantiate(`PointerTableIter<HashTableItemBase<String<Char> > *, String<Char>, Hash, HashTableKeyFunction<String<Char> > >')
+__instantiate(Vector<HashTableItemBase<String<Char> >*>)
+__instantiate(Ptr<Origin>)
+__instantiate(`HashTable<StringC,Char>')
+__instantiate(ConstPtr<Entity>)
+__instantiate(Ptr<Entity>)
+__instantiate(SubstTable<Char>)
+__instantiate(Ptr<Syntax>)
+__instantiate(ConstPtr<Syntax>)
+__instantiate(ISet<Char>)
+__instantiate(Vector<TextItem>)
+__instantiate(`HashTableItem<StringC, int>')
+__instantiate(`HashTable<StringC,int>')
+__instantiate(Vector<PackedBoolean>)
+__instantiate(Owner<EventHandler>)
+__instantiate(Ptr<EntityManager>)
+__instantiate(Ptr<ExtendEntityManager>)
+__instantiate(Vector<StorageObjectSpec>)
+__instantiate(Ptr<EntityCatalog>)
+__instantiate(ConstPtr<EntityCatalog>)
+__instantiate(CharMap<Char>)
+__instantiate(CharMapPage<Char>)
+#ifdef SP_NAMESPACE
+}
+#endif
+
+#endif /* SP_MANUAL_INST */
--- openjade-1.4devel1.orig/style/primitive.cxx
+++ openjade-1.4devel1/style/primitive.cxx
@@ -1697,8 +1697,34 @@
 
 DEFPRIMITIVE(SosofoAppend, argc, argv, context, interp, loc)
 {
-  AppendSosofoObj *obj = new (interp) AppendSosofoObj;
-  for (int i = 0; i < argc; i++) {
+  /* Optimize the case where there is no or only
+     one argument */
+  if (argc == 0)
+    return new (interp) EmptySosofoObj;
+  else if (argc == 1) {
+    SosofoObj *sosofo = argv[0]->asSosofo();
+    if (!sosofo)
+      return argError(interp, loc, InterpreterMessages::notASosofo,
+		      0, argv[0]);
+    return sosofo;	
+  }
+
+  /* Don't create another object if the first argument is
+     already an AppendSosofoObj, this handles gracefully 
+     case like 
+     (let loop ( (res (empty-sosofo))
+		 (nl  (node-list-rest (children (current-node)))))
+	(loop (sosofo-append res (process-node-list (node-list-first nl)))
+	      (node-list-rest nl)))
+   */
+  AppendSosofoObj *obj;
+  int i = 0; 
+  if ( argv[i]->asAppendSosofo() )
+    obj = argv[i++]->asAppendSosofo();
+  else 
+    obj = new (interp) AppendSosofoObj;
+
+  for ( ; i < argc; i++) {
     SosofoObj *sosofo = argv[i]->asSosofo();
     if (!sosofo)
       return argError(interp, loc, InterpreterMessages::notASosofo,
@@ -5292,23 +5318,69 @@
   return obj;
 }
           
-static long timeConv(const Char *s, size_t n)
+static time_t timeConv(const Char *s, size_t n)
 {
   char buf[100];
-  for (unsigned i = 0; i < n; i++) 
+  unsigned i;
+  
+  for ( i = 0; i < n && i < (sizeof(buf) - 1); i++) 
     buf[i] = char(s[i]);
-  buf[n] = 0;
-  struct tm tim;
-  sscanf(buf, "%d-%d-%dT%d:%d:%d", 
-            &tim.tm_year,
-            &tim.tm_mon,
-            &tim.tm_mday,
-	    &tim.tm_hour,
-	    &tim.tm_min,
-	    &tim.tm_sec);
-  tim.tm_year -= 1900;
-  tim.tm_mon -= 1;
-  return long(mktime(&tim)); 
+  buf[i] = 0;
+  time_t    today_sec = time(NULL);
+  struct tm tim, *today;
+  int       nparsed;
+
+  today = localtime(&today_sec);
+  
+  /* First try to parse as time string without date */
+  /* Defaults are same as of today */
+  memcpy(&tim, today, sizeof(tim));
+  nparsed = sscanf(buf, "%d:%d:%d", 
+		   &tim.tm_hour,
+		   &tim.tm_min,
+		   &tim.tm_sec);
+
+  /* If we got only one number, it could be
+     a year so try to parse complete format */
+  if ( nparsed < 2 ) {
+    /* Defaults are set to zero */
+    memset( &tim, 0, sizeof(tim) );
+
+    /* This accepts any non digit character between 
+       the date and time spec 
+    */
+    nparsed = sscanf(buf, "%d-%d-%d%*[^0-9]%d:%d:%d", 
+		     &tim.tm_year,
+		     &tim.tm_mon,
+		     &tim.tm_mday,
+		     &tim.tm_hour,
+		     &tim.tm_min,
+		     &tim.tm_sec);
+    switch (nparsed) {
+    case 0:
+	/* Invalid parse */
+	return (time_t)-1;
+	/* Not reached */
+    case 1:
+	/* We only got a year set to January First 
+	   Month is already set to 0
+	*/
+	/* Fall through */
+    case 2:
+	tim.tm_mday = 1;
+	/* Fall through to month normalization */
+    default:
+	tim.tm_mon -= 1;
+	break;
+    }
+
+    if (tim.tm_year < 38 )
+      tim.tm_year += 100; /* Y2K workaround */
+    else if (tim.tm_year >= 1900)
+      tim.tm_year -= 1900;
+  }
+  
+  return mktime(&tim); 
 }
 
 #define DEFTIMECOMP(NAME, OP) \
@@ -5316,12 +5388,19 @@
 { \
   const Char *s1, *s2; \
   size_t n1, n2; \
+  time_t t1, t2; \
   if (!argv[0]->stringData(s1, n1)) \
     return argError(interp, loc, \
                     InterpreterMessages::notAString, 0, argv[0]); \
   if (!argv[1]->stringData(s2, n2)) \
     return argError(interp, loc, \
                     InterpreterMessages::notAString, 1, argv[1]); \
+  if ( (t1 = timeConv(s1, n1)) == (time_t)-1 ) \
+    return argError(interp, loc, \
+                    InterpreterMessages::notATimeString, 0, argv[0]); \
+  if ( (t2 = timeConv(s2, n2)) == (time_t)-1 ) \
+    return argError(interp, loc, \
+                    InterpreterMessages::notATimeString, 1, argv[1]); \
   if (timeConv(s1, n1) OP timeConv(s2, n2)) \
     return interp.makeTrue(); \
   else \
--- openjade-1.4devel1.orig/testsuite/Makefile
+++ openjade-1.4devel1/testsuite/Makefile
@@ -0,0 +1,26 @@
+# OpenJade testsuite makefile
+# Copyright (C) 1999 Avi Kivity
+
+JADE=../jade/openjade
+JADEX=$(JADE) -c ../dsssl/catalog
+
+all: expr-lang.expected contains.expected specificity.expected query-root.expected
+	@echo All tests passed.
+
+%.expected: %.actual
+	diff $< $@
+
+expr-lang.actual: $(JADE)
+	$(JADEX) -t sgml -d expr-lang.dsl null.sgml > $@
+    
+contains.actual: $(JADE)
+	$(JADEX) -t fot -d contains.dsl -o $@ contains.sgml 
+
+specificity.actual: $(JADE)
+	$(JADEX) -t fot -d specificity.dsl -o $@ specificity.sgml 
+
+query-root.actual: $(JADE)
+	$(JADEX) -t fot -d query-root.dsl -o $@ query-root.sgml 
+
+clean:
+	rm *.actual
--- openjade-1.4devel1.orig/testsuite/contains.actual
+++ openjade-1.4devel1/testsuite/contains.actual
@@ -0,0 +1,680 @@
+<?xml version="1.0"?>
+<fot>
+<simple-page-sequence>
+<paragraph>
+<text>node A is in subtree with start A</text>
+</paragraph>
+<paragraph>
+<text>node B is in subtree with start A</text>
+</paragraph>
+<paragraph>
+<text>node C is in subtree with start A</text>
+</paragraph>
+<paragraph>
+<text>node D is in subtree with start A</text>
+</paragraph>
+<paragraph>
+<text>node E is in subtree with start A</text>
+</paragraph>
+<paragraph>
+<text>node F is in subtree with start A</text>
+</paragraph>
+<paragraph>
+<text>node G is in subtree with start A</text>
+</paragraph>
+<paragraph>
+<text>node H is in subtree with start A</text>
+</paragraph>
+<paragraph>
+<text>node I is in subtree with start A</text>
+</paragraph>
+<paragraph>
+<text>node J is in subtree with start A</text>
+</paragraph>
+<paragraph>
+<text>node K is in subtree with start A</text>
+</paragraph>
+<paragraph>
+<text>node L is in subtree with start A</text>
+</paragraph>
+<paragraph>
+<text>node M is in subtree with start A</text>
+</paragraph>
+<paragraph>
+<text>node N is in subtree with start A</text>
+</paragraph>
+<paragraph>
+<text>node O is in subtree with start A</text>
+</paragraph>
+<paragraph>
+<text>node A is not in subtree with start B</text>
+</paragraph>
+<paragraph>
+<text>node B is in subtree with start B</text>
+</paragraph>
+<paragraph>
+<text>node C is in subtree with start B</text>
+</paragraph>
+<paragraph>
+<text>node D is in subtree with start B</text>
+</paragraph>
+<paragraph>
+<text>node E is in subtree with start B</text>
+</paragraph>
+<paragraph>
+<text>node F is in subtree with start B</text>
+</paragraph>
+<paragraph>
+<text>node G is in subtree with start B</text>
+</paragraph>
+<paragraph>
+<text>node H is in subtree with start B</text>
+</paragraph>
+<paragraph>
+<text>node I is in subtree with start B</text>
+</paragraph>
+<paragraph>
+<text>node J is in subtree with start B</text>
+</paragraph>
+<paragraph>
+<text>node K is in subtree with start B</text>
+</paragraph>
+<paragraph>
+<text>node L is in subtree with start B</text>
+</paragraph>
+<paragraph>
+<text>node M is in subtree with start B</text>
+</paragraph>
+<paragraph>
+<text>node N is in subtree with start B</text>
+</paragraph>
+<paragraph>
+<text>node O is in subtree with start B</text>
+</paragraph>
+<paragraph>
+<text>node A is not in subtree with start C</text>
+</paragraph>
+<paragraph>
+<text>node B is not in subtree with start C</text>
+</paragraph>
+<paragraph>
+<text>node C is in subtree with start C</text>
+</paragraph>
+<paragraph>
+<text>node D is in subtree with start C</text>
+</paragraph>
+<paragraph>
+<text>node E is in subtree with start C</text>
+</paragraph>
+<paragraph>
+<text>node F is in subtree with start C</text>
+</paragraph>
+<paragraph>
+<text>node G is in subtree with start C</text>
+</paragraph>
+<paragraph>
+<text>node H is in subtree with start C</text>
+</paragraph>
+<paragraph>
+<text>node I is in subtree with start C</text>
+</paragraph>
+<paragraph>
+<text>node J is in subtree with start C</text>
+</paragraph>
+<paragraph>
+<text>node K is in subtree with start C</text>
+</paragraph>
+<paragraph>
+<text>node L is in subtree with start C</text>
+</paragraph>
+<paragraph>
+<text>node M is in subtree with start C</text>
+</paragraph>
+<paragraph>
+<text>node N is in subtree with start C</text>
+</paragraph>
+<paragraph>
+<text>node O is in subtree with start C</text>
+</paragraph>
+<paragraph>
+<text>node A is not in subtree with start D</text>
+</paragraph>
+<paragraph>
+<text>node B is not in subtree with start D</text>
+</paragraph>
+<paragraph>
+<text>node C is not in subtree with start D</text>
+</paragraph>
+<paragraph>
+<text>node D is in subtree with start D</text>
+</paragraph>
+<paragraph>
+<text>node E is in subtree with start D</text>
+</paragraph>
+<paragraph>
+<text>node F is in subtree with start D</text>
+</paragraph>
+<paragraph>
+<text>node G is in subtree with start D</text>
+</paragraph>
+<paragraph>
+<text>node H is in subtree with start D</text>
+</paragraph>
+<paragraph>
+<text>node I is in subtree with start D</text>
+</paragraph>
+<paragraph>
+<text>node J is in subtree with start D</text>
+</paragraph>
+<paragraph>
+<text>node K is in subtree with start D</text>
+</paragraph>
+<paragraph>
+<text>node L is in subtree with start D</text>
+</paragraph>
+<paragraph>
+<text>node M is in subtree with start D</text>
+</paragraph>
+<paragraph>
+<text>node N is in subtree with start D</text>
+</paragraph>
+<paragraph>
+<text>node O is in subtree with start D</text>
+</paragraph>
+<paragraph>
+<text>node A is not in subtree with start E</text>
+</paragraph>
+<paragraph>
+<text>node B is not in subtree with start E</text>
+</paragraph>
+<paragraph>
+<text>node C is not in subtree with start E</text>
+</paragraph>
+<paragraph>
+<text>node D is not in subtree with start E</text>
+</paragraph>
+<paragraph>
+<text>node E is in subtree with start E</text>
+</paragraph>
+<paragraph>
+<text>node F is in subtree with start E</text>
+</paragraph>
+<paragraph>
+<text>node G is in subtree with start E</text>
+</paragraph>
+<paragraph>
+<text>node H is in subtree with start E</text>
+</paragraph>
+<paragraph>
+<text>node I is in subtree with start E</text>
+</paragraph>
+<paragraph>
+<text>node J is in subtree with start E</text>
+</paragraph>
+<paragraph>
+<text>node K is in subtree with start E</text>
+</paragraph>
+<paragraph>
+<text>node L is in subtree with start E</text>
+</paragraph>
+<paragraph>
+<text>node M is in subtree with start E</text>
+</paragraph>
+<paragraph>
+<text>node N is in subtree with start E</text>
+</paragraph>
+<paragraph>
+<text>node O is in subtree with start E</text>
+</paragraph>
+<paragraph>
+<text>node A is not in subtree with start F</text>
+</paragraph>
+<paragraph>
+<text>node B is not in subtree with start F</text>
+</paragraph>
+<paragraph>
+<text>node C is not in subtree with start F</text>
+</paragraph>
+<paragraph>
+<text>node D is not in subtree with start F</text>
+</paragraph>
+<paragraph>
+<text>node E is not in subtree with start F</text>
+</paragraph>
+<paragraph>
+<text>node F is in subtree with start F</text>
+</paragraph>
+<paragraph>
+<text>node G is in subtree with start F</text>
+</paragraph>
+<paragraph>
+<text>node H is in subtree with start F</text>
+</paragraph>
+<paragraph>
+<text>node I is in subtree with start F</text>
+</paragraph>
+<paragraph>
+<text>node J is in subtree with start F</text>
+</paragraph>
+<paragraph>
+<text>node K is in subtree with start F</text>
+</paragraph>
+<paragraph>
+<text>node L is in subtree with start F</text>
+</paragraph>
+<paragraph>
+<text>node M is in subtree with start F</text>
+</paragraph>
+<paragraph>
+<text>node N is in subtree with start F</text>
+</paragraph>
+<paragraph>
+<text>node O is in subtree with start F</text>
+</paragraph>
+<paragraph>
+<text>node A is not in subtree with start G</text>
+</paragraph>
+<paragraph>
+<text>node B is not in subtree with start G</text>
+</paragraph>
+<paragraph>
+<text>node C is not in subtree with start G</text>
+</paragraph>
+<paragraph>
+<text>node D is not in subtree with start G</text>
+</paragraph>
+<paragraph>
+<text>node E is not in subtree with start G</text>
+</paragraph>
+<paragraph>
+<text>node F is not in subtree with start G</text>
+</paragraph>
+<paragraph>
+<text>node G is in subtree with start G</text>
+</paragraph>
+<paragraph>
+<text>node H is in subtree with start G</text>
+</paragraph>
+<paragraph>
+<text>node I is in subtree with start G</text>
+</paragraph>
+<paragraph>
+<text>node J is in subtree with start G</text>
+</paragraph>
+<paragraph>
+<text>node K is in subtree with start G</text>
+</paragraph>
+<paragraph>
+<text>node L is in subtree with start G</text>
+</paragraph>
+<paragraph>
+<text>node M is in subtree with start G</text>
+</paragraph>
+<paragraph>
+<text>node N is in subtree with start G</text>
+</paragraph>
+<paragraph>
+<text>node O is in subtree with start G</text>
+</paragraph>
+<paragraph>
+<text>node A is not in subtree with start H</text>
+</paragraph>
+<paragraph>
+<text>node B is not in subtree with start H</text>
+</paragraph>
+<paragraph>
+<text>node C is not in subtree with start H</text>
+</paragraph>
+<paragraph>
+<text>node D is not in subtree with start H</text>
+</paragraph>
+<paragraph>
+<text>node E is not in subtree with start H</text>
+</paragraph>
+<paragraph>
+<text>node F is not in subtree with start H</text>
+</paragraph>
+<paragraph>
+<text>node G is not in subtree with start H</text>
+</paragraph>
+<paragraph>
+<text>node H is in subtree with start H</text>
+</paragraph>
+<paragraph>
+<text>node I is in subtree with start H</text>
+</paragraph>
+<paragraph>
+<text>node J is in subtree with start H</text>
+</paragraph>
+<paragraph>
+<text>node K is in subtree with start H</text>
+</paragraph>
+<paragraph>
+<text>node L is in subtree with start H</text>
+</paragraph>
+<paragraph>
+<text>node M is in subtree with start H</text>
+</paragraph>
+<paragraph>
+<text>node N is in subtree with start H</text>
+</paragraph>
+<paragraph>
+<text>node O is in subtree with start H</text>
+</paragraph>
+<paragraph>
+<text>node A is not in subtree with start I</text>
+</paragraph>
+<paragraph>
+<text>node B is not in subtree with start I</text>
+</paragraph>
+<paragraph>
+<text>node C is not in subtree with start I</text>
+</paragraph>
+<paragraph>
+<text>node D is not in subtree with start I</text>
+</paragraph>
+<paragraph>
+<text>node E is not in subtree with start I</text>
+</paragraph>
+<paragraph>
+<text>node F is not in subtree with start I</text>
+</paragraph>
+<paragraph>
+<text>node G is not in subtree with start I</text>
+</paragraph>
+<paragraph>
+<text>node H is not in subtree with start I</text>
+</paragraph>
+<paragraph>
+<text>node I is in subtree with start I</text>
+</paragraph>
+<paragraph>
+<text>node J is in subtree with start I</text>
+</paragraph>
+<paragraph>
+<text>node K is in subtree with start I</text>
+</paragraph>
+<paragraph>
+<text>node L is in subtree with start I</text>
+</paragraph>
+<paragraph>
+<text>node M is in subtree with start I</text>
+</paragraph>
+<paragraph>
+<text>node N is in subtree with start I</text>
+</paragraph>
+<paragraph>
+<text>node O is in subtree with start I</text>
+</paragraph>
+<paragraph>
+<text>node A is not in subtree with start J</text>
+</paragraph>
+<paragraph>
+<text>node B is not in subtree with start J</text>
+</paragraph>
+<paragraph>
+<text>node C is not in subtree with start J</text>
+</paragraph>
+<paragraph>
+<text>node D is not in subtree with start J</text>
+</paragraph>
+<paragraph>
+<text>node E is not in subtree with start J</text>
+</paragraph>
+<paragraph>
+<text>node F is not in subtree with start J</text>
+</paragraph>
+<paragraph>
+<text>node G is not in subtree with start J</text>
+</paragraph>
+<paragraph>
+<text>node H is not in subtree with start J</text>
+</paragraph>
+<paragraph>
+<text>node I is not in subtree with start J</text>
+</paragraph>
+<paragraph>
+<text>node J is in subtree with start J</text>
+</paragraph>
+<paragraph>
+<text>node K is in subtree with start J</text>
+</paragraph>
+<paragraph>
+<text>node L is in subtree with start J</text>
+</paragraph>
+<paragraph>
+<text>node M is in subtree with start J</text>
+</paragraph>
+<paragraph>
+<text>node N is in subtree with start J</text>
+</paragraph>
+<paragraph>
+<text>node O is in subtree with start J</text>
+</paragraph>
+<paragraph>
+<text>node A is not in subtree with start K</text>
+</paragraph>
+<paragraph>
+<text>node B is not in subtree with start K</text>
+</paragraph>
+<paragraph>
+<text>node C is not in subtree with start K</text>
+</paragraph>
+<paragraph>
+<text>node D is not in subtree with start K</text>
+</paragraph>
+<paragraph>
+<text>node E is not in subtree with start K</text>
+</paragraph>
+<paragraph>
+<text>node F is not in subtree with start K</text>
+</paragraph>
+<paragraph>
+<text>node G is not in subtree with start K</text>
+</paragraph>
+<paragraph>
+<text>node H is not in subtree with start K</text>
+</paragraph>
+<paragraph>
+<text>node I is not in subtree with start K</text>
+</paragraph>
+<paragraph>
+<text>node J is not in subtree with start K</text>
+</paragraph>
+<paragraph>
+<text>node K is in subtree with start K</text>
+</paragraph>
+<paragraph>
+<text>node L is in subtree with start K</text>
+</paragraph>
+<paragraph>
+<text>node M is in subtree with start K</text>
+</paragraph>
+<paragraph>
+<text>node N is in subtree with start K</text>
+</paragraph>
+<paragraph>
+<text>node O is in subtree with start K</text>
+</paragraph>
+<paragraph>
+<text>node A is not in subtree with start L</text>
+</paragraph>
+<paragraph>
+<text>node B is not in subtree with start L</text>
+</paragraph>
+<paragraph>
+<text>node C is not in subtree with start L</text>
+</paragraph>
+<paragraph>
+<text>node D is not in subtree with start L</text>
+</paragraph>
+<paragraph>
+<text>node E is not in subtree with start L</text>
+</paragraph>
+<paragraph>
+<text>node F is not in subtree with start L</text>
+</paragraph>
+<paragraph>
+<text>node G is not in subtree with start L</text>
+</paragraph>
+<paragraph>
+<text>node H is not in subtree with start L</text>
+</paragraph>
+<paragraph>
+<text>node I is not in subtree with start L</text>
+</paragraph>
+<paragraph>
+<text>node J is not in subtree with start L</text>
+</paragraph>
+<paragraph>
+<text>node K is not in subtree with start L</text>
+</paragraph>
+<paragraph>
+<text>node L is in subtree with start L</text>
+</paragraph>
+<paragraph>
+<text>node M is in subtree with start L</text>
+</paragraph>
+<paragraph>
+<text>node N is in subtree with start L</text>
+</paragraph>
+<paragraph>
+<text>node O is in subtree with start L</text>
+</paragraph>
+<paragraph>
+<text>node A is not in subtree with start M</text>
+</paragraph>
+<paragraph>
+<text>node B is not in subtree with start M</text>
+</paragraph>
+<paragraph>
+<text>node C is not in subtree with start M</text>
+</paragraph>
+<paragraph>
+<text>node D is not in subtree with start M</text>
+</paragraph>
+<paragraph>
+<text>node E is not in subtree with start M</text>
+</paragraph>
+<paragraph>
+<text>node F is not in subtree with start M</text>
+</paragraph>
+<paragraph>
+<text>node G is not in subtree with start M</text>
+</paragraph>
+<paragraph>
+<text>node H is not in subtree with start M</text>
+</paragraph>
+<paragraph>
+<text>node I is not in subtree with start M</text>
+</paragraph>
+<paragraph>
+<text>node J is not in subtree with start M</text>
+</paragraph>
+<paragraph>
+<text>node K is not in subtree with start M</text>
+</paragraph>
+<paragraph>
+<text>node L is not in subtree with start M</text>
+</paragraph>
+<paragraph>
+<text>node M is in subtree with start M</text>
+</paragraph>
+<paragraph>
+<text>node N is in subtree with start M</text>
+</paragraph>
+<paragraph>
+<text>node O is in subtree with start M</text>
+</paragraph>
+<paragraph>
+<text>node A is not in subtree with start N</text>
+</paragraph>
+<paragraph>
+<text>node B is not in subtree with start N</text>
+</paragraph>
+<paragraph>
+<text>node C is not in subtree with start N</text>
+</paragraph>
+<paragraph>
+<text>node D is not in subtree with start N</text>
+</paragraph>
+<paragraph>
+<text>node E is not in subtree with start N</text>
+</paragraph>
+<paragraph>
+<text>node F is not in subtree with start N</text>
+</paragraph>
+<paragraph>
+<text>node G is not in subtree with start N</text>
+</paragraph>
+<paragraph>
+<text>node H is not in subtree with start N</text>
+</paragraph>
+<paragraph>
+<text>node I is not in subtree with start N</text>
+</paragraph>
+<paragraph>
+<text>node J is not in subtree with start N</text>
+</paragraph>
+<paragraph>
+<text>node K is not in subtree with start N</text>
+</paragraph>
+<paragraph>
+<text>node L is not in subtree with start N</text>
+</paragraph>
+<paragraph>
+<text>node M is not in subtree with start N</text>
+</paragraph>
+<paragraph>
+<text>node N is in subtree with start N</text>
+</paragraph>
+<paragraph>
+<text>node O is in subtree with start N</text>
+</paragraph>
+<paragraph>
+<text>node A is not in subtree with start O</text>
+</paragraph>
+<paragraph>
+<text>node B is not in subtree with start O</text>
+</paragraph>
+<paragraph>
+<text>node C is not in subtree with start O</text>
+</paragraph>
+<paragraph>
+<text>node D is not in subtree with start O</text>
+</paragraph>
+<paragraph>
+<text>node E is not in subtree with start O</text>
+</paragraph>
+<paragraph>
+<text>node F is not in subtree with start O</text>
+</paragraph>
+<paragraph>
+<text>node G is not in subtree with start O</text>
+</paragraph>
+<paragraph>
+<text>node H is not in subtree with start O</text>
+</paragraph>
+<paragraph>
+<text>node I is not in subtree with start O</text>
+</paragraph>
+<paragraph>
+<text>node J is not in subtree with start O</text>
+</paragraph>
+<paragraph>
+<text>node K is not in subtree with start O</text>
+</paragraph>
+<paragraph>
+<text>node L is not in subtree with start O</text>
+</paragraph>
+<paragraph>
+<text>node M is not in subtree with start O</text>
+</paragraph>
+<paragraph>
+<text>node N is not in subtree with start O</text>
+</paragraph>
+<paragraph>
+<text>node O is in subtree with start O</text>
+</paragraph>
+</simple-page-sequence>
+</fot>
--- openjade-1.4devel1.orig/testsuite/contains.dsl
+++ openjade-1.4devel1/testsuite/contains.dsl
@@ -0,0 +1,20 @@
+<!DOCTYPE style-sheet PUBLIC "-//James Clark//DTD DSSSL Style Sheet//EN">
+
+(define (check-node nl nd)
+  (make paragraph
+    (literal "node " (gi nd)
+	     (if (node-list-contains? nl nd) " is " " is not ")
+	     "in subtree with start " (gi (node-list-first nl)))))
+(root 
+    (make simple-page-sequence
+      (let ((nl (subtree (node-property 'docelem (current-root)))))
+	(let loop ((nl1 nl) (ret (empty-sosofo)))
+	  (if (node-list-empty? nl1)
+	      ret
+	      (let loop2 ((nl2 nl) (ret2 ret))
+		(if (node-list-empty? nl2)
+		    (loop (node-list-rest nl1) ret2)
+		    (loop2 (node-list-rest nl2) 
+			   (sosofo-append 
+			    ret2 
+			    (check-node nl1 (node-list-first nl2)))))))))))
--- openjade-1.4devel1.orig/testsuite/contains.expected
+++ openjade-1.4devel1/testsuite/contains.expected
@@ -0,0 +1,680 @@
+<?xml version="1.0"?>
+<fot>
+<simple-page-sequence>
+<paragraph>
+<text>node A is in subtree with start A</text>
+</paragraph>
+<paragraph>
+<text>node B is in subtree with start A</text>
+</paragraph>
+<paragraph>
+<text>node C is in subtree with start A</text>
+</paragraph>
+<paragraph>
+<text>node D is in subtree with start A</text>
+</paragraph>
+<paragraph>
+<text>node E is in subtree with start A</text>
+</paragraph>
+<paragraph>
+<text>node F is in subtree with start A</text>
+</paragraph>
+<paragraph>
+<text>node G is in subtree with start A</text>
+</paragraph>
+<paragraph>
+<text>node H is in subtree with start A</text>
+</paragraph>
+<paragraph>
+<text>node I is in subtree with start A</text>
+</paragraph>
+<paragraph>
+<text>node J is in subtree with start A</text>
+</paragraph>
+<paragraph>
+<text>node K is in subtree with start A</text>
+</paragraph>
+<paragraph>
+<text>node L is in subtree with start A</text>
+</paragraph>
+<paragraph>
+<text>node M is in subtree with start A</text>
+</paragraph>
+<paragraph>
+<text>node N is in subtree with start A</text>
+</paragraph>
+<paragraph>
+<text>node O is in subtree with start A</text>
+</paragraph>
+<paragraph>
+<text>node A is not in subtree with start B</text>
+</paragraph>
+<paragraph>
+<text>node B is in subtree with start B</text>
+</paragraph>
+<paragraph>
+<text>node C is in subtree with start B</text>
+</paragraph>
+<paragraph>
+<text>node D is in subtree with start B</text>
+</paragraph>
+<paragraph>
+<text>node E is in subtree with start B</text>
+</paragraph>
+<paragraph>
+<text>node F is in subtree with start B</text>
+</paragraph>
+<paragraph>
+<text>node G is in subtree with start B</text>
+</paragraph>
+<paragraph>
+<text>node H is in subtree with start B</text>
+</paragraph>
+<paragraph>
+<text>node I is in subtree with start B</text>
+</paragraph>
+<paragraph>
+<text>node J is in subtree with start B</text>
+</paragraph>
+<paragraph>
+<text>node K is in subtree with start B</text>
+</paragraph>
+<paragraph>
+<text>node L is in subtree with start B</text>
+</paragraph>
+<paragraph>
+<text>node M is in subtree with start B</text>
+</paragraph>
+<paragraph>
+<text>node N is in subtree with start B</text>
+</paragraph>
+<paragraph>
+<text>node O is in subtree with start B</text>
+</paragraph>
+<paragraph>
+<text>node A is not in subtree with start C</text>
+</paragraph>
+<paragraph>
+<text>node B is not in subtree with start C</text>
+</paragraph>
+<paragraph>
+<text>node C is in subtree with start C</text>
+</paragraph>
+<paragraph>
+<text>node D is in subtree with start C</text>
+</paragraph>
+<paragraph>
+<text>node E is in subtree with start C</text>
+</paragraph>
+<paragraph>
+<text>node F is in subtree with start C</text>
+</paragraph>
+<paragraph>
+<text>node G is in subtree with start C</text>
+</paragraph>
+<paragraph>
+<text>node H is in subtree with start C</text>
+</paragraph>
+<paragraph>
+<text>node I is in subtree with start C</text>
+</paragraph>
+<paragraph>
+<text>node J is in subtree with start C</text>
+</paragraph>
+<paragraph>
+<text>node K is in subtree with start C</text>
+</paragraph>
+<paragraph>
+<text>node L is in subtree with start C</text>
+</paragraph>
+<paragraph>
+<text>node M is in subtree with start C</text>
+</paragraph>
+<paragraph>
+<text>node N is in subtree with start C</text>
+</paragraph>
+<paragraph>
+<text>node O is in subtree with start C</text>
+</paragraph>
+<paragraph>
+<text>node A is not in subtree with start D</text>
+</paragraph>
+<paragraph>
+<text>node B is not in subtree with start D</text>
+</paragraph>
+<paragraph>
+<text>node C is not in subtree with start D</text>
+</paragraph>
+<paragraph>
+<text>node D is in subtree with start D</text>
+</paragraph>
+<paragraph>
+<text>node E is in subtree with start D</text>
+</paragraph>
+<paragraph>
+<text>node F is in subtree with start D</text>
+</paragraph>
+<paragraph>
+<text>node G is in subtree with start D</text>
+</paragraph>
+<paragraph>
+<text>node H is in subtree with start D</text>
+</paragraph>
+<paragraph>
+<text>node I is in subtree with start D</text>
+</paragraph>
+<paragraph>
+<text>node J is in subtree with start D</text>
+</paragraph>
+<paragraph>
+<text>node K is in subtree with start D</text>
+</paragraph>
+<paragraph>
+<text>node L is in subtree with start D</text>
+</paragraph>
+<paragraph>
+<text>node M is in subtree with start D</text>
+</paragraph>
+<paragraph>
+<text>node N is in subtree with start D</text>
+</paragraph>
+<paragraph>
+<text>node O is in subtree with start D</text>
+</paragraph>
+<paragraph>
+<text>node A is not in subtree with start E</text>
+</paragraph>
+<paragraph>
+<text>node B is not in subtree with start E</text>
+</paragraph>
+<paragraph>
+<text>node C is not in subtree with start E</text>
+</paragraph>
+<paragraph>
+<text>node D is not in subtree with start E</text>
+</paragraph>
+<paragraph>
+<text>node E is in subtree with start E</text>
+</paragraph>
+<paragraph>
+<text>node F is in subtree with start E</text>
+</paragraph>
+<paragraph>
+<text>node G is in subtree with start E</text>
+</paragraph>
+<paragraph>
+<text>node H is in subtree with start E</text>
+</paragraph>
+<paragraph>
+<text>node I is in subtree with start E</text>
+</paragraph>
+<paragraph>
+<text>node J is in subtree with start E</text>
+</paragraph>
+<paragraph>
+<text>node K is in subtree with start E</text>
+</paragraph>
+<paragraph>
+<text>node L is in subtree with start E</text>
+</paragraph>
+<paragraph>
+<text>node M is in subtree with start E</text>
+</paragraph>
+<paragraph>
+<text>node N is in subtree with start E</text>
+</paragraph>
+<paragraph>
+<text>node O is in subtree with start E</text>
+</paragraph>
+<paragraph>
+<text>node A is not in subtree with start F</text>
+</paragraph>
+<paragraph>
+<text>node B is not in subtree with start F</text>
+</paragraph>
+<paragraph>
+<text>node C is not in subtree with start F</text>
+</paragraph>
+<paragraph>
+<text>node D is not in subtree with start F</text>
+</paragraph>
+<paragraph>
+<text>node E is not in subtree with start F</text>
+</paragraph>
+<paragraph>
+<text>node F is in subtree with start F</text>
+</paragraph>
+<paragraph>
+<text>node G is in subtree with start F</text>
+</paragraph>
+<paragraph>
+<text>node H is in subtree with start F</text>
+</paragraph>
+<paragraph>
+<text>node I is in subtree with start F</text>
+</paragraph>
+<paragraph>
+<text>node J is in subtree with start F</text>
+</paragraph>
+<paragraph>
+<text>node K is in subtree with start F</text>
+</paragraph>
+<paragraph>
+<text>node L is in subtree with start F</text>
+</paragraph>
+<paragraph>
+<text>node M is in subtree with start F</text>
+</paragraph>
+<paragraph>
+<text>node N is in subtree with start F</text>
+</paragraph>
+<paragraph>
+<text>node O is in subtree with start F</text>
+</paragraph>
+<paragraph>
+<text>node A is not in subtree with start G</text>
+</paragraph>
+<paragraph>
+<text>node B is not in subtree with start G</text>
+</paragraph>
+<paragraph>
+<text>node C is not in subtree with start G</text>
+</paragraph>
+<paragraph>
+<text>node D is not in subtree with start G</text>
+</paragraph>
+<paragraph>
+<text>node E is not in subtree with start G</text>
+</paragraph>
+<paragraph>
+<text>node F is not in subtree with start G</text>
+</paragraph>
+<paragraph>
+<text>node G is in subtree with start G</text>
+</paragraph>
+<paragraph>
+<text>node H is in subtree with start G</text>
+</paragraph>
+<paragraph>
+<text>node I is in subtree with start G</text>
+</paragraph>
+<paragraph>
+<text>node J is in subtree with start G</text>
+</paragraph>
+<paragraph>
+<text>node K is in subtree with start G</text>
+</paragraph>
+<paragraph>
+<text>node L is in subtree with start G</text>
+</paragraph>
+<paragraph>
+<text>node M is in subtree with start G</text>
+</paragraph>
+<paragraph>
+<text>node N is in subtree with start G</text>
+</paragraph>
+<paragraph>
+<text>node O is in subtree with start G</text>
+</paragraph>
+<paragraph>
+<text>node A is not in subtree with start H</text>
+</paragraph>
+<paragraph>
+<text>node B is not in subtree with start H</text>
+</paragraph>
+<paragraph>
+<text>node C is not in subtree with start H</text>
+</paragraph>
+<paragraph>
+<text>node D is not in subtree with start H</text>
+</paragraph>
+<paragraph>
+<text>node E is not in subtree with start H</text>
+</paragraph>
+<paragraph>
+<text>node F is not in subtree with start H</text>
+</paragraph>
+<paragraph>
+<text>node G is not in subtree with start H</text>
+</paragraph>
+<paragraph>
+<text>node H is in subtree with start H</text>
+</paragraph>
+<paragraph>
+<text>node I is in subtree with start H</text>
+</paragraph>
+<paragraph>
+<text>node J is in subtree with start H</text>
+</paragraph>
+<paragraph>
+<text>node K is in subtree with start H</text>
+</paragraph>
+<paragraph>
+<text>node L is in subtree with start H</text>
+</paragraph>
+<paragraph>
+<text>node M is in subtree with start H</text>
+</paragraph>
+<paragraph>
+<text>node N is in subtree with start H</text>
+</paragraph>
+<paragraph>
+<text>node O is in subtree with start H</text>
+</paragraph>
+<paragraph>
+<text>node A is not in subtree with start I</text>
+</paragraph>
+<paragraph>
+<text>node B is not in subtree with start I</text>
+</paragraph>
+<paragraph>
+<text>node C is not in subtree with start I</text>
+</paragraph>
+<paragraph>
+<text>node D is not in subtree with start I</text>
+</paragraph>
+<paragraph>
+<text>node E is not in subtree with start I</text>
+</paragraph>
+<paragraph>
+<text>node F is not in subtree with start I</text>
+</paragraph>
+<paragraph>
+<text>node G is not in subtree with start I</text>
+</paragraph>
+<paragraph>
+<text>node H is not in subtree with start I</text>
+</paragraph>
+<paragraph>
+<text>node I is in subtree with start I</text>
+</paragraph>
+<paragraph>
+<text>node J is in subtree with start I</text>
+</paragraph>
+<paragraph>
+<text>node K is in subtree with start I</text>
+</paragraph>
+<paragraph>
+<text>node L is in subtree with start I</text>
+</paragraph>
+<paragraph>
+<text>node M is in subtree with start I</text>
+</paragraph>
+<paragraph>
+<text>node N is in subtree with start I</text>
+</paragraph>
+<paragraph>
+<text>node O is in subtree with start I</text>
+</paragraph>
+<paragraph>
+<text>node A is not in subtree with start J</text>
+</paragraph>
+<paragraph>
+<text>node B is not in subtree with start J</text>
+</paragraph>
+<paragraph>
+<text>node C is not in subtree with start J</text>
+</paragraph>
+<paragraph>
+<text>node D is not in subtree with start J</text>
+</paragraph>
+<paragraph>
+<text>node E is not in subtree with start J</text>
+</paragraph>
+<paragraph>
+<text>node F is not in subtree with start J</text>
+</paragraph>
+<paragraph>
+<text>node G is not in subtree with start J</text>
+</paragraph>
+<paragraph>
+<text>node H is not in subtree with start J</text>
+</paragraph>
+<paragraph>
+<text>node I is not in subtree with start J</text>
+</paragraph>
+<paragraph>
+<text>node J is in subtree with start J</text>
+</paragraph>
+<paragraph>
+<text>node K is in subtree with start J</text>
+</paragraph>
+<paragraph>
+<text>node L is in subtree with start J</text>
+</paragraph>
+<paragraph>
+<text>node M is in subtree with start J</text>
+</paragraph>
+<paragraph>
+<text>node N is in subtree with start J</text>
+</paragraph>
+<paragraph>
+<text>node O is in subtree with start J</text>
+</paragraph>
+<paragraph>
+<text>node A is not in subtree with start K</text>
+</paragraph>
+<paragraph>
+<text>node B is not in subtree with start K</text>
+</paragraph>
+<paragraph>
+<text>node C is not in subtree with start K</text>
+</paragraph>
+<paragraph>
+<text>node D is not in subtree with start K</text>
+</paragraph>
+<paragraph>
+<text>node E is not in subtree with start K</text>
+</paragraph>
+<paragraph>
+<text>node F is not in subtree with start K</text>
+</paragraph>
+<paragraph>
+<text>node G is not in subtree with start K</text>
+</paragraph>
+<paragraph>
+<text>node H is not in subtree with start K</text>
+</paragraph>
+<paragraph>
+<text>node I is not in subtree with start K</text>
+</paragraph>
+<paragraph>
+<text>node J is not in subtree with start K</text>
+</paragraph>
+<paragraph>
+<text>node K is in subtree with start K</text>
+</paragraph>
+<paragraph>
+<text>node L is in subtree with start K</text>
+</paragraph>
+<paragraph>
+<text>node M is in subtree with start K</text>
+</paragraph>
+<paragraph>
+<text>node N is in subtree with start K</text>
+</paragraph>
+<paragraph>
+<text>node O is in subtree with start K</text>
+</paragraph>
+<paragraph>
+<text>node A is not in subtree with start L</text>
+</paragraph>
+<paragraph>
+<text>node B is not in subtree with start L</text>
+</paragraph>
+<paragraph>
+<text>node C is not in subtree with start L</text>
+</paragraph>
+<paragraph>
+<text>node D is not in subtree with start L</text>
+</paragraph>
+<paragraph>
+<text>node E is not in subtree with start L</text>
+</paragraph>
+<paragraph>
+<text>node F is not in subtree with start L</text>
+</paragraph>
+<paragraph>
+<text>node G is not in subtree with start L</text>
+</paragraph>
+<paragraph>
+<text>node H is not in subtree with start L</text>
+</paragraph>
+<paragraph>
+<text>node I is not in subtree with start L</text>
+</paragraph>
+<paragraph>
+<text>node J is not in subtree with start L</text>
+</paragraph>
+<paragraph>
+<text>node K is not in subtree with start L</text>
+</paragraph>
+<paragraph>
+<text>node L is in subtree with start L</text>
+</paragraph>
+<paragraph>
+<text>node M is in subtree with start L</text>
+</paragraph>
+<paragraph>
+<text>node N is in subtree with start L</text>
+</paragraph>
+<paragraph>
+<text>node O is in subtree with start L</text>
+</paragraph>
+<paragraph>
+<text>node A is not in subtree with start M</text>
+</paragraph>
+<paragraph>
+<text>node B is not in subtree with start M</text>
+</paragraph>
+<paragraph>
+<text>node C is not in subtree with start M</text>
+</paragraph>
+<paragraph>
+<text>node D is not in subtree with start M</text>
+</paragraph>
+<paragraph>
+<text>node E is not in subtree with start M</text>
+</paragraph>
+<paragraph>
+<text>node F is not in subtree with start M</text>
+</paragraph>
+<paragraph>
+<text>node G is not in subtree with start M</text>
+</paragraph>
+<paragraph>
+<text>node H is not in subtree with start M</text>
+</paragraph>
+<paragraph>
+<text>node I is not in subtree with start M</text>
+</paragraph>
+<paragraph>
+<text>node J is not in subtree with start M</text>
+</paragraph>
+<paragraph>
+<text>node K is not in subtree with start M</text>
+</paragraph>
+<paragraph>
+<text>node L is not in subtree with start M</text>
+</paragraph>
+<paragraph>
+<text>node M is in subtree with start M</text>
+</paragraph>
+<paragraph>
+<text>node N is in subtree with start M</text>
+</paragraph>
+<paragraph>
+<text>node O is in subtree with start M</text>
+</paragraph>
+<paragraph>
+<text>node A is not in subtree with start N</text>
+</paragraph>
+<paragraph>
+<text>node B is not in subtree with start N</text>
+</paragraph>
+<paragraph>
+<text>node C is not in subtree with start N</text>
+</paragraph>
+<paragraph>
+<text>node D is not in subtree with start N</text>
+</paragraph>
+<paragraph>
+<text>node E is not in subtree with start N</text>
+</paragraph>
+<paragraph>
+<text>node F is not in subtree with start N</text>
+</paragraph>
+<paragraph>
+<text>node G is not in subtree with start N</text>
+</paragraph>
+<paragraph>
+<text>node H is not in subtree with start N</text>
+</paragraph>
+<paragraph>
+<text>node I is not in subtree with start N</text>
+</paragraph>
+<paragraph>
+<text>node J is not in subtree with start N</text>
+</paragraph>
+<paragraph>
+<text>node K is not in subtree with start N</text>
+</paragraph>
+<paragraph>
+<text>node L is not in subtree with start N</text>
+</paragraph>
+<paragraph>
+<text>node M is not in subtree with start N</text>
+</paragraph>
+<paragraph>
+<text>node N is in subtree with start N</text>
+</paragraph>
+<paragraph>
+<text>node O is in subtree with start N</text>
+</paragraph>
+<paragraph>
+<text>node A is not in subtree with start O</text>
+</paragraph>
+<paragraph>
+<text>node B is not in subtree with start O</text>
+</paragraph>
+<paragraph>
+<text>node C is not in subtree with start O</text>
+</paragraph>
+<paragraph>
+<text>node D is not in subtree with start O</text>
+</paragraph>
+<paragraph>
+<text>node E is not in subtree with start O</text>
+</paragraph>
+<paragraph>
+<text>node F is not in subtree with start O</text>
+</paragraph>
+<paragraph>
+<text>node G is not in subtree with start O</text>
+</paragraph>
+<paragraph>
+<text>node H is not in subtree with start O</text>
+</paragraph>
+<paragraph>
+<text>node I is not in subtree with start O</text>
+</paragraph>
+<paragraph>
+<text>node J is not in subtree with start O</text>
+</paragraph>
+<paragraph>
+<text>node K is not in subtree with start O</text>
+</paragraph>
+<paragraph>
+<text>node L is not in subtree with start O</text>
+</paragraph>
+<paragraph>
+<text>node M is not in subtree with start O</text>
+</paragraph>
+<paragraph>
+<text>node N is not in subtree with start O</text>
+</paragraph>
+<paragraph>
+<text>node O is in subtree with start O</text>
+</paragraph>
+</simple-page-sequence>
+</fot>
--- openjade-1.4devel1.orig/testsuite/contains.sgml
+++ openjade-1.4devel1/testsuite/contains.sgml
@@ -0,0 +1,11 @@
+<!doctype a [
+<!element a - o (b,i) >
+<!element b - o (c,f) >
+<!element c - o (d,e) > 
+<!element f - o (g,h) >
+<!element i - o (j,m) >
+<!element j - o (k,l) >
+<!element m - o (n,o) >
+<!element (d,e,g,h,k,l,n,o) - o empty >
+]>
+<a><b><c><d><e><f><g><h><i><j><k><l><m><n><o>
--- openjade-1.4devel1.orig/testsuite/expr-lang.actual
+++ openjade-1.4devel1/testsuite/expr-lang.actual
@@ -0,0 +1,156 @@
+Character Primitives
+(char=? #\a #\b) --> #f
+(char=? #\a #\a) --> #t
+(char=? #\a #\A) --> #f
+(char<? #\a #\b) --> #t
+(char<? #\a #\a) --> #f
+(char<? #\a #\A) --> #t
+(char<=? #\a #\b) --> #t
+(char<=? #\a #\a) --> #t
+(char<=? #\a #\A) --> #t
+(char>? #\a #\b) --> #f
+(char>? #\a #\a) --> #f
+(char>? #\a #\A) --> #f
+(char>=? #\a #\b) --> #f
+(char>=? #\a #\a) --> #t
+(char>=? #\a #\A) --> #f
+(char-ci=? #\a #\b) --> #f
+(char-ci=? #\a #\a) --> #t
+(char-ci=? #\a #\A) --> #t
+(char-ci<? #\a #\b) --> #t
+(char-ci<? #\a #\a) --> #f
+(char-ci<? #\a #\A) --> #f
+(char-ci<=? #\a #\b) --> #t
+(char-ci<=? #\a #\a) --> #t
+(char-ci<=? #\a #\A) --> #t
+(char-ci>? #\a #\b) --> #f
+(char-ci>? #\a #\a) --> #f
+(char-ci>? #\a #\A) --> #f
+(char-ci>=? #\a #\b) --> #f
+(char-ci>=? #\a #\a) --> #t
+(char-ci>=? #\a #\A) --> #t
+
+Character Properties
+(char-property space? #\ ) --> #t
+(char-property space? #\  foo) --> #t
+(char-property space? #\!) --> #f
+(char-property space? #\! foo) --> foo
+(char-property break-before-priority #\ ) --> 2
+(char-property break-after-priority #\ ) --> 3
+(char-property break-before-priority #\a) --> 1
+(char-property break-after-priority #\a) --> 1
+(char-property funny #\a) --> #\a
+(char-property funny #\b) --> #\a
+(char-property funny #\c) --> #\a
+(char-property funny #\d) --> boring
+(char-property funny #\e) --> boring
+(char-property funny #\z) --> boring
+
+String Primitives
+
+Standard examples
+(not #t) --> #f
+(not 3) --> #f
+(not (3)) --> #f
+(not #f) --> #t
+(not ()) --> #f
+(not ()) --> #f
+(not nil) --> #f
+(boolean? #f) --> #t
+(boolean? 0) --> #f
+(boolean? ()) --> #f
+(pair? (a . b)) --> #t
+(pair? (a b c)) --> #t
+(pair? ()) --> #f
+(cons a ()) --> (a)
+(cons (a) (b c d)) --> ((a) b c d)
+(cons "a" (b c)) --> ("a" b c)
+(cons a 3) --> (a . 3)
+(cons (a b) c) --> ((a b) . c)
+(car (a b c)) --> a
+(car ((a) b c d)) --> (a)
+(car (1 . 2)) --> 1
+(cdr ((a) b c d)) --> (b c d)
+(cdr (1 . 2)) --> 2
+(list? (a b c)) --> #t
+(list? ()) --> #t
+(list? (a . b)) --> #f
+(list a 7 c) --> (a 7 c)
+(list) --> ()
+(length (a b c)) --> 3
+(length (a (b) (c d e))) --> 3
+(length ()) --> 0
+(append (x) (y)) --> (x y)
+(append (a) (b c d)) --> (a b c d)
+(append (a (b)) ((c))) --> (a (b) (c))
+(append (a b) (c . d)) --> (a . (b . (c . d)))
+(append () a) --> a
+(reverse (a b c)) --> (c b a)
+(reverse (a (b c) d (e (f)))) --> ((e (f)) d (b c) a)
+(list-ref (a b c d) 2) --> c
+(list-ref (a b c d) 2) --> c
+(member a (a b c)) --> (a b c)
+(member b (a b c)) --> (b c)
+(member a (b c d)) --> #f
+(assoc a ((a 1) (b 2) (c 3))) --> (a 1)
+(assoc b ((a 1) (b 2) (c 3))) --> (b 2)
+(assoc d ((a 1) (b 2) (c 3))) --> #f
+(symbol? foo) --> #t
+(symbol? a) --> #t
+(symbol? "bar") --> #f
+(symbol? nil) --> #t
+(symbol? ()) --> #f
+(symbol? #f) --> #f
+(symbol->string flying-fish) --> "flying-fish"
+(symbol->string Malvina) --> "Malvina"
+(equal? mISSISSIppi mississippi) --> #f
+(equal? bitBlt bitBlt) --> #t
+(equal? JollyWog JollyWog) --> #t
+(string=? "K. Harper, M.D." "K. Harper, M.D.") --> #t
+(keyword->string Argentina:) --> "Argentina"
+(string->keyword "foobar") --> foobar:
+(real? 3) --> #t
+(integer? 3) --> #t
+(max 3 4) --> 4
+(max 3.9 4) --> 4
+(+ 3 4) --> 7
+(+ 3) --> 3
+(+) --> 0
+(* 4) --> 4
+(*) --> 1
+(- 3 4) --> -1
+(- 3 4 5) --> -6
+(- 3) --> -3
+(/ 3 4 5) --> 0.15
+(/ 3) --> 0.333333
+(abs -7) --> 7
+(modulo 13 4) --> 1
+(remainder 13 4) --> 1
+(modulo -13 4) --> 3
+(remainder -13 4) --> -1
+(modulo 13 -4) --> -3
+(remainder 13 -4) --> 1
+(modulo -13 -4) --> -1
+(remainder -13 -4) --> -1
+(remainder -13 -4) --> -1
+(floor -4.3) --> -5
+(ceiling -4.3) --> -4
+(truncate -4.3) --> -4
+(round -4.3) --> -4
+(floor 3.5) --> 3
+(ceiling 3.5) --> 4
+(truncate 3.5) --> 3
+(round 3.5) --> 4
+(round 7) --> 7
+(string->number "100") --> 100
+(string->number "100" 16) --> 256
+(string->number "1e2") --> 100
+(procedure? procedure) --> #t
+(procedure? car) --> #f
+(procedure? procedure) --> #t
+(procedure? (lambda (x) (* x x))) --> #f
+(apply procedure (3 4)) --> 7
+(map procedure ((a b) (d e) (g h))) --> (b e h)
+(map procedure (1 2 3 4 5)) --> (1 4 27 256 3125)
+(map procedure (1 2 3) (4 5 6)) --> (5 7 9)
+
--- openjade-1.4devel1.orig/testsuite/expr-lang.dsl
+++ openjade-1.4devel1/testsuite/expr-lang.dsl
@@ -0,0 +1,291 @@
+<!doctype style-sheet PUBLIC "-//James Clark//DTD DSSSL Style Sheet//EN">
+<!-- Copyright (C) 1999 Avi Kivity -->
+                 
+<![cdata[                
+                 
+(root
+    (test-expression-language)
+)
+
+(define (test-expression-language)
+    (sosofo-append
+        (make-test "Character Primitives" test-char)
+	(make-test "Character Properties" test-char-properties)
+        (make-test "String Primitives" test-string)
+	(make-test "Standard examples" test-examples)
+    )
+)
+
+(define (test-char)
+    (sosofo-append
+        (testcase 'char=?      #\a #\b)
+        (testcase 'char=?      #\a #\a)
+        (testcase 'char=?      #\a #\A)
+        (testcase 'char<?      #\a #\b)
+        (testcase 'char<?      #\a #\a)
+        (testcase 'char<?      #\a #\A)
+        (testcase 'char<=?     #\a #\b)
+        (testcase 'char<=?     #\a #\a)
+        (testcase 'char<=?     #\a #\A)
+        (testcase 'char>?      #\a #\b)
+        (testcase 'char>?      #\a #\a)
+        (testcase 'char>?      #\a #\A)
+        (testcase 'char>=?     #\a #\b)
+        (testcase 'char>=?     #\a #\a)
+        (testcase 'char>=?     #\a #\A)
+        (testcase 'char-ci=?   #\a #\b)
+        (testcase 'char-ci=?   #\a #\a)
+        (testcase 'char-ci=?   #\a #\A)
+        (testcase 'char-ci<?   #\a #\b)
+        (testcase 'char-ci<?   #\a #\a)
+        (testcase 'char-ci<?   #\a #\A)
+        (testcase 'char-ci<=?  #\a #\b)
+        (testcase 'char-ci<=?  #\a #\a)
+        (testcase 'char-ci<=?  #\a #\A)
+        (testcase 'char-ci>?   #\a #\b)
+        (testcase 'char-ci>?   #\a #\a)
+        (testcase 'char-ci>?   #\a #\A)
+        (testcase 'char-ci>=?  #\a #\b)
+        (testcase 'char-ci>=?  #\a #\a)
+        (testcase 'char-ci>=?  #\a #\A)
+    )
+)
+
+(add-char-properties funny: #\a #\a)
+(add-char-properties funny: (char-property 'funny #\a) #\b #\c)
+(add-char-properties funny: (char-property 'funny #\z) #\d)
+(declare-char-property funny 'boring)
+(define (test-char-properties)
+    (sosofo-append
+        (testcase 'char-property 'space? #\space)
+        (testcase 'char-property 'space? #\space 'foo)
+	(testcase 'char-property 'space? #\exclamation-mark)
+	(testcase 'char-property 'space? #\exclamation-mark 'foo)
+        (testcase 'char-property 'break-before-priority #\space)
+	(testcase 'char-property 'break-after-priority #\space)
+	(testcase 'char-property 'break-before-priority #\a)
+	(testcase 'char-property 'break-after-priority #\a)
+	(testcase 'char-property 'funny #\a)
+	(testcase 'char-property 'funny #\b)
+	(testcase 'char-property 'funny #\c)
+	(testcase 'char-property 'funny #\d)
+	(testcase 'char-property 'funny #\e)
+	(testcase 'char-property 'funny #\z)
+    ))
+
+(define (test-string)
+    (empty-sosofo)
+)
+
+(define (test-examples)
+    (sosofo-append
+        (testcase 'not  #t)
+        (testcase 'not  3)
+        (testcase 'not  (list 3))
+        (testcase 'not  #f)
+        (testcase 'not  '())
+        (testcase 'not  (list))
+        (testcase 'not  'nil)
+        (testcase 'boolean?  #f)
+        (testcase 'boolean?  0)
+        (testcase 'boolean?  '())
+        (testcase 'pair?  '(a . b))
+        (testcase 'pair?  '(a b c))
+        (testcase 'pair?  '())
+        (testcase 'cons  'a '())
+        (testcase 'cons  '(a) '(b c d))
+        (testcase 'cons  "a" '(b c))
+        (testcase 'cons  'a 3)
+        (testcase 'cons  '(a b) 'c)
+	(testcase 'car  '(a b c))
+	(testcase 'car  '((a) b c d))
+	(testcase 'car  '(1 . 2))
+	;(testcase 'car  '()) ;==> error
+        (testcase 'cdr	'((a) b c d))
+	(testcase 'cdr 	'(1 . 2))
+	;(testcase 'cdr  '()) ;==> error
+	(testcase 'list?  '(a b c))
+	(testcase 'list?  '())
+	(testcase 'list?  '(a . b))
+	(testcase 'list  'a (+ 3 4) 'c)
+	(testcase 'list)
+	(testcase 'length  '(a b c))
+	(testcase 'length  '(a (b) (c d e)))
+	(testcase 'length  '())
+	(testcase 'append  '(x) '(y))
+	(testcase 'append  '(a) '(b c d))
+	(testcase 'append  '(a (b)) '((c))) 	
+	(testcase 'append  '(a b) '(c . d)) 	
+	(testcase 'append  '() 'a) 	
+	(testcase 'reverse  '(a b c))
+	(testcase 'reverse  '(a (b c) d (e (f))))
+	(testcase 'list-ref  '(a b c d) 2)
+	(testcase 'list-ref  '(a b c d) (inexact->exact (round 1.8)))
+	(testcase 'member  'a '(a b c))
+	(testcase 'member  'b '(a b c))
+	(testcase 'member  'a '(b c d))
+	(testcase 'assoc  'a '((a 1) (b 2) (c 3)))
+	(testcase 'assoc  'b '((a 1) (b 2) (c 3)))
+	(testcase 'assoc  'd '((a 1) (b 2) (c 3)))
+	(testcase 'symbol?  'foo)
+	(testcase 'symbol?  (car '(a b)))
+	(testcase 'symbol?  "bar")
+	(testcase 'symbol?  'nil)
+	(testcase 'symbol?  '())
+	(testcase 'symbol?  #f)
+	(testcase 'symbol->string  'flying-fish)
+	(testcase 'symbol->string (string->symbol "Malvina"))
+	(testcase 'equal?  'mISSISSIppi 'mississippi)
+	(testcase 'equal?  'bitBlt (string->symbol "bitBlt"))
+	(testcase 'equal?  'JollyWog 
+		(string->symbol (symbol->string 'JollyWog)))
+	(testcase 'string=? "K. Harper, M.D."
+		(symbol->string (string->symbol "K. Harper, M.D.")))
+	(testcase 'keyword->string  Argentina:)
+	(testcase 'string->keyword  "foobar")
+	(testcase 'real?  3)
+	(testcase 'integer?  3.0)
+	(testcase 'max  3 4)
+	(testcase 'max  3.9 4)
+	(testcase '+  3 4)
+	(testcase '+  3)
+	(testcase '+) 
+	(testcase '*  4)
+	(testcase '*)
+	(testcase '-  3 4)
+	(testcase '-  3 4 5)
+	(testcase '-  3)
+	(testcase '/  3 4 5)
+	(testcase '/  3)
+        (testcase 'abs  -7)
+	(testcase 'modulo  13 4)
+	(testcase 'remainder  13 4)
+	(testcase 'modulo  -13 4)
+	(testcase 'remainder  -13 4)
+	(testcase 'modulo  13 -4)
+	(testcase 'remainder  13 -4)
+	(testcase 'modulo  -13 -4)
+	(testcase 'remainder  -13 -4)
+	(testcase 'remainder  -13 -4.0)
+	(testcase 'floor  -4.3)
+	(testcase 'ceiling  -4.3)
+	(testcase 'truncate  -4.3)
+	(testcase 'round  -4.3)
+	(testcase 'floor  3.5)
+	(testcase 'ceiling  3.5)
+	(testcase 'truncate  3.5)
+	(testcase 'round  3.5)
+	(testcase 'round  7)
+	(testcase 'string->number  "100")
+	(testcase 'string->number  "100" 16)
+	(testcase 'string->number  "1e2")
+	(testcase 'procedure?  car)
+	(testcase 'procedure?  'car)
+	(testcase 'procedure?  (lambda (x) (* x x)))
+	(testcase 'procedure?  '(lambda (x) (* x x)))
+	(testcase 'apply  + (list 3 4))
+	(testcase 'map  cadr '((a b) (d e) (g h)))
+	(testcase 'map  (lambda (n) (expt n n)) '(1 2 3 4 5))
+	(testcase 'map  + '(1 2 3) '(4 5 6))
+    )
+)
+
+(define symbol-proc-map
+    `(
+        (char=? . ,char=?) (char<? . ,char<?) (char<=? . ,char<=?) 
+        (char>? . ,char>?) (char>=? . ,char>=?) (char-ci=? . ,char-ci=?)
+        (char-ci<? . ,char-ci<?) (char-ci<=? . ,char-ci<=?)
+        (char-ci>? . ,char-ci>?) (char-ci>=? . ,char-ci>=?)
+	(char-property . ,char-property)
+        (not . ,not) (boolean? . ,boolean?) (pair? . ,pair?) 
+        (cons . ,cons) (car . ,car) (cdr . ,cdr) (list? . ,list?)
+	(list . ,list) (length . ,length) (append . ,append)
+	(reverse . ,reverse) (list-ref . ,list-ref) (member . ,member)
+	(assoc . ,assoc) (symbol? . ,symbol?) 
+	(symbol->string . ,symbol->string) (equal? . ,equal?)
+	(string=? . ,string=?) (keyword->string . ,keyword->string)
+	(string->keyword . ,string->keyword) (real? . ,real?)
+	(integer? . ,integer?) (max . ,max) (+ . ,+) (* . ,*) (- . ,-)
+	(/ . ,/) (abs . ,abs) (modulo . ,modulo) (remainder . ,remainder)
+	(floor . ,floor) (ceiling . ,ceiling) (truncate . ,truncate)
+	(round . ,round) (string->number . ,string->number)
+	(procedure? . ,procedure?) (apply . ,apply) (map . ,map)
+    )     
+)
+     
+(define (symbol->proc sym) (cdr (assoc sym symbol-proc-map)))     
+                  
+(define (testcase proc-sym #!rest args)
+    (write-line
+        (string-append
+            "(" 
+            (symbol->string proc-sym)
+            (reduce 
+                args
+                (lambda (args arg) (string-append args " " (obj->string arg)))
+                ""
+            )
+            ") --> "
+            (obj->string (apply (symbol->proc proc-sym) args))
+        )
+    )
+)       
+
+(define (reduce list combine init)
+  (let loop ((result init)
+             (list list))
+    (if (null? list)
+        result
+        (loop (combine result (car list))
+              (cdr list)))))
+
+(define (obj->string obj)
+    (cond
+        ((char? obj) (list->string (list #\# #\\ obj)))
+        ((string? obj) (string-append "\"" obj "\""))
+        ((boolean? obj) (if obj "#t" "#f"))
+        ((symbol? obj) (symbol->string obj))
+	((keyword? obj) (string-append (keyword->string obj) ":"))
+        ((number? obj) (number->string obj)) 
+	((procedure? obj) "procedure")
+        ((list? obj) 
+	    (if (null? obj)
+		"()"
+            	(apply string-append 
+                    (append (list "(" (obj->string (car obj)))
+                        (map (lambda (x) 
+				(string-append " " (obj->string x))) (cdr obj))
+                    '(")")))))
+	((pair? obj) (string-append "(" (obj->string (car obj))
+				" . " (obj->string (cdr obj)) ")"))
+        (else "unimplemented")
+    )
+)           
+                  
+(define (make-test title proc)
+    (sosofo-append
+        (write-line title)
+        (proc)
+        (write-empty-line)
+    )
+)    
+
+(define (write-empty-line) (write-line ""))
+
+(define newline "\carriage-return;\line-feed;")
+
+(define (write-line string)
+    (make formatting-instruction
+        data: (string-append string newline)
+    )
+)
+
+(declare-flow-object-class formatting-instruction
+  "UNREGISTERED::James Clark//Flow Object Class::formatting-instruction")
+
+(declare-default-language (language "EN" "US"))
+
+(define language
+  (external-procedure "UNREGISTERED::OpenJade//Procedure::language"))
+
+]]>
--- openjade-1.4devel1.orig/testsuite/expr-lang.expected
+++ openjade-1.4devel1/testsuite/expr-lang.expected
@@ -0,0 +1,156 @@
+Character Primitives
+(char=? #\a #\b) --> #f
+(char=? #\a #\a) --> #t
+(char=? #\a #\A) --> #f
+(char<? #\a #\b) --> #t
+(char<? #\a #\a) --> #f
+(char<? #\a #\A) --> #f
+(char<=? #\a #\b) --> #t
+(char<=? #\a #\a) --> #t
+(char<=? #\a #\A) --> #f
+(char>? #\a #\b) --> #f
+(char>? #\a #\a) --> #f
+(char>? #\a #\A) --> #t
+(char>=? #\a #\b) --> #f
+(char>=? #\a #\a) --> #t
+(char>=? #\a #\A) --> #t
+(char-ci=? #\a #\b) --> #f
+(char-ci=? #\a #\a) --> #t
+(char-ci=? #\a #\A) --> #t
+(char-ci<? #\a #\b) --> #t
+(char-ci<? #\a #\a) --> #f
+(char-ci<? #\a #\A) --> #f
+(char-ci<=? #\a #\b) --> #t
+(char-ci<=? #\a #\a) --> #t
+(char-ci<=? #\a #\A) --> #t
+(char-ci>? #\a #\b) --> #f
+(char-ci>? #\a #\a) --> #f
+(char-ci>? #\a #\A) --> #f
+(char-ci>=? #\a #\b) --> #f
+(char-ci>=? #\a #\a) --> #t
+(char-ci>=? #\a #\A) --> #t
+
+Character Properties
+(char-property space? #\ ) --> #t
+(char-property space? #\  foo) --> #t
+(char-property space? #\!) --> #f
+(char-property space? #\! foo) --> foo
+(char-property break-before-priority #\ ) --> 2
+(char-property break-after-priority #\ ) --> 3
+(char-property break-before-priority #\a) --> 1
+(char-property break-after-priority #\a) --> 1
+(char-property funny #\a) --> #\a
+(char-property funny #\b) --> #\a
+(char-property funny #\c) --> #\a
+(char-property funny #\d) --> boring
+(char-property funny #\e) --> boring
+(char-property funny #\z) --> boring
+
+String Primitives
+
+Standard examples
+(not #t) --> #f
+(not 3) --> #f
+(not (3)) --> #f
+(not #f) --> #t
+(not ()) --> #f
+(not ()) --> #f
+(not nil) --> #f
+(boolean? #f) --> #t
+(boolean? 0) --> #f
+(boolean? ()) --> #f
+(pair? (a . b)) --> #t
+(pair? (a b c)) --> #t
+(pair? ()) --> #f
+(cons a ()) --> (a)
+(cons (a) (b c d)) --> ((a) b c d)
+(cons "a" (b c)) --> ("a" b c)
+(cons a 3) --> (a . 3)
+(cons (a b) c) --> ((a b) . c)
+(car (a b c)) --> a
+(car ((a) b c d)) --> (a)
+(car (1 . 2)) --> 1
+(cdr ((a) b c d)) --> (b c d)
+(cdr (1 . 2)) --> 2
+(list? (a b c)) --> #t
+(list? ()) --> #t
+(list? (a . b)) --> #f
+(list a 7 c) --> (a 7 c)
+(list) --> ()
+(length (a b c)) --> 3
+(length (a (b) (c d e))) --> 3
+(length ()) --> 0
+(append (x) (y)) --> (x y)
+(append (a) (b c d)) --> (a b c d)
+(append (a (b)) ((c))) --> (a (b) (c))
+(append (a b) (c . d)) --> (a . (b . (c . d)))
+(append () a) --> a
+(reverse (a b c)) --> (c b a)
+(reverse (a (b c) d (e (f)))) --> ((e (f)) d (b c) a)
+(list-ref (a b c d) 2) --> c
+(list-ref (a b c d) 2) --> c
+(member a (a b c)) --> (a b c)
+(member b (a b c)) --> (b c)
+(member a (b c d)) --> #f
+(assoc a ((a 1) (b 2) (c 3))) --> (a 1)
+(assoc b ((a 1) (b 2) (c 3))) --> (b 2)
+(assoc d ((a 1) (b 2) (c 3))) --> #f
+(symbol? foo) --> #t
+(symbol? a) --> #t
+(symbol? "bar") --> #f
+(symbol? nil) --> #t
+(symbol? ()) --> #f
+(symbol? #f) --> #f
+(symbol->string flying-fish) --> "flying-fish"
+(symbol->string Malvina) --> "Malvina"
+(equal? mISSISSIppi mississippi) --> #f
+(equal? bitBlt bitBlt) --> #t
+(equal? JollyWog JollyWog) --> #t
+(string=? "K. Harper, M.D." "K. Harper, M.D.") --> #t
+(keyword->string Argentina:) --> "Argentina"
+(string->keyword "foobar") --> foobar:
+(real? 3) --> #t
+(integer? 3) --> #t
+(max 3 4) --> 4
+(max 3.9 4) --> 4
+(+ 3 4) --> 7
+(+ 3) --> 3
+(+) --> 0
+(* 4) --> 4
+(*) --> 1
+(- 3 4) --> -1
+(- 3 4 5) --> -6
+(- 3) --> -3
+(/ 3 4 5) --> 0.15
+(/ 3) --> 0.333333
+(abs -7) --> 7
+(modulo 13 4) --> 1
+(remainder 13 4) --> 1
+(modulo -13 4) --> 3
+(remainder -13 4) --> -1
+(modulo 13 -4) --> -3
+(remainder 13 -4) --> 1
+(modulo -13 -4) --> -1
+(remainder -13 -4) --> -1
+(remainder -13 -4) --> -1
+(floor -4.3) --> -5
+(ceiling -4.3) --> -4
+(truncate -4.3) --> -4
+(round -4.3) --> -4
+(floor 3.5) --> 3
+(ceiling 3.5) --> 4
+(truncate 3.5) --> 3
+(round 3.5) --> 4
+(round 7) --> 7
+(string->number "100") --> 100
+(string->number "100" 16) --> 256
+(string->number "1e2") --> 100
+(procedure? procedure) --> #t
+(procedure? car) --> #f
+(procedure? procedure) --> #t
+(procedure? (lambda (x) (* x x))) --> #f
+(apply procedure (3 4)) --> 7
+(map procedure ((a b) (d e) (g h))) --> (b e h)
+(map procedure (1 2 3 4 5)) --> (1 4 27 256 3125)
+(map procedure (1 2 3) (4 5 6)) --> (5 7 9)
+
--- openjade-1.4devel1.orig/testsuite/flow-obj.dsl
+++ openjade-1.4devel1/testsuite/flow-obj.dsl
@@ -0,0 +1,50 @@
+<!doctype style-sheet PUBLIC "-//James Clark//DTD DSSSL Style Sheet//EN">
+<!-- Copyright (C) 1999 Avi Kivity -->
+                 
+<![cdata[                
+                 
+(root
+    (test-flow-object-classes)
+)
+
+(define (test-flow-object-classes)
+    (make simple-page-sequence
+        (make paragraph (literal "A paragraph."))
+        (make side-by-side
+            side-by-side-overlap-control: 'none
+            (let loop
+                (                          
+                    (n 1)
+                    (max 3)
+                    (result (empty-sosofo))
+                )
+                (if (> n max)
+                    result
+                    (loop 
+                        (+ n 1) 
+                        max 
+                        (sosofo-append
+                            result
+                            (make side-by-side-item
+                                (make paragraph
+                                    (literal 
+                                        "side-by-side-item #"
+                                        (format-number n "1")
+                                    )
+                                )
+                            )
+                        )
+                    )
+                )
+            )
+        )
+        (make paragraph (literal "A paragraph."))
+    )
+)
+
+;(declare-default-language (language "EN" "US"))
+
+(define language
+  (external-procedure "UNREGISTERED::OpenJade//Procedure::language"))
+
+]]>
--- openjade-1.4devel1.orig/testsuite/null.sgml
+++ openjade-1.4devel1/testsuite/null.sgml
@@ -0,0 +1,7 @@
+<!doctype nothing [
+<!-- Copyright (C) 1999 Avi Kivity -->
+<!element nothing o o (#pcdata)>
+
+]>
+
+<nothing></nothing>
--- openjade-1.4devel1.orig/testsuite/query-root.actual
+++ openjade-1.4devel1/testsuite/query-root.actual
@@ -0,0 +1,14 @@
+<?xml version="1.0"?>
+<fot>
+<simple-page-sequence>
+<sequence>
+<paragraph>
+<a name="0"/>
+<text>test-mode default rule matching SUB in B</text>
+</paragraph>
+<paragraph>
+<text>test-mode query rule matching SUB in A</text>
+</paragraph>
+</sequence>
+</simple-page-sequence>
+</fot>
--- openjade-1.4devel1.orig/testsuite/query-root.dsl
+++ openjade-1.4devel1/testsuite/query-root.dsl
@@ -0,0 +1,26 @@
+<!DOCTYPE style-sheet PUBLIC "-//James Clark//DTD DSSSL Style Sheet//EN" >
+
+(root (make simple-page-sequence (process-children)))
+
+(element A
+  (with-mode test-mode
+    (make sequence
+      (process-node-list (q-element 'sub (sgml-parse "query-root2.sgml")))
+      (process-children))))
+
+(define (describe-match s)
+  (make paragraph 
+    (literal "test-mode " s " matching " (gi (current-node))
+             " in " (gi (parent (current-node))))))
+ 
+(mode test-mode
+
+;; this should match sub elements in the grove being processed, but
+;; not in node-lists created via sgml-parse
+(query (q-element 'sub (current-root))
+  (describe-match "query rule"))
+
+(default 
+  (describe-match "default rule"))
+  
+) ;; end of test-mode 
--- openjade-1.4devel1.orig/testsuite/query-root.expected
+++ openjade-1.4devel1/testsuite/query-root.expected
@@ -0,0 +1,14 @@
+<?xml version="1.0"?>
+<fot>
+<simple-page-sequence>
+<sequence>
+<paragraph>
+<a name="0"/>
+<text>test-mode default rule matching SUB in B</text>
+</paragraph>
+<paragraph>
+<text>test-mode query rule matching SUB in A</text>
+</paragraph>
+</sequence>
+</simple-page-sequence>
+</fot>
--- openjade-1.4devel1.orig/testsuite/query-root.sgml
+++ openjade-1.4devel1/testsuite/query-root.sgml
@@ -0,0 +1,6 @@
+
+<!doctype a [
+<!element a - - (sub) >
+<!element sub - o empty >
+]>
+<a><sub></a>
--- openjade-1.4devel1.orig/testsuite/query-root2.sgml
+++ openjade-1.4devel1/testsuite/query-root2.sgml
@@ -0,0 +1,5 @@
+<!doctype b [
+<!element b - - (sub) >
+<!element sub - o empty >
+]>
+<b><sub></b>
--- openjade-1.4devel1.orig/testsuite/specificity.actual
+++ openjade-1.4devel1/testsuite/specificity.actual
@@ -0,0 +1,54 @@
+<?xml version="1.0"?>
+<fot>
+<simple-page-sequence>
+<paragraph>
+<a name="0"/>
+<text>query (priority 1) matching A</text>
+</paragraph>
+<paragraph>
+<text>query (priority 0) matching B</text>
+</paragraph>
+<paragraph>
+<text>query (priority -1) matching C</text>
+</paragraph>
+<paragraph>
+<text>id matching D</text>
+</paragraph>
+<paragraph>
+<text>element matching E</text>
+</paragraph>
+<paragraph>
+<text>initial mode query (priority 1) matching F</text>
+</paragraph>
+<paragraph>
+<text>initial mode query (priority 0) matching G</text>
+</paragraph>
+<paragraph>
+<text>initial mode query (priority -1) matching H</text>
+</paragraph>
+<paragraph>
+<text>initial mode id matching I</text>
+</paragraph>
+<paragraph>
+<text>initial mode element matching J</text>
+</paragraph>
+<paragraph>
+<text>part 2 initial mode query (priority 1) matching K</text>
+</paragraph>
+<paragraph>
+<text>part 2 initial mode query (priority 0) matching L</text>
+</paragraph>
+<paragraph>
+<text>part 2 initial mode query (priority -1) matching M</text>
+</paragraph>
+<paragraph>
+<text>part 2 initial mode id matching N</text>
+</paragraph>
+<paragraph>
+<text>part 2 initial mode element matching O</text>
+</paragraph>
+<paragraph>
+<text>part 2 initial mode default matching P</text>
+</paragraph>
+</simple-page-sequence>
+</fot>
--- openjade-1.4devel1.orig/testsuite/specificity.dsl
+++ openjade-1.4devel1/testsuite/specificity.dsl
@@ -0,0 +1,195 @@
+<!DOCTYPE style-sheet PUBLIC "-//James Clark//DTD DSSSL Style Sheet//EN">
+
+<style-specification id=test1 use=test2>
+
+(define debug (external-procedure "UNREGISTERED::James Clark//Procedure::debug"))
+
+(root 
+  (make simple-page-sequence (process-children)))
+
+(element test (with-mode test-mode (process-children)))
+
+
+;; test specificity rules
+
+; this was necessary to avoid bugs in subgrove
+;(define (doc-root) (node-property 'docelem (current-root))) 
+(define doc-root current-root)
+
+(mode test-mode
+
+(query 
+  (q-element 'A (doc-root))
+  (make paragraph (literal "query (priority 1) matching " (gi (current-node))))
+  1)
+  
+(query 
+  (node-list 
+    (q-element 'A (doc-root)) 
+    (q-element 'B (doc-root)))
+  (make paragraph (literal "query (priority 0) matching " (gi (current-node)))))
+  
+(query 
+  (node-list 
+    (q-element 'A (doc-root)) 
+    (q-element 'B (doc-root)) 
+    (q-element 'C (doc-root))) 
+  (make paragraph (literal "query (priority -1) matching " (gi (current-node))))
+  -1)
+  
+(id A (make paragraph (literal "id matching " (gi (current-node)))))
+(id B (make paragraph (literal "id matching " (gi (current-node)))))
+(id C (make paragraph (literal "id matching " (gi (current-node)))))
+(id D (make paragraph (literal "id matching " (gi (current-node)))))
+
+(element A (make paragraph (literal "element matching " (gi (current-node)))))
+(element B (make paragraph (literal "element matching " (gi (current-node)))))
+(element C (make paragraph (literal "element matching " (gi (current-node)))))
+(element D (make paragraph (literal "element matching " (gi (current-node)))))
+(element E (make paragraph (literal "element matching " (gi (current-node)))))
+
+) ; end of test mode
+
+(query 
+  (node-list 
+    (q-element 'A (doc-root)) 
+    (q-element 'B (doc-root)) 
+    (q-element 'C (doc-root)) 
+    (q-element 'D (doc-root)) 
+    (q-element 'E (doc-root)) 
+    (q-element 'F (doc-root))) 
+  (make paragraph (literal "initial mode query (priority 1) matching " (gi (current-node))))
+  1)
+  
+
+(query 
+  (node-list 
+    (q-element 'A (doc-root)) 
+    (q-element 'B (doc-root)) 
+    (q-element 'C (doc-root)) 
+    (q-element 'D (doc-root)) 
+    (q-element 'E (doc-root)) 
+    (q-element 'F (doc-root)) 
+    (q-element 'G (doc-root))) 
+  (make paragraph (literal "initial mode query (priority 0) matching " (gi (current-node)))))
+  
+(query 
+  (node-list 
+    (q-element 'A (doc-root)) 
+    (q-element 'B (doc-root)) 
+    (q-element 'C (doc-root)) 
+    (q-element 'D (doc-root)) 
+    (q-element 'E (doc-root)) 
+    (q-element 'F (doc-root)) 
+    (q-element 'G (doc-root)) 
+    (q-element 'H (doc-root))) 
+  (make paragraph (literal "initial mode query (priority -1) matching " (gi (current-node))))
+  -1)
+  
+(id A (make paragraph (literal "initial mode id matching " (gi (current-node)))))
+(id B (make paragraph (literal "initial mode id matching " (gi (current-node)))))
+(id C (make paragraph (literal "initial mode id matching " (gi (current-node)))))
+(id D (make paragraph (literal "initial mode id matching " (gi (current-node)))))
+(id E (make paragraph (literal "initial mode id matching " (gi (current-node)))))
+(id F (make paragraph (literal "initial mode id matching " (gi (current-node)))))
+(id G (make paragraph (literal "initial mode id matching " (gi (current-node)))))
+(id H (make paragraph (literal "initial mode id matching " (gi (current-node)))))
+(id I (make paragraph (literal "initial mode id matching " (gi (current-node)))))
+
+(element A (make paragraph (literal "initial mode element matching " (gi (current-node)))))
+(element B (make paragraph (literal "initial mode element matching " (gi (current-node)))))
+(element C (make paragraph (literal "initial mode element matching " (gi (current-node)))))
+(element D (make paragraph (literal "initial mode element matching " (gi (current-node)))))
+(element E (make paragraph (literal "initial mode element matching " (gi (current-node)))))
+(element F (make paragraph (literal "initial mode element matching " (gi (current-node)))))
+(element G (make paragraph (literal "initial mode element matching " (gi (current-node)))))
+(element H (make paragraph (literal "initial mode element matching " (gi (current-node)))))
+(element I (make paragraph (literal "initial mode element matching " (gi (current-node)))))
+(element J (make paragraph (literal "initial mode element matching " (gi (current-node)))))
+
+<style-specification id=test2>
+
+(query 
+  (node-list 
+    (q-element 'A (doc-root)) 
+    (q-element 'B (doc-root)) 
+    (q-element 'C (doc-root)) 
+    (q-element 'D (doc-root)) 
+    (q-element 'E (doc-root)) 
+    (q-element 'F (doc-root)) 
+    (q-element 'G (doc-root)) 
+    (q-element 'H (doc-root)) 
+    (q-element 'I (doc-root)) 
+    (q-element 'J (doc-root)) 
+    (q-element 'K (doc-root))) 
+  (make paragraph (literal "part 2 initial mode query (priority 1) matching " (gi (current-node))))
+  1)
+  
+
+(query 
+  (node-list 
+    (q-element 'A (doc-root)) 
+    (q-element 'B (doc-root)) 
+    (q-element 'C (doc-root)) 
+    (q-element 'D (doc-root)) 
+    (q-element 'E (doc-root)) 
+    (q-element 'F (doc-root)) 
+    (q-element 'G (doc-root)) 
+    (q-element 'H (doc-root)) 
+    (q-element 'I (doc-root)) 
+    (q-element 'J (doc-root)) 
+    (q-element 'K (doc-root)) 
+    (q-element 'L (doc-root))) 
+  (make paragraph (literal "part 2 initial mode query (priority 0) matching " (gi (current-node)))))
+  
+(query 
+  (node-list 
+    (q-element 'A (doc-root)) 
+    (q-element 'B (doc-root)) 
+    (q-element 'C (doc-root)) 
+    (q-element 'D (doc-root)) 
+    (q-element 'E (doc-root)) 
+    (q-element 'F (doc-root)) 
+    (q-element 'G (doc-root)) 
+    (q-element 'H (doc-root)) 
+    (q-element 'I (doc-root)) 
+    (q-element 'J (doc-root)) 
+    (q-element 'K (doc-root)) 
+    (q-element 'L (doc-root)) 
+    (q-element 'M (doc-root))) 
+  (make paragraph (literal "part 2 initial mode query (priority -1) matching " (gi (current-node))))
+  -1)
+  
+(id A (make paragraph (literal "part 2 initial mode id matching " (gi (current-node)))))
+(id B (make paragraph (literal "part 2 initial mode id matching " (gi (current-node)))))
+(id C (make paragraph (literal "part 2 initial mode id matching " (gi (current-node)))))
+(id D (make paragraph (literal "part 2 initial mode id matching " (gi (current-node)))))
+(id E (make paragraph (literal "part 2 initial mode id matching " (gi (current-node)))))
+(id F (make paragraph (literal "part 2 initial mode id matching " (gi (current-node)))))
+(id G (make paragraph (literal "part 2 initial mode id matching " (gi (current-node)))))
+(id H (make paragraph (literal "part 2 initial mode id matching " (gi (current-node)))))
+(id I (make paragraph (literal "part 2 initial mode id matching " (gi (current-node)))))
+(id J (make paragraph (literal "part 2 initial mode id matching " (gi (current-node)))))
+(id K (make paragraph (literal "part 2 initial mode id matching " (gi (current-node)))))
+(id L (make paragraph (literal "part 2 initial mode id matching " (gi (current-node)))))
+(id M (make paragraph (literal "part 2 initial mode id matching " (gi (current-node)))))
+(id N (make paragraph (literal "part 2 initial mode id matching " (gi (current-node)))))
+
+(element A (make paragraph (literal "part 2 initial mode element matching " (gi (current-node)))))
+(element B (make paragraph (literal "part 2 initial mode element matching " (gi (current-node)))))
+(element C (make paragraph (literal "part 2 initial mode element matching " (gi (current-node)))))
+(element D (make paragraph (literal "part 2 initial mode element matching " (gi (current-node)))))
+(element E (make paragraph (literal "part 2 initial mode element matching " (gi (current-node)))))
+(element F (make paragraph (literal "part 2 initial mode element matching " (gi (current-node)))))
+(element G (make paragraph (literal "part 2 initial mode element matching " (gi (current-node)))))
+(element H (make paragraph (literal "part 2 initial mode element matching " (gi (current-node)))))
+(element I (make paragraph (literal "part 2 initial mode element matching " (gi (current-node)))))
+(element J (make paragraph (literal "part 2 initial mode element matching " (gi (current-node)))))
+(element K (make paragraph (literal "part 2 initial mode element matching " (gi (current-node)))))
+(element L (make paragraph (literal "part 2 initial mode element matching " (gi (current-node)))))
+(element M (make paragraph (literal "part 2 initial mode element matching " (gi (current-node)))))
+(element N (make paragraph (literal "part 2 initial mode element matching " (gi (current-node)))))
+(element O (make paragraph (literal "part 2 initial mode element matching " (gi (current-node)))))
+
+(default (make paragraph (literal "part 2 initial mode default matching " (gi (current-node)))))
+
--- openjade-1.4devel1.orig/testsuite/specificity.expected
+++ openjade-1.4devel1/testsuite/specificity.expected
@@ -0,0 +1,54 @@
+<?xml version="1.0"?>
+<fot>
+<simple-page-sequence>
+<paragraph>
+<a name="0"/>
+<text>query (priority 1) matching A</text>
+</paragraph>
+<paragraph>
+<text>query (priority 0) matching B</text>
+</paragraph>
+<paragraph>
+<text>query (priority -1) matching C</text>
+</paragraph>
+<paragraph>
+<text>id matching D</text>
+</paragraph>
+<paragraph>
+<text>element matching E</text>
+</paragraph>
+<paragraph>
+<text>initial mode query (priority 1) matching F</text>
+</paragraph>
+<paragraph>
+<text>initial mode query (priority 0) matching G</text>
+</paragraph>
+<paragraph>
+<text>initial mode query (priority -1) matching H</text>
+</paragraph>
+<paragraph>
+<text>initial mode id matching I</text>
+</paragraph>
+<paragraph>
+<text>initial mode element matching J</text>
+</paragraph>
+<paragraph>
+<text>part 2 initial mode query (priority 1) matching K</text>
+</paragraph>
+<paragraph>
+<text>part 2 initial mode query (priority 0) matching L</text>
+</paragraph>
+<paragraph>
+<text>part 2 initial mode query (priority -1) matching M</text>
+</paragraph>
+<paragraph>
+<text>part 2 initial mode id matching N</text>
+</paragraph>
+<paragraph>
+<text>part 2 initial mode element matching O</text>
+</paragraph>
+<paragraph>
+<text>part 2 initial mode default matching P</text>
+</paragraph>
+</simple-page-sequence>
+</fot>
--- openjade-1.4devel1.orig/testsuite/specificity.sgml
+++ openjade-1.4devel1/testsuite/specificity.sgml
@@ -0,0 +1,10 @@
+<!doctype test [
+<!entity % elts "(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p)" >
+<!element test - - %elts; >
+<!element %elts; - o empty > 
+<!attlist %elts id ID #required > 
+]>
+<test>
+<a id=a><b id=b><c id=c><d id=d><e id=e><f id=f><g id=g><h id=h>
+<i id=i><j id=j><k id=k><l id=l><m id=m><n id=n><o id=o><p id=p>
+</test>
--- openjade-1.4devel1.orig/unicode/Makefile.am
+++ openjade-1.4devel1/unicode/Makefile.am
@@ -0,0 +1,11 @@
+## Process this file with automake to produce Makefile.in
+
+pkgdatadir = $(datadir)/@PACKAGE@/unicode
+
+pkgdata_DATA = catalog demo.sgm unicode.sd unicode.syn
+
+pkgdata_SCRIPTS = gensyntax.pl
+
+EXTRA_DIST = catalog demo.sgm gensyntax.pl unicode.sd unicode.syn
+
+MAINTAINERCLEANFILES = Makefile.in
--- openjade-1.4devel1.orig/unicode/catalog
+++ openjade-1.4devel1/unicode/catalog
@@ -0,0 +1,5 @@
+PUBLIC
+"-//SGML Open:TR95xx//SYNTAX Extended (ISO/IEC 10646-1:1993 repertoire)//EN"
+unicode.syn
+
+SGMLDECL unicode.sd
--- openjade-1.4devel1.orig/unicode/demo.sgm
+++ openjade-1.4devel1/unicode/demo.sgm
@@ -0,0 +1,5 @@
+<!doctype doc [
+<!element doc - o empty>
+<!attlist doc a nmtokens #implied>
+]>
+<doc a="&#224;&#428;&#40869;x&#12526;y">
--- openjade-1.4devel1.orig/unicode/gensyntax.pl
+++ openjade-1.4devel1/unicode/gensyntax.pl
@@ -0,0 +1,224 @@
+#! /usr/bin/perl
+
+# Feed this ftp://unicode.org/MappingTables/UnicodeData-1.1.4.txt.
+
+$compat_start = 0xfb00;
+
+# Small Kana
+$uc[12353] = 12354;
+$is_uc[12354] = 1;
+$uc[12355] = 12356;
+$is_uc[12356] = 1;
+$uc[12357] = 12358;
+$is_uc[12358] = 1;
+$uc[12359] = 12360;
+$is_uc[12360] = 1;
+$uc[12361] = 12362;
+$is_uc[12362] = 1;
+$uc[12387] = 12388;
+$is_uc[12388] = 1;
+$uc[12419] = 12420;
+$is_uc[12420] = 1;
+$uc[12421] = 12422;
+$is_uc[12422] = 1;
+$uc[12423] = 12424;
+$is_uc[12424] = 1;
+$uc[12430] = 12430;
+$is_uc[12430] = 1;
+$uc[12449] = 12450;
+$is_uc[12450] = 1;
+$uc[12451] = 12452;
+$is_uc[12452] = 1;
+$uc[12453] = 12454;
+$is_uc[12454] = 1;
+$uc[12455] = 12456;
+$is_uc[12456] = 1;
+$uc[12457] = 12458;
+$is_uc[12458] = 1;
+$uc[12483] = 12484;
+$is_uc[12484] = 1;
+$uc[12515] = 12516;
+$is_uc[12516] = 1;
+$uc[12517] = 12518;
+$is_uc[12518] = 1;
+$uc[12519] = 12520;
+$is_uc[12520] = 1;
+$uc[12526] = 12527;
+$is_uc[12527] = 1;
+
+while (<>) {
+    next if /^#/;
+    @F = split(';');
+    $code = hex($F[0]);
+    next if $code < 0x200c && $F[2] eq "Cc";
+    $type[$code] = $F[2];
+    # 0x17f maps to 0x53, but SGML doesn't allow that.
+    if ($F[12] && hex($F[12]) > 128) {
+	$uc[$code] = hex($F[12]);
+	$is_uc[hex($F[12])] = 1;
+    }
+    if ($F[2] eq "Zs") {
+	$name[$code] = $F[1];
+    }
+	
+    if ($code == 0x4e00) {
+	foreach $code (0x4e00 .. 0x9fa5) {
+	    $type[$code] = $F[2];
+	}
+	foreach $code (0xf900 .. 0xfa2e) {
+	    $type[$code] = $F[2];
+	}
+    }
+}
+
+print <<EOF;
+SHUNCHAR CONTROLS
+BASESET "ISO Registration Number 176//CHARSET
+ISO/IEC 10646-1:1993 UCS-2 with implementation level 3//ESC 2/5 2/15 4/5"
+
+DESCSET         0               65536   0        -- 16 bit --
+
+FUNCTION        RE                      13
+                RS                      10
+                SPACE                   32       
+                TAB             SEPCHAR 9
+EOF
+
+foreach $code (128 .. $#type) {
+    if ($type[$code] eq "Zs") {
+	$s = $name[$code];
+	$s =~ s/ /-/g;
+	print("\"$s\" SEPCHAR $code\n");
+    }
+}
+
+print "NAMING\n";
+
+$is_nmstrt{"Lu"} = 1;
+$is_nmstrt{"Ll"} = 1;
+$is_nmchar{"Lm"} = 1;
+$is_nmstrt{"Lo"} = 1;
+$is_nmchar{"Mn"} = 1;
+$is_nmchar{"Mc"} = 1;
+$is_nmchar{"Nd"} = 1;
+$is_nmstrt{"No"} = 1;
+$is_nmstrt{"Cc"} = 1; # >= 0x200c
+$is_sr{"Cc"} = 1; # >= 0x200c
+$is_sr{"Pd"} = 1;
+$is_sr{"Ps"} = 1;
+$is_sr{"Pe"} = 1;
+$is_sr{"Po"} = 1;
+$is_sr{"Sm"} = 1;
+$is_sr{"Sc"} = 1;
+$is_sr{"So"} = 1;
+$is_sr{"Zs"} = 1;
+$is_sr{"Zl"} = 1;
+$is_sr{"Zp"} = 1;
+
+print "LCNMSTRT\n";
+foreach $code (128 .. $#type) {
+
+    if ($uc[$code] && $code < $compat_start) {
+	&output($code);
+    }
+    
+}
+&flush();
+
+print "UCNMSTRT\n";
+
+foreach $code (128 .. $#type) {
+    if ($uc[$code] && $code < $compat_start) {
+	&output($uc[$code]);
+    }
+    
+}
+&flush();
+
+print "NAMESTRT\n";
+foreach $code (128 .. $#type) {
+    if (!$uc[$code] && !$is_uc[$code]
+	&& $is_nmstrt{$type[$code]} && $code < $compat_start) {
+	&output($code);
+    }
+    
+}
+&flush();
+
+print "LCNMCHAR\n";
+&output(ord("-"));
+&output(ord("."));
+&flush();
+
+print "UCNMCHAR\n";
+&output(ord("-"));
+&output(ord("."));
+&flush();
+
+print "NAMECHAR\n";
+foreach $code (128 .. $#type) {
+    if ($is_nmchar{$type[$code]} && $code < $compat_start) {
+	&output($code);
+    }
+    
+}
+&flush();
+
+print <<EOF;
+NAMECASE   GENERAL    YES
+           ENTITY     NO
+DELIM      GENERAL    SGMLREF
+	   SHORTREF   SGMLREF
+EOF
+
+foreach $code (128 .. $#type) {
+    if ($is_sr{$type[$code]}) {
+	&output($code);
+    }
+    
+}
+
+&flush;
+
+print <<EOF;
+NAMES           SGMLREF 
+
+QUANTITY        SGMLREF         -- To be determined --
+        ATTSPLEN        1920    -- ?? --
+        LITLEN          240     -- ?? --
+        NAMELEN         240     -- ?? --
+        PILEN           1920    -- ?? --
+        TAGLEN          1920    -- ?? --
+EOF
+
+
+sub output {
+    $ch = $_[0];
+    if ($pending > 0 && $base + $pending == $ch) {
+	$pending++;
+    }
+    else {
+	&flush;
+	$base = $ch;
+	$pending = 1;
+    }
+}
+
+sub flush {
+    if ($pending > 0) {
+	printf("%d", $base);
+	if ($pending > 1) {
+	    if ($pending > 2) {
+		print "-";
+	    }
+	    else {
+		print "\n";
+	    }
+	    printf("%d", $base + ($pending - 1));
+	}
+	print "\n";
+	$count += $pending;
+	$pending = 0;
+    }
+}
+
--- openjade-1.4devel1.orig/unicode/unicode.sd
+++ openjade-1.4devel1/unicode/unicode.sd
@@ -0,0 +1,24 @@
+<!SGML "ISO 8879:1986"
+CHARSET
+BASESET 
+"ISO Registration Number 176//CHARSET
+ISO/IEC 10646-1:1993 UCS-2 with implementation level 3//ESC 2/5 2/15 4/5"
+DESCSET     0    9   UNUSED
+	    9    2   9
+	   11    2   UNUSED
+	   13    1   13
+	   14   18   UNUSED
+	   32   95   32
+	  127    1   UNUSED
+          128   32   UNUSED
+          160  65376 160
+CAPACITY     PUBLIC "ISO 8879:1986//CAPACITY Reference//EN"
+
+SCOPE        DOCUMENT
+SYNTAX PUBLIC 
+"-//SGML Open:TR95xx//SYNTAX Extended (ISO/IEC 10646-1:1993 repertoire)//EN"
+FEATURES
+MINIMIZE   DATATAG   NO   OMITTAG    YES          RANK       NO    SHORTTAG YES
+LINK       SIMPLE    NO   IMPLICIT   NO           EXPLICIT   NO
+OTHER      CONCUR    NO   SUBDOC     YES 99999999 FORMAL     YES
+APPINFO    NONE>
--- openjade-1.4devel1.orig/unicode/unicode.syn
+++ openjade-1.4devel1/unicode/unicode.syn
@@ -0,0 +1,1272 @@
+SHUNCHAR CONTROLS
+BASESET "ISO Registration Number 176//CHARSET
+ISO/IEC 10646-1:1993 UCS-2 with implementation level 3//ESC 2/5 2/15 4/5"
+
+DESCSET         0               65536   0        -- 16 bit --
+
+FUNCTION        RE                      13
+                RS                      10
+                SPACE                   32       
+                TAB             SEPCHAR 9
+"NO-BREAK-SPACE" SEPCHAR 160
+"EN-QUAD" SEPCHAR 8192
+"EM-QUAD" SEPCHAR 8193
+"EN-SPACE" SEPCHAR 8194
+"EM-SPACE" SEPCHAR 8195
+"THREE-PER-EM-SPACE" SEPCHAR 8196
+"FOUR-PER-EM-SPACE" SEPCHAR 8197
+"SIX-PER-EM-SPACE" SEPCHAR 8198
+"FIGURE-SPACE" SEPCHAR 8199
+"PUNCTUATION-SPACE" SEPCHAR 8200
+"THIN-SPACE" SEPCHAR 8201
+"HAIR-SPACE" SEPCHAR 8202
+"ZERO-WIDTH-SPACE" SEPCHAR 8203
+"IDEOGRAPHIC-SPACE" SEPCHAR 12288
+"ZERO-WIDTH-NO-BREAK-SPACE" SEPCHAR 65279
+NAMING
+LCNMSTRT
+224-246
+248-255
+257
+259
+261
+263
+265
+267
+269
+271
+273
+275
+277
+279
+281
+283
+285
+287
+289
+291
+293
+295
+297
+299
+301
+303
+307
+309
+311
+314
+316
+318
+320
+322
+324
+326
+328
+331
+333
+335
+337
+339
+341
+343
+345
+347
+349
+351
+353
+355
+357
+359
+361
+363
+365
+367
+369
+371
+373
+375
+378
+380
+382
+387
+389
+392
+396
+402
+409
+417
+419
+421
+424
+429
+432
+436
+438
+441
+445
+453
+454
+456
+457
+459
+460
+462
+464
+466
+468
+470
+472
+474
+476
+479
+481
+483
+485
+487
+489
+491
+493
+495
+498
+499
+501
+507
+509
+511
+513
+515
+517
+519
+521
+523
+525
+527
+529
+531
+533
+535
+595
+596
+599-601
+603
+608
+611
+616
+617
+623
+626
+643
+648
+650
+651
+658
+940-943
+945-961
+963-974
+976
+977
+981
+982
+995
+997
+999
+1001
+1003
+1005
+1007-1009
+1072-1103
+1105-1116
+1118
+1119
+1121
+1123
+1125
+1127
+1129
+1131
+1133
+1135
+1137
+1139
+1141
+1143
+1145
+1147
+1149
+1151
+1153
+1169
+1171
+1173
+1175
+1177
+1179
+1181
+1183
+1185
+1187
+1189
+1191
+1193
+1195
+1197
+1199
+1201
+1203
+1205
+1207
+1209
+1211
+1213
+1215
+1218
+1220
+1224
+1228
+1233
+1235
+1237
+1239
+1241
+1243
+1245
+1247
+1249
+1251
+1253
+1255
+1257
+1259
+1263
+1265
+1267
+1269
+1273
+1377-1414
+7681
+7683
+7685
+7687
+7689
+7691
+7693
+7695
+7697
+7699
+7701
+7703
+7705
+7707
+7709
+7711
+7713
+7715
+7717
+7719
+7721
+7723
+7725
+7727
+7729
+7731
+7733
+7735
+7737
+7739
+7741
+7743
+7745
+7747
+7749
+7751
+7753
+7755
+7757
+7759
+7761
+7763
+7765
+7767
+7769
+7771
+7773
+7775
+7777
+7779
+7781
+7783
+7785
+7787
+7789
+7791
+7793
+7795
+7797
+7799
+7801
+7803
+7805
+7807
+7809
+7811
+7813
+7815
+7817
+7819
+7821
+7823
+7825
+7827
+7829
+7841
+7843
+7845
+7847
+7849
+7851
+7853
+7855
+7857
+7859
+7861
+7863
+7865
+7867
+7869
+7871
+7873
+7875
+7877
+7879
+7881
+7883
+7885
+7887
+7889
+7891
+7893
+7895
+7897
+7899
+7901
+7903
+7905
+7907
+7909
+7911
+7913
+7915
+7917
+7919
+7921
+7923
+7925
+7927
+7929
+7936-7943
+7952-7957
+7968-7975
+7984-7991
+8000-8005
+8017
+8019
+8021
+8023
+8032-8039
+8048-8061
+8064-8071
+8080-8087
+8096-8103
+8112
+8113
+8115
+8131
+8144
+8145
+8160
+8161
+8165
+8179
+8560-8575
+9424-9449
+12353
+12355
+12357
+12359
+12361
+12387
+12419
+12421
+12423
+12430
+12449
+12451
+12453
+12455
+12457
+12483
+12515
+12517
+12519
+12526
+UCNMSTRT
+192-214
+216-222
+376
+256
+258
+260
+262
+264
+266
+268
+270
+272
+274
+276
+278
+280
+282
+284
+286
+288
+290
+292
+294
+296
+298
+300
+302
+306
+308
+310
+313
+315
+317
+319
+321
+323
+325
+327
+330
+332
+334
+336
+338
+340
+342
+344
+346
+348
+350
+352
+354
+356
+358
+360
+362
+364
+366
+368
+370
+372
+374
+377
+379
+381
+386
+388
+391
+395
+401
+408
+416
+418
+420
+423
+428
+431
+435
+437
+440
+444
+452
+452
+455
+455
+458
+458
+461
+463
+465
+467
+469
+471
+473
+475
+478
+480
+482
+484
+486
+488
+490
+492
+494
+497
+497
+500
+506
+508
+510
+512
+514
+516
+518
+520
+522
+524
+526
+528
+530
+532
+534
+385
+390
+394
+398-400
+403
+404
+407
+406
+412
+413
+425
+430
+433
+434
+439
+902
+904-906
+913-929
+931-939
+908
+910
+911
+914
+920
+934
+928
+994
+996
+998
+1000
+1002
+1004
+1006
+922
+929
+1040-1071
+1025-1036
+1038
+1039
+1120
+1122
+1124
+1126
+1128
+1130
+1132
+1134
+1136
+1138
+1140
+1142
+1144
+1146
+1148
+1150
+1152
+1168
+1170
+1172
+1174
+1176
+1178
+1180
+1182
+1184
+1186
+1188
+1190
+1192
+1194
+1196
+1198
+1200
+1202
+1204
+1206
+1208
+1210
+1212
+1214
+1217
+1219
+1223
+1227
+1232
+1234
+1236
+1238
+1240
+1242
+1244
+1246
+1248
+1250
+1252
+1254
+1256
+1258
+1262
+1264
+1266
+1268
+1272
+1329-1366
+7680
+7682
+7684
+7686
+7688
+7690
+7692
+7694
+7696
+7698
+7700
+7702
+7704
+7706
+7708
+7710
+7712
+7714
+7716
+7718
+7720
+7722
+7724
+7726
+7728
+7730
+7732
+7734
+7736
+7738
+7740
+7742
+7744
+7746
+7748
+7750
+7752
+7754
+7756
+7758
+7760
+7762
+7764
+7766
+7768
+7770
+7772
+7774
+7776
+7778
+7780
+7782
+7784
+7786
+7788
+7790
+7792
+7794
+7796
+7798
+7800
+7802
+7804
+7806
+7808
+7810
+7812
+7814
+7816
+7818
+7820
+7822
+7824
+7826
+7828
+7840
+7842
+7844
+7846
+7848
+7850
+7852
+7854
+7856
+7858
+7860
+7862
+7864
+7866
+7868
+7870
+7872
+7874
+7876
+7878
+7880
+7882
+7884
+7886
+7888
+7890
+7892
+7894
+7896
+7898
+7900
+7902
+7904
+7906
+7908
+7910
+7912
+7914
+7916
+7918
+7920
+7922
+7924
+7926
+7928
+7944-7951
+7960-7965
+7976-7983
+7992-7999
+8008-8013
+8025
+8027
+8029
+8031
+8040-8047
+8122
+8123
+8136-8139
+8154
+8155
+8184
+8185
+8170
+8171
+8186
+8187
+8072-8079
+8088-8095
+8104-8111
+8120
+8121
+8124
+8140
+8152
+8153
+8168
+8169
+8172
+8188
+8544-8559
+9398-9423
+12354
+12356
+12358
+12360
+12362
+12388
+12420
+12422
+12424
+12430
+12450
+12452
+12454
+12456
+12458
+12484
+12516
+12518
+12520
+12527
+NAMESTRT
+223
+304
+305
+312
+329
+383
+384
+393
+397
+405
+410
+411
+414
+415
+422
+426
+427
+442
+443
+446-451
+477
+496
+592-594
+597
+598
+602
+604-607
+609
+610
+612-615
+618-622
+624
+625
+627-642
+644-647
+649
+652-657
+659-680
+912
+944
+962
+978-980
+986
+988
+990
+992
+1010
+1011
+1216
+1415
+1488-1514
+1520-1522
+1569-1594
+1600-1610
+1649-1719
+1722-1726
+1728-1742
+1744-1747
+1749
+2309-2361
+2392-2401
+2437-2444
+2447
+2448
+2451-2472
+2474-2480
+2482
+2486-2489
+2524
+2525
+2527-2529
+2544
+2545
+2565-2570
+2575
+2576
+2579-2600
+2602-2608
+2610
+2611
+2613
+2614
+2616
+2617
+2649-2652
+2654
+2693-2699
+2701
+2703-2705
+2707-2728
+2730-2736
+2738
+2739
+2741-2745
+2784
+2821-2828
+2831
+2832
+2835-2856
+2858-2864
+2866
+2867
+2870-2873
+2908
+2909
+2911-2913
+2949-2954
+2958-2960
+2962-2965
+2969
+2970
+2972
+2974
+2975
+2979
+2980
+2984-2986
+2990-2997
+2999-3001
+3056-3058
+3077-3084
+3086-3088
+3090-3112
+3114-3123
+3125-3129
+3168
+3169
+3205-3212
+3214-3216
+3218-3240
+3242-3251
+3253-3257
+3294
+3296
+3297
+3333-3340
+3342-3344
+3346-3368
+3370-3385
+3424
+3425
+3585-3632
+3634
+3635
+3648-3654
+3663
+3674
+3675
+3713
+3714
+3716
+3719
+3720
+3722
+3725
+3732-3735
+3737-3743
+3745-3747
+3749
+3751
+3754
+3755
+3757
+3758
+3760
+3762
+3763
+3773
+3776-3780
+4256-4293
+4304-4342
+4352-4441
+4447-4514
+4520-4601
+7830-7834
+8016
+8018
+8020
+8022
+8114
+8116
+8118
+8119
+8130
+8132
+8134
+8135
+8146
+8147
+8150
+8151
+8162-8164
+8166
+8167
+8178
+8180
+8182
+8183
+8204-8207
+8234-8238
+8298-8303
+12295
+12321-12329
+12363-12386
+12389-12418
+12425-12429
+12431-12436
+12459-12482
+12485-12514
+12521-12525
+12528-12538
+12549-12588
+12593-12686
+13312-40869
+63744-64046
+LCNMCHAR
+45
+46
+UCNMCHAR
+45
+46
+NAMECHAR
+168
+175
+180
+184
+688-734
+736-745
+768-837
+864
+865
+890
+900
+901
+1155-1158
+1369
+1456-1465
+1467-1469
+1471
+1473
+1474
+1611-1618
+1632-1641
+1648
+1750-1768
+1770-1773
+1776-1785
+2305-2307
+2364
+2366-2381
+2385-2388
+2402
+2403
+2406-2415
+2433-2435
+2492
+2494-2500
+2503
+2504
+2507-2509
+2519
+2530
+2531
+2534-2543
+2562
+2620
+2622-2626
+2631
+2632
+2635-2637
+2662-2673
+2689-2691
+2748
+2750-2757
+2759-2761
+2763-2765
+2790-2799
+2817-2819
+2876
+2878-2883
+2887
+2888
+2891-2893
+2902
+2903
+2918-2927
+2946
+2947
+3006-3010
+3014-3016
+3018-3021
+3031
+3047-3055
+3073-3075
+3134-3140
+3142-3144
+3146-3149
+3157
+3158
+3174-3183
+3202
+3203
+3262-3268
+3270-3272
+3274-3277
+3285
+3286
+3302-3311
+3330
+3331
+3390-3395
+3398-3400
+3402-3405
+3415
+3430-3439
+3633
+3636-3642
+3655-3662
+3664-3673
+3761
+3764-3769
+3771
+3772
+3784-3789
+3792-3801
+8125-8129
+8141-8143
+8157-8159
+8173-8175
+8189
+8190
+8400-8417
+9332-9340
+9352-9360
+9450
+12330-12335
+12441-12446
+12540-12542
+NAMECASE   GENERAL    YES
+           ENTITY     NO
+DELIM      GENERAL    SGMLREF
+	   SHORTREF   SGMLREF
+160-167
+169-174
+176-179
+181-183
+185-191
+215
+247
+884
+885
+894
+903
+1154
+1370-1375
+1417
+1470
+1472
+1475
+1523
+1524
+1548
+1563
+1567
+1642-1645
+1748
+1769
+2365
+2384
+2404
+2405
+2416
+2546-2554
+2674-2676
+2749
+2768
+2877
+2928
+3647
+3759
+3782
+3804
+3805
+4347
+8192-8238
+8240-8262
+8298-8304
+8308-8334
+8352-8362
+8448-8504
+8531-8578
+8592-8682
+8704-8945
+8960
+8962-9082
+9216-9252
+9280-9290
+9312-9331
+9341-9351
+9361-9449
+9472-9621
+9632-9711
+9728-9747
+9754-9839
+9985-9988
+9990-9993
+9996-10023
+10025-10059
+10061
+10063-10066
+10070
+10072-10078
+10081-10087
+10102-10132
+10136-10159
+10161-10174
+12288-12294
+12296-12320
+12336-12343
+12351
+12539
+12688-12703
+12800-12828
+12832-12867
+12896-12923
+12927-12976
+12992-13003
+13008-13054
+13056-13174
+13179-13277
+13280-13310
+64297
+64830
+64831
+65072-65092
+65097-65106
+65108-65126
+65128-65131
+65279
+65281-65295
+65306-65312
+65339-65344
+65371-65374
+65377-65381
+65392
+65438
+65439
+65504-65510
+65512-65518
+65533
+NAMES           SGMLREF 
+
+QUANTITY        SGMLREF         -- To be determined --
+        ATTSPLEN        1920    -- ?? --
+        LITLEN          240     -- ?? --
+        NAMELEN         240     -- ?? --
+        PILEN           1920    -- ?? --
+        TAGLEN          1920    -- ?? --
