From 37b14bbb149dfd0944c20b9da6ea472eb2f669cd Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Albertas=20Vy=C5=A1niauskas?= <thezbyg@gmail.com>
Date: Sun, 27 Dec 2020 20:27:58 +0200
Subject: [PATCH] Refactor color structure.

Fix type conversion and other warnings.
---
 source/BlendColors.cpp                        |   48 +-
 source/BrightnessDarkness.cpp                 |   19 +-
 source/Clipboard.cpp                          |    4 +-
 source/Color.cpp                              | 1284 +++++++----------
 source/Color.h                                |  929 ++++++------
 source/ColorMixer.cpp                         |   48 +-
 source/ColorPicker.cpp                        |   46 +-
 source/ColorRYB.cpp                           |   23 +-
 source/ColorWheelType.cpp                     |    6 +-
 source/GenerateScheme.cpp                     |   32 +-
 source/HtmlUtils.cpp                          |   73 +-
 source/HtmlUtils.h                            |   23 +-
 source/ImportExport.cpp                       |   82 +-
 source/MathUtil.cpp                           |   86 +-
 source/MathUtil.h                             |   27 -
 source/Sampler.cpp                            |   38 +-
 source/StandardDragDropHandler.cpp            |    2 +-
 source/StandardMenu.cpp                       |    6 +-
 source/Variations.cpp                         |   43 +-
 source/Vector2.h                              |    4 +-
 source/color_names/ColorNames.cpp             |   33 +-
 source/dynv/Map.cpp                           |    1 -
 source/dynv/Types.cpp                         |   16 +-
 source/dynv/Xml.cpp                           |    4 +-
 source/gtk/ColorCell.cpp                      |    2 +-
 source/gtk/ColorComponent.cpp                 |  195 ++-
 source/gtk/ColorComponent.h                   |    2 +-
 source/gtk/ColorWheel.cpp                     |   87 +-
 source/gtk/ColorWheel.h                       |    4 +-
 source/gtk/ColorWidget.cpp                    |  117 +-
 source/gtk/ColorWidget.h                      |    4 +-
 source/gtk/LayoutPreview.cpp                  |   24 +-
 source/gtk/LayoutPreview.h                    |    6 +-
 source/gtk/Range2D.cpp                        |   56 +-
 source/gtk/Shapes.cpp                         |   55 +
 source/{ColorUtils.h => gtk/Shapes.h}         |   24 +-
 source/gtk/Swatch.cpp                         |   87 +-
 source/gtk/Swatch.h                           |    4 +-
 source/gtk/Zoomed.cpp                         |   36 +-
 source/gtk/Zoomed.h                           |    6 +-
 source/layout/Box.cpp                         |    4 +-
 source/layout/Style.cpp                       |    2 +-
 source/lua/Color.cpp                          |   78 +-
 source/lua/Layout.cpp                         |    8 +-
 source/math/Algorithms.h                      |  103 ++
 source/math/Matrix.h                          |  202 +++
 source/math/Vector.h                          |  291 ++++
 source/parser/TextFileParser.rl               |   52 +-
 source/test/Color.cpp                         |   88 ++
 source/test/Dynv.cpp                          |    6 +-
 source/test/Matrix.cpp                        |   49 +
 source/test/TextFileParser.cpp                |   39 +-
 source/tools/ColorSpaceSampler.cpp            |   30 +-
 source/tools/PaletteFromImage.cpp             |    6 +-
 source/transformation/Chain.cpp               |    6 +-
 .../transformation/ColorVisionDeficiency.cpp  |   11 +-
 source/transformation/GammaModification.cpp   |   15 +-
 source/transformation/Quantization.cpp        |    2 +-
 source/transformation/Transformation.cpp      |    2 +-
 source/uiApp.cpp                              |    2 +-
 source/uiColorInput.cpp                       |    4 +-
 source/uiDialogAutonumber.cpp                 |    7 +-
 source/uiDialogGenerate.cpp                   |   32 +-
 source/uiDialogMix.cpp                        |   43 +-
 source/uiDialogOptions.cpp                    |    4 +-
 source/uiDialogSort.cpp                       |   76 +-
 source/uiDialogVariations.cpp                 |   37 +-
 67 files changed, 2531 insertions(+), 2254 deletions(-)
 create mode 100644 source/gtk/Shapes.cpp
 rename source/{ColorUtils.h => gtk/Shapes.h} (78%)
 create mode 100644 source/math/Algorithms.h
 create mode 100644 source/math/Matrix.h
 create mode 100644 source/math/Vector.h
 create mode 100644 source/test/Color.cpp
 create mode 100644 source/test/Matrix.cpp

diff --git a/source/BlendColors.cpp b/source/BlendColors.cpp
index 5572901..6f8fc92 100644
--- a/source/BlendColors.cpp
+++ b/source/BlendColors.cpp
@@ -20,7 +20,6 @@
 #include "ColorObject.h"
 #include "ColorSource.h"
 #include "ColorSourceManager.h"
-#include "ColorUtils.h"
 #include "uiListPalette.h"
 #include "uiUtilities.h"
 #include "dynv/Map.h"
@@ -122,10 +121,7 @@ struct BlendColorsArgs {
 		Color a, b;
 		gtk_color_get_color(GTK_COLOR(args->startColor), &a);
 		gtk_color_get_color(GTK_COLOR(args->endColor), &b);
-		color_multiply(&a, 0.5f);
-		color_multiply(&b, 0.5f);
-		color_add(&a, &b);
-		gtk_color_set_color(GTK_COLOR(args->middleColor), a);
+		gtk_color_set_color(GTK_COLOR(args->middleColor), ((a.linearRgb() + b.linearRgb()) / 2.0f).nonLinearRgb());
 		args->update();
 	}
 	static void onChange(GtkWidget *, BlendColorsArgs *args) {
@@ -156,18 +152,15 @@ struct BlendColorsArgs {
 			int i = stage;
 			switch (type) {
 			case 0:
-				color_rgb_get_linear(&a, &a);
-				color_rgb_get_linear(&b, &b);
+				a.linearRgbInplace();
+				b.linearRgbInplace();
 				for (; i < steps; ++i) {
-					color_utils::mix(a, b, i / static_cast<float>(steps - 1), r);
-					color_linear_get_rgb(&r, &r);
-					add(r, i, nameAssigner);
+					r = math::mix(a, b, i / static_cast<float>(steps - 1));
+					add(r.nonLinearRgb(), i, nameAssigner);
 				}
 				break;
 			case 1: {
-				Color a_hsv, b_hsv, r_hsv;
-				color_rgb_to_hsv(&a, &a_hsv);
-				color_rgb_to_hsv(&b, &b_hsv);
+				Color a_hsv = a.rgbToHsv(), b_hsv = b.rgbToHsv();
 				if (a_hsv.hsv.hue > b_hsv.hsv.hue) {
 					if (a_hsv.hsv.hue - b_hsv.hsv.hue > 0.5)
 						a_hsv.hsv.hue -= 1;
@@ -176,27 +169,20 @@ struct BlendColorsArgs {
 						b_hsv.hsv.hue -= 1;
 				}
 				for (; i < steps; ++i) {
-					color_utils::mix(a_hsv, b_hsv, i / static_cast<float>(steps - 1), r_hsv);
-					if (r_hsv.hsv.hue < 0) r_hsv.hsv.hue += 1;
-					color_hsv_to_rgb(&r_hsv, &r);
-					add(r, i, nameAssigner);
+					r = math::mix(a_hsv, b_hsv, i / static_cast<float>(steps - 1));
+					if (r.hsv.hue < 0) r.hsv.hue += 1;
+					add(r.hsvToRgb(), i, nameAssigner);
 				}
 			} break;
 			case 2: {
-				Color a_lab, b_lab, r_lab;
-				color_rgb_to_lab_d50(&a, &a_lab);
-				color_rgb_to_lab_d50(&b, &b_lab);
+				Color a_lab = a.rgbToLabD50(), b_lab = b.rgbToLabD50();
 				for (; i < steps; ++i) {
-					color_utils::mix(a_lab, b_lab, i / static_cast<float>(steps - 1), r_lab);
-					color_lab_to_rgb_d50(&r_lab, &r);
-					color_rgb_normalize(&r);
-					add(r, i, nameAssigner);
+					r = math::mix(a_lab, b_lab, i / static_cast<float>(steps - 1));
+					add(r.labToRgbD50().normalizeRgbInplace(), i, nameAssigner);
 				}
 			} break;
 			case 3: {
-				Color a_lch, b_lch, r_lch;
-				color_rgb_to_lch_d50(&a, &a_lch);
-				color_rgb_to_lch_d50(&b, &b_lch);
+				Color a_lch = a.rgbToLchD50(), b_lch = b.rgbToLchD50();
 				if (a_lch.lch.h > b_lch.lch.h) {
 					if (a_lch.lch.h - b_lch.lch.h > 180)
 						a_lch.lch.h -= 360;
@@ -205,11 +191,9 @@ struct BlendColorsArgs {
 						b_lch.lch.h -= 360;
 				}
 				for (; i < steps; ++i) {
-					color_utils::mix(a_lch, b_lch, i / static_cast<float>(steps - 1), r_lch);
-					if (r_lch.lch.h < 0) r_lch.lch.h += 360;
-					color_lch_to_rgb_d50(&r_lch, &r);
-					color_rgb_normalize(&r);
-					add(r, i, nameAssigner);
+					r = math::mix(a_lch, b_lch, i / static_cast<float>(steps - 1));
+					if (r.lch.h < 0) r.lch.h += 360;
+					add(r.lchToRgbD50().normalizeRgbInplace(), i, nameAssigner);
 				}
 			} break;
 			}
diff --git a/source/BrightnessDarkness.cpp b/source/BrightnessDarkness.cpp
index ca8ed85..9bce25a 100644
--- a/source/BrightnessDarkness.cpp
+++ b/source/BrightnessDarkness.cpp
@@ -139,28 +139,27 @@ struct BrightnessDarknessArgs {
 			options->set("brightness", brightness);
 			options->set("darkness", brightness);
 		}
-		Color hslOriginal, hsl, r;
-		color_rgb_to_hsl(&color, &hslOriginal);
+		Color hslOriginal = color.rgbToHsl(), hsl, r;
 		Box *box;
 		std::string name;
 		if (layoutSystem == nullptr)
 			return;
 		for (int i = 1; i <= 4; i++) {
-			color_copy(&hslOriginal, &hsl);
-			hsl.hsl.lightness = mix_float(hsl.hsl.lightness, mix_float(hsl.hsl.lightness, 1, brightness), i / 4.0f);
-			color_hsl_to_rgb(&hsl, &r);
+			hsl = hslOriginal;
+			hsl.hsl.lightness = math::mix(hsl.hsl.lightness, math::mix(hsl.hsl.lightness, 1.0f, brightness), i / 4.0f);
+			r = hsl.hslToRgb();
 			name = format('b', i);
 			box = layoutSystem->GetNamedBox(name.c_str());
 			if (box && box->style) {
-				color_copy(&r, &box->style->color);
+				box->style->color = r;
 			}
-			color_copy(&hslOriginal, &hsl);
-			hsl.hsl.lightness = mix_float(hsl.hsl.lightness, mix_float(hsl.hsl.lightness, 0, darkness), i / 4.0f);
-			color_hsl_to_rgb(&hsl, &r);
+			hsl = hslOriginal;
+			hsl.hsl.lightness = math::mix(hsl.hsl.lightness, math::mix(hsl.hsl.lightness, 0.0f, darkness), i / 4.0f);
+			r = hsl.hslToRgb();
 			name = format('c', i);
 			box = layoutSystem->GetNamedBox(name.c_str());
 			if (box && box->style) {
-				color_copy(&r, &box->style->color);
+				box->style->color = r;
 			}
 		}
 		gtk_widget_queue_draw(GTK_WIDGET(layoutView));
diff --git a/source/Clipboard.cpp b/source/Clipboard.cpp
index 39175b4..0929414 100644
--- a/source/Clipboard.cpp
+++ b/source/Clipboard.cpp
@@ -294,7 +294,7 @@ ColorObject *getFirst(GlobalState *gs) {
 			color.rgb.red = static_cast<float>(data[0] / static_cast<double>(0xFFFF));
 			color.rgb.green = static_cast<float>(data[1] / static_cast<double>(0xFFFF));
 			color.rgb.blue = static_cast<float>(data[2] / static_cast<double>(0xFFFF));
-			color.ma[3] = 0;
+			color[3] = 0;
 			result = new ColorObject("", color);
 			return VisitResult::stop;
 		} break;
@@ -355,7 +355,7 @@ ColorList *getColors(GlobalState *gs) {
 			color.rgb.red = static_cast<float>(data[0] / static_cast<double>(0xFFFF));
 			color.rgb.green = static_cast<float>(data[1] / static_cast<double>(0xFFFF));
 			color.rgb.blue = static_cast<float>(data[2] / static_cast<double>(0xFFFF));
-			color.ma[3] = 0;
+			color[3] = 0;
 			ColorObject *reference;
 			color_list_add_color_object(colorList, (reference = new ColorObject("", color)), false);
 			reference->release();
diff --git a/source/Color.cpp b/source/Color.cpp
index 2835012..bee6492 100644
--- a/source/Color.cpp
+++ b/source/Color.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2009-2016, Albertas Vyšniauskas
+ * Copyright (c) 2009-2020, Albertas Vyšniauskas
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
@@ -17,828 +17,638 @@
  */
 
 #include "Color.h"
-#include <math.h>
-#include "MathUtil.h"
-
-#include <iostream>
-using namespace std;
+#include <cmath>
+#include <string>
+#include <tuple>
+#include <stdexcept>
 
 // Constant used for lab->xyz transform. Should be calculated with maximum accuracy possible.
-#define EPSILON (216.0 / 24389.0)
-
-static vector3 references[][2] = {
-	{{{{109.850, 100.000,  35.585}}}, {{{111.144, 100.000,  35.200}}}},
-	{{{{ 98.074, 100.000, 118.232}}}, {{{ 97.285, 100.000, 116.145}}}},
-	{{{{ 96.422, 100.000,  82.521}}}, {{{ 96.720, 100.000,  81.427}}}},
-	{{{{ 95.682, 100.000,  92.149}}}, {{{ 95.799, 100.000,  90.926}}}},
-	{{{{ 95.047, 100.000, 108.883}}}, {{{ 94.811, 100.000, 107.304}}}},
-	{{{{ 94.972, 100.000, 122.638}}}, {{{ 94.416, 100.000, 120.641}}}},
-	{{{{ 99.187, 100.000,  67.395}}}, {{{103.280, 100.000,  69.026}}}},
-	{{{{ 95.044, 100.000, 108.755}}}, {{{ 95.792, 100.000, 107.687}}}},
-	{{{{100.966, 100.000,  64.370}}}, {{{103.866, 100.000,  65.627}}}},
+const double Epsilon = 216.0 / 24389.0;
+const double Kk = 24389.0 / 27.0;
+const Color Color::white = { 1.0f, 1.0f, 1.0f };
+const Color Color::black = { 0.0f, 0.0f, 0.0f };
+static Color::Matrix3d sRGBTransformation;
+static Color::Matrix3d sRGBTransformationInverted;
+static Color::Matrix3d d65d50AdaptationMatrixValue;
+static Color::Matrix3d d50d65AdaptationMatrixValue;
+const Color::Matrix3d &Color::sRGBMatrix = sRGBTransformation;
+const Color::Matrix3d &Color::sRGBInvertedMatrix = sRGBTransformationInverted;
+const Color::Matrix3d &Color::d65d50AdaptationMatrix = d65d50AdaptationMatrixValue;
+const Color::Matrix3d &Color::d50d65AdaptationMatrix = d50d65AdaptationMatrixValue;
+static Color::Vector3f references[][2] = {
+	{ { 109.850f, 100.000f, 35.585f }, { 111.144f, 100.000f, 35.200f } },
+	{ { 98.074f, 100.000f, 118.232f }, { 97.285f, 100.000f, 116.145f } },
+	{ { 96.422f, 100.000f, 82.521f }, { 96.720f, 100.000f, 81.427f } },
+	{ { 95.682f, 100.000f, 92.149f }, { 95.799f, 100.000f, 90.926f } },
+	{ { 95.047f, 100.000f, 108.883f }, { 94.811f, 100.000f, 107.304f } },
+	{ { 94.972f, 100.000f, 122.638f }, { 94.416f, 100.000f, 120.641f } },
+	{ { 99.187f, 100.000f, 67.395f }, { 103.280f, 100.000f, 69.026f } },
+	{ { 95.044f, 100.000f, 108.755f }, { 95.792f, 100.000f, 107.687f } },
+	{ { 100.966f, 100.000f, 64.370f }, { 103.866f, 100.000f, 65.627f } },
 };
-
-static matrix3x3 sRGB_transformation;
-static matrix3x3 sRGB_transformation_inverted;
-
-static matrix3x3 d65_d50_adaptation_matrix;
-static matrix3x3 d50_d65_adaptation_matrix;
-
-
-void color_init()
-{
+void Color::initialize() {
 	// constants used below are sRGB working space red, green and blue primaries for D65 reference white
-	color_get_working_space_matrix(0.6400, 0.3300, 0.3000, 0.6000, 0.1500, 0.0600, color_get_reference(REFERENCE_ILLUMINANT_D65, REFERENCE_OBSERVER_2), &sRGB_transformation);
-	matrix3x3_inverse(&sRGB_transformation, &sRGB_transformation_inverted);
-
-	color_get_chromatic_adaptation_matrix(color_get_reference(REFERENCE_ILLUMINANT_D65, REFERENCE_OBSERVER_2), color_get_reference(REFERENCE_ILLUMINANT_D50, REFERENCE_OBSERVER_2), &d65_d50_adaptation_matrix);
-	color_get_chromatic_adaptation_matrix(color_get_reference(REFERENCE_ILLUMINANT_D50, REFERENCE_OBSERVER_2), color_get_reference(REFERENCE_ILLUMINANT_D65, REFERENCE_OBSERVER_2), &d50_d65_adaptation_matrix);
-
+	sRGBTransformation = getWorkingSpaceMatrix(0.6400f, 0.3300f, 0.3000f, 0.6000f, 0.1500f, 0.0600f, getReference(ReferenceIlluminant::D65, ReferenceObserver::_2));
+	sRGBTransformationInverted = sRGBTransformation.inverse().value();
+	d65d50AdaptationMatrixValue = getChromaticAdaptationMatrix(getReference(ReferenceIlluminant::D65, ReferenceObserver::_2), getReference(ReferenceIlluminant::D50, ReferenceObserver::_2));
+	d50d65AdaptationMatrixValue = getChromaticAdaptationMatrix(getReference(ReferenceIlluminant::D50, ReferenceObserver::_2), getReference(ReferenceIlluminant::D65, ReferenceObserver::_2));
+}
+namespace util {
+template<typename T>
+inline void copy(const T *source, T *destination, size_t count = 1) {
+	for (size_t i = 0; i < count; i++) {
+		destination[i] = source[i];
+	}
 }
-
-Color::Color():
-	ma { 0, 0, 0, 0 } {
+template<typename T, typename TSource>
+inline void castCopy(const TSource *source, T *destination, size_t count = 1) {
+	for (size_t i = 0; i < count; i++) {
+		destination[i] = static_cast<T>(source[i]);
+	}
 }
-Color::Color(float grayValue):
-	ma { grayValue, grayValue, grayValue, 0 } {
+template<typename T>
+inline void fill(T *destination, T value, size_t count = 1) {
+	for (size_t i = 0; i < count; i++) {
+		destination[i] = value;
+	}
 }
-Color::Color(float red, float green, float blue):
-	ma { red, green, blue, 0 } {
 }
-bool Color::operator==(const Color &color) const {
-	return color_equal(this, &color);
+Color &Color::zero() {
+	for (auto i = 0; i < Color::MemberCount; i++)
+		data[i] = 0;
+	return *this;
 }
-
-void color_rgb_to_hsv(const Color* a, Color* b)
-{
-	float min, max, delta;
-
-	max = max_float_3(a->rgb.red, a->rgb.green, a->rgb.blue);
-	min = min_float_3(a->rgb.red, a->rgb.green, a->rgb.blue);
-	delta = max - min;
-
-	b->hsv.value = max;
-
-	if (max != 0.0f)
-		b->hsv.saturation = delta / max;
-	else
-		b->hsv.saturation = 0.0f;
-
-	if (b->hsv.saturation == 0.0f) {
-		b->hsv.hue = 0.0f;
-	}
-	else {
-		if (a->rgb.red == max)
-			b->hsv.hue = (a->rgb.green - a->rgb.blue) / delta;
-		else if (a->rgb.green == max)
-			b->hsv.hue = 2.0f + (a->rgb.blue - a->rgb.red) / delta;
-		else if (a->rgb.blue == max)
-			b->hsv.hue = 4.0f + (a->rgb.red - a->rgb.green) / delta;
-
-		b->hsv.hue /= 6.0f;
-
-		if (b->hsv.hue < 0.0f)
-			b->hsv.hue += 1.0f;
-		if (b->hsv.hue >= 1.0f)
-			b->hsv.hue -= 1.0f;
-	}
+Color Color::zero() const {
+	return Color();
 }
-
-
-void color_hsv_to_rgb(const Color* a, Color* b)
-{
-	float h,v, f, x, y, z;
-	int i;
-
-	v = a->hsv.value;
-
-	if (a->hsv.saturation == 0.0f) {
-		b->rgb.red = b->rgb.green = b->rgb.blue = a->hsv.value;
-	} else {
-
-		h = (a->hsv.hue - floor(a->hsv.hue)) * 6.0f;
-
-		i = int(h);
-		f = h - floor(h);
-
-		x = v * (1.0f - a->hsv.saturation) ;
-		y = v * (1.0f - (a->hsv.saturation * f));
-		z = v * (1.0f - (a->hsv.saturation * (1.0f - f)));
-
-		if (i == 0){
-			b->rgb.red = v;
-			b->rgb.green = z;
-			b->rgb.blue = x;
-		}else if (i == 1){
-			b->rgb.red = y;
-			b->rgb.green = v;
-			b->rgb.blue = x;
-		}else if (i == 2){
-			b->rgb.red = x;
-			b->rgb.green = v;
-			b->rgb.blue = z;
-		}else if (i == 3){
-			b->rgb.red = x;
-			b->rgb.green = y;
-			b->rgb.blue = v;
-		}else if (i == 4){
-			b->rgb.red = z;
-			b->rgb.green = x;
-			b->rgb.blue = v;
-		}else{
-			b->rgb.red = v;
-			b->rgb.green = x;
-			b->rgb.blue = y;
-		}
-	}
+Color::Color() {
+	util::fill(data, 0.0f, ChannelCount);
 }
-
-void color_rgb_to_xyz(const Color* a, Color* b, const matrix3x3* transformation)
-{
-	float R=a->rgb.red, G=a->rgb.green, B=a->rgb.blue;
-
-	if (R>0.04045){
-		R=pow(((R+0.055)/1.055),2.4);
-	}else{
-		R=R/12.92;
-	}
-
-	if (G>0.04045){
-		G=pow(((G+0.055)/1.055),2.4);
-	}else{
-		G=G/12.92;
-	}
-
-	if (B>0.04045){
-		B=pow(((B+0.055)/1.055),2.4);
-	}else{
-		B=B/12.92;
-	}
-
-	vector3 rgb;
-	rgb.x = R;
-	rgb.y = G;
-	rgb.z = B;
-
-	vector3_multiply_matrix3x3(&rgb, transformation, &rgb);
-
-	b->xyz.x = rgb.x;
-	b->xyz.y = rgb.y;
-	b->xyz.z = rgb.z;
+Color::Color(float value) {
+	util::fill(data, value, ChannelCount);
 }
-
-void color_xyz_to_rgb(const Color* a, Color* b, const matrix3x3* transformation_inverted)
-{
-	vector3 rgb;
-	float R,G,B;
-
-	vector3_multiply_matrix3x3((vector3*)a, transformation_inverted, &rgb);
-	R=rgb.x;
-	G=rgb.y;
-	B=rgb.z;
-
-	if (R>0.0031308){
-		R=1.055*(pow(R,1/2.4f))-0.055;
-	}else{
-		R=12.92*R;
-	}
-	if (G>0.0031308){
-		G=1.055*(pow(G,1/2.4f))-0.055;
-	}else{
-		G=12.92*G;
-	}
-	if(B>0.0031308){
-		B=1.055*(pow(B,1/2.4f))-0.055;
-	}else{
-		B=12.92*B;
-	}
-
-	b->rgb.red=R;
-	b->rgb.green=G;
-	b->rgb.blue=B;
+Color::Color(int value) {
+	util::fill(data, value / 255.0f, ChannelCount);
 }
-
-
-
-void color_rgb_to_lab(const Color* a, Color* b, const vector3* reference_white, const matrix3x3* transformation, const matrix3x3* adaptation_matrix)
-{
-	Color c;
-	color_rgb_to_xyz(a, &c, transformation);
-	color_xyz_chromatic_adaptation(&c, &c, adaptation_matrix);
-	color_xyz_to_lab(&c, b, reference_white);
+Color::Color(float red, float green, float blue) {
+	rgb.red = red;
+	rgb.green = green;
+	rgb.blue = blue;
+	util::fill(data + 3, 0.0f, ChannelCount - 3);
 }
-
-void color_lab_to_rgb(const Color* a, Color* b, const vector3* reference_white, const matrix3x3* transformation_inverted, const matrix3x3* adaptation_matrix_inverted)
-{
-	Color c;
-	color_lab_to_xyz(a, &c, reference_white);
-	color_xyz_chromatic_adaptation(&c, &c, adaptation_matrix_inverted);
-	color_xyz_to_rgb(&c, b, transformation_inverted);
+Color::Color(float value1, float value2, float value3, float value4) {
+	data[0] = value1;
+	data[1] = value2;
+	data[2] = value3;
+	data[3] = value4;
 }
-
-void color_copy(const Color* a, Color* b)
-{
-	b->m.m1 = a->m.m1;
-	b->m.m2 = a->m.m2;
-	b->m.m3 = a->m.m3;
-	b->m.m4 = a->m.m4;
+Color::Color(int red, int green, int blue) {
+	rgb.red = static_cast<float>(red / 255.0f);
+	rgb.green = static_cast<float>(green / 255.0f);
+	rgb.blue = static_cast<float>(blue / 255.0f);
+	util::fill(data + 3, 0.0f, ChannelCount - 3);
 }
-
-void color_add(Color* a, const Color* b)
-{
-	a->m.m1 += b->m.m1;
-	a->m.m2 += b->m.m2;
-	a->m.m3 += b->m.m3;
-	a->m.m4 += b->m.m4;
+Color::Color(const Color &color) {
+	util::copy(color.data, data, MemberCount);
 }
-
-void color_multiply(Color* a, float b)
-{
-	a->m.m1 *= b;
-	a->m.m2 *= b;
-	a->m.m3 *= b;
-	a->m.m4 *= b;
+Color::Color(const Vector3f &value) {
+	util::copy(value.data, data, 3);
+	util::fill(data + 3, 0.0f, ChannelCount - 3);
 }
-
-void color_zero(Color* a)
-{
-	a->m.m1 = 0;
-	a->m.m2 = 0;
-	a->m.m3 = 0;
-	a->m.m4 = 0;
+Color::Color(const Vector3d &value) {
+	util::castCopy(value.data, data, 3);
+	util::fill(data + 3, 0.0f, ChannelCount - 3);
 }
-
-void
-color_get_contrasting(const Color* a, Color* b)
-{
-	Color t;
-	color_rgb_to_lab(a, &t, color_get_reference(REFERENCE_ILLUMINANT_D50, REFERENCE_OBSERVER_2), &sRGB_transformation, &d65_d50_adaptation_matrix);
-
-	if (t.lab.L > 50){
-		t.hsv.value=0;
-	}else{
-		t.hsv.value=1;
-	}
-
-	t.hsv.saturation=0;
-	t.hsv.hue=0;
-
-	color_hsv_to_rgb(&t, b);
+template<>
+Color::Vector3f Color::rgbVector() const {
+	return Vector3f(rgb.red, rgb.green, rgb.blue);
 }
-
-void color_set(Color* a, float value)
-{
-	a->rgb.red = a->rgb.green = a->rgb.blue = value;
-	a->ma[3] = 0;
-}
-void color_set(Color* a, float red, float green, float blue)
-{
-	a->rgb.red = red;
-	a->rgb.green = green;
-	a->rgb.blue = blue;
-	a->ma[3] = 0;
-}
-void color_set(Color* a, int red, int green, int blue)
-{
-	a->rgb.red = red / 255.0;
-	a->rgb.green = green / 255.0;
-	a->rgb.blue = blue / 255.0;
-	a->ma[3] = 0;
+template<>
+Color::Vector3d Color::rgbVector() const {
+	return Vector3d(rgb.red, rgb.green, rgb.blue);
 }
-
-Color* color_new()
-{
-	return new Color;
-}
-
-void color_destroy(Color *a)
-{
-	delete a;
+Color Color::rgbToHsv() const {
+	float min, max;
+	std::tie(min, max) = math::minMax(rgb.red, rgb.green, rgb.blue);
+	float delta = max - min;
+	Color result;
+	result.hsv.value = max;
+	if (max != 0.0f)
+		result.hsv.saturation = delta / max;
+	else
+		result.hsv.saturation = 0.0f;
+	if (result.hsv.saturation == 0.0f) {
+		result.hsv.hue = 0.0f;
+	} else {
+		if (rgb.red == max)
+			result.hsv.hue = (rgb.green - rgb.blue) / delta;
+		else if (rgb.green == max)
+			result.hsv.hue = 2.0f + (rgb.blue - rgb.red) / delta;
+		else if (rgb.blue == max)
+			result.hsv.hue = 4.0f + (rgb.red - rgb.green) / delta;
+		result.hsv.hue /= 6.0f;
+		if (result.hsv.hue < 0.0f)
+			result.hsv.hue += 1.0f;
+		if (result.hsv.hue >= 1.0f)
+			result.hsv.hue -= 1.0f;
+	}
+	return result;
 }
-
-void color_rgb_to_hsl(const Color* a, Color* b)
-{
-	float min, max, delta;
-
-	min = min_float_3(a->rgb.red, a->rgb.green, a->rgb.blue);
-	max = max_float_3(a->rgb.red, a->rgb.green, a->rgb.blue);
-	delta = max - min;
-
-	b->hsl.lightness = (max + min) / 2;
-
+Color Color::hsvToRgb() const {
+	float v = hsv.value;
+	Color result;
+	if (hsv.saturation == 0.0f) {
+		result.rgb.red = result.rgb.green = result.rgb.blue = hsv.value;
+	} else {
+		float h, f, x, y, z;
+		h = (hsv.hue - std::floor(hsv.hue)) * 6.0f;
+		int i = int(h);
+		f = h - std::floor(h);
+		x = v * (1.0f - hsv.saturation);
+		y = v * (1.0f - (hsv.saturation * f));
+		z = v * (1.0f - (hsv.saturation * (1.0f - f)));
+		if (i == 0) {
+			result.rgb.red = v;
+			result.rgb.green = z;
+			result.rgb.blue = x;
+		} else if (i == 1) {
+			result.rgb.red = y;
+			result.rgb.green = v;
+			result.rgb.blue = x;
+		} else if (i == 2) {
+			result.rgb.red = x;
+			result.rgb.green = v;
+			result.rgb.blue = z;
+		} else if (i == 3) {
+			result.rgb.red = x;
+			result.rgb.green = y;
+			result.rgb.blue = v;
+		} else if (i == 4) {
+			result.rgb.red = z;
+			result.rgb.green = x;
+			result.rgb.blue = v;
+		} else {
+			result.rgb.red = v;
+			result.rgb.green = x;
+			result.rgb.blue = y;
+		}
+	}
+	return result;
+}
+Color Color::rgbToHsl() const {
+	float min, max;
+	std::tie(min, max) = math::minMax(rgb.red, rgb.green, rgb.blue);
+	float delta = max - min;
+	Color result;
+	result.hsl.lightness = (max + min) / 2;
 	if (delta == 0) {
-		b->hsl.hue = 0;
-		b->hsl.saturation = 0;
+		result.hsl.hue = 0;
+		result.hsl.saturation = 0;
 	} else {
-		if (b->hsl.lightness < 0.5) {
-			b->hsl.saturation = delta / (max + min);
+		if (result.hsl.lightness < 0.5) {
+			result.hsl.saturation = delta / (max + min);
 		} else {
-			b->hsl.saturation = delta / (2 - max - min);
+			result.hsl.saturation = delta / (2 - max - min);
 		}
-
-		if (a->rgb.red == max)
-			b->hsv.hue = (a->rgb.green - a->rgb.blue) / delta;
-		else if (a->rgb.green == max)
-			b->hsv.hue = 2.0f + (a->rgb.blue - a->rgb.red) / delta;
-		else if (a->rgb.blue == max)
-			b->hsv.hue = 4.0f + (a->rgb.red - a->rgb.green) / delta;
-
-		b->hsv.hue /= 6.0f;
-
-		if (b->hsv.hue < 0.0f)
-			b->hsv.hue += 1.0f;
-		if (b->hsv.hue >= 1.0f)
-			b->hsv.hue -= 1.0f;
-
+		if (rgb.red == max)
+			result.hsv.hue = (rgb.green - rgb.blue) / delta;
+		else if (rgb.green == max)
+			result.hsv.hue = 2.0f + (rgb.blue - rgb.red) / delta;
+		else if (rgb.blue == max)
+			result.hsv.hue = 4.0f + (rgb.red - rgb.green) / delta;
+		result.hsv.hue /= 6.0f;
+		if (result.hsv.hue < 0.0f)
+			result.hsv.hue += 1.0f;
+		if (result.hsv.hue >= 1.0f)
+			result.hsv.hue -= 1.0f;
 	}
+	return result;
 }
-
-
-void color_hsl_to_rgb(const Color* a, Color* b)
-{
-	if (a->hsl.saturation == 0) {
-		b->rgb.red = b->rgb.green = b->rgb.blue = a->hsl.lightness;
+Color Color::hslToRgb() const {
+	Color result;
+	if (hsl.saturation == 0) {
+		result.rgb.red = result.rgb.green = result.rgb.blue = hsl.lightness;
 	} else {
-		float q, p, R, G, B;
-
-		if (a->hsl.lightness < 0.5)
-			q = a->hsl.lightness * (1.0 + a->hsl.saturation);
+		float q;
+		if (hsl.lightness < 0.5f)
+			q = hsl.lightness * (1.0f + hsl.saturation);
 		else
-			q = a->hsl.lightness + a->hsl.saturation - a->hsl.lightness * a->hsl.saturation;
-
-		p = 2 * a->hsl.lightness - q;
-
-		R = a->hsl.hue+1/3.0;
-		G = a->hsl.hue;
-		B = a->hsl.hue-1/3.0;
-
-		if (R>1) R-=1;
-		if (B<0) B+=1;
-
-		if (6.0 * R < 1)
-			b->rgb.red = p + (q - p) * 6.0 * R;
+			q = hsl.lightness + hsl.saturation - hsl.lightness * hsl.saturation;
+		float p = 2 * hsl.lightness - q;
+		float R = hsl.hue + 1 / 3.0f;
+		float G = hsl.hue;
+		float B = hsl.hue - 1 / 3.0f;
+		if (R > 1) R -= 1;
+		if (B < 0) B += 1;
+		if (6.0f * R < 1)
+			result.rgb.red = p + (q - p) * 6.0f * R;
 		else if (2.0 * R < 1)
-			b->rgb.red = q;
+			result.rgb.red = q;
 		else if (3.0 * R < 2)
-			b->rgb.red = p + (q - p) * ((2.0 / 3.0) - R) * 6.0;
+			result.rgb.red = p + (q - p) * ((2.0f / 3.0f) - R) * 6.0f;
 		else
-			b->rgb.red = p;
-
-		if (6.0 * G < 1)
-			b->rgb.green = p + (q - p) * 6.0 * G;
-		else if (2.0 * G < 1)
-			b->rgb.green = q;
-		else if (3.0 * G < 2)
-			b->rgb.green = p + (q - p) * ((2.0 / 3.0) - G) * 6.0;
+			result.rgb.red = p;
+		if (6.0f * G < 1)
+			result.rgb.green = p + (q - p) * 6.0f * G;
+		else if (2.0f * G < 1)
+			result.rgb.green = q;
+		else if (3.0f * G < 2)
+			result.rgb.green = p + (q - p) * ((2.0f / 3.0f) - G) * 6.0f;
 		else
-			b->rgb.green = p;
-
-		if (6.0 * B < 1)
-			b->rgb.blue = p + (q - p) * 6.0 * B;
-		else if (2.0 * B < 1)
-			b->rgb.blue = q;
-		else if (3.0 * B < 2)
-			b->rgb.blue = p + (q - p) * ((2.0 / 3.0) - B) * 6.0;
+			result.rgb.green = p;
+		if (6.0f * B < 1)
+			result.rgb.blue = p + (q - p) * 6.0f * B;
+		else if (2.0f * B < 1)
+			result.rgb.blue = q;
+		else if (3.0f * B < 2)
+			result.rgb.blue = p + (q - p) * ((2.0f / 3.0f) - B) * 6.0f;
 		else
-			b->rgb.blue = p;
-
-
+			result.rgb.blue = p;
 	}
+	return result;
 }
-
-void color_lab_to_lch(const Color* a, Color* b)
-{
+Color Color::rgbToXyz(const Matrix3d &transformation) const {
+	return linearRgb().rgbVector<double>() * transformation;
+}
+Color Color::xyzToRgb(const Matrix3d &transformationInverted) const {
+	return Color(rgbVector<double>() * transformationInverted).nonLinearRgbInplace();
+}
+Color Color::rgbToLab(const Vector3f &referenceWhite, const Matrix3d &transformation, const Matrix3d &adaptationMatrix) const {
+	return rgbToXyz(transformation).xyzChromaticAdaptation(adaptationMatrix).xyzToLab(referenceWhite);
+}
+Color Color::labToRgb(const Vector3f &referenceWhite, const Matrix3d &transformationInverted, const Matrix3d &adaptationMatrixInverted) const {
+	return labToXyz(referenceWhite).xyzChromaticAdaptation(adaptationMatrixInverted).xyzToRgb(transformationInverted);
+}
+Color Color::labToLch() const {
 	double H;
-	if (a->lab.a == 0 && a->lab.b == 0){
+	if (lab.a == 0 && lab.b == 0) {
 		H = 0;
-	}else{
-		H = atan2(a->lab.b, a->lab.a);
+	} else {
+		H = std::atan2(lab.b, lab.a);
 	}
-
-	H *= 180.0 / PI;
-
+	H *= 180.0f / math::PI;
 	if (H < 0) H += 360;
 	if (H >= 360) H -= 360;
-
-	b->lch.L = a->lab.L;
-	b->lch.C = sqrt(a->lab.a * a->lab.a + a->lab.b * a->lab.b);
-	b->lch.h = H;
-}
-
-void color_lch_to_lab(const Color* a, Color* b)
-{
-	b->lab.L = a->lch.L;
-	b->lab.a = a->lch.C * cos(a->lch.h * PI / 180.0);
-	b->lab.b = a->lch.C * sin(a->lch.h * PI / 180.0);
+	return Color(lab.L, static_cast<float>(std::sqrt(lab.a * lab.a + lab.b * lab.b)), static_cast<float>(H));
+}
+Color Color::lchToLab() const {
+	return Color(lch.L, static_cast<float>(lch.C * std::cos(lch.h * math::PI / 180.0f)), static_cast<float>(lch.C * std::sin(lch.h * math::PI / 180.0f)));
+}
+Color Color::hslToHsv() const {
+	float l = hsl.lightness * 2.0f;
+	float s = hsl.saturation * ((l <= 1.0f) ? (l) : (2.0f - l));
+	Color result;
+	result.hsv.hue = hsl.hue;
+	if (l + s == 0) {
+		result.hsv.value = 0;
+		result.hsv.saturation = 1;
+	} else {
+		result.hsv.value = (l + s) / 2.0f;
+		result.hsv.saturation = (2.0f * s) / (l + s);
+	}
+	return result;
 }
-
-void color_rgb_to_lch_d50(const Color* a, Color* b)
-{
-	Color c;
-	color_rgb_to_lab(a, &c, color_get_reference(REFERENCE_ILLUMINANT_D50, REFERENCE_OBSERVER_2), &sRGB_transformation, &d65_d50_adaptation_matrix);
-	color_lab_to_lch(&c, b);
+Color Color::hsvToHsl() const {
+	float l = (2.0f - hsv.saturation) * hsv.value;
+	float s = (hsv.saturation * hsv.value) / ((l <= 1.0f) ? (l) : (2 - l));
+	if (l == 0) s = 0;
+	return Color(hsv.hue, s, l / 2.0f);
 }
-
-void color_lch_to_rgb_d50(const Color* a, Color* b)
-{
-	Color c;
-	color_lch_to_lab(a, &c);
-	color_lab_to_rgb(&c, b, color_get_reference(REFERENCE_ILLUMINANT_D50, REFERENCE_OBSERVER_2), &sRGB_transformation_inverted, &d50_d65_adaptation_matrix);
+Color &Color::linearRgbInplace() {
+	if (rgb.red > 0.04045f)
+		rgb.red = std::pow((rgb.red + 0.055f) / 1.055f, 2.4f);
+	else
+		rgb.red = rgb.red / 12.92f;
+	if (rgb.green > 0.04045f)
+		rgb.green = std::pow((rgb.green + 0.055f) / 1.055f, 2.4f);
+	else
+		rgb.green = rgb.green / 12.92f;
+	if (rgb.blue > 0.04045f)
+		rgb.blue = std::pow((rgb.blue + 0.055f) / 1.055f, 2.4f);
+	else
+		rgb.blue = rgb.blue / 12.92f;
+	return *this;
 }
-
-void color_rgb_to_lch(const Color* a, Color* b, const vector3* reference_white, const matrix3x3* transformation, const matrix3x3* adaptation_matrix)
-{
-	Color c;
-	color_rgb_to_lab(a, &c, reference_white, transformation, adaptation_matrix);
-	color_lab_to_lch(&c, b);
+Color Color::linearRgb() const {
+	Color result;
+	if (rgb.red > 0.04045f)
+		result.rgb.red = std::pow((rgb.red + 0.055f) / 1.055f, 2.4f);
+	else
+		result.rgb.red = rgb.red / 12.92f;
+	if (rgb.green > 0.04045f)
+		result.rgb.green = std::pow((rgb.green + 0.055f) / 1.055f, 2.4f);
+	else
+		result.rgb.green = rgb.green / 12.92f;
+	if (rgb.blue > 0.04045f)
+		result.rgb.blue = std::pow((rgb.blue + 0.055f) / 1.055f, 2.4f);
+	else
+		result.rgb.blue = rgb.blue / 12.92f;
+	return result;
 }
-
-void color_lch_to_rgb(const Color* a, Color* b, const vector3* reference_white, const matrix3x3* transformation_inverted, const matrix3x3* adaptation_matrix_inverted)
-{
-	Color c;
-	color_lch_to_lab(a, &c);
-	color_lab_to_rgb(&c, b, reference_white, transformation_inverted, adaptation_matrix_inverted);
+Color Color::nonLinearRgb() const {
+	Color result;
+	if (rgb.red > 0.0031308f)
+		result.rgb.red = (1.055f * std::pow(rgb.red, 1.0f / 2.4f)) - 0.055f;
+	else
+		result.rgb.red = rgb.red * 12.92f;
+	if (rgb.green > 0.0031308f)
+		result.rgb.green = (1.055f * std::pow(rgb.green, 1.0f / 2.4f)) - 0.055f;
+	else
+		result.rgb.green = rgb.green * 12.92f;
+	if (rgb.blue > 0.0031308f)
+		result.rgb.blue = (1.055f * std::pow(rgb.blue, 1.0f / 2.4f)) - 0.055f;
+	else
+		result.rgb.blue = rgb.blue * 12.92f;
+	return result;
 }
-
-void color_rgb_to_lab_d50(const Color* a, Color* b)
-{
-	color_rgb_to_lab(a, b, color_get_reference(REFERENCE_ILLUMINANT_D50, REFERENCE_OBSERVER_2), &sRGB_transformation, &d65_d50_adaptation_matrix);
+Color &Color::nonLinearRgbInplace() {
+	if (rgb.red > 0.0031308f)
+		rgb.red = (1.055f * std::pow(rgb.red, 1.0f / 2.4f)) - 0.055f;
+	else
+		rgb.red = rgb.red * 12.92f;
+	if (rgb.green > 0.0031308f)
+		rgb.green = (1.055f * std::pow(rgb.green, 1.0f / 2.4f)) - 0.055f;
+	else
+		rgb.green = rgb.green * 12.92f;
+	if (rgb.blue > 0.0031308f)
+		rgb.blue = (1.055f * std::pow(rgb.blue, 1.0f / 2.4f)) - 0.055f;
+	else
+		rgb.blue = rgb.blue * 12.92f;
+	return *this;
 }
-
-void color_lab_to_rgb_d50(const Color* a, Color* b)
-{
-	color_lab_to_rgb(a, b, color_get_reference(REFERENCE_ILLUMINANT_D50, REFERENCE_OBSERVER_2), &sRGB_transformation_inverted, &d50_d65_adaptation_matrix);
+Color Color::rgbToLch(const Vector3f &referenceWhite, const Matrix3d &transformation, const Matrix3d &adaptationMatrix) const {
+	return rgbToLab(referenceWhite, transformation, adaptationMatrix).labToLch();
 }
-
-#define Kk (24389.0 / 27.0)
-
-void color_xyz_to_lab(const Color* a, Color* b, const vector3* reference_white)
-{
-	float X,Y,Z;
-
-	X = a->xyz.x / reference_white->x; //95.047f;
-	Y = a->xyz.y / reference_white->y; //100.000f;
-	Z = a->xyz.z / reference_white->z; //108.883f;
-
-	if (X>EPSILON){
-		X=pow(X,1.0f/3.0f);
-	}else{
-		X=(Kk*X+16.0f)/116.0f;
-	}
-	if (Y>EPSILON){
-		Y=pow(Y,1.0f/3.0f);
-	}else{
-		Y=(Kk*Y+16.0f)/116.0f;
-	}
-	if (Z>EPSILON){
-		Z=pow(Z,1.0f/3.0f);
-	}else{
-		Z=(Kk*Z+16.0f)/116.0f;
-	}
-
-	b->lab.L=(116*Y)-16;
-	b->lab.a=500*(X-Y);
-	b->lab.b=200*(Y-Z);
-
+Color Color::lchToRgb(const Vector3f &referenceWhite, const Matrix3d &transformationInverted, const Matrix3d &adaptationMatrixInverted) const {
+	return lchToLab().labToRgb(referenceWhite, transformationInverted, adaptationMatrixInverted);
 }
-
-void color_lab_to_xyz(const Color* a, Color* b, const vector3* reference_white)
-{
-	float x, y, z;
-
-	float fy = (a->lab.L + 16) / 116;
-	float fx = a->lab.a / 500 + fy;
-	float fz = fy - a->lab.b / 200;
-
-	const double K=(24389.0 / 27.0);
-
-	if (pow(fx, 3)>EPSILON){
-		x=pow(fx, 3);
-	}else{
-		x=(116*fx-16)/K;
-	}
-
-	if (a->lab.L > K*EPSILON){
-		y=pow((a->lab.L+16)/116, 3);
-	}else{
-		y=a->lab.L/K;
-	}
-
-	if (pow(fz, 3)>EPSILON){
-		z=pow(fz, 3);
-	}else{
-		z=(116*fz-16)/K;
-	}
-
-	b->xyz.x = x * reference_white->x; //95.047f;
-	b->xyz.y = y * reference_white->y; //100.000f;
-	b->xyz.z = z * reference_white->z; //108.883f;
+Color Color::rgbToLchD50() const {
+	return rgbToLab(getReference(ReferenceIlluminant::D50, ReferenceObserver::_2), sRGBMatrix, d65d50AdaptationMatrix).labToLch();
 }
-
-void color_get_working_space_matrix(float xr, float yr, float xg, float yg, float xb, float yb, const vector3* reference_white, matrix3x3* result)
-{
-	float Xr,Yr,Zr;
-	float Xg,Yg,Zg;
-	float Xb,Yb,Zb;
-
-	Xr=xr/yr;
-	Yr=1;
-	Zr=(1-xr-yr)/yr;
-
-	Xg=xg/yg;
-	Yg=1;
-	Zg=(1-xg-yg)/yg;
-
-	Xb=xb/yb;
-	Yb=1;
-	Zb=(1-xb-yb)/yb;
-
-	vector3 v;
-	v.x=reference_white->x;
-	v.y=reference_white->y;
-	v.z=reference_white->z;
-
-	matrix3x3 m_inv;
-	m_inv.m[0][0]=Xr; m_inv.m[1][0]=Yr; m_inv.m[2][0]=Zr;
-	m_inv.m[0][1]=Xg; m_inv.m[1][1]=Yg; m_inv.m[2][1]=Zg;
-	m_inv.m[0][2]=Xb; m_inv.m[1][2]=Yb; m_inv.m[2][2]=Zb;
-
-	matrix3x3_inverse(&m_inv, &m_inv);
-
-	vector3_multiply_matrix3x3(&v, &m_inv, &v);
-
-	result->m[0][0]=Xr*v.x;	result->m[1][0]=Yr*v.x;	result->m[2][0]=Zr*v.x;
-	result->m[0][1]=Xg*v.y;	result->m[1][1]=Yg*v.y;	result->m[2][1]=Zg*v.y;
-	result->m[0][2]=Xb*v.z;	result->m[1][2]=Yb*v.z;	result->m[2][2]=Zb*v.z;
+Color Color::lchToRgbD50() const {
+	return lchToLab().labToRgb(getReference(ReferenceIlluminant::D50, ReferenceObserver::_2), sRGBInvertedMatrix, d50d65AdaptationMatrix);
 }
-
-void color_get_chromatic_adaptation_matrix(const vector3* source_reference_white, const vector3* destination_reference_white, matrix3x3* result)
-{
-
-	matrix3x3 Ma;
-	//Bradford matrix
-	Ma.m[0][0]= 0.8951; Ma.m[1][0]=-0.7502; Ma.m[2][0]= 0.0389;
-	Ma.m[0][1]= 0.2664; Ma.m[1][1]= 1.7135; Ma.m[2][1]=-0.0685;
-	Ma.m[0][2]=-0.1614; Ma.m[1][2]= 0.0367; Ma.m[2][2]= 1.0296;
-
-	matrix3x3 Ma_inv;
-	//Bradford inverted matrix
-	Ma_inv.m[0][0]= 0.986993; Ma_inv.m[1][0]= 0.432305; Ma_inv.m[2][0]=-0.008529;
-	Ma_inv.m[0][1]=-0.147054; Ma_inv.m[1][1]= 0.518360; Ma_inv.m[2][1]= 0.040043;
-	Ma_inv.m[0][2]= 0.159963; Ma_inv.m[1][2]= 0.049291; Ma_inv.m[2][2]= 0.968487;
-
-	vector3 Vs, Vd;
-	vector3_multiply_matrix3x3(source_reference_white, &Ma, &Vs);
-	vector3_multiply_matrix3x3(destination_reference_white, &Ma, &Vd);
-
-	matrix3x3 M;
-	matrix3x3_identity(&M);
-	M.m[0][0]=Vd.x / Vs.x;
-	M.m[1][1]=Vd.y / Vs.y;
-	M.m[2][2]=Vd.z / Vs.z;
-
-	matrix3x3_multiply(&Ma, &M, &M);
-	matrix3x3_multiply(&M, &Ma_inv, result);
+Color Color::rgbToLabD50() const {
+	return rgbToLab(getReference(ReferenceIlluminant::D50, ReferenceObserver::_2), sRGBMatrix, d65d50AdaptationMatrix);
 }
-
-void color_xyz_chromatic_adaptation(const Color* a, Color* result, const matrix3x3* adaptation)
-{
-	vector3 x;
-	x.x=a->xyz.x;
-	x.y=a->xyz.y;
-	x.z=a->xyz.z;
-	vector3_multiply_matrix3x3(&x, adaptation, &x);
-	result->xyz.x=x.x;
-	result->xyz.y=x.y;
-	result->xyz.z=x.z;
+Color Color::labToRgbD50() const {
+	return labToRgb(getReference(ReferenceIlluminant::D50, ReferenceObserver::_2), sRGBInvertedMatrix, d50d65AdaptationMatrix);
 }
-
-void color_rgb_to_cmy(const Color* a, Color* b)
-{
-	b->cmy.c = 1 - a->rgb.red;
-	b->cmy.m = 1 - a->rgb.green;
-	b->cmy.y = 1 - a->rgb.blue;
+Color Color::rgbToCmy() const {
+	return Color(1 - rgb.red, 1 - rgb.green, 1 - rgb.blue);
 }
-
-void color_cmy_to_rgb(const Color* a, Color* b)
-{
-	b->rgb.red = 1 - a->cmy.c;
-	b->rgb.green = 1 - a->cmy.m;
-	b->rgb.blue = 1 - a->cmy.y;
+Color Color::cmyToRgb() const {
+	return Color(1 - cmy.c, 1 - cmy.m, 1 - cmy.y);
 }
-
-void color_cmy_to_cmyk(const Color* a, Color* b)
-{
+Color Color::cmyToCmyk() const {
 	float k = 1;
-
-	if (a->cmy.c < k) k = a->cmy.c;
-	if (a->cmy.m < k) k = a->cmy.m;
-	if (a->cmy.y < k) k = a->cmy.y;
-
-	if (k == 1){
-		b->cmyk.c = b->cmyk.m = b->cmyk.y = 0;
-	}else{
-		b->cmyk.c = (a->cmy.c - k) / (1 - k);
-		b->cmyk.m = (a->cmy.m - k) / (1 - k);
-		b->cmyk.y = (a->cmy.y - k) / (1 - k);
+	if (cmy.c < k) k = cmy.c;
+	if (cmy.m < k) k = cmy.m;
+	if (cmy.y < k) k = cmy.y;
+	Color result;
+	if (k == 1) {
+		result.cmyk.c = result.cmyk.m = result.cmyk.y = 0;
+	} else {
+		result.cmyk.c = (cmy.c - k) / (1 - k);
+		result.cmyk.m = (cmy.m - k) / (1 - k);
+		result.cmyk.y = (cmy.y - k) / (1 - k);
 	}
-	b->cmyk.k = k;
+	result.cmyk.k = k;
+	return result;
 }
-
-void color_cmyk_to_cmy(const Color* a, Color* b)
-{
-	b->cmy.c = (a->cmyk.c * (1 - a->cmyk.k) + a->cmyk.k);
-	b->cmy.m = (a->cmyk.m * (1 - a->cmyk.k) + a->cmyk.k);
-	b->cmy.y = (a->cmyk.y * (1 - a->cmyk.k) + a->cmyk.k);
+Color Color::cmykToCmy() const {
+	return Color(cmyk.c * (1 - cmyk.k) + cmyk.k, cmyk.m * (1 - cmyk.k) + cmyk.k, cmyk.y * (1 - cmyk.k) + cmyk.k);
 }
-
-void color_rgb_to_cmyk(const Color* a, Color* b)
-{
-	Color c;
-	color_rgb_to_cmy(a, &c);
-	color_cmy_to_cmyk(&c, b);
+Color Color::rgbToCmyk() const {
+	return rgbToCmy().cmyToCmyk();
 }
-
-void color_cmyk_to_rgb(const Color* a, Color* b)
-{
-	Color c;
-	color_cmyk_to_cmy(a, &c);
-	color_cmy_to_rgb(&c, b);
+Color Color::cmykToRgb() const {
+	return cmykToCmy().cmyToRgb();
 }
-
-
-void color_rgb_normalize(Color* a)
-{
-	a->rgb.red = clamp_float(a->rgb.red, 0, 1);
-	a->rgb.green = clamp_float(a->rgb.green, 0, 1);
-	a->rgb.blue = clamp_float(a->rgb.blue, 0, 1);
-	a->ma[3] = clamp_float(a->ma[3], 0, 1);
-}
-
-void color_hsl_to_hsv(const Color *a, Color *b)
-{
-	float l = a->hsl.lightness * 2.0;
-	float s = a->hsl.saturation * ((l <= 1.0) ? (l) : (2.0 - l));
-
-	b->hsv.hue = a->hsl.hue;
-	if (l + s == 0){
-		b->hsv.value = 0;
-		b->hsv.saturation = 1;
-	}else{
-		b->hsv.value = (l + s) / 2.0;
-		b->hsv.saturation = (2.0 * s) / (l + s);
+Color Color::xyzToLab(const Vector3f &referenceWhite) const {
+	float X = xyz.x / referenceWhite.x;
+	float Y = xyz.y / referenceWhite.y;
+	float Z = xyz.z / referenceWhite.z;
+	if (X > Epsilon) {
+		X = static_cast<float>(std::pow(X, 1.0f / 3.0f));
+	} else {
+		X = static_cast<float>((Kk * X + 16.0f) / 116.0f);
 	}
+	if (Y > Epsilon) {
+		Y = static_cast<float>(std::pow(Y, 1.0f / 3.0f));
+	} else {
+		Y = static_cast<float>((Kk * Y + 16.0f) / 116.0f);
+	}
+	if (Z > Epsilon) {
+		Z = static_cast<float>(std::pow(Z, 1.0f / 3.0f));
+	} else {
+		Z = static_cast<float>((Kk * Z + 16.0f) / 116.0f);
+	}
+	return Color((116 * Y) - 16, 500 * (X - Y), 200 * (Y - Z));
 }
-
-void color_hsv_to_hsl(const Color *a, Color *b)
-{
-	float l = (2.0 - a->hsv.saturation) * a->hsv.value;
-	float s = (a->hsv.saturation * a->hsv.value) / ((l <= 1.0) ? (l) : (2 - l));
-	if (l == 0) s = 0;
-
-	b->hsl.hue = a->hsv.hue;
-	b->hsl.saturation = s;
-	b->hsl.lightness = l / 2.0;
-}
-
-void color_rgb_get_linear(const Color* a, Color* b)
-{
-	if (a->rgb.red > 0.04045f)
-		b->rgb.red = pow((a->rgb.red + 0.055f) / 1.055f, 2.4f);
-	else
-		b->rgb.red = a->rgb.red / 12.92f;
-
-	if (a->rgb.green > 0.04045f)
-		b->rgb.green = pow((a->rgb.green + 0.055f) / 1.055f, 2.4f);
-	else
-		b->rgb.green = a->rgb.green / 12.92f;
-
-	if (a->rgb.blue > 0.04045f)
-		b->rgb.blue = pow((a->rgb.blue + 0.055f) / 1.055f, 2.4f);
-	else
-		b->rgb.blue = a->rgb.blue / 12.92f;
-
-}
-
-void color_linear_get_rgb(const Color* a, Color* b)
-{
-	if (a->rgb.red > 0.0031308f)
-		b->rgb.red = (1.055f * pow(a->rgb.red, 1.0f / 2.4f)) - 0.055f;
-	else
-		b->rgb.red = a->rgb.red * 12.92f;
-
-	if (a->rgb.green > 0.0031308f)
-		b->rgb.green = (1.055f * pow(a->rgb.green, 1.0f / 2.4f)) - 0.055f;
-	else
-		b->rgb.green = a->rgb.green * 12.92f;
-
-	if (a->rgb.blue > 0.0031308f)
-		b->rgb.blue = (1.055f * pow(a->rgb.blue, 1.0f / 2.4f)) - 0.055f;
-	else
-		b->rgb.blue = a->rgb.blue * 12.92f;
-}
-
-const matrix3x3* color_get_sRGB_transformation_matrix()
-{
-	return &sRGB_transformation;
-}
-
-const matrix3x3* color_get_inverted_sRGB_transformation_matrix()
-{
-	return &sRGB_transformation_inverted;
-}
-
-const matrix3x3* color_get_d65_d50_adaptation_matrix()
-{
-	return &d65_d50_adaptation_matrix;
-}
-
-const matrix3x3* color_get_d50_d65_adaptation_matrix()
-{
-	return &d50_d65_adaptation_matrix;
-}
-
-const vector3* color_get_reference(ReferenceIlluminant illuminant, ReferenceObserver observer)
-{
-	return &references[illuminant][observer];
-}
-
-const ReferenceIlluminant color_get_illuminant(const std::string &illuminant) {
+Color Color::labToXyz(const Vector3f &referenceWhite) const {
+	float x, y, z;
+	float fy = (lab.L + 16) / 116;
+	float fx = lab.a / 500 + fy;
+	float fz = fy - lab.b / 200;
+	const double K = (24389.0 / 27.0);
+	if (std::pow(fx, 3) > Epsilon) {
+		x = static_cast<float>(std::pow(fx, 3));
+	} else {
+		x = static_cast<float>((116 * fx - 16) / K);
+	}
+	if (lab.L > K * Epsilon) {
+		y = static_cast<float>(std::pow((lab.L + 16) / 116, 3));
+	} else {
+		y = static_cast<float>(lab.L / K);
+	}
+	if (std::pow(fz, 3) > Epsilon) {
+		z = static_cast<float>(std::pow(fz, 3));
+	} else {
+		z = static_cast<float>((116 * fz - 16) / K);
+	}
+	return Color(x * referenceWhite.x, y * referenceWhite.y, z * referenceWhite.z);
+}
+Color::Matrix3d Color::getWorkingSpaceMatrix(float xr, float yr, float xg, float yg, float xb, float yb, const Vector3f &referenceWhite) {
+	float Xr = xr / yr;
+	float Yr = 1;
+	float Zr = (1 - xr - yr) / yr;
+	float Xg = xg / yg;
+	float Yg = 1;
+	float Zg = (1 - xg - yg) / yg;
+	float Xb = xb / yb;
+	float Yb = 1;
+	float Zb = (1 - xb - yb) / yb;
+	auto s = math::vectorCast<double>(referenceWhite) * Matrix3d { Xr, Xg, Xb, Yr, Yg, Yb, Zr, Zg, Zb }.inverse().value();
+	return Matrix3d { Xr * s.r, Xg * s.g, Xb * s.b, Yr * s.r, Yg * s.g, Yb * s.b, Zr * s.r, Zg * s.g, Zb * s.b };
+}
+Color::Matrix3d Color::getChromaticAdaptationMatrix(const Vector3f &sourceReferenceWhite, const Vector3f &destinationReferenceWhite) {
+	const Matrix3d bradfordMatrix { 0.8951, 0.2664, -0.1614, -0.7502, 1.7135, 0.0367, 0.0389, -0.0685, 1.0296 };
+	const Matrix3d bradfordInvertedMatrix = *bradfordMatrix.inverse();
+	auto source = math::vectorCast<double>(sourceReferenceWhite) * bradfordMatrix;
+	auto destination = math::vectorCast<double>(destinationReferenceWhite) * bradfordMatrix;
+	Matrix3d matrix;
+	matrix[0] = destination.x / source.x;
+	matrix[4] = destination.y / source.y;
+	matrix[8] = destination.z / source.z;
+	return bradfordMatrix * matrix * bradfordInvertedMatrix;
+}
+Color Color::xyzChromaticAdaptation(const Matrix3d &adaptation) const {
+	return rgbVector<double>() * adaptation;
+}
+const Color::Vector3f &Color::getReference(ReferenceIlluminant illuminant, ReferenceObserver observer) {
+	return references[static_cast<uint8_t>(illuminant)][static_cast<uint8_t>(observer)];
+}
+ReferenceIlluminant Color::getIlluminant(const std::string &illuminant) {
 	const struct {
 		const char *label;
 		ReferenceIlluminant illuminant;
 	} illuminants[] = {
-		{"A", REFERENCE_ILLUMINANT_A},
-		{"C", REFERENCE_ILLUMINANT_C},
-		{"D50", REFERENCE_ILLUMINANT_D50},
-		{"D55", REFERENCE_ILLUMINANT_D55},
-		{"D65", REFERENCE_ILLUMINANT_D65},
-		{"D75", REFERENCE_ILLUMINANT_D75},
-		{"F2", REFERENCE_ILLUMINANT_F2},
-		{"F7", REFERENCE_ILLUMINANT_F7},
-		{"F11", REFERENCE_ILLUMINANT_F11},
-		{0, REFERENCE_ILLUMINANT_D50},
+		{ "A", ReferenceIlluminant::A },
+		{ "C", ReferenceIlluminant::C },
+		{ "D50", ReferenceIlluminant::D50 },
+		{ "D55", ReferenceIlluminant::D55 },
+		{ "D65", ReferenceIlluminant::D65 },
+		{ "D75", ReferenceIlluminant::D75 },
+		{ "F2", ReferenceIlluminant::F2 },
+		{ "F7", ReferenceIlluminant::F7 },
+		{ "F11", ReferenceIlluminant::F11 },
+		{ nullptr, ReferenceIlluminant::D50 },
 	};
 	for (int i = 0; illuminants[i].label; i++) {
-		if (illuminants[i].label == illuminant) {
+		if (illuminant == illuminants[i].label) {
 			return illuminants[i].illuminant;
 		}
 	}
-	return REFERENCE_ILLUMINANT_D50;
+	return ReferenceIlluminant::D50;
 };
-
-const ReferenceObserver color_get_observer(const std::string &observer) {
+ReferenceObserver Color::getObserver(const std::string &observer) {
 	const struct {
 		const char *label;
 		ReferenceObserver observer;
 	} observers[] = {
-		{"2", REFERENCE_OBSERVER_2},
-		{"10", REFERENCE_OBSERVER_10},
-		{0, REFERENCE_OBSERVER_2},
+		{ "2", ReferenceObserver::_2 },
+		{ "10", ReferenceObserver::_10 },
+		{ nullptr, ReferenceObserver::_2 },
 	};
 	for (int i = 0; observers[i].label; i++) {
-		if (observers[i].label == observer) {
+		if (observer == observers[i].label) {
 			return observers[i].observer;
 		}
 	}
-	return REFERENCE_OBSERVER_2;
-}
-
-bool color_is_rgb_out_of_gamut(const Color* a)
-{
-	if (a->rgb.red < 0 || a->rgb.red > 1) return true;
-	if (a->rgb.green < 0 || a->rgb.green > 1) return true;
-	if (a->rgb.blue < 0 || a->rgb.blue > 1) return true;
+	return ReferenceObserver::_2;
+}
+bool Color::isOutOfRgbGamut() const {
+	if (rgb.red < 0 || rgb.red > 1)
+		return true;
+	if (rgb.green < 0 || rgb.green > 1)
+		return true;
+	if (rgb.blue < 0 || rgb.blue > 1)
+		return true;
 	return false;
 }
-
-float color_distance(const Color* a, const Color* b)
-{
-	Color al, bl;
-	color_rgb_get_linear(a, &al);
-	color_rgb_get_linear(b, &bl);
-	return sqrt(
-		pow(bl.rgb.red - al.rgb.red, 2) +
-		pow(bl.rgb.green - al.rgb.green, 2) +
-		pow(bl.rgb.blue - al.rgb.blue, 2)
-	);
+float Color::distance(const Color &a, const Color &b) {
+	auto al = a.linearRgb();
+	auto bl = b.linearRgb();
+	return static_cast<float>(std::sqrt(
+		std::pow(bl.rgb.red - al.rgb.red, 2) +
+		std::pow(bl.rgb.green - al.rgb.green, 2) +
+		std::pow(bl.rgb.blue - al.rgb.blue, 2)));
+}
+float Color::distanceLch(const Color &a, const Color &b) {
+	auto al = a.labToLch();
+	auto bl = b.labToLch();
+	return static_cast<float>(std::sqrt(
+		std::pow((bl.lch.L - al.lch.L) / 1, 2) +
+		std::pow((bl.lch.C - al.lch.C) / (1 + 0.045 * al.lch.C), 2) +
+		std::pow((std::pow(a.lab.a - b.lab.a, 2) + std::pow(a.lab.b - b.lab.b, 2) - (bl.lch.C - al.lch.C)) / (1 + 0.015 * al.lch.C), 2)));
+}
+Color mix(const Color &a, const Color &b, float ratio) {
+	return (a.linearRgb() * (1.0f - ratio) + b.linearRgb() * ratio).nonLinearRgb();
 }
-
-float color_distance_lch(const Color* a, const Color* b)
-{
-	Color al, bl;
-	color_lab_to_lch(a, &al);
-	color_lab_to_lch(b, &bl);
-	return sqrt(
-		pow((bl.lch.L - al.lch.L) / 1, 2) +
-		pow((bl.lch.C - al.lch.C) / (1 + 0.045 * al.lch.C), 2) +
-		pow((pow(a->lab.a - b->lab.a, 2) + pow(a->lab.b - b->lab.b, 2) - (bl.lch.C - al.lch.C)) / (1 + 0.015 * al.lch.C), 2)
-	);
-}
-bool color_equal(const Color* a, const Color* b)
-{
-	for (int i = 0; i < 4; i++){
-		if (abs_float(a->ma[i] - b->ma[i]) > 1e-6) return false;
+bool Color::operator==(const Color &color) const {
+	for (auto i = 0; i < MemberCount; i++) {
+		if (math::abs(data[i] - color.data[i]) > 1e-6)
+			return false;
 	}
 	return true;
 }
+bool Color::operator!=(const Color &color) const {
+	for (auto i = 0; i < MemberCount; i++) {
+		if (math::abs(data[i] - color.data[i]) > 1e-6)
+			return true;
+	}
+	return false;
+}
+Color Color::operator*(float value) const {
+	return Color(data[0] * value, data[1] * value, data[2] * value, data[3] * value);
+}
+Color Color::operator/(float value) const {
+	return Color(data[0] / value, data[1] / value, data[2] / value, data[3] / value);
+}
+Color Color::operator+(const Color &color) const {
+	Color result;
+	for (auto i = 0; i < Color::MemberCount; i++)
+		result.data[i] = data[i] + color.data[i];
+	return result;
+}
+Color Color::operator-(const Color &color) const {
+	Color result;
+	for (auto i = 0; i < Color::MemberCount; i++)
+		result.data[i] = data[i] - color.data[i];
+	return result;
+}
+Color Color::operator*(const Color &color) const {
+	Color result;
+	for (auto i = 0; i < Color::MemberCount; i++)
+		result.data[i] = data[i] * color.data[i];
+	return result;
+}
+Color &Color::operator*=(const Color &color) {
+	for (auto i = 0; i < Color::MemberCount; i++)
+		data[i] *= color.data[i];
+	return *this;
+}
+Color &Color::operator+=(const Color &color) {
+	for (auto i = 0; i < Color::MemberCount; i++)
+		data[i] += color.data[i];
+	return *this;
+}
+float &Color::operator[](int index) {
+	if (index < 0 || index >= MemberCount)
+		throw std::invalid_argument("index");
+	return data[index];
+}
+float Color::operator[](int index) const {
+	if (index < 0 || index >= MemberCount)
+		throw std::invalid_argument("index");
+	return data[index];
+}
+Color Color::normalizeRgb() const {
+	Color result(*this);
+	result.rgb.red = math::clamp(rgb.red, 0.0f, 1.0f);
+	result.rgb.green = math::clamp(rgb.green, 0.0f, 1.0f);
+	result.rgb.blue = math::clamp(rgb.blue, 0.0f, 1.0f);
+	return result;
+}
+Color &Color::normalizeRgbInplace() {
+	rgb.red = math::clamp(rgb.red, 0.0f, 1.0f);
+	rgb.green = math::clamp(rgb.green, 0.0f, 1.0f);
+	rgb.blue = math::clamp(rgb.blue, 0.0f, 1.0f);
+	return *this;
+}
+Color Color::absolute() const {
+	Color result(*this);
+	for (auto i = 0; i < Color::MemberCount; i++)
+		result.data[i] = math::abs(data[i]);
+	return result;
+}
+Color &Color::absoluteInplace() {
+	for (auto i = 0; i < Color::MemberCount; i++)
+		data[i] = math::abs(data[i]);
+	return *this;
+}
+const Color &Color::getContrasting() const {
+	auto t = rgbToLab(getReference(ReferenceIlluminant::D50, ReferenceObserver::_2), sRGBMatrix, d65d50AdaptationMatrix);
+	return t.lab.L > 50 ? black : white;
+}
diff --git a/source/Color.h b/source/Color.h
index c943813..75eb00f 100644
--- a/source/Color.h
+++ b/source/Color.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2009-2016, Albertas Vyšniauskas
+ * Copyright (c) 2009-2020, Albertas Vyšniauskas
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
@@ -19,499 +19,470 @@
 #ifndef GPICK_COLOR_H_
 #define GPICK_COLOR_H_
 
-#include "MathUtil.h"
+#include "math/Matrix.h"
+#include "math/Vector.h"
 #include <string>
+#include <stdint.h>
 
 /** \file source/Color.h
  * \brief Color structure and functions to convert colors from one color space to another.
  */
 
-/** \struct Color
- * \brief Color structure is an union of all available color spaces.
- */
-struct Color {
-	Color();
-	Color(float grayValue);
-	Color(float red, float green, float blue);
-	bool operator==(const Color &color) const;
-	union{
-		struct{
-			float red; /**< Red component */
-			float green; /**< Green component */
-			float blue; /**< Blue component */
-		}rgb;
-		struct{
-			float hue;
-			float saturation;
-			float value;
-		}hsv;
-		struct{
-			float hue;
-			float saturation;
-			float lightness;
-		}hsl;
-		struct{
-			float x;
-			float y;
-			float z;
-		}xyz;
-		struct{
-			float L;
-			float a;
-			float b;
-		}lab;
-		struct{
-			float L;
-			float C;
-			float h;
-		}lch;
-		struct{
-			float c;
-			float m;
-			float y;
-		}cmy;
-		struct{
-			float c;
-			float m;
-			float y;
-			float k;
-		}cmyk;
-		struct{
-			float m1;
-			float m2;
-			float m3;
-			float m4;
-		}m; /**< General data access structure */
-		float ma[4]; /**< General data access array */
-	};
-};
-
 /** \enum ReferenceIlluminant
  * \brief Reference illuminants.
  */
-enum ReferenceIlluminant {
-	REFERENCE_ILLUMINANT_A = 0,
-	REFERENCE_ILLUMINANT_C = 1,
-	REFERENCE_ILLUMINANT_D50 = 2,
-	REFERENCE_ILLUMINANT_D55 = 3,
-	REFERENCE_ILLUMINANT_D65 = 4,
-	REFERENCE_ILLUMINANT_D75 = 5,
-	REFERENCE_ILLUMINANT_F2 = 6,
-	REFERENCE_ILLUMINANT_F7 = 7,
-	REFERENCE_ILLUMINANT_F11 = 8,
+enum class ReferenceIlluminant : uint8_t {
+	A = 0,
+	C = 1,
+	D50 = 2,
+	D55 = 3,
+	D65 = 4,
+	D75 = 5,
+	F2 = 6,
+	F7 = 7,
+	F11 = 8,
 };
 
 /** \enum ReferenceObserver
  * \brief Reference observers.
  */
-enum ReferenceObserver {
-	REFERENCE_OBSERVER_2 = 0,
-	REFERENCE_OBSERVER_10 = 1,
+enum class ReferenceObserver : uint8_t {
+	_2 = 0,
+	_10 = 1,
 };
 
-
-/**
- * Initialize things needed for color conversion functions. Must be called before using any other functions.
- */
-void color_init();
-
-/**
- * Convert RGB color space to HSL color space.
- * @param[in] a Source color in RGB color space.
- * @param[out] b Destination color in HSL color space.
- */
-void color_rgb_to_hsl(const Color* a, Color* b);
-
-/**
- * Convert HSL color space to RGB color space.
- * @param[in] a Source color in HSL color space.
- * @param[out] b Destination color in RGB color space.
- */
-void color_hsl_to_rgb(const Color* a, Color* b);
-
-/**
- * Convert HSL color space to HSV color space.
- * @param[in] a Source color in HSL color space.
- * @param[out] b Destination color in HSV color space.
- */
-void color_hsl_to_hsv(const Color *a, Color *b);
-
-/**
- * Convert HSV color space to HSL color space.
- * @param[in] a Source color in HSV color space.
- * @param[out] b Destination color in HSL color space.
- */
-void color_hsv_to_hsl(const Color *a, Color *b);
-
-/**
- * Convert RGB color space to HSV color space.
- * @param[in] a Source color in RGB color space.
- * @param[out] b Destination color in HSV color space.
- */
-void color_rgb_to_hsv(const Color* a, Color* b);
-
-/**
- * Convert HSV color space to RGB color space.
- * @param[in] a Source color in HSV color space.
- * @param[out] b Destination color in RGB color space.
- */
-void color_hsv_to_rgb(const Color* a, Color* b);
-
-/**
- * Convert RGB color space to XYZ color space.
- * @param[in] a Source color in RGB color space.
- * @param[out] b Destination color in XYZ color space.
- * @param[in] transformation Transformation matrix for RGB to XYZ conversion.
- */
-void color_rgb_to_xyz(const Color* a, Color* b, const matrix3x3* transformation);
-
-/**
- * Convert XYZ color space to RGB color space.
- * @param[in] a Source color in XYZ color space.
- * @param[out] b Destination color in RGB color space.
- * @param[in] transformation_inverted Transformation matrix for XYZ to RGB conversion.
- */
-void color_xyz_to_rgb(const Color* a, Color* b, const matrix3x3* transformation_inverted);
-
-/**
- * Convert XYZ color space to Lab color space.
- * @param[in] a Source color in XYZ color space.
- * @param[out] b Destination color in Lab color space.
- * @param[in] reference_white Reference white color values.
- */
-void color_xyz_to_lab(const Color* a, Color* b, const vector3* reference_white);
-
-/**
- * Convert Lab color space to XYZ color space.
- * @param[in] a Source color in Lab color space.
- * @param[out] b Destination color in XYZ color space.
- * @param[in] reference_white Reference white color values.
- */
-void color_lab_to_xyz(const Color* a, Color* b, const vector3* reference_white);
-
-/**
- * Convert RGB color space to Lab color space.
- * @param[in] a Source color in RGB color space.
- * @param[out] b Destination color in Lab color space.
- * @param[in] reference_white Reference white color values.
- * @param[in] transformation Transformation matrix for RGB to XYZ conversion.
- * @param[in] adaptation_matrix XYZ chromatic adaptation matrix.
- */
-void color_rgb_to_lab(const Color* a, Color* b, const vector3* reference_white, const matrix3x3* transformation, const matrix3x3* adaptation_matrix);
-
-/**
- * Convert Lab color space to RGB color space.
- * @param[in] a Source color in Lab color space.
- * @param[out] b Destination color in RGB color space.
- * @param[in] reference_white Reference white color values.
- * @param[in] transformation_inverted Transformation matrix for XYZ to RGB conversion.
- * @param[in] adaptation_matrix_inverted Inverted XYZ chromatic adaptation matrix.
- */
-void color_lab_to_rgb(const Color* a, Color* b, const vector3* reference_white, const matrix3x3* transformation_inverted, const matrix3x3* adaptation_matrix_inverted);
-
-/**
- * Convert RGB color space to Lab color space with illuminant D50, observer 2, sRGB transformation matrix and D65-D50 adaptation matrix.
- * @param[in] a Source color in RGB color space.
- * @param[out] b Destination color in Lab color space.
- */
-void color_rgb_to_lab_d50(const Color* a, Color* b);
-
-/**
- * Convert Lab color space to RGB color space with illuminant D50, observer 2, inverted sRGB transformation matrix and D50-D65 adaptation matrix.
- * @param[in] a Source color in Lab color space.
- * @param[out] b Destination color in RGB color space.
- */
-void color_lab_to_rgb_d50(const Color* a, Color* b);
-
-/**
- * Convert Lab color space to LCH color space.
- * @param[in] a Source color in Lab color space.
- * @param[out] b Destination color in LCH color space.
- */
-void color_lab_to_lch(const Color* a, Color* b);
-
-/**
- * Convert Lab color space to LCH color space.
- * @param[in] a Source color in Lab color space.
- * @param[out] b Destination color in LCH color space.
- */
-void color_lch_to_lab(const Color* a, Color* b);
-
-/**
- * Convert RGB color space to LCH color space.
- * @param[in] a Source color in RGB color space.
- * @param[out] b Destination color in LCH color space.
- * @param[in] reference_white Reference white color values.
- * @param[in] transformation Transformation matrix for RGB to XYZ conversion.
- * @param[in] adaptation_matrix XYZ chromatic adaptation matrix.
- */
-void color_rgb_to_lch(const Color* a, Color* b, const vector3* reference_white, const matrix3x3* transformation, const matrix3x3* adaptation_matrix);
-
-/**
- * Convert LCH color space to RGB color space.
- * @param[in] a Source color in LCH color space.
- * @param[out] b Destination color in RGB color space.
- * @param[in] reference_white Reference white color values.
- * @param[in] transformation_inverted Transformation matrix for XYZ to RGB conversion.
- * @param[in] adaptation_matrix_inverted Inverted XYZ chromatic adaptation matrix.
- */
-void color_lch_to_rgb(const Color* a, Color* b, const vector3* reference_white, const matrix3x3* transformation_inverted, const matrix3x3* adaptation_matrix_inverted);
-
-/**
- * Convert RGB color space to LCH color space with illuminant D50, observer 2, sRGB transformation matrix and D65-D50 adaptation matrix.
- * @param[in] a Source color in RGB color space.
- * @param[out] b Destination color in LCH color space.
- */
-void color_rgb_to_lch_d50(const Color* a, Color* b);
-
-/**
- * Convert LCH color space to RGB color space with illuminant D50, observer 2, inverted sRGB transformation matrix and D50-D65 adaptation matrix.
- * @param[in] a Source color in LCH color space.
- * @param[out] b Destination color in RGB color space.
- */
-void color_lch_to_rgb_d50(const Color* a, Color* b);
-
-/**
- * Convert RGB color space to CMY color space.
- * @param[in] a Source color in RGB color space.
- * @param[out] b Destination color in CMY color space.
- */
-void color_rgb_to_cmy(const Color* a, Color* b);
-
-/**
- * Convert CMY color space to RGB color space.
- * @param[in] a Source color in CMY color space.
- * @param[out] b Destination color in RGB color space.
- */
-void color_cmy_to_rgb(const Color* a, Color* b);
-
-/**
- * Convert CMY color space to CMYK color space.
- * @param[in] a Source color in CMY color space.
- * @param[out] b Destination color in CMYK color space.
- */
-void color_cmy_to_cmyk(const Color* a, Color* b);
-
-/**
- * Convert CMYK color space to CMY color space.
- * @param[in] a Source color in CMYK color space.
- * @param[out] b Destination color in CMY color space.
- */
-void color_cmyk_to_cmy(const Color* a, Color* b);
-
-/**
- * Convert RGB color space to CMYK color space.
- * @param[in] a Source color in RGB color space.
- * @param[out] b Destination color in CMYK color space.
- */
-void color_rgb_to_cmyk(const Color* a, Color* b);
-
-/**
- * Convert CMYK color space to RGB color space.
- * @param[in] a Source color in CMYK color space.
- * @param[out] b Destination color in RGB color space.
- */
-void color_cmyk_to_rgb(const Color* a, Color* b);
-
-
-/**
- * Normalize RGB color values.
- * @param[in,out] a Color in RGB color space.
- */
-void color_rgb_normalize(Color* a);
-
-/**
- * Check whenever the color contains invalid (out of RGB gamut) value.
- * @param[in] a Color in RGB color space.
- * @return True, when color is out of RGB gamut.
- */
-bool color_is_rgb_out_of_gamut(const Color* a);
-
-/**
- * Transform RGB color to linear RGB color.
- * @param[in] a Color in RGB color space.
- * @param[out] b Linear color in RGB color space.
- */
-void color_rgb_get_linear(const Color* a, Color* b);
-
-/**
- * Transform linear RGB color to RGB color.
- * @param[in] a Linear color in RGB color space.
- * @param[out] b Color in RGB color space.
- */
-void color_linear_get_rgb(const Color* a, Color* b);
-
-/**
- * Copy color.
- * @param[in] a Source color in any color space.
- * @param[out] b Destination color.
- */
-void color_copy(const Color* a, Color* b);
-
-/**
- * Add color values.
- * @param[in,out] a Source color in any color space.
- * @param[in] b Color values.
- */
-void color_add(Color* a, const Color* b);
-
-/**
- * Multiply color values by specified amount.
- * @param[in,out] a Source color in any color space.
- * @param[in] b Multiplier.
- */
-void color_multiply(Color* a, float b);
-
-/**
- * Set all color values to zero.
- * @param[in,out] a Color to be set.
- */
-void color_zero(Color* a);
-
-/**
- * Create new Color structure.
- * @return Color structure with unspecified values.
- */
-Color* color_new();
-
-/**
- * Free memory associated with Color structure.
- * @param[in] a Color to be freed.
- */
-void color_destroy(Color* a);
-
-/**
- * Set all color values to specified value.
- * @param[in,out] a Color to be set.
- * @param[in] value Value which is used.
- */
-void color_set(Color* a, float value);
-
-/**
- * Set color values to specified values.
- * @param[in,out] a Color to be set.
- * @param[in] red Red value which is used.
- * @param[in] green Green value which is used.
- * @param[in] blue Blue value which is used.
- */
-void color_set(Color* a, float red, float green, float blue);
-
-/**
- * Set color values to specified values.
- * @param[in,out] a Color to be set.
- * @param[in] red Red value which is used.
- * @param[in] green Green value which is used.
- * @param[in] blue Blue value which is used.
- */
-void color_set(Color* a, int red, int green, int blue);
-
-/**
- * Get either black or white color depending on which has more contrast with specified color.
- * @param[in] a Source color in RGB color space.
- * @param[out] b Color with most contrast in RGB color space.
- */
-void color_get_contrasting(const Color* a, Color* b);
-
-/**
- * Calculate working space matrix.
- * @param[in] xr Red primary in x channel.
- * @param[in] yr Red primary in y channel.
- * @param[in] xg Green primary in x channel.
- * @param[in] yg Green primary in y channel.
- * @param[in] xb Blue primary in x channel.
- * @param[in] yb Blue primary in y channel.
- * @param[in] reference_white Reference white vector.
- * @param[out] result Calculated working space matrix.
- */
-void color_get_working_space_matrix(float xr, float yr, float xg, float yg, float xb, float yb, const vector3* reference_white, matrix3x3* result);
-
-/**
- * Calculate chromatic adaptation matrix from source and destination reference white vectors.
- * @param[in] source_reference_white Source reference white vector.
- * @param[in] destination_reference_white Destination reference white vector.
- * @param[out] result Calculated chromatic adaptation matrix.
- */
-void color_get_chromatic_adaptation_matrix(const vector3* source_reference_white, const vector3* destination_reference_white, matrix3x3* result);
-
-/**
- * Apply chromatic adaptation matrix to the XYZ color.
- * @param[in] a Source color in XYZ color space.
- * @param[out] result Pointer to a Color structure where the result is stored in XYZ color space.
- * @param[in] adaptation Chromatic adaptation matrix.
- * @see color_get_chromatic_adaptation_matrix.
- */
-void color_xyz_chromatic_adaptation(const Color* a, Color* result, const matrix3x3* adaptation);
-
-/**
- * Get working space matrix for sRGB.
- * @return Constant reference to sRGB working space matrix.
- */
-const matrix3x3* color_get_sRGB_transformation_matrix();
-
-/**
- * Get inverted working space matrix for sRGB.
- * @return Constant reference to inverted sRGB working space matrix.
- */
-const matrix3x3* color_get_inverted_sRGB_transformation_matrix();
-
-/**
- * Get D65 to D50 chromatic adaptation matrix.
- * @return Constant reference to chromatic adaptation matrix.
- */
-const matrix3x3* color_get_d65_d50_adaptation_matrix();
-
-/**
- * Get D50 to D65 chromatic adaptation matrix.
- * @return Constant reference to chromatic adaptation matrix.
- */
-const matrix3x3* color_get_d50_d65_adaptation_matrix();
-
-/**
- * Get reference white vector for specified illuminant and observer.
- * @param[in] illuminant Illuminant.
- * @param[in] observer Observer.
- * @return Reference white vector.
- */
-const vector3* color_get_reference(ReferenceIlluminant illuminant, ReferenceObserver observer);
-
-/**
- * Get illuminant by name.
- * @param[in] illuminant Illuminant name.
- * @return Reference illuminant.
- */
-const ReferenceIlluminant color_get_illuminant(const char *illuminant);
-const ReferenceIlluminant color_get_illuminant(const std::string &illuminant);
-
-/**
- * Get observer by name.
- * @param[in] observer Observer name.
- * @return Reference observer.
- */
-const ReferenceObserver color_get_observer(const char *observer);
-const ReferenceObserver color_get_observer(const std::string &observer);
-
-/**
- * Get distance between two colors.
- * @param[in] a First color.
- * @param[in] b Second color.
- * @return Distance.
- */
-float color_distance(const Color* a, const Color* b);
-
-/**
- * Get distance between two colors using CIE94 color difference calculation.
- * @param[in] a First color.
- * @param[in] b Second color.
- * @return Distance.
- */
-float color_distance_lch(const Color* a, const Color* b);
-
-/**
- * Check if colors are equal.
- * @param[in] a First color.
- * @param[in] b Second color.
- * @return Equality.
+/** \struct Color
+ * \brief Color structure is an union of all available color spaces.
  */
-bool color_equal(const Color* a, const Color* b);
-
+struct Color {
+	using Matrix3d = math::Matrix3d;
+	using Vector3f = math::Vector3f;
+	using Vector3d = math::Vector3d;
+	static const int MemberCount = 4;
+	static const int ChannelCount = MemberCount;
+	static const Color white;
+	static const Color black;
+	/**
+	 * Working space matrix for sRGB.
+	 */
+	static const Matrix3d &sRGBMatrix;
+	/**
+	 * Inverted working space matrix for sRGB.
+	 */
+	static const Matrix3d &sRGBInvertedMatrix;
+	/**
+	 * D65 to D50 chromatic adaptation matrix.
+	 */
+	static const Matrix3d &d65d50AdaptationMatrix;
+	/**
+	 * D50 to D65 chromatic adaptation matrix.
+	 */
+	static const Matrix3d &d50d65AdaptationMatrix;
+	/**
+	 * Initialize things needed for color conversion functions. Must be called before using any other functions.
+	 */
+	static void initialize();
+	Color();
+	Color(const Color &color);
+	Color(float value);
+	Color(int value);
+	Color(float red, float green, float blue);
+	Color(int red, int green, int blue);
+	Color(float value1, float value2, float value3, float value4);
+	Color(const Vector3f &value);
+	Color(const Vector3d &value);
+	/**
+	 * Check if colors are equal.
+	 * @param[in] color Color in the same color space as current color.
+	 * @return True if colors are equal.
+	 */
+	bool operator==(const Color &color) const;
+	/**
+	 * Check if colors are not equal.
+	 * @param[in] color Color in the same color space as current color.
+	 * @return True if colors are not equal.
+	 */
+	bool operator!=(const Color &color) const;
+	/**
+	 * Add color values.
+	 * @param[in] color Color to be added to current color.
+	 * @return Result of two colors added together.
+	 */
+	Color operator+(const Color &color) const;
+	/**
+	 * Subtract color values.
+	 * @param[in] color Color to be subtracted from current color.
+	 * @return Result of color subtracted from current color.
+	 */
+	Color operator-(const Color &color) const;
+	/**
+	 * Add color values.
+	 * @param[in] color Color to be added to current color.
+	 * @return Result of two colors added together.
+	 */
+	Color &operator+=(const Color &color);
+	/**
+	 * Multiply color values by value.
+	 * @param[in] value Multiplier.
+	 * @return Color with all values multiplied by provided value.
+	 */
+	Color operator*(float value) const;
+	/**
+	 * Multiply color values by color values.
+	 * @param[in] color Color to multiply with.
+	 * @return Color with all values multiplied by color values.
+	 */
+	Color operator*(const Color &color) const;
+	/**
+	 * Multiply color values by color values.
+	 * @param[in] color Color to multiply with.
+	 * @return Color with all values multiplied by color values.
+	 */
+	Color &operator*=(const Color &color);
+	/**
+	 * Divide color values by value.
+	 * @param[in] value Divider.
+	 * @return Color with all values divided by provided value.
+	 */
+	Color operator/(float value) const;
+	/**
+	 * Get color value.
+	 * @param[in] index Value index.
+	 * @return Color value.
+	 */
+	float &operator[](int index);
+	/**
+	 * Get color value.
+	 * @param[in] index Value index.
+	 * @return Color value.
+	 */
+	float operator[](int index) const;
+	/**
+	 * Zero all color values.
+	 * @return Color with all values set to zero.
+	 */
+	Color &zero();
+	/**
+	 * Zero all color values.
+	 * @return Color with all values set to zero.
+	 */
+	Color zero() const;
+	/**
+	 * Transform RGB color to linear RGB color.
+	 * @return Linear color in RGB color space.
+	 */
+	Color &linearRgbInplace();
+	/**
+	 * Transform RGB color to linear RGB color.
+	 * @return Linear color in RGB color space.
+	 */
+	Color linearRgb() const;
+	/**
+	 * Transform linear RGB color to RGB color.
+	 * @return Color in RGB color space.
+	 */
+	Color &nonLinearRgbInplace();
+	/**
+	 * Transform linear RGB color to RGB color.
+	 * @return Color in RGB color space.
+	 */
+	Color nonLinearRgb() const;
+	/**
+	 * Set all color values to absolute values.
+	 * @return Color with absolute values.
+	 */
+	Color absolute() const;
+	/**
+	 * Set all color values to absolute values.
+	 * @return Color with absolute values.
+	 */
+	Color &absoluteInplace();
+	/**
+	 * Convert RGB color space to HSL color space.
+	 * @return Color in HSL color space.
+	 */
+	Color rgbToHsl() const;
+	/**
+	 * Convert HSL color space to RGB color space.
+	 * @return Color in RGB color space.
+	 */
+	Color hslToRgb() const;
+	/**
+	 * Convert HSL color space to HSV color space.
+	 * @return Color in HSV color space.
+	 */
+	Color hslToHsv() const;
+	/**
+	 * Convert HSV color space to HSL color space.
+	 * @return Color in HSL color space.
+	 */
+	Color hsvToHsl() const;
+	/**
+	 * Convert RGB color space to HSV color space.
+	 * @return Color in HSV color space.
+	 */
+	Color rgbToHsv() const;
+	/**
+	 * Convert HSV color space to RGB color space.
+	 * @return Color in RGB color space.
+	 */
+	Color hsvToRgb() const;
+	/**
+	 * Convert RGB color space to XYZ color space.
+	 * @param[in] transformation Transformation matrix for RGB to XYZ conversion.
+	 * @return Color in XYZ color space.
+	 */
+	Color rgbToXyz(const Matrix3d &transformation) const;
+	/**
+	 * Convert XYZ color space to RGB color space.
+	 * @param[in] transformationInverted Transformation matrix for XYZ to RGB conversion.
+	 * @return Color in RGB color space.
+	 */
+	Color xyzToRgb(const Matrix3d &transformationInverted) const;
+	/**
+	 * Convert XYZ color space to Lab color space.
+	 * @param[in] referenceWhite Reference white color values.
+	 * @return Color in LAB color space.
+	 */
+	Color xyzToLab(const Vector3f &referenceWhite) const;
+	/**
+	 * Convert Lab color space to XYZ color space.
+	 * @param[in] referenceWhite Reference white color values.
+	 * @return Color in XYZ  color space.
+	 */
+	Color labToXyz(const Vector3f &referenceWhite) const;
+	/**
+	 * Convert RGB color space to Lab color space.
+	 * @param[in] referenceWhite Reference white color values.
+	 * @param[in] transformation Transformation matrix for RGB to XYZ conversion.
+	 * @param[in] adaptationMatrix XYZ chromatic adaptation matrix.
+	 * @return Color in LAB color space.
+	 */
+	Color rgbToLab(const Vector3f &referenceWhite, const Matrix3d &transformation, const Matrix3d &adaptationMatrix) const;
+	/**
+	 * Convert Lab color space to RGB color space.
+	 * @param[in] referenceWhite Reference white color values.
+	 * @param[in] transformationInverted Transformation matrix for XYZ to RGB conversion.
+	 * @param[in] adaptationMatrixInverted Inverted XYZ chromatic adaptation matrix.
+	 * @return Color in RGB color space.
+	 */
+	Color labToRgb(const Vector3f &referenceWhite, const Matrix3d &transformationInverted, const Matrix3d &adaptationMatrixInverted) const;
+	/**
+	 * Convert RGB color space to Lab color space with illuminant D50, observer 2, sRGB transformation matrix and D65-D50 adaptation matrix.
+	 * @return Color in LAB color space.
+	 */
+	Color rgbToLabD50() const;
+	/**
+	 * Convert Lab color space to RGB color space with illuminant D50, observer 2, inverted sRGB transformation matrix and D50-D65 adaptation matrix.
+	 * @return Color in RGB color space.
+	 */
+	Color labToRgbD50() const;
+	/**
+	 * Convert Lab color space to LCH color space.
+	 * @return Color in LCH color space.
+	 */
+	Color labToLch() const;
+	/**
+	 * Convert Lab color space to LCH color space.
+	 * @return Color in LAB color space.
+	 */
+	Color lchToLab() const;
+	/**
+	 * Convert RGB color space to LCH color space.
+	 * @param[in] referenceWhite Reference white color values.
+	 * @param[in] transformation Transformation matrix for RGB to XYZ conversion.
+	 * @param[in] adaptationMatrix XYZ chromatic adaptation matrix.
+	 * @return Color in LCH color space.
+	 */
+	Color rgbToLch(const Vector3f &referenceWhite, const Matrix3d &transformation, const Matrix3d &adaptationMatrix) const;
+	/**
+	 * Convert LCH color space to RGB color space.
+	 * @param[in] referenceWhite Reference white color values.
+	 * @param[in] transformationInverted Transformation matrix for XYZ to RGB conversion.
+	 * @param[in] adaptationMatrixInverted Inverted XYZ chromatic adaptation matrix.
+	 * @return Color in RGB color space.
+	 */
+	Color lchToRgb(const Vector3f &referenceWhite, const Matrix3d &transformationInverted, const Matrix3d &adaptationMatrixInverted) const;
+	/**
+	 * Convert RGB color space to LCH color space with illuminant D50, observer 2, sRGB transformation matrix and D65-D50 adaptation matrix.
+	 * @return Color in LCH color space.
+	 */
+	Color rgbToLchD50() const;
+	/**
+	 * Convert LCH color space to RGB color space with illuminant D50, observer 2, inverted sRGB transformation matrix and D50-D65 adaptation matrix.
+	 * @return Color in RGB color space.
+	 */
+	Color lchToRgbD50() const;
+	/**
+	 * Convert RGB color space to CMY color space.
+	 * @return Color in CMY color space.
+	 */
+	Color rgbToCmy() const;
+	/**
+	 * Convert CMY color space to RGB color space.
+	 * @return Color in RGB color space.
+	 */
+	Color cmyToRgb() const;
+	/**
+	 * Convert CMY color space to CMYK color space.
+	 * @return Color in CMYK color space.
+	 */
+	Color cmyToCmyk() const;
+	/**
+	 * Convert CMYK color space to CMY color space.
+	 * @return Color in CMY color space.
+	 */
+	Color cmykToCmy() const;
+	/**
+	 * Convert RGB color space to CMYK color space.
+	 * @return Color in CMYK color space.
+	 */
+	Color rgbToCmyk() const;
+	/**
+	 * Convert CMYK color space to RGB color space.
+	 * @return Color in RGB color space.
+	 */
+	Color cmykToRgb() const;
+	/**
+	 * Normalize RGB color values.
+	 * @return Color with normalized RGB values.
+	 */
+	Color &normalizeRgbInplace();
+	/**
+	 * Normalize RGB color values.
+	 * @return Color with normalized RGB values.
+	 */
+	Color normalizeRgb() const;
+	/**
+	 * Check whenever the color contains invalid (out of RGB gamut) value.
+	 * @return True, when color is out of RGB gamut.
+	 */
+	bool isOutOfRgbGamut() const;
+	/**
+	 * Get either black or white color depending on which has more contrast with specified color.
+	 * @return Color with most contrast in RGB color space.
+	 */
+	const Color &getContrasting() const;
+	/**
+	 * Get RGB values as vector.
+	 * @return RGB value vector.
+	 */
+	template<typename T>
+	math::Vector<T, 3> rgbVector() const;
+	/**
+	 * Get distance between two colors.
+	 * @param[in] a First color in RGB color space.
+	 * @param[in] b Second color in RGB color space.
+	 * @return Distance.
+	 */
+	static float distance(const Color &a, const Color &b);
+	/**
+	 * Get distance between two colors using CIE94 color difference calculation.
+	 * @param[in] a First color in LAB color space.
+	 * @param[in] b Second color in LAB color space.
+	 * @return Distance.
+	 */
+	static float distanceLch(const Color &a, const Color &b);
+	/**
+	 * Mix two colors together.
+	 * @param[in] a First color in linear RGB color space.
+	 * @param[in] b Second color in linear RGB color space.
+	 * @param[in] ratio The amount of second color to mix into first color.
+	 * @return Mixed color.
+	 */
+	static Color mix(const Color &a, const Color &b, float ratio = 0.5f);
+	/**
+	 * Get reference white vector for specified illuminant and observer.
+	 * @param[in] illuminant Illuminant.
+	 * @param[in] observer Observer.
+	 * @return Reference white vector.
+	 */
+	static const Vector3f &getReference(ReferenceIlluminant illuminant, ReferenceObserver observer);
+	/**
+	 * Get illuminant by name.
+	 * @param[in] illuminant Illuminant name.
+	 * @return Reference illuminant.
+	 */
+	static ReferenceIlluminant getIlluminant(const std::string &illuminant);
+	/**
+	 * Get observer by name.
+	 * @param[in] observer Observer name.
+	 * @return Reference observer.
+	 */
+	static ReferenceObserver getObserver(const std::string &observer);
+	/**
+	 * Calculate working space matrix.
+	 * @param[in] xr Red primary in x channel.
+	 * @param[in] yr Red primary in y channel.
+	 * @param[in] xg Green primary in x channel.
+	 * @param[in] yg Green primary in y channel.
+	 * @param[in] xb Blue primary in x channel.
+	 * @param[in] yb Blue primary in y channel.
+	 * @param[in] referenceWhite Reference white vector.
+	 * @return Calculated working space matrix.
+	 */
+	static Matrix3d getWorkingSpaceMatrix(float xr, float yr, float xg, float yg, float xb, float yb, const Vector3f &referenceWhite);
+	/**
+	 * Calculate chromatic adaptation matrix from source and destination reference white vectors.
+	 * @param[in] sourceReference_white Source reference white vector.
+	 * @param[in] destinationReferenceWhite Destination reference white vector.
+	 * @return Calculated chromatic adaptation matrix.
+	 */
+	static Matrix3d getChromaticAdaptationMatrix(const Vector3f &sourceReferenceWhite, const Vector3f &destinationReferenceWhite);
+	/**
+	 * Apply chromatic adaptation matrix to the XYZ color.
+	 * @param[in] adaptation Chromatic adaptation matrix.
+	 * @return Color with applied chromatic adaptation.
+	 * @see getChromaticAdaptationMatrix.
+	 */
+	Color xyzChromaticAdaptation(const Matrix3d &adaptation) const;
+	union {
+		struct {
+			union {
+				struct {
+					float red; /**< Red component */
+					float green; /**< Green component */
+					float blue; /**< Blue component */
+				} rgb;
+				struct {
+					float hue;
+					float saturation;
+					float value;
+				} hsv;
+				struct {
+					float hue;
+					float saturation;
+					float lightness;
+				} hsl;
+				struct {
+					float x;
+					float y;
+					float z;
+				} xyz;
+				struct {
+					float L;
+					float a;
+					float b;
+				} lab;
+				struct {
+					float L;
+					float C;
+					float h;
+				} lch;
+				struct {
+					float c;
+					float m;
+					float y;
+				} cmy;
+				struct {
+					float c;
+					float m;
+					float y;
+					float k;
+				} cmyk;
+			};
+		};
+		float data[MemberCount]; /**< General data access array */
+	};
+};
 #endif /* GPICK_COLOR_H_ */
diff --git a/source/ColorMixer.cpp b/source/ColorMixer.cpp
index 031e3a9..b572a71 100644
--- a/source/ColorMixer.cpp
+++ b/source/ColorMixer.cpp
@@ -171,53 +171,42 @@ struct ColorMixerArgs {
 		if (saveSettings) {
 			options->set("opacity", opacity);
 		}
-		Color color, color2, r, hsv1, hsv2;
+		Color color, color2, r, hsv1, hsv2, hsl1, hsl2;
 		gtk_color_get_color(GTK_COLOR(secondaryColor), &color2);
 		for (int i = 0; i < Rows; ++i) {
 			gtk_color_get_color(GTK_COLOR(rows[i].input), &color);
 			switch (mixerType->mode) {
 			case Mode::normal:
-				r.rgb.red = color2.rgb.red;
-				r.rgb.green = color2.rgb.green;
-				r.rgb.blue = color2.rgb.blue;
+				r = math::mix(color.linearRgb(), color2.linearRgb(), opacity / 100.0f).nonLinearRgbInplace();
 				break;
 			case Mode::multiply:
-				r.rgb.red = color.rgb.red * color2.rgb.red;
-				r.rgb.green = color.rgb.green * color2.rgb.green;
-				r.rgb.blue = color.rgb.blue * color2.rgb.blue;
+				r = math::mix(color.linearRgb(), color.linearRgb() * color2.linearRgb(), opacity / 100.0f).nonLinearRgbInplace();
 				break;
 			case Mode::add:
-				r.rgb.red = clamp_float(color.rgb.red + color2.rgb.red, 0, 1);
-				r.rgb.green = clamp_float(color.rgb.green + color2.rgb.green, 0, 1);
-				r.rgb.blue = clamp_float(color.rgb.blue + color2.rgb.blue, 0, 1);
+				r = math::mix(color.linearRgb(), color.linearRgb() + color2.linearRgb(), opacity / 100.0f).nonLinearRgbInplace();
 				break;
 			case Mode::difference:
-				r.rgb.red = std::fabs(color.rgb.red - color2.rgb.red);
-				r.rgb.green = std::fabs(color.rgb.green - color2.rgb.green);
-				r.rgb.blue = std::fabs(color.rgb.blue - color2.rgb.blue);
+				r = math::mix(color.linearRgb(), (color.linearRgb() - color2.linearRgb()).absoluteInplace(), opacity / 100.0f).nonLinearRgbInplace();
 				break;
 			case Mode::hue:
-				color_rgb_to_hsv(&color, &hsv1);
-				color_rgb_to_hsv(&color2, &hsv2);
-				hsv1.hsv.hue = hsv2.hsv.hue;
-				color_hsv_to_rgb(&hsv1, &r);
+				hsv1 = color.rgbToHsv();
+				hsv2 = color2.rgbToHsv();
+				hsv1.hsv.hue = math::mix(hsv1.hsv.hue, hsv2.hsv.hue, opacity / 100.0f);
+				r = hsv1.hsvToRgb();
 				break;
 			case Mode::saturation:
-				color_rgb_to_hsv(&color, &hsv1);
-				color_rgb_to_hsv(&color2, &hsv2);
-				hsv1.hsv.saturation = hsv2.hsv.saturation;
-				color_hsv_to_rgb(&hsv1, &r);
+				hsv1 = color.rgbToHsv();
+				hsv2 = color2.rgbToHsv();
+				hsv1.hsv.saturation = math::mix(hsv1.hsv.saturation, hsv2.hsv.saturation, opacity / 100.0f);
+				r = hsv1.hsvToRgb();
 				break;
 			case Mode::lightness:
-				color_rgb_to_hsl(&color, &hsv1);
-				color_rgb_to_hsl(&color2, &hsv2);
-				hsv1.hsl.lightness = hsv2.hsl.lightness;
-				color_hsl_to_rgb(&hsv1, &r);
+				hsl1 = color.rgbToHsl();
+				hsl2 = color2.rgbToHsl();
+				hsl1.hsl.lightness = math::mix(hsl1.hsl.lightness, hsl2.hsl.lightness, opacity / 100.0f);
+				r = hsl1.hslToRgb();
 				break;
 			}
-			r.rgb.red = (color.rgb.red * (100 - opacity) + r.rgb.red * opacity) / 100;
-			r.rgb.green = (color.rgb.green * (100 - opacity) + r.rgb.green * opacity) / 100;
-			r.rgb.blue = (color.rgb.blue * (100 - opacity) + r.rgb.blue * opacity) / 100;
 			gtk_color_set_color(GTK_COLOR(rows[i].output), r);
 		}
 	}
@@ -373,8 +362,7 @@ static ColorSource *source_implement(ColorSource *source, GlobalState *gs, const
 			}
 		}
 	}
-	Color c;
-	color_set(&c, 0.5);
+	Color c = { 0.5f };
 	char tmp[32];
 	auto type_name = options->getString("mixer_type", "normal");
 	for (uint32_t j = 0; j < sizeof(types) / sizeof(Type); j++) {
diff --git a/source/ColorPicker.cpp b/source/ColorPicker.cpp
index 48d609b..1cc2163 100644
--- a/source/ColorPicker.cpp
+++ b/source/ColorPicker.cpp
@@ -44,10 +44,7 @@
 #include "ScreenReader.h"
 #include "Sampler.h"
 #include <gdk/gdkkeysyms.h>
-#include <math.h>
-#ifdef _MSC_VER
-#define M_PI 3.14159265359
-#endif
+#include <cmath>
 #include <string.h>
 #include <sstream>
 #include <iostream>
@@ -361,19 +358,19 @@ static void updateDisplays(ColorPickerArgs *args, GtkWidget *except_widget)
 	stringstream ss;
 	ss.setf(ios::fixed, ios::floatfield);
 	Color c_lab, c2_lab;
-	color_rgb_to_lab_d50(&c, &c_lab);
-	color_rgb_to_lab_d50(&c2, &c2_lab);
+	c_lab = c.rgbToLabD50();
+	c2_lab = c2.rgbToLabD50();
 	const ColorWheelType *wheel = &color_wheel_types_get()[0];
 	Color hsl1, hsl2;
 	double hue1, hue2;
-	color_rgb_to_hsl(&c, &hsl1);
-	color_rgb_to_hsl(&c2, &hsl2);
+	hsl1 = c.rgbToHsl();
+	hsl2 = c2.rgbToHsl();
 	wheel->rgbhue_to_hue(hsl1.hsl.hue, &hue1);
 	wheel->rgbhue_to_hue(hsl2.hsl.hue, &hue2);
 	double complementary = std::abs(hue1 - hue2);
 	complementary -= std::floor(complementary);
-	complementary *= std::sin(hsl1.hsl.lightness * M_PI) * std::sin(hsl2.hsl.lightness * M_PI);
-	complementary *= std::sin(hsl1.hsl.saturation * M_PI / 2) * std::sin(hsl2.hsl.saturation * M_PI / 2);
+	complementary *= std::sin(hsl1.hsl.lightness * math::PI) * std::sin(hsl2.hsl.lightness * math::PI);
+	complementary *= std::sin(hsl1.hsl.saturation * math::PI / 2) * std::sin(hsl2.hsl.saturation * math::PI / 2);
 	ss << std::setprecision(1) << std::abs(c_lab.lab.L - c2_lab.lab.L) + complementary * 50 << "%";
 	auto message = ss.str();
 	gtk_label_set_text(GTK_LABEL(args->contrastCheckMsg), message.c_str());
@@ -553,13 +550,13 @@ static void ser_decimal_get(GtkColorComponentComp component, int component_id, C
 		case GtkColorComponentComp::hsv:
 		case GtkColorComponentComp::hsl:
 			if (component_id == 0){
-				color->ma[component_id] = static_cast<float>(v / 360);
+				(*color)[component_id] = static_cast<float>(v / 360);
 			}else{
-				color->ma[component_id] = static_cast<float>(v / 100);
+				(*color)[component_id] = static_cast<float>(v / 100);
 			}
 			break;
 		default:
-			color->ma[component_id] = static_cast<float>(v / 100);
+			(*color)[component_id] = static_cast<float>(v / 100);
 	}
 }
 
@@ -569,13 +566,13 @@ static string ser_decimal_set(GtkColorComponentComp component, int component_id,
 		case GtkColorComponentComp::hsv:
 		case GtkColorComponentComp::hsl:
 			if (component_id == 0){
-				ss << setprecision(0) << fixed << color->ma[component_id] * 360;
+				ss << setprecision(0) << fixed << (*color)[component_id] * 360;
 			}else{
-				ss << setprecision(0) << fixed << color->ma[component_id] * 100;
+				ss << setprecision(0) << fixed << (*color)[component_id] * 100;
 			}
 			break;
 		default:
-			ss << setprecision(0) << fixed << color->ma[component_id] * 100;
+			ss << setprecision(0) << fixed << (*color)[component_id] * 100;
 	}
 	return ss.str();
 }
@@ -804,13 +801,13 @@ static int source_activate(ColorPickerArgs *args)
 	bool out_of_gamut_mask = args->options->getBool("out_of_gamut_mask", true);
 
 	gtk_color_component_set_out_of_gamut_mask(GTK_COLOR_COMPONENT(args->lab_control), out_of_gamut_mask);
-	gtk_color_component_set_lab_illuminant(GTK_COLOR_COMPONENT(args->lab_control), color_get_illuminant(args->options->getString("lab.illuminant", "D50")));
-	gtk_color_component_set_lab_observer(GTK_COLOR_COMPONENT(args->lab_control), color_get_observer(args->options->getString("lab.observer", "2")));
+	gtk_color_component_set_lab_illuminant(GTK_COLOR_COMPONENT(args->lab_control), Color::getIlluminant(args->options->getString("lab.illuminant", "D50")));
+	gtk_color_component_set_lab_observer(GTK_COLOR_COMPONENT(args->lab_control), Color::getObserver(args->options->getString("lab.observer", "2")));
 	updateComponentText(args, GTK_COLOR_COMPONENT(args->lab_control), "lab");
 
 	gtk_color_component_set_out_of_gamut_mask(GTK_COLOR_COMPONENT(args->lch_control), out_of_gamut_mask);
-	gtk_color_component_set_lab_illuminant(GTK_COLOR_COMPONENT(args->lch_control), color_get_illuminant(args->options->getString("lab.illuminant", "D50")));
-	gtk_color_component_set_lab_observer(GTK_COLOR_COMPONENT(args->lch_control), color_get_observer(args->options->getString("lab.observer", "2")));
+	gtk_color_component_set_lab_illuminant(GTK_COLOR_COMPONENT(args->lch_control), Color::getIlluminant(args->options->getString("lab.illuminant", "D50")));
+	gtk_color_component_set_lab_observer(GTK_COLOR_COMPONENT(args->lch_control), Color::getObserver(args->options->getString("lab.observer", "2")));
 	updateComponentText(args, GTK_COLOR_COMPONENT(args->lch_control), "lch");
 
 	auto chain = args->gs->getTransformationChain();
@@ -923,21 +920,14 @@ static ColorSource* source_implement(ColorSource *source, GlobalState *gs, const
 
 			{
 				char tmp[32];
-				Color color;
 				for (gint i=1; i<7; ++i){
 					sprintf(tmp, "swatch.color%d", i);
-					Color color, result;
-					color.hsl.hue = (i - 1) / 15.f;
-					color.hsl.saturation = 0.8f;
-					color.hsl.lightness = 0.5f;
-					color_hsl_to_rgb(&color, &result);
+					Color color = Color((i - 1) / 15.f, 0.8f, 0.5f).hslToRgb();
 					color = options->getColor(tmp, color);
 					gtk_swatch_set_color(GTK_SWATCH(args->swatch_display), i, color);
 				}
 			}
 
-
-
 			args->color_code = gtk_color_new();
 			gtk_box_pack_start (GTK_BOX(vbox), args->color_code, false, true, 0);
 			g_signal_connect(G_OBJECT(args->color_code), "activated", G_CALLBACK(show_dialog_converter), args);
diff --git a/source/ColorRYB.cpp b/source/ColorRYB.cpp
index 07fbb39..b4732cd 100644
--- a/source/ColorRYB.cpp
+++ b/source/ColorRYB.cpp
@@ -123,11 +123,10 @@ int color_rgbhue_to_rybhue(double rgb_hue, double* ryb_hue){
 
 	Color color, color2;
 	for (int limit=100; limit>0; --limit){
-		color.rgb.red = bezier_eval_at_x(red, hue*36, 0.01),
-		color.rgb.green = bezier_eval_at_x(green, hue*36, 0.01),
-		color.rgb.blue = bezier_eval_at_x(blue, hue*36, 0.01);
-
-		color_rgb_to_hsv(&color, &color2);
+		color.rgb.red = static_cast<float>(bezier_eval_at_x(red, hue*36, 0.01));
+		color.rgb.green = static_cast<float>(bezier_eval_at_x(green, hue*36, 0.01));
+		color.rgb.blue = static_cast<float>(bezier_eval_at_x(blue, hue*36, 0.01));
+		color2 = color.rgbToHsv();
 
 		d = rgb_hue - color2.hsv.hue;
 		if (fabs(d)<delta){
@@ -185,9 +184,9 @@ void color_rybhue_to_rgb(double hue, Color* color){
 	list<bezier*> red, green, blue;
 	color_get_ryb_curves(red, green, blue);
 
-	color->rgb.red = bezier_eval_at_x(red, hue*36, 0.01),
-	color->rgb.green = bezier_eval_at_x(green, hue*36, 0.01),
-	color->rgb.blue = bezier_eval_at_x(blue, hue*36, 0.01);
+	color->rgb.red = static_cast<float>(bezier_eval_at_x(red, hue*36, 0.01));
+	color->rgb.green = static_cast<float>(bezier_eval_at_x(green, hue*36, 0.01));
+	color->rgb.blue = static_cast<float>(bezier_eval_at_x(blue, hue*36, 0.01));
 }
 
 double color_ryb_transform_lightness(double hue1, double hue2){
@@ -210,8 +209,8 @@ double color_ryb_transform_lightness(double hue1, double hue2){
 	};
 	int32_t samples=sizeof(values)/sizeof(double)-1;
 	double n;
-	return 	mix_double(values[int(floor(hue2*samples))], values[int(floor(hue2*samples))+1], modf(hue2*samples,&n))/
-			mix_double(values[int(floor(hue2*samples))], values[int(floor(hue1*samples))+1], modf(hue1*samples,&n));
+	return math::mix(values[int(floor(hue2*samples))], values[int(floor(hue2*samples))+1], modf(hue2*samples,&n))/
+		math::mix(values[int(floor(hue2*samples))], values[int(floor(hue1*samples))+1], modf(hue1*samples,&n));
 }
 
 double color_ryb_transform_hue(double hue, bool forward){
@@ -248,7 +247,7 @@ double color_ryb_transform_hue(double hue, bool forward){
 
 				mix = (hue-values[index1])/(values[index2]-values[index1]);
 
-				new_hue= mix_double(value1, value2, mix);
+				new_hue = math::mix(value1, value2, mix);
 
 				return new_hue;
 			}
@@ -261,7 +260,7 @@ double color_ryb_transform_hue(double hue, bool forward){
 		double n;
 		double mix = modf(hue*samples, &n);
 
-		new_hue = mix_double(value1, value2, mix);
+		new_hue = math::mix(value1, value2, mix);
 
 		return new_hue;
 	}
diff --git a/source/ColorWheelType.cpp b/source/ColorWheelType.cpp
index e419e83..f361767 100644
--- a/source/ColorWheelType.cpp
+++ b/source/ColorWheelType.cpp
@@ -23,7 +23,7 @@
 
 
 static void rgb_hue2hue(double hue, Color* hsl){
-	hsl->hsl.hue = hue;
+	hsl->hsl.hue = static_cast<float>(hue);
 	hsl->hsl.saturation = 1;
 	hsl->hsl.lightness = 0.5;
 }
@@ -35,7 +35,7 @@ static void rgb_rgbhue2hue(double rgbhue, double *hue){
 static void ryb1_hue2hue(double hue, Color* hsl){
 	Color c;
 	color_rybhue_to_rgb(hue, &c);
-	color_rgb_to_hsl(&c, hsl);
+	*hsl = c.rgbToHsl();
 }
 
 static void ryb1_rgbhue2hue(double rgbhue, double *hue){
@@ -43,7 +43,7 @@ static void ryb1_rgbhue2hue(double rgbhue, double *hue){
 }
 
 static void ryb2_hue2hue(double hue, Color* hsl){
-	hsl->hsl.hue = color_rybhue_to_rgbhue_f(hue);
+	hsl->hsl.hue = static_cast<float>(color_rybhue_to_rgbhue_f(hue));
 	hsl->hsl.saturation = 1;
 	hsl->hsl.lightness = 0.5;
 }
diff --git a/source/GenerateScheme.cpp b/source/GenerateScheme.cpp
index 3ce0e96..30eb3ff 100644
--- a/source/GenerateScheme.cpp
+++ b/source/GenerateScheme.cpp
@@ -111,14 +111,14 @@ struct GenerateSchemeArgs {
 		Color color = colorObject.getColor();
 		float hue, saturation, lightness, shiftedHue;
 		Color hsl, hsv, hslResult;
-		color_rgb_to_hsv(&color, &hsv);
-		color_hsv_to_hsl(&hsv, &hsl);
+		hsv = color.rgbToHsv();
+		hsl = hsv.hsvToHsl();
 		int wheelType = gtk_combo_box_get_active(GTK_COMBO_BOX(wheelTypeCombo));
 		auto &wheel = color_wheel_types_get()[wheelType];
 		double tmp;
 		wheel.rgbhue_to_hue(hsl.hsl.hue, &tmp);
 		hue = static_cast<float>(tmp);
-		shiftedHue = wrap_float(hue - items[index].colorHue - items[index].hueShift);
+		shiftedHue = math::wrap(hue - items[index].colorHue - items[index].hueShift);
 		wheel.hue_to_hsl(hue, &hslResult);
 		saturation = hsl.hsl.saturation * 1 / hslResult.hsl.saturation;
 		lightness = hsl.hsl.lightness - hslResult.hsl.lightness;
@@ -199,7 +199,7 @@ struct GenerateSchemeArgs {
 	static void onHueChange(GtkWidget *widget, gint colorId, GenerateSchemeArgs *args) {
 		if (args->wheelLocked) {
 			float hue = static_cast<float>(gtk_range_get_value(GTK_RANGE(args->hueRange)) / 360.0f);
-			hue = wrap_float(hue - args->items[colorId].hueShift + static_cast<float>(gtk_color_wheel_get_hue(GTK_COLOR_WHEEL(widget), colorId)) - args->items[colorId].originalHue);
+			hue = math::wrap(hue - args->items[colorId].hueShift + static_cast<float>(gtk_color_wheel_get_hue(GTK_COLOR_WHEEL(widget), colorId)) - args->items[colorId].originalHue);
 			gtk_range_set_value(GTK_RANGE(args->hueRange), hue * 360.0f);
 		} else {
 			args->items[colorId].hueShift = static_cast<float>(gtk_color_wheel_get_hue(GTK_COLOR_WHEEL(widget), colorId)) - args->items[colorId].originalHue;
@@ -252,25 +252,25 @@ struct GenerateSchemeArgs {
 		float hueStep;
 		Color hsv;
 		for (int i = 0; i < colorCount; ++i) {
-			wheel.hue_to_hsl(wrap_float(hue + items[i].hueShift), &hsl);
-			hsl.hsl.lightness = clamp_float(hsl.hsl.lightness + lightness, 0, 1);
-			hsl.hsl.saturation = clamp_float(hsl.hsl.saturation * saturation, 0, 1);
-			color_hsl_to_hsv(&hsl, &hsv);
+			wheel.hue_to_hsl(math::wrap(hue + items[i].hueShift), &hsl);
+			hsl.hsl.lightness = math::clamp(hsl.hsl.lightness + lightness, 0.0f, 1.0f);
+			hsl.hsl.saturation = math::clamp(hsl.hsl.saturation * saturation, 0.0f, 1.0f);
+			hsv = hsl.hslToHsv();
 			items[i].originalHue = hue;
 			items[i].originalSaturation = hsv.hsv.saturation;
 			items[i].originalValue = hsv.hsv.value;
-			hsv.hsv.saturation = clamp_float(hsv.hsv.saturation + items[i].saturationShift, 0, 1);
-			hsv.hsv.value = clamp_float(hsv.hsv.value + items[i].valueShift, 0, 1);
-			color_hsv_to_rgb(&hsv, &r);
+			hsv.hsv.saturation = math::clamp(hsv.hsv.saturation + items[i].saturationShift, 0.0f, 1.0f);
+			hsv.hsv.value = math::clamp(hsv.hsv.value + items[i].valueShift, 0.0f, 1.0f);
+			r = hsv.hsvToRgb();
 			auto text = gs->converters().serialize(r, Converters::Type::display);
 			gtk_color_set_color(GTK_COLOR(items[i].widget), r, text);
 			items[i].colorHue = hueOffset;
-			gtk_color_wheel_set_hue(GTK_COLOR_WHEEL(colorWheel), i, wrap_float(hue + items[i].hueShift));
+			gtk_color_wheel_set_hue(GTK_COLOR_WHEEL(colorWheel), i, math::wrap(hue + items[i].hueShift));
 			gtk_color_wheel_set_saturation(GTK_COLOR_WHEEL(colorWheel), i, hsv.hsv.saturation);
 			gtk_color_wheel_set_value(GTK_COLOR_WHEEL(colorWheel), i, hsv.hsv.value);
 			hueStep = (generate_scheme_get_scheme_type(type)->turn[i % generate_scheme_get_scheme_type(type)->turn_types]) / (360.0f) + chaos * static_cast<float>(random_get_double(gs->getRandom()) - 0.5);
-			hue = wrap_float(hue + hueStep);
-			hueOffset = wrap_float(hueOffset + hueStep);
+			hue = math::wrap(hue + hueStep);
+			hueOffset = math::wrap(hueOffset + hueStep);
 		}
 	}
 	struct Editable: IEditableColorsUI, IMenuExtension {
@@ -344,7 +344,7 @@ struct GenerateSchemeArgs {
 			Color color, hsl;
 			float hue;
 			color = colorObject.getColor();
-			color_rgb_to_hsl(&color, &hsl);
+			hsl = color.rgbToHsl();
 			int wheelType = gtk_combo_box_get_active(GTK_COMBO_BOX(args->wheelTypeCombo));
 			auto &wheel = color_wheel_types_get()[wheelType];
 			double tmp;
@@ -352,7 +352,7 @@ struct GenerateSchemeArgs {
 			hue = static_cast<float>(tmp);
 			if (args->wheelLocked) {
 				float hueShift = (hue - args->items[index].originalHue) - args->items[index].hueShift;
-				hue = wrap_float(static_cast<float>(gtk_range_get_value(GTK_RANGE(args->hueRange))) / 360.0f + hueShift);
+				hue = math::wrap(static_cast<float>(gtk_range_get_value(GTK_RANGE(args->hueRange))) / 360.0f + hueShift);
 				gtk_range_set_value(GTK_RANGE(args->hueRange), hue * 360.0f);
 			} else {
 				args->items[index].hueShift = hue - args->items[index].originalHue;
diff --git a/source/HtmlUtils.cpp b/source/HtmlUtils.cpp
index 4395333..52b2242 100644
--- a/source/HtmlUtils.cpp
+++ b/source/HtmlUtils.cpp
@@ -21,81 +21,82 @@
 #include <algorithm>
 #include <iterator>
 #include <boost/math/special_functions/round.hpp>
-using namespace std;
 
 template<typename InputIterator, typename OutputIterator>
-OutputIterator copy_zero_terminated_string(InputIterator begin, OutputIterator out)
-{
+OutputIterator copy_zero_terminated_string(InputIterator begin, OutputIterator out) {
 	while (*begin != '\0'){
 		*out++ = *begin++;
 	}
 	return out;
 }
 template<typename InputIterator, typename OutputIterator>
-OutputIterator escape(InputIterator begin, InputIterator end, OutputIterator out)
-{
-	const char escape_chars[] = {'&', '"', '\'', '<', '>'};
+OutputIterator escape(InputIterator begin, InputIterator end, OutputIterator out) {
+	const char escapeChars[] = {'&', '"', '\'', '<', '>'};
 	const char *replacements[] = {"&amp;", "&quot;", "&apos;", "&lt;", "&gt;"};
-	const size_t n_escape_chars = sizeof(escape_chars) / sizeof(const char);
+	const size_t escapeCharCount = sizeof(escapeChars) / sizeof(const char);
 	for (; begin != end; ++begin){
-		size_t escape_char_index = distance(escape_chars, find(escape_chars, escape_chars + n_escape_chars, *begin));
-		if (escape_char_index != n_escape_chars){
-			out = copy_zero_terminated_string(replacements[escape_char_index], out);
+		size_t escapeCharIndex = std::distance(escapeChars, std::find(escapeChars, escapeChars + escapeCharCount, *begin));
+		if (escapeCharIndex != escapeCharCount){
+			out = copy_zero_terminated_string(replacements[escapeCharIndex], out);
 		}else{
 			*out++ = *begin;
 		}
 	}
 	return out;
 }
-string &escapeHtmlInplace(string &str)
-{
-	string result;
+HtmlRGB::HtmlRGB(const Color &color):
+	color(color) {
+}
+HtmlHEX::HtmlHEX(const Color &color):
+	color(color) {
+}
+HtmlHSL::HtmlHSL(const Color &color):
+	color(color) {
+}
+std::string &escapeHtmlInplace(std::string &str) {
+	std::string result;
 	result.reserve(str.size());
-	escape(str.begin(), str.end(), back_inserter(result));
+	escape(str.begin(), str.end(), std::back_inserter(result));
 	str.swap(result);
 	return str;
 }
-string escapeHtml(const string &str)
-{
-	string result;
+std::string escapeHtml(const std::string &str) {
+	std::string result;
 	result.reserve(str.size());
-	escape(str.begin(), str.end(), back_inserter(result));
+	escape(str.begin(), str.end(), std::back_inserter(result));
 	return result;
 }
-std::ostream& operator<<(std::ostream& os, const HtmlRGB color)
-{
+std::ostream& operator<<(std::ostream& os, const HtmlRGB color) {
 	using boost::math::iround;
 	int r, g, b;
-	r = iround(color.color->rgb.red * 255);
-	g = iround(color.color->rgb.green * 255);
-	b = iround(color.color->rgb.blue * 255);
+	r = iround(color.color.rgb.red * 255);
+	g = iround(color.color.rgb.green * 255);
+	b = iround(color.color.rgb.blue * 255);
 	auto flags = os.flags();
-	os << "rgb(" << dec << r << ", " << g << ", " << b << ")";
+	os << "rgb(" << std::dec << r << ", " << g << ", " << b << ")";
 	os.setf(flags);
 	return os;
 }
-std::ostream& operator<<(std::ostream& os, const HtmlHEX color)
-{
+std::ostream& operator<<(std::ostream& os, const HtmlHEX color) {
 	using boost::math::iround;
 	int r, g, b;
-	r = iround(color.color->rgb.red * 255);
-	g = iround(color.color->rgb.green * 255);
-	b = iround(color.color->rgb.blue * 255);
+	r = iround(color.color.rgb.red * 255);
+	g = iround(color.color.rgb.green * 255);
+	b = iround(color.color.rgb.blue * 255);
 	char fill = os.fill();
 	auto flags = os.flags();
-	os << "#" << hex << setfill('0') << setw(2) << r << setw(2) << g << setw(2) << b << setfill(fill);
+	os << "#" << std::hex << std::setfill('0') << std::setw(2) << r << std::setw(2) << g << std::setw(2) << b << std::setfill(fill);
 	os.setf(flags);
 	return os;
 }
-std::ostream& operator<<(std::ostream& os, const HtmlHSL color)
-{
+std::ostream& operator<<(std::ostream& os, const HtmlHSL color) {
 	using boost::math::iround;
 	int h, s, l;
-	h = iround(color.color->hsl.hue * 360);
-	s = iround(color.color->hsl.saturation * 100);
-	l = iround(color.color->hsl.lightness * 100);
+	h = iround(color.color.hsl.hue * 360);
+	s = iround(color.color.hsl.saturation * 100);
+	l = iround(color.color.hsl.lightness * 100);
 	auto flags = os.flags();
-	os << "hsl(" << dec << h << ", " << s << "%, " << l << "%)";
+	os << "hsl(" << std::dec << h << ", " << s << "%, " << l << "%)";
 	os.setf(flags);
 	return os;
 }
diff --git a/source/HtmlUtils.h b/source/HtmlUtils.h
index c289e31..299008e 100644
--- a/source/HtmlUtils.h
+++ b/source/HtmlUtils.h
@@ -18,27 +18,24 @@
 
 #ifndef GPICK_HTML_UTILS_H_
 #define GPICK_HTML_UTILS_H_
-
 #include <string>
-#include <iostream>
+#include <iosfwd>
 std::string &escapeHtmlInplace(std::string &str);
 std::string escapeHtml(const std::string &str);
-
 struct Color;
-struct HtmlRGB
-{
-	Color *color;
+struct HtmlRGB {
+	HtmlRGB(const Color &color);
+	const Color &color;
 };
-struct HtmlHEX
-{
-	Color *color;
+struct HtmlHEX {
+	HtmlHEX(const Color &color);
+	const Color &color;
 };
-struct HtmlHSL
-{
-	Color *color;
+struct HtmlHSL {
+	HtmlHSL(const Color &color);
+	const Color &color;
 };
 std::ostream& operator<<(std::ostream& os, const HtmlRGB color);
 std::ostream& operator<<(std::ostream& os, const HtmlHEX color);
 std::ostream& operator<<(std::ostream& os, const HtmlHSL color);
-
 #endif /* GPICK_HTML_UTILS_H_ */
diff --git a/source/ImportExport.cpp b/source/ImportExport.cpp
index a6f6a17..1fce4d4 100644
--- a/source/ImportExport.cpp
+++ b/source/ImportExport.cpp
@@ -220,9 +220,9 @@ bool ImportExport::importGPL()
 		ss >> r >> g >> b;
 		getline(ss, line);
 		if (!f.good()) line = "";
-		c.rgb.red = r / 255.0;
-		c.rgb.green = g / 255.0;
-		c.rgb.blue = b / 255.0;
+		c.rgb.red = r / 255.0f;
+		c.rgb.green = g / 255.0f;
+		c.rgb.blue = b / 255.0f;
 		color_object = color_list_new_color_object(m_color_list, &c);
 		stripLeadingTrailingChars(line, strip_chars);
 		color_object->setName(line);
@@ -336,11 +336,11 @@ static void cssColor(ColorObject* color_object, ostream &stream)
 {
 	Color color, hsl;
 	color = color_object->getColor();
-	color_rgb_to_hsl(&color, &hsl);
+	hsl = color.rgbToHsl();
 	stream << " * " << color_object->getName()
-		<< ": " << HtmlHEX{&color}
-		<< ", " << HtmlRGB{&color}
-		<< ", " << HtmlHSL{&color}
+		<< ": " << HtmlHEX{color}
+		<< ", " << HtmlRGB{color}
+		<< ", " << HtmlHSL{color}
 		<< endl;
 }
 bool ImportExport::exportCSS()
@@ -374,21 +374,25 @@ static void htmlColor(ColorObject* color_object, bool include_color_name, ostrea
 {
 	Color color, text_color;
 	color = color_object->getColor();
-	color_get_contrasting(&color, &text_color);
-	stream << "<div style=\"background-color:" << HtmlRGB{&color} << "; color:" << HtmlRGB{&text_color} << "\">";
+	text_color = color.getContrasting();
+	stream << "<div style=\"background-color:" << HtmlRGB{color} << "; color:" << HtmlRGB{text_color} << "\">";
 	if (include_color_name){
 		string name = color_object->getName();
 		escapeHtmlInplace(name);
 		if (!name.empty())
 			stream << name << ":<br/>";
 	}
-	stream << "<span>" << HtmlHEX{&color} << "</span>" << "</div>";
+	stream << "<span>" << HtmlHEX{color} << "</span>" << "</div>";
 }
-static string getHtmlColor(ColorObject* color_object)
-{
-	Color color = color_object->getColor();
-	stringstream ss;
-	ss << HtmlRGB{&color};
+static string getHtmlColor(ColorObject* colorObject) {
+	Color color = colorObject->getColor();
+	std::stringstream ss;
+	ss << HtmlRGB{color};
+	return ss.str();
+}
+static string getHtmlColor(const Color &color) {
+	std::stringstream ss;
+	ss << HtmlRGB{color};
 	return ss.str();
 }
 bool ImportExport::exportHTML()
@@ -415,26 +419,38 @@ bool ImportExport::exportHTML()
 		case ItemSize::controllable:
 			break;
 	}
-	string background = "";
+	std::string htmlBackgroundCss = "";
+	std::string htmlColorCss = "";
 	switch (m_background){
 		case Background::none:
 			break;
 		case Background::white:
-			background = "background-color:white;";
+			htmlBackgroundCss = "background-color:white;";
+			htmlColorCss = "color:black;";
 			break;
 		case Background::gray:
-			background = "background-color:gray;";
+			htmlBackgroundCss = "background-color:gray;";
+			htmlColorCss = "color:black;";
 			break;
 		case Background::black:
-			background = "background-color:black;";
+			htmlBackgroundCss = "background-color:black;";
+			htmlColorCss = "color:white;";
 			break;
 		case Background::first_color:
-			if (!ordered.empty())
-				background = "background-color:" + getHtmlColor(ordered.front()) + ";";
+			if (!ordered.empty()) {
+				htmlBackgroundCss = "background-color:" + getHtmlColor(ordered.front()) + ";";
+				auto color = ordered.front()->getColor();
+				Color textColor = color.getContrasting();
+				htmlColorCss = "color:" + getHtmlColor(textColor) + ";";
+			}
 			break;
 		case Background::last_color:
-			if (!ordered.empty())
-				background = "background-color:" + getHtmlColor(ordered.back()) + ";";
+			if (!ordered.empty()) {
+				htmlBackgroundCss = "background-color:" + getHtmlColor(ordered.back()) + ";";
+				auto color = ordered.back()->getColor();
+				Color textColor = color.getContrasting();
+				htmlColorCss = "color:" + getHtmlColor(textColor) + ";";
+			}
 			break;
 		case Background::controllable:
 			break;
@@ -446,7 +462,7 @@ bool ImportExport::exportHTML()
 		<< "div#colors div{float: left; width: " << item_size << "px; height: " << item_size << "px; margin: 2px; text-align: center; font-size: 12px; font-family: Arial, Helvetica, sans-serif}" << endl
 		<< "div#colors div span{font-weight: bold; cursor: pointer}" << endl
 		<< "div#colors div span:hover{text-decoration: underline}" << endl
-		<< "html{" << background << "}" << endl
+		<< "html{" << htmlBackgroundCss << htmlColorCss << "}" << endl
 		<< "input{margin-left: 1em;}" << endl
 		<< "</style>"
 		<< "</head>" << endl
@@ -679,7 +695,7 @@ bool ImportExport::importASE()
 					c2.cmyk.m = cmyk[1].f;
 					c2.cmyk.y = cmyk[2].f;
 					c2.cmyk.k = cmyk[3].f;
-					color_cmyk_to_rgb(&c2, &c);
+					c = c2.cmykToRgb();
 					color_supported = 1;
 				}else if (memcmp(color_space, "Gray", 4) == 0){
 					FloatInt gray;
@@ -696,13 +712,13 @@ bool ImportExport::importASE()
 					lab[0].i = boost::endian::big_to_native<uint32_t>(lab[0].i);
 					lab[1].i = boost::endian::big_to_native<uint32_t>(lab[1].i);
 					lab[2].i = boost::endian::big_to_native<uint32_t>(lab[2].i);
-					c2.lab.L = lab[0].f*100;
+					c2.lab.L = lab[0].f * 100;
 					c2.lab.a = lab[1].f;
 					c2.lab.b = lab[2].f;
-					color_lab_to_rgb_d50(&c2, &c);
-					c.rgb.red = clamp_float(c.rgb.red, 0, 1);
-					c.rgb.green = clamp_float(c.rgb.green, 0, 1);
-					c.rgb.blue = clamp_float(c.rgb.blue, 0, 1);
+					c = c2.labToRgbD50();
+					c.rgb.red = math::clamp(c.rgb.red, 0.0f, 1.0f);
+					c.rgb.green = math::clamp(c.rgb.green, 0.0f, 1.0f);
+					c.rgb.blue = math::clamp(c.rgb.blue, 0.0f, 1.0f);
 					color_supported = 1;
 				}
 				if (color_supported){
@@ -763,9 +779,9 @@ bool ImportExport::importRGBTXT()
 		if (hash_position != string::npos){
 			size_t last_non_space = rfind_first_of_not(line, hash_position, " \t");
 
-			c.rgb.red = hexPairToInt(&line.at(hash_position + 1)) / 255.0;
-			c.rgb.green = hexPairToInt(&line.at(hash_position + 3)) / 255.0;
-			c.rgb.blue = hexPairToInt(&line.at(hash_position + 5)) / 255.0;
+			c.rgb.red = hexPairToInt(&line.at(hash_position + 1)) / 255.0f;
+			c.rgb.green = hexPairToInt(&line.at(hash_position + 3)) / 255.0f;
+			c.rgb.blue = hexPairToInt(&line.at(hash_position + 5)) / 255.0f;
 
 			color_object = color_list_new_color_object(m_color_list, &c);
 			if (last_non_space != string::npos){
diff --git a/source/MathUtil.cpp b/source/MathUtil.cpp
index 2d18c8c..f355bd4 100644
--- a/source/MathUtil.cpp
+++ b/source/MathUtil.cpp
@@ -17,82 +17,10 @@
  */
 
 #include "MathUtil.h"
+#include "math/Algorithms.h"
 #include <math.h>
 #include <string.h>
 
-float max_float_3(float a, float b, float c) {
-	if (a > b){
-		if (a > c){
-			return a;
-		}else{
-			return c;
-		}
-	}else{
-		if (b > c){
-			return b;
-		}else{
-			return c;
-		}
-	}
-}
-
-float min_float_3(float a, float b, float c) {
-	if (a < b){
-		if (a < c){
-			return a;
-		}else{
-			return c;
-		}
-	}else{
-		if (b < c){
-			return b;
-		}else{
-			return c;
-		}
-	}
-}
-
-float clamp_float(float x, float a, float b) {
-	if (x < a)
-		return a;
-	if (x > b)
-		return b;
-	return x;
-}
-
-
-int clamp_int(int x, int a, int b) {
-	if (x < a)
-		return a;
-	if (x > b)
-		return b;
-	return x;
-}
-
-int min_int(int a, int b) {
-	if (a > b)
-		return b;
-	return a;
-}
-
-int max_int(int a, int b) {
-	if (a < b)
-		return b;
-	return a;
-}
-
-int abs_int(int a) {
-	if (a < 0)
-		return -a;
-	return a;
-}
-
-float abs_float(float a) {
-	if (a < 0)
-		return -a;
-	return a;
-}
-
 void matrix3x3_identity(matrix3x3* matrix) {
 	int i,j;
 	for (i=0;i<3;++i){
@@ -246,9 +174,9 @@ void vector3_multiply_matrix3x3(const vector3* vector, const matrix3x3* matrix,
 		vector=&vector_t;
 	}
 
-	result->x = vector->x * matrix->m[0][0] + vector->y * matrix->m[0][1] + vector->z * matrix->m[0][2];
-	result->y = vector->x * matrix->m[1][0] + vector->y * matrix->m[1][1] + vector->z * matrix->m[1][2];
-	result->z = vector->x * matrix->m[2][0] + vector->y * matrix->m[2][1] + vector->z * matrix->m[2][2];
+	result->x = static_cast<float>(vector->x * matrix->m[0][0] + vector->y * matrix->m[0][1] + vector->z * matrix->m[0][2]);
+	result->y = static_cast<float>(vector->x * matrix->m[1][0] + vector->y * matrix->m[1][1] + vector->z * matrix->m[1][2]);
+	result->z = static_cast<float>(vector->x * matrix->m[2][0] + vector->y * matrix->m[2][1] + vector->z * matrix->m[2][2]);
 }
 
 void vector3_set(vector3* vector, float x, float y, float z) {
@@ -266,7 +194,7 @@ float vector3_length(const vector3* vector) {
 }
 
 void vector3_clamp(vector3* vector, float a, float b){
-	vector->x = clamp_float(vector->x, a, b);
-	vector->y = clamp_float(vector->y, a, b);
-	vector->z = clamp_float(vector->z, a, b);
+	vector->x = math::clamp(vector->x, a, b);
+	vector->y = math::clamp(vector->y, a, b);
+	vector->z = math::clamp(vector->z, a, b);
 }
diff --git a/source/MathUtil.h b/source/MathUtil.h
index eeebabe..71d8386 100644
--- a/source/MathUtil.h
+++ b/source/MathUtil.h
@@ -19,33 +19,6 @@
 #ifndef GPICK_MATH_UTIL_H_
 #define GPICK_MATH_UTIL_H_
 
-#define PI 3.14159265
-
-float min_float_3(float a, float b, float c);
-
-float max_float_3(float a, float b, float c);
-
-int min_int(int a, int b);
-
-int max_int(int a, int b);
-
-int wrap_int(int x, int a, int b);
-
-float clamp_float(float x, float a, float b);
-
-float wrap_float(float x);
-
-float mix_float(float a, float b, float mix);
-
-int clamp_int(int x, int a, int b);
-
-int abs_int(int a);
-
-float abs_float(float a);
-
-double mix_double(double a, double b, double mix);
-
-
 typedef struct matrix3x3{
 	double m[3][3];
 }matrix3x3;
diff --git a/source/Sampler.cpp b/source/Sampler.cpp
index 7a7cb0a..70d712e 100644
--- a/source/Sampler.cpp
+++ b/source/Sampler.cpp
@@ -19,7 +19,7 @@
 #include "Sampler.h"
 #include "ScreenReader.h"
 #include "MathUtil.h"
-#include <math.h>
+#include <cmath>
 #include <gdk/gdk.h>
 using namespace math;
 
@@ -93,27 +93,26 @@ static void get_pixel(unsigned char *data, int stride, int x, int y, Color* colo
 {
 	unsigned char *p;
 	p = data + y * stride + x * 4;
-	color->rgb.red = p[2] * (1 / 255.0);
-	color->rgb.green = p[1] * (1 / 255.0);
-	color->rgb.blue = p[0] * (1 / 255.0);
+	color->rgb.red = p[2] * (1 / 255.0f);
+	color->rgb.green = p[1] * (1 / 255.0f);
+	color->rgb.blue = p[0] * (1 / 255.0f);
 }
 int sampler_get_color_sample(Sampler *sampler, Vec2<int>& pointer, Rect2<int>& screen_rect, Vec2<int>& offset, Color* color)
 {
-	Color sample, result;
+	Color sample, result = { 0.0f };
 	float divider = 0;
-	color_zero(&result);
 	cairo_surface_t *surface = screen_reader_get_surface(sampler->screen_reader);
 	int x = pointer.x, y = pointer.y;
 	int left, right, top, bottom;
-	left = max_int(screen_rect.getLeft(), x - sampler->oversample);
-	right = min_int(screen_rect.getRight(), x + sampler->oversample + 1);
-	top = max_int(screen_rect.getTop(), y - sampler->oversample);
-	bottom = min_int(screen_rect.getBottom(), y + sampler->oversample + 1);
+	left = math::max(screen_rect.getLeft(), x - sampler->oversample);
+	right = math::min(screen_rect.getRight(), x + sampler->oversample + 1);
+	top = math::max(screen_rect.getTop(), y - sampler->oversample);
+	bottom = math::min(screen_rect.getBottom(), y + sampler->oversample + 1);
 	int width = right - left;
 	int height = bottom - top;
 	int center_x = x - left;
 	int center_y = y - top;
-	float max_distance = 1 / sqrt(2 * pow((double)sampler->oversample, 2));
+	float max_distance = static_cast<float>(1 / std::sqrt(2 * std::pow((double)sampler->oversample, 2)));
 	unsigned char *data = cairo_image_surface_get_data(surface);
 	int stride = cairo_image_surface_get_stride(surface);
 	for (int x=-sampler->oversample; x <= sampler->oversample; ++x){
@@ -123,18 +122,17 @@ int sampler_get_color_sample(Sampler *sampler, Vec2<int>& pointer, Rect2<int>& s
 			get_pixel(data, stride, offset.x + center_x + x, offset.y + center_y + y, &sample);
 			float f;
 			if (sampler->oversample){
-				f = sampler->falloff_fnc(sqrt((double)(x * x + y * y)) * max_distance);
+				f = sampler->falloff_fnc(static_cast<float>(std::sqrt((double)(x * x + y * y)) * max_distance));
 			}else{
 				f = 1;
 			}
-			color_multiply(&sample, f);
-			color_add(&result, &sample);
+			result += sample * f;
 			divider += f;
 		}
 	}
 	if (divider > 0)
-		color_multiply(&result, 1 / divider);
-	color_copy(&result, color);
+		result *= 1 / divider;
+	*color = result;
 	return 0;
 }
 SamplerFalloff sampler_get_falloff(Sampler *sampler)
@@ -148,9 +146,9 @@ int sampler_get_oversample(Sampler *sampler)
 void sampler_get_screen_rect(Sampler *sampler, math::Vec2<int>& pointer, math::Rect2<int>& screen_rect, math::Rect2<int> *rect)
 {
 	int left, right, top, bottom;
-	left = max_int(screen_rect.getLeft(), pointer.x - sampler->oversample);
-	right = min_int(screen_rect.getRight(), pointer.x + sampler->oversample + 1);
-	top = max_int(screen_rect.getTop(), pointer.y - sampler->oversample);
-	bottom = min_int(screen_rect.getBottom(), pointer.y + sampler->oversample + 1);
+	left = math::max(screen_rect.getLeft(), pointer.x - sampler->oversample);
+	right = math::min(screen_rect.getRight(), pointer.x + sampler->oversample + 1);
+	top = math::max(screen_rect.getTop(), pointer.y - sampler->oversample);
+	bottom = math::min(screen_rect.getBottom(), pointer.y + sampler->oversample + 1);
 	*rect = math::Rect2<int>(left, top, right, bottom);
 }
diff --git a/source/StandardDragDropHandler.cpp b/source/StandardDragDropHandler.cpp
index 052d2d4..4da3193 100644
--- a/source/StandardDragDropHandler.cpp
+++ b/source/StandardDragDropHandler.cpp
@@ -156,7 +156,7 @@ static void onDragDataReceived(GtkWidget *widget, GdkDragContext *context, gint
 		color.rgb.red = static_cast<float>(data[0] / static_cast<double>(0xFFFF));
 		color.rgb.green = static_cast<float>(data[1] / static_cast<double>(0xFFFF));
 		color.rgb.blue = static_cast<float>(data[2] / static_cast<double>(0xFFFF));
-		color.ma[3] = 0;
+		color[3] = 0;
 		ColorObject colorObject("", color);
 		success = setColor(colorObject, readonlyColorUI, x, y);
 	} break;
diff --git a/source/StandardMenu.cpp b/source/StandardMenu.cpp
index 3710048..f835ccf 100644
--- a/source/StandardMenu.cpp
+++ b/source/StandardMenu.cpp
@@ -132,10 +132,10 @@ GtkWidget *StandardMenu::newMenu(const ColorObject &colorObject, IReadonlyColorU
 GtkWidget *StandardMenu::newNearestColorsMenu(const ColorObject &colorObject, GlobalState *gs) {
 	GtkWidget *menu = gtk_menu_new();
 	std::multimap<float, ColorObject *> colorDistances;
-	Color sourceColor = colorObject.getColor();
+	Color sourceColor = colorObject.getColor().rgbToLabD50();
 	for (auto &colorObject: gs->getColorList()->colors) {
-		Color targetColor = colorObject->getColor();
-		colorDistances.insert(std::pair<float, ColorObject *>(color_distance_lch(&sourceColor, &targetColor), colorObject));
+		Color targetColor = colorObject->getColor().rgbToLabD50();
+		colorDistances.insert(std::pair<float, ColorObject *>(Color::distanceLch(sourceColor, targetColor), colorObject));
 	}
 	int count = 0;
 	for (auto item: colorDistances) {
diff --git a/source/Variations.cpp b/source/Variations.cpp
index 54b5ff2..bcc943a 100644
--- a/source/Variations.cpp
+++ b/source/Variations.cpp
@@ -204,15 +204,15 @@ struct VariationsArgs {
 			case Component::rgbRed:
 			case Component::rgbGreen:
 			case Component::rgbBlue:
-				color_rgb_get_linear(&color, &rgb);
+				rgb = color.linearRgb();
 				break;
 			case Component::hslHue:
 			case Component::hslSaturation:
 			case Component::hslLightness:
-				color_rgb_to_hsl(&color, &hsl);
+				hsl = color.rgbToHsl();
 				break;
 			case Component::labLightness:
-				color_rgb_to_lab_d50(&color, &lab);
+				lab = color.rgbToLabD50();
 				break;
 			}
 			for (int j = 0; j < VariantWidgets; ++j) {
@@ -220,39 +220,38 @@ struct VariationsArgs {
 				switch (rows[i].type->component) {
 				case Component::rgbRed:
 					rgbModified = rgb;
-					rgbModified.rgb.red = clamp_float(rgbModified.rgb.red + position / 100.0f, 0, 1);
-					color_linear_get_rgb(&rgbModified, &r);
+					rgbModified.rgb.red = math::clamp(rgbModified.rgb.red + position / 100.0f, 0.0f, 1.0f);
+					r = rgbModified.nonLinearRgb();
 					break;
 				case Component::rgbGreen:
 					rgbModified = rgb;
-					rgbModified.rgb.green = clamp_float(rgbModified.rgb.green + position / 100.0f, 0, 1);
-					color_linear_get_rgb(&rgbModified, &r);
+					rgbModified.rgb.green = math::clamp(rgbModified.rgb.green + position / 100.0f, 0.0f, 1.0f);
+					r = rgbModified.nonLinearRgb();
 					break;
 				case Component::rgbBlue:
 					rgbModified = rgb;
-					rgbModified.rgb.blue = clamp_float(rgbModified.rgb.blue + position / 100.0f, 0, 1);
-					color_linear_get_rgb(&rgbModified, &r);
+					rgbModified.rgb.blue = math::clamp(rgbModified.rgb.blue + position / 100.0f, 0.0f, 1.0f);
+					r = rgbModified.nonLinearRgb();
 					break;
 				case Component::hslHue:
-					color_copy(&hsl, &hslModified);
-					hslModified.hsl.hue = wrap_float(hsl.hsl.hue + position / 100.0f);
-					color_hsl_to_rgb(&hslModified, &r);
+					hslModified = hsl;
+					hslModified.hsl.hue = math::wrap(hsl.hsl.hue + position / 100.0f);
+					r = hslModified.hslToRgb();
 					break;
 				case Component::hslSaturation:
-					color_copy(&hsl, &hslModified);
-					hslModified.hsl.saturation = clamp_float(hsl.hsl.saturation + position / 100.0f, 0, 1);
-					color_hsl_to_rgb(&hslModified, &r);
+					hslModified = hsl;
+					hslModified.hsl.saturation = math::clamp(hsl.hsl.saturation + position / 100.0f, 0.0f, 1.0f);
+					r = hslModified.hslToRgb();
 					break;
 				case Component::hslLightness:
-					color_copy(&hsl, &hslModified);
-					hslModified.hsl.lightness = clamp_float(hsl.hsl.lightness + position / 100.0f, 0, 1);
-					color_hsl_to_rgb(&hslModified, &r);
+					hslModified = hsl;
+					hslModified.hsl.lightness = math::clamp(hsl.hsl.lightness + position / 100.0f, 0.0f, 1.0f);
+					r = hslModified.hslToRgb();
 					break;
 				case Component::labLightness:
-					color_copy(&lab, &labModified);
-					labModified.lab.L = clamp_float(lab.lab.L + position, 0, 100);
-					color_lab_to_rgb_d50(&labModified, &r);
-					color_rgb_normalize(&r);
+					labModified = lab;
+					labModified.lab.L = math::clamp(lab.lab.L + position, 0.0f, 100.0f);
+					r = labModified.labToRgbD50().normalizeRgbInplace();
 					break;
 				}
 				gtk_color_set_color(GTK_COLOR(rows[i].variants[j]), r);
diff --git a/source/Vector2.h b/source/Vector2.h
index d165aa7..5db0599 100644
--- a/source/Vector2.h
+++ b/source/Vector2.h
@@ -58,8 +58,8 @@ struct Vec2
 		Vec2 operator*(const double &v)
 		{
 			Vec2 r;
-			r.x = x * v;
-			r.y = y * v;
+			r.x = static_cast<T>(x * v);
+			r.y = static_cast<T>(y * v);
 			return r;
 		};
 		Vec2 operator+(const Vec2 &v)
diff --git a/source/color_names/ColorNames.cpp b/source/color_names/ColorNames.cpp
index 19c33b3..6174495 100644
--- a/source/color_names/ColorNames.cpp
+++ b/source/color_names/ColorNames.cpp
@@ -44,14 +44,10 @@ struct ColorNames
 {
 	std::list<ColorNameEntry*> names;
 	std::vector<ColorEntry*> colors[SpaceDivisions][SpaceDivisions][SpaceDivisions];
-	void (*color_space_convert)(const Color* a, Color* b);
-	float (*color_space_distance)(const Color* a, const Color* b);
 };
 ColorNames* color_names_new()
 {
 	ColorNames* color_names = new ColorNames;
-	color_names->color_space_convert = color_rgb_to_lab_d50;
-	color_names->color_space_distance = color_distance_lch;
 	return color_names;
 }
 void color_names_clear(ColorNames *color_names)
@@ -91,19 +87,19 @@ void color_names_normalize(const Color &color, Color &out)
 }
 void color_names_get_color_xyz(ColorNames* color_names, Color* c, int* x1, int* y1, int* z1, int* x2, int* y2, int* z2)
 {
-	*x1 = clamp_int(int(c->xyz.x / 100 * SpaceDivisions - 0.5), 0, SpaceDivisions - 1);
-	*y1 = clamp_int(int((c->xyz.y + 100) / 200 * SpaceDivisions - 0.5), 0, SpaceDivisions - 1);
-	*z1 = clamp_int(int((c->xyz.z + 100) / 200 * SpaceDivisions - 0.5), 0, SpaceDivisions - 1);
-	*x2 = clamp_int(int(c->xyz.x / 100 * SpaceDivisions + 0.5), 0, SpaceDivisions - 1);
-	*y2 = clamp_int(int((c->xyz.y + 100) / 200 * SpaceDivisions + 0.5), 0, SpaceDivisions - 1);
-	*z2 = clamp_int(int((c->xyz.z + 100) / 200 * SpaceDivisions + 0.5), 0, SpaceDivisions - 1);
+	*x1 = math::clamp(int(c->xyz.x / 100 * SpaceDivisions - 0.5), 0, SpaceDivisions - 1);
+	*y1 = math::clamp(int((c->xyz.y + 100) / 200 * SpaceDivisions - 0.5), 0, SpaceDivisions - 1);
+	*z1 = math::clamp(int((c->xyz.z + 100) / 200 * SpaceDivisions - 0.5), 0, SpaceDivisions - 1);
+	*x2 = math::clamp(int(c->xyz.x / 100 * SpaceDivisions + 0.5), 0, SpaceDivisions - 1);
+	*y2 = math::clamp(int((c->xyz.y + 100) / 200 * SpaceDivisions + 0.5), 0, SpaceDivisions - 1);
+	*z2 = math::clamp(int((c->xyz.z + 100) / 200 * SpaceDivisions + 0.5), 0, SpaceDivisions - 1);
 }
 static vector<ColorEntry*>* color_names_get_color_list(ColorNames* color_names, Color* c)
 {
 	int x,y,z;
-	x = clamp_int(int(c->xyz.x / 100 * SpaceDivisions), 0, SpaceDivisions - 1);
-	y = clamp_int(int((c->xyz.y + 100) / 200 * SpaceDivisions), 0, SpaceDivisions - 1);
-	z = clamp_int(int((c->xyz.z + 100) / 200 * SpaceDivisions), 0, SpaceDivisions - 1);
+	x = math::clamp(int(c->xyz.x / 100 * SpaceDivisions), 0, SpaceDivisions - 1);
+	y = math::clamp(int((c->xyz.y + 100) / 200 * SpaceDivisions), 0, SpaceDivisions - 1);
+	z = math::clamp(int((c->xyz.z + 100) / 200 * SpaceDivisions), 0, SpaceDivisions - 1);
 	return &color_names->colors[x][y][z];
 }
 int color_names_load_from_file(ColorNames* color_names, const std::string &filename)
@@ -130,14 +126,14 @@ int color_names_load_from_file(ColorNames* color_names, const std::string &filen
 				while(++i != name.end()){
 					*i = tolower((unsigned char)*i);
 				}
-				color_multiply(&color, 1 / 255.0f);
+				color *= 1 / 255.0f;
 				ColorNameEntry* name_entry = new ColorNameEntry;
 				name_entry->name = name;
 				color_names->names.push_back(name_entry);
 				ColorEntry* color_entry = new ColorEntry;
 				color_entry->name = name_entry;
-				color_names->color_space_convert(&color, &color_entry->color);
-				color_copy(&color, &color_entry->original_color);
+				color_entry->color = color.rgbToLabD50();
+				color_entry->original_color = color;
 				color_names_get_color_list(color_names, &color_entry->color)->push_back(color_entry);
 			}
 		}
@@ -153,8 +149,7 @@ void color_names_destroy(ColorNames* color_names)
 }
 static void color_names_iterate(ColorNames* color_names, const Color* color, function<bool(ColorEntry*, float)> on_color, function<bool()> on_expansion)
 {
-	Color c1;
-	color_names->color_space_convert(color, &c1);
+	Color c1 = color->rgbToLabD50();
 	int x1, y1, z1, x2, y2, z2;
 	color_names_get_color_xyz(color_names, &c1, &x1, &y1, &z1, &x2, &y2, &z2);
 	char skip_mask[SpaceDivisions][SpaceDivisions][SpaceDivisions];
@@ -173,7 +168,7 @@ static void color_names_iterate(ColorNames* color_names, const Color* color, fun
 					if (skip_mask[x_i][y_i][z_i]) continue; // skip checked items
 					skip_mask[x_i][y_i][z_i] = 1;
 					for (auto i = color_names->colors[x_i][y_i][z_i].begin(); i != color_names->colors[x_i][y_i][z_i].end(); ++i){
-						float delta = color_names->color_space_distance(&(*i)->color, &c1);
+						float delta = Color::distanceLch((*i)->color, c1);
 						if (!on_color(*i, delta)) return;
 					}
 				}
diff --git a/source/dynv/Map.cpp b/source/dynv/Map.cpp
index 1762ffa..fe63233 100644
--- a/source/dynv/Map.cpp
+++ b/source/dynv/Map.cpp
@@ -23,7 +23,6 @@
 #include "Types.h"
 #include <vector>
 #include <queue>
-#include <iostream>
 #include <type_traits>
 namespace dynv {
 template<typename T, typename std::enable_if_t<!std::is_reference<T>::value, int> = 0>
diff --git a/source/dynv/Types.cpp b/source/dynv/Types.cpp
index 35819f5..46941a7 100644
--- a/source/dynv/Types.cpp
+++ b/source/dynv/Types.cpp
@@ -97,7 +97,7 @@ template<> bool write(std::ostream &stream, const std::string &value) {
 	return stream.good();
 }
 template<> bool write(std::ostream &stream, const Color &value) {
-	stream << value.ma[0] << " " << value.ma[1] << " " << value.ma[2] << " " << value.ma[3];
+	stream << value[0] << " " << value[1] << " " << value[2] << " " << value[3];
 	return stream.good();
 }
 template<> bool write(std::ostream &stream, const Ref &value) {
@@ -145,15 +145,15 @@ template<> bool write(std::ostream &stream, const std::string &value) {
 	return stream.good();
 }
 template<> bool write(std::ostream &stream, const Color &value) {
-	if (!write(stream, static_cast<uint32_t>(sizeof(value.ma))))
+	if (!write(stream, static_cast<uint32_t>(sizeof(float) * 4)))
 		return false;
-	if (!write(stream, static_cast<float>(value.ma[0])))
+	if (!write(stream, static_cast<float>(value[0])))
 		return false;
-	if (!write(stream, static_cast<float>(value.ma[1])))
+	if (!write(stream, static_cast<float>(value[1])))
 		return false;
-	if (!write(stream, static_cast<float>(value.ma[2])))
+	if (!write(stream, static_cast<float>(value[2])))
 		return false;
-	if (!write(stream, static_cast<float>(value.ma[3])))
+	if (!write(stream, static_cast<float>(value[3])))
 		return false;
 	return true;
 }
@@ -208,11 +208,11 @@ template<> Color read(std::istream &stream) {
 	Color result;
 	for (int i = 0; i < 4; i++) {
 #if BOOST_VERSION >= 107100
-		result.ma[i] = boost::endian::endian_load<float, sizeof(float), boost::endian::order::little>(buffer + i * sizeof(float));
+		result[i] = boost::endian::endian_load<float, sizeof(float), boost::endian::order::little>(buffer + i * sizeof(float));
 #else
 		float value;
 		stream.read(reinterpret_cast<char *>(&value), sizeof(float));
-		result.ma[i] = boost::endian::little_to_native(value);
+		result[i] = boost::endian::little_to_native(value);
 #endif
 	}
 	return result;
diff --git a/source/dynv/Xml.cpp b/source/dynv/Xml.cpp
index 9ffa4f5..462ddf2 100644
--- a/source/dynv/Xml.cpp
+++ b/source/dynv/Xml.cpp
@@ -338,7 +338,7 @@ static void onEndElement(Context *context, const XML_Char *name) {
 		case ValueType::color: {
 			std::stringstream in(entity.data());
 			Color color;
-			in >> color.ma[0] >> color.ma[1] >> color.ma[2] >> color.ma[3];
+			in >> color[0] >> color[1] >> color[2] >> color[3];
 			boost::get<std::vector<Color> &>(data).push_back(color);
 		} break;
 		case ValueType::map:
@@ -367,7 +367,7 @@ static void onEndElement(Context *context, const XML_Char *name) {
 		case ValueType::color: {
 			std::stringstream in(entity.data());
 			Color color;
-			in >> color.ma[0] >> color.ma[1] >> color.ma[2] >> color.ma[3];
+			in >> color[0] >> color[1] >> color[2] >> color[3];
 			map.set(name, color);
 		} break;
 		case ValueType::map:
diff --git a/source/gtk/ColorCell.cpp b/source/gtk/ColorCell.cpp
index b1a8bd5..ac5a925 100644
--- a/source/gtk/ColorCell.cpp
+++ b/source/gtk/ColorCell.cpp
@@ -17,7 +17,7 @@
  */
 
 #include "ColorCell.h"
-#include "../ColorObject.h"
+#include "ColorObject.h"
 #include <boost/math/special_functions/round.hpp>
 
 static void init(CustomCellRendererColor *cellcolor);
diff --git a/source/gtk/ColorComponent.cpp b/source/gtk/ColorComponent.cpp
index 3695629..d2eefc4 100644
--- a/source/gtk/ColorComponent.cpp
+++ b/source/gtk/ColorComponent.cpp
@@ -17,12 +17,11 @@
  */
 
 #include "ColorComponent.h"
-#include "../uiUtilities.h"
-#include "../Color.h"
-#include "../MathUtil.h"
-#include "../Paths.h"
-#include <math.h>
-#include <string.h>
+#include "uiUtilities.h"
+#include "Color.h"
+#include "MathUtil.h"
+#include "Paths.h"
+#include <cmath>
 #include <vector>
 using namespace std;
 
@@ -40,16 +39,14 @@ static gboolean draw(GtkWidget *widget, cairo_t *cr);
 static gboolean expose(GtkWidget *widget, GdkEventExpose *event);
 static void size_request(GtkWidget *widget, GtkRequisition *requisition);
 #endif
-enum
-{
+enum {
 	COLOR_CHANGED,
 	INPUT_CLICKED,
 	LAST_SIGNAL
 };
 static const int MaxNumberOfComponents = 4;
 static guint signals[LAST_SIGNAL] = {};
-struct GtkColorComponentPrivate
-{
+struct GtkColorComponentPrivate {
 	Color orig_color;
 	Color color;
 	GtkColorComponentComp component;
@@ -136,8 +133,8 @@ GtkWidget *gtk_color_component_new(GtkColorComponentComp component)
 	ns->component = component;
 	ns->last_event_position = -1;
 	ns->changing_color = false;
-	ns->lab_illuminant = REFERENCE_ILLUMINANT_D50;
-	ns->lab_observer= REFERENCE_OBSERVER_2;
+	ns->lab_illuminant = ReferenceIlluminant::D50;
+	ns->lab_observer = ReferenceObserver::_2;
 	ns->out_of_gamut_mask = false;
 #if GTK_MAJOR_VERSION >= 3
 	ns->pointer_grab = nullptr;
@@ -184,17 +181,17 @@ GtkWidget *gtk_color_component_new(GtkColorComponentComp component)
 void gtk_color_component_get_color(GtkColorComponent* color_component, Color* color)
 {
 	GtkColorComponentPrivate *ns = GET_PRIVATE(color_component);
-	color_copy(&ns->orig_color, color);
+	*color = ns->orig_color;
 }
 void gtk_color_component_get_transformed_color(GtkColorComponent* color_component, Color* color)
 {
 	GtkColorComponentPrivate *ns = GET_PRIVATE(color_component);
-	color_copy(&ns->color, color);
+	*color = ns->color;
 }
 void gtk_color_component_set_transformed_color(GtkColorComponent* color_component, Color* color)
 {
 	GtkColorComponentPrivate *ns = GET_PRIVATE(color_component);
-	color_copy(color, &ns->color);
+	*color = ns->color;
 	update_rgb_color(ns, &ns->orig_color);
 	gtk_widget_queue_draw(GTK_WIDGET(color_component));
 }
@@ -235,25 +232,24 @@ void gtk_color_component_set_label(GtkColorComponent* color_component, const cha
 void gtk_color_component_set_color(GtkColorComponent* color_component, Color* color)
 {
 	GtkColorComponentPrivate *ns = GET_PRIVATE(color_component);
-	color_copy(color, &ns->orig_color);
+	ns->orig_color = *color;
 	switch (ns->component){
 		case GtkColorComponentComp::rgb:
-			color_copy(&ns->orig_color, &ns->color);
+			ns->color = ns->orig_color;
 			break;
 		case GtkColorComponentComp::hsl:
-			color_rgb_to_hsl(&ns->orig_color, &ns->color);
+			ns->color = ns->orig_color.rgbToHsl();
 			break;
 		case GtkColorComponentComp::hsv:
-			color_rgb_to_hsv(&ns->orig_color, &ns->color);
+			ns->color = ns->orig_color.rgbToHsv();
 			break;
 		case GtkColorComponentComp::cmyk:
-			color_rgb_to_cmyk(&ns->orig_color, &ns->color);
+			ns->color = ns->orig_color.rgbToCmyk();
 			break;
 		case GtkColorComponentComp::lab:
 			{
-				matrix3x3 adaptation_matrix;
-				color_get_chromatic_adaptation_matrix(color_get_reference(REFERENCE_ILLUMINANT_D65, REFERENCE_OBSERVER_2), color_get_reference(ns->lab_illuminant, ns->lab_observer), &adaptation_matrix);
-				color_rgb_to_lab(&ns->orig_color, &ns->color, color_get_reference(ns->lab_illuminant, ns->lab_observer), color_get_sRGB_transformation_matrix(), &adaptation_matrix);
+				auto adaptationMatrix = Color::getChromaticAdaptationMatrix(Color::getReference(ReferenceIlluminant::D65, ReferenceObserver::_2), Color::getReference(ns->lab_illuminant, ns->lab_observer));
+				ns->color = ns->orig_color.rgbToLab(Color::getReference(ns->lab_illuminant, ns->lab_observer), Color::sRGBMatrix, adaptationMatrix);
 			}
 			break;
 		case GtkColorComponentComp::xyz:
@@ -261,9 +257,8 @@ void gtk_color_component_set_color(GtkColorComponent* color_component, Color* co
 			break;
 		case GtkColorComponentComp::lch:
 			{
-				matrix3x3 adaptation_matrix;
-				color_get_chromatic_adaptation_matrix(color_get_reference(REFERENCE_ILLUMINANT_D65, REFERENCE_OBSERVER_2), color_get_reference(ns->lab_illuminant, ns->lab_observer), &adaptation_matrix);
-				color_rgb_to_lch(&ns->orig_color, &ns->color, color_get_reference(ns->lab_illuminant, ns->lab_observer), color_get_sRGB_transformation_matrix(), &adaptation_matrix);
+				auto adaptationMatrix = Color::getChromaticAdaptationMatrix(Color::getReference(ReferenceIlluminant::D65, ReferenceObserver::_2), Color::getReference(ns->lab_illuminant, ns->lab_observer));
+				ns->color = ns->orig_color.rgbToLch(Color::getReference(ns->lab_illuminant, ns->lab_observer), Color::sRGBMatrix, adaptationMatrix);
 			}
 			break;
 	}
@@ -289,7 +284,7 @@ static void size_request(GtkWidget *widget, GtkRequisition *requisition)
 static int get_x_offset(GtkWidget *widget)
 {
 #if GTK_MAJOR_VERSION >= 3
-	return 0;
+	return gtk_widget_get_allocated_width(widget) - 240;
 #else
 	return widget->allocation.width - widget->style->xthickness * 2 - 240;
 #endif
@@ -299,10 +294,10 @@ static gboolean draw(GtkWidget *widget, cairo_t *cr)
 	GtkColorComponentPrivate *ns = GET_PRIVATE(widget);
 	Color c[MaxNumberOfComponents];
 	double pointer_pos[MaxNumberOfComponents];
-	float steps;
+	int steps;
 	int i, j;
 	for (int i = 0; i < ns->n_components; ++i){
-		pointer_pos[i] = (ns->color.ma[i] - ns->offset[i]) / ns->range[i];
+		pointer_pos[i] = (ns->color[i] - ns->offset[i]) / ns->range[i];
 	}
 	cairo_surface_t *surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, 200, ns->n_components * 16);
 	unsigned char *data = cairo_image_surface_get_data(surface);
@@ -311,13 +306,13 @@ static gboolean draw(GtkWidget *widget, cairo_t *cr)
 	unsigned char *col_ptr;
 	Color *rgb_points = new Color[ns->n_components * 200];
 	double int_part;
-	matrix3x3 adaptation_matrix;
-	vector<vector<bool> > out_of_gamut(MaxNumberOfComponents, vector<bool>(false, 1));
+	math::Matrix3d adaptationMatrix;
+	std::vector<std::vector<bool>> out_of_gamut(MaxNumberOfComponents, std::vector<bool>(false, 1));
 	switch (ns->component) {
 		case GtkColorComponentComp::rgb:
 			steps = 1;
 			for (i = 0; i < 3; ++i){
-				color_copy(&ns->color, &c[i]);
+				c[i] = ns->color;
 			}
 			for (i = 0; i < surface_width; ++i){
 				c[0].rgb.red = c[1].rgb.green = c[2].rgb.blue = (float)i / (float)(surface_width - 1);
@@ -341,20 +336,20 @@ static gboolean draw(GtkWidget *widget, cairo_t *cr)
 		case GtkColorComponentComp::hsv:
 			steps = 100;
 			for (i = 0; i < 3; ++i){
-				color_copy(&ns->color, &c[i]);
+				c[i] = ns->color;
 			}
 			for (i = 0; i <= steps; ++i){
-				c[0].hsv.hue = c[1].hsv.saturation = c[2].hsv.value = i / steps;
+				c[0].hsv.hue = c[1].hsv.saturation = c[2].hsv.value = i / static_cast<float>(steps);
 				for (j = 0; j < 3; ++j){
-					color_hsv_to_rgb(&c[j], &rgb_points[j * (int(steps) + 1) + i]);
+					rgb_points[j * (steps + 1) + i] = c[j].hsvToRgb();
 				}
 			}
 			for (i = 0; i < surface_width; ++i){
-				float position = modf(i * steps / surface_width, &int_part);
-				int index = i * int(steps) / surface_width;
-				interpolate_colors(&rgb_points[0 * (int(steps) + 1) + index], &rgb_points[0 * (int(steps) + 1) + index + 1], position, &c[0]);
-				interpolate_colors(&rgb_points[1 * (int(steps) + 1) + index], &rgb_points[1 * (int(steps) + 1) + index + 1], position, &c[1]);
-				interpolate_colors(&rgb_points[2 * (int(steps) + 1) + index], &rgb_points[2 * (int(steps) + 1) + index + 1], position, &c[2]);
+				float position = static_cast<float>(std::modf(i * static_cast<float>(steps) / surface_width, &int_part));
+				int index = i * steps / surface_width;
+				interpolate_colors(&rgb_points[0 * (steps + 1) + index], &rgb_points[0 * (steps + 1) + index + 1], position, &c[0]);
+				interpolate_colors(&rgb_points[1 * (steps + 1) + index], &rgb_points[1 * (steps + 1) + index + 1], position, &c[1]);
+				interpolate_colors(&rgb_points[2 * (steps + 1) + index], &rgb_points[2 * (steps + 1) + index + 1], position, &c[2]);
 				col_ptr = data + i * 4;
 				for (int y = 0; y < ns->n_components * 16; ++y){
 					if ((y & 0x0f) != 0x0f){
@@ -375,20 +370,20 @@ static gboolean draw(GtkWidget *widget, cairo_t *cr)
 		case GtkColorComponentComp::hsl:
 			steps = 100;
 			for (i = 0; i < 3; ++i){
-				color_copy(&ns->color, &c[i]);
+				c[i] = ns->color;
 			}
 			for (i = 0; i <= steps; ++i){
-				c[0].hsl.hue = c[1].hsl.saturation = c[2].hsl.lightness = i / steps;
+				c[0].hsl.hue = c[1].hsl.saturation = c[2].hsl.lightness = i / static_cast<float>(steps);
 				for (j = 0; j < 3; ++j){
-					color_hsl_to_rgb(&c[j], &rgb_points[j * (int(steps) + 1) + i]);
+					rgb_points[j * (steps + 1) + i] = c[j].hslToRgb();
 				}
 			}
 			for (i = 0; i < surface_width; ++i){
-				float position = modf(i * steps / surface_width, &int_part);
-				int index = i * int(steps) / surface_width;
-				interpolate_colors(&rgb_points[0 * (int(steps) + 1) + index], &rgb_points[0 * (int(steps) + 1) + index + 1], position, &c[0]);
-				interpolate_colors(&rgb_points[1 * (int(steps) + 1) + index], &rgb_points[1 * (int(steps) + 1) + index + 1], position, &c[1]);
-				interpolate_colors(&rgb_points[2 * (int(steps) + 1) + index], &rgb_points[2 * (int(steps) + 1) + index + 1], position, &c[2]);
+				float position = static_cast<float>(std::modf(i * static_cast<float>(steps) / surface_width, &int_part));
+				int index = i * steps / surface_width;
+				interpolate_colors(&rgb_points[0 * (steps + 1) + index], &rgb_points[0 * (steps + 1) + index + 1], position, &c[0]);
+				interpolate_colors(&rgb_points[1 * (steps + 1) + index], &rgb_points[1 * (steps + 1) + index + 1], position, &c[1]);
+				interpolate_colors(&rgb_points[2 * (steps + 1) + index], &rgb_points[2 * (steps + 1) + index + 1], position, &c[2]);
 				col_ptr = data + i * 4;
 				for (int y = 0; y < ns->n_components * 16; ++y){
 					if ((y & 0x0f) != 0x0f){
@@ -409,21 +404,21 @@ static gboolean draw(GtkWidget *widget, cairo_t *cr)
 		case GtkColorComponentComp::cmyk:
 			steps = 100;
 			for (i = 0; i < 4; ++i){
-				color_copy(&ns->color, &c[i]);
+				c[i] = ns->color;
 			}
 			for (i = 0; i <= steps; ++i){
-				c[0].cmyk.c = c[1].cmyk.m = c[2].cmyk.y = c[3].cmyk.k = i / steps;
+				c[0].cmyk.c = c[1].cmyk.m = c[2].cmyk.y = c[3].cmyk.k = i / static_cast<float>(steps);
 				for (j = 0; j < 4; ++j){
-					color_cmyk_to_rgb(&c[j], &rgb_points[j * (int(steps) + 1) + i]);
+					rgb_points[j * (steps + 1) + i] = c[j].cmykToRgb();
 				}
 			}
 			for (i = 0; i < surface_width; ++i){
-				float position = modf(i * steps / surface_width, &int_part);
-				int index = i * int(steps) / surface_width;
-				interpolate_colors(&rgb_points[0 * (int(steps) + 1) + index], &rgb_points[0 * (int(steps) + 1) + index + 1], position, &c[0]);
-				interpolate_colors(&rgb_points[1 * (int(steps) + 1) + index], &rgb_points[1 * (int(steps) + 1) + index + 1], position, &c[1]);
-				interpolate_colors(&rgb_points[2 * (int(steps) + 1) + index], &rgb_points[2 * (int(steps) + 1) + index + 1], position, &c[2]);
-				interpolate_colors(&rgb_points[3 * (int(steps) + 1) + index], &rgb_points[3 * (int(steps) + 1) + index + 1], position, &c[3]);
+				float position = static_cast<float>(std::modf(i * static_cast<float>(steps) / surface_width, &int_part));
+				int index = i * steps / surface_width;
+				interpolate_colors(&rgb_points[0 * (steps + 1) + index], &rgb_points[0 * (steps + 1) + index + 1], position, &c[0]);
+				interpolate_colors(&rgb_points[1 * (steps + 1) + index], &rgb_points[1 * (steps + 1) + index + 1], position, &c[1]);
+				interpolate_colors(&rgb_points[2 * (steps + 1) + index], &rgb_points[2 * (steps + 1) + index + 1], position, &c[2]);
+				interpolate_colors(&rgb_points[3 * (steps + 1) + index], &rgb_points[3 * (steps + 1) + index + 1], position, &c[3]);
 				col_ptr = data + i * 4;
 				for (int y = 0; y < ns->n_components * 16; ++y){
 					if ((y & 0x0f) != 0x0f){
@@ -443,25 +438,25 @@ static gboolean draw(GtkWidget *widget, cairo_t *cr)
 			break;
 		case GtkColorComponentComp::lab:
 			steps = 100;
-			color_get_chromatic_adaptation_matrix(color_get_reference(ns->lab_illuminant, ns->lab_observer), color_get_reference(REFERENCE_ILLUMINANT_D65, REFERENCE_OBSERVER_2), &adaptation_matrix);
+			adaptationMatrix = Color::getChromaticAdaptationMatrix(Color::getReference(ns->lab_illuminant, ns->lab_observer), Color::getReference(ReferenceIlluminant::D65, ReferenceObserver::_2));
 			for (j = 0; j < 3; ++j){
-				color_copy(&ns->color, &c[j]);
-				out_of_gamut[j] = vector<bool>(steps + 1, false);
+				c[j] = ns->color;
+				out_of_gamut[j] = std::vector<bool>(steps + 1, false);
 				for (i = 0; i <= steps; ++i){
-					c[j].ma[j] = (i / steps) * ns->range[j] + ns->offset[j];
-					color_lab_to_rgb(&c[j], &rgb_points[j * (int(steps) + 1) + i], color_get_reference(ns->lab_illuminant, ns->lab_observer), color_get_inverted_sRGB_transformation_matrix(), &adaptation_matrix);
-					if (color_is_rgb_out_of_gamut(&rgb_points[j * (int(steps) + 1) + i])){
+					c[j][j] = static_cast<float>((i / static_cast<float>(steps)) * ns->range[j] + ns->offset[j]);
+					rgb_points[j * (steps + 1) + i] = c[j].labToRgb(Color::getReference(ns->lab_illuminant, ns->lab_observer), Color::sRGBInvertedMatrix, adaptationMatrix);
+					if (rgb_points[j * (steps + 1) + i].isOutOfRgbGamut()){
 						out_of_gamut[j][i] = true;
 					}
-					color_rgb_normalize(&rgb_points[j * (int(steps) + 1) + i]);
+					rgb_points[j * (steps + 1) + i].normalizeRgbInplace();
 				}
 			}
 			for (i = 0; i < surface_width; ++i){
-				float position = modf(i * steps / surface_width, &int_part);
-				int index = i * int(steps) / surface_width;
-				interpolate_colors(&rgb_points[0 * (int(steps) + 1) + index], &rgb_points[0 * (int(steps) + 1) + index + 1], position, &c[0]);
-				interpolate_colors(&rgb_points[1 * (int(steps) + 1) + index], &rgb_points[1 * (int(steps) + 1) + index + 1], position, &c[1]);
-				interpolate_colors(&rgb_points[2 * (int(steps) + 1) + index], &rgb_points[2 * (int(steps) + 1) + index + 1], position, &c[2]);
+				float position = static_cast<float>(std::modf(i * static_cast<float>(steps) / surface_width, &int_part));
+				int index = i * steps / surface_width;
+				interpolate_colors(&rgb_points[0 * (steps + 1) + index], &rgb_points[0 * (steps + 1) + index + 1], position, &c[0]);
+				interpolate_colors(&rgb_points[1 * (steps + 1) + index], &rgb_points[1 * (steps + 1) + index + 1], position, &c[1]);
+				interpolate_colors(&rgb_points[2 * (steps + 1) + index], &rgb_points[2 * (steps + 1) + index + 1], position, &c[2]);
 				col_ptr = data + i * 4;
 				for (int y = 0; y < ns->n_components * 16; ++y){
 					if ((y & 0x0f) != 0x0f){
@@ -481,25 +476,25 @@ static gboolean draw(GtkWidget *widget, cairo_t *cr)
 			break;
 		case GtkColorComponentComp::lch:
 			steps = 100;
-			color_get_chromatic_adaptation_matrix(color_get_reference(ns->lab_illuminant, ns->lab_observer), color_get_reference(REFERENCE_ILLUMINANT_D65, REFERENCE_OBSERVER_2), &adaptation_matrix);
+			adaptationMatrix = Color::getChromaticAdaptationMatrix(Color::getReference(ns->lab_illuminant, ns->lab_observer), Color::getReference(ReferenceIlluminant::D65, ReferenceObserver::_2));
 			for (j = 0; j < 3; ++j){
-				color_copy(&ns->color, &c[j]);
-				out_of_gamut[j] = vector<bool>(steps + 1, false);
+				c[j] = ns->color;
+				out_of_gamut[j] = std::vector<bool>(steps + 1, false);
 				for (i = 0; i <= steps; ++i){
-					c[j].ma[j] = (i / steps) * ns->range[j] + ns->offset[j];
-					color_lch_to_rgb(&c[j], &rgb_points[j * (int(steps) + 1) + i], color_get_reference(ns->lab_illuminant, ns->lab_observer), color_get_inverted_sRGB_transformation_matrix(), &adaptation_matrix);
-					if (color_is_rgb_out_of_gamut(&rgb_points[j * (int(steps) + 1) + i])){
+					c[j][j] = static_cast<float>((i / static_cast<float>(steps)) * ns->range[j] + ns->offset[j]);
+					rgb_points[j * (steps + 1) + i] = c[j].lchToRgb(Color::getReference(ns->lab_illuminant, ns->lab_observer), Color::sRGBInvertedMatrix, adaptationMatrix);
+					if (rgb_points[j * (steps + 1) + i].isOutOfRgbGamut()){
 						out_of_gamut[j][i] = true;
 					}
-					color_rgb_normalize(&rgb_points[j * (int(steps) + 1) + i]);
+					rgb_points[j * (steps + 1) + i].normalizeRgbInplace();
 				}
 			}
 			for (i = 0; i < surface_width; ++i){
-				float position = modf(i * steps / surface_width, &int_part);
-				int index = i * int(steps) / surface_width;
-				interpolate_colors(&rgb_points[0 * (int(steps) + 1) + index], &rgb_points[0 * (int(steps) + 1) + index + 1], position, &c[0]);
-				interpolate_colors(&rgb_points[1 * (int(steps) + 1) + index], &rgb_points[1 * (int(steps) + 1) + index + 1], position, &c[1]);
-				interpolate_colors(&rgb_points[2 * (int(steps) + 1) + index], &rgb_points[2 * (int(steps) + 1) + index + 1], position, &c[2]);
+				float position = static_cast<float>(std::modf(i * static_cast<float>(steps) / surface_width, &int_part));
+				int index = i * steps / surface_width;
+				interpolate_colors(&rgb_points[0 * (steps + 1) + index], &rgb_points[0 * (steps + 1) + index + 1], position, &c[0]);
+				interpolate_colors(&rgb_points[1 * (steps + 1) + index], &rgb_points[1 * (steps + 1) + index + 1], position, &c[1]);
+				interpolate_colors(&rgb_points[2 * (steps + 1) + index], &rgb_points[2 * (steps + 1) + index + 1], position, &c[2]);
 				col_ptr = data + i * 4;
 				for (int y = 0; y < ns->n_components * 16; ++y){
 					if ((y & 0x0f) != 0x0f){
@@ -634,27 +629,21 @@ static void update_rgb_color(GtkColorComponentPrivate *ns, Color *c)
 {
 	switch (ns->component){
 		case GtkColorComponentComp::rgb:
-			color_copy(&ns->color, c);
-			color_rgb_normalize(c);
+			*c = ns->color.normalizeRgb();
 			break;
 		case GtkColorComponentComp::hsv:
-			color_hsv_to_rgb(&ns->color, c);
-			color_rgb_normalize(c);
+			*c = ns->color.hsvToRgb().normalizeRgbInplace();
 			break;
 		case GtkColorComponentComp::hsl:
-			color_hsl_to_rgb(&ns->color, c);
-			color_rgb_normalize(c);
+			*c = ns->color.hslToRgb().normalizeRgbInplace();
 			break;
 		case GtkColorComponentComp::cmyk:
-			color_cmyk_to_rgb(&ns->color, c);
-			color_rgb_normalize(c);
+			*c = ns->color.cmykToRgb().normalizeRgbInplace();
 			break;
 		case GtkColorComponentComp::lab:
 			{
-				matrix3x3 adaptation_matrix;
-				color_get_chromatic_adaptation_matrix(color_get_reference(ns->lab_illuminant, ns->lab_observer), color_get_reference(REFERENCE_ILLUMINANT_D65, REFERENCE_OBSERVER_2), &adaptation_matrix);
-				color_lab_to_rgb(&ns->color, c, color_get_reference(ns->lab_illuminant, ns->lab_observer), color_get_inverted_sRGB_transformation_matrix(), &adaptation_matrix);
-				color_rgb_normalize(c);
+				auto adaptationMatrix = Color::getChromaticAdaptationMatrix(Color::getReference(ns->lab_illuminant, ns->lab_observer), Color::getReference(ReferenceIlluminant::D65, ReferenceObserver::_2));
+				*c = ns->color.labToRgb(Color::getReference(ns->lab_illuminant, ns->lab_observer), Color::sRGBInvertedMatrix, adaptationMatrix).normalizeRgbInplace();
 			}
 			break;
 		case GtkColorComponentComp::xyz:
@@ -662,10 +651,8 @@ static void update_rgb_color(GtkColorComponentPrivate *ns, Color *c)
 			break;
 		case GtkColorComponentComp::lch:
 			{
-				matrix3x3 adaptation_matrix;
-				color_get_chromatic_adaptation_matrix(color_get_reference(ns->lab_illuminant, ns->lab_observer), color_get_reference(REFERENCE_ILLUMINANT_D65, REFERENCE_OBSERVER_2), &adaptation_matrix);
-				color_lch_to_rgb(&ns->color, c, color_get_reference(ns->lab_illuminant, ns->lab_observer), color_get_inverted_sRGB_transformation_matrix(), &adaptation_matrix);
-				color_rgb_normalize(c);
+				auto adaptationMatrix = Color::getChromaticAdaptationMatrix(Color::getReference(ns->lab_illuminant, ns->lab_observer), Color::getReference(ReferenceIlluminant::D65, ReferenceObserver::_2));
+				*c = ns->color.lchToRgb(Color::getReference(ns->lab_illuminant, ns->lab_observer), Color::sRGBInvertedMatrix, adaptationMatrix).normalizeRgbInplace();
 			}
 			break;
 	}
@@ -673,15 +660,15 @@ static void update_rgb_color(GtkColorComponentPrivate *ns, Color *c)
 void gtk_color_component_get_raw_color(GtkColorComponent* color_component, Color* color)
 {
 	GtkColorComponentPrivate *ns = GET_PRIVATE(color_component);
-	color_copy(&ns->color, color);
+	*color = ns->color;
 }
 void gtk_color_component_set_raw_color(GtkColorComponent* color_component, Color* color)
 {
 	GtkColorComponentPrivate *ns = GET_PRIVATE(color_component);
-	color_copy(color, &ns->color);
+	ns->color = *color;
 	Color c;
 	update_rgb_color(ns, &c);
-	color_copy(&c, &ns->orig_color);
+	ns->orig_color = c;
 	gtk_widget_queue_draw(GTK_WIDGET(color_component));
 	g_signal_emit(GTK_WIDGET(color_component), signals[COLOR_CHANGED], 0, &c);
 }
@@ -689,7 +676,7 @@ static void emit_color_change(GtkWidget *widget, int component, double value)
 {
 	GtkColorComponentPrivate *ns = GET_PRIVATE(widget);
 	Color c;
-	ns->color.ma[component] = value * ns->range[component] + ns->offset[component];
+	ns->color[component] = static_cast<float>(value * ns->range[component] + ns->offset[component]);
 	update_rgb_color(ns, &c);
 	g_signal_emit(widget, signals[COLOR_CHANGED], 0, &c);
 }
@@ -711,7 +698,7 @@ static gboolean button_press(GtkWidget *widget, GdkEventButton *event)
 {
 	GtkColorComponentPrivate *ns = GET_PRIVATE(widget);
 	if ((event->type == GDK_BUTTON_PRESS) && (event->button == 1)){
-		int component = event->y / 16;
+		int component = static_cast<int>(event->y / 16);
 		if (component < 0) component = 0;
 		else if (component >= ns->n_components) component = ns->n_components - 1;
 		int offset_x = get_x_offset(widget);
@@ -720,7 +707,7 @@ static gboolean button_press(GtkWidget *widget, GdkEventButton *event)
 			return FALSE;
 		}
 		ns->changing_color = true;
-		ns->last_event_position = event->x;
+		ns->last_event_position = static_cast<gint>(event->x);
 		double value;
 		value = (event->x - offset_x) / 200.0;
 		if (value < 0) value = 0;
@@ -744,7 +731,7 @@ static gboolean motion_notify(GtkWidget *widget, GdkEventMotion *event)
 	if (ns->changing_color && (event->state & GDK_BUTTON1_MASK)){
 		int offset_x = get_x_offset(widget);
 		if ((event->x < offset_x && ns->last_event_position < offset_x) || ((event->x > 200 + offset_x) && (ns->last_event_position > 200 + offset_x))) return FALSE;
-		ns->last_event_position = event->x;
+		ns->last_event_position = static_cast<gint>(event->x);
 		double value;
 		value = (event->x - offset_x) / 200.0;
 		if (value < 0) value = 0;
diff --git a/source/gtk/ColorComponent.h b/source/gtk/ColorComponent.h
index b84d86f..6ef929e 100644
--- a/source/gtk/ColorComponent.h
+++ b/source/gtk/ColorComponent.h
@@ -20,7 +20,7 @@
 #define GPICK_GTK_COLOR_COMPONENT_H_
 
 #include <gtk/gtk.h>
-#include "../Color.h"
+#include "Color.h"
 
 #define GTK_TYPE_COLOR_COMPONENT (gtk_color_component_get_type())
 #define GTK_COLOR_COMPONENT(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), GTK_TYPE_COLOR_COMPONENT, GtkColorComponent))
diff --git a/source/gtk/ColorWheel.cpp b/source/gtk/ColorWheel.cpp
index 6ecda63..787e0c6 100644
--- a/source/gtk/ColorWheel.cpp
+++ b/source/gtk/ColorWheel.cpp
@@ -17,18 +17,11 @@
  */
 
 #include "ColorWheel.h"
-#include "../Color.h"
-#include "../ColorWheelType.h"
-#include "../MathUtil.h"
-#include <math.h>
-#ifdef _MSC_VER
-#define M_PI 3.14159265359
-#endif
-#include <stdlib.h>
+#include "Color.h"
+#include "ColorWheelType.h"
+#include "MathUtil.h"
 #include <list>
 #include <iostream>
-using namespace std;
-
 #define GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), GTK_TYPE_COLOR_WHEEL, GtkColorWheelPrivate))
 
 G_DEFINE_TYPE (GtkColorWheel, gtk_color_wheel, GTK_TYPE_DRAWING_AREA);
@@ -64,9 +57,9 @@ struct GtkColorWheelPrivate
 	bool grab_block;
 	ColorPoint *selected;
 	int active_color;
-	double radius;
-	double circle_width;
-	double block_size;
+	float radius;
+	float circle_width;
+	float block_size;
 	bool block_editable;
 	const ColorWheelType *color_wheel_type;
 	cairo_surface_t *cache_color_wheel;
@@ -112,11 +105,11 @@ GtkWidget* gtk_color_wheel_new()
 	ns->active_color = 1;
 	ns->radius = 80;
 	ns->circle_width = 14;
-	ns->block_size = 2 * (ns->radius - ns->circle_width) * sin(M_PI / 4) - 8;
+	ns->block_size = static_cast<float>(2 * (ns->radius - ns->circle_width) * std::sin(math::PI / 4) - 8);
 #if GTK_MAJOR_VERSION >= 3
-	gtk_widget_set_size_request(GTK_WIDGET(widget), ns->radius * 2, ns->radius * 2);
+	gtk_widget_set_size_request(GTK_WIDGET(widget), static_cast<int>(std::ceil(ns->radius * 2)), static_cast<int>(std::ceil(ns->radius * 2)));
 #else
-	gtk_widget_set_size_request(GTK_WIDGET(widget), ns->radius * 2 + widget->style->xthickness * 2, ns->radius * 2 + widget->style->ythickness * 2);
+	gtk_widget_set_size_request(GTK_WIDGET(widget), static_cast<int>(std::ceil(ns->radius * 2 + widget->style->xthickness * 2)), static_cast<int>(std::ceil(ns->radius * 2 + widget->style->ythickness * 2)));
 #endif
 	ns->n_cpoint = 0;
 	ns->grab_active = 0;
@@ -229,34 +222,34 @@ double gtk_color_wheel_get_value(GtkColorWheel* color_wheel, guint32 index)
 }
 static void draw_dot(cairo_t *cr, double x, double y, double size)
 {
-	cairo_arc(cr, x, y, size - 1, 0, 2 * M_PI);
+	cairo_arc(cr, x, y, size - 1, 0, 2 * math::PI);
 	cairo_set_source_rgba(cr, 1, 1, 1, 0.5);
 	cairo_set_line_width(cr, 2);
 	cairo_stroke(cr);
-	cairo_arc(cr, x, y, size, 0, 2 * M_PI);
+	cairo_arc(cr, x, y, size, 0, 2 * math::PI);
 	cairo_set_source_rgba(cr, 0, 0, 0, 1);
 	cairo_set_line_width(cr, 1);
 	cairo_stroke(cr);
 }
 static void draw_sat_val_block(cairo_t *cr, double pos_x, double pos_y, double size, double hue)
 {
-	cairo_surface_t *surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, ceil(size), ceil(size));
+	cairo_surface_t *surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, static_cast<int>(std::ceil(size)), static_cast<int>(std::ceil(size)));
 	unsigned char *data = cairo_image_surface_get_data(surface);
 	int stride = cairo_image_surface_get_stride(surface);
 	int surface_width = cairo_image_surface_get_width(surface);
 	int surface_height = cairo_image_surface_get_height(surface);
 	Color c;
-	unsigned char *line_data;
+	uint8_t *line_data;
 	for (int y = 0; y < surface_height; ++y){
 		line_data = data + stride * y;
 		for (int x = 0; x < surface_width; ++x){
-			c.hsv.hue = hue;
-			c.hsv.saturation = x / size;
-			c.hsv.value = y / size;
-			color_hsv_to_rgb(&c, &c);
-			line_data[2] = c.rgb.red * 255;
-			line_data[1] = c.rgb.green * 255;
-			line_data[0] = c.rgb.blue * 255;
+			c.hsv.hue = static_cast<float>(hue);
+			c.hsv.saturation = static_cast<float>(x / size);
+			c.hsv.value = static_cast<float>(y / size);
+			c = c.hsvToRgb();
+			line_data[2] = static_cast<uint8_t>(c.rgb.red * 255);
+			line_data[1] = static_cast<uint8_t>(c.rgb.green * 255);
+			line_data[0] = static_cast<uint8_t>(c.rgb.blue * 255);
 			line_data[3] = 0xFF;
 			line_data += 4;
 		}
@@ -276,9 +269,9 @@ static void draw_wheel(GtkColorWheelPrivate *ns, cairo_t *cr, double radius, dou
 	if (ns->cache_color_wheel){
 		surface = ns->cache_color_wheel;
 	}else{
-		surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, ceil(radius * 2), ceil(radius * 2));
+		surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, static_cast<int>(std::ceil(radius * 2)), static_cast<int>(std::ceil(radius * 2)));
 		if (cairo_surface_status(surface) != CAIRO_STATUS_SUCCESS){
-			cerr << "ColorWheel image surface allocation failed" << endl;
+			std::cerr << "ColorWheel image surface allocation failed" << std::endl;
 			return;
 		}
 		unsigned char *data = cairo_image_surface_get_data(surface);
@@ -288,7 +281,7 @@ static void draw_wheel(GtkColorWheelPrivate *ns, cairo_t *cr, double radius, dou
 		double radius_sq = radius * radius + 2 * radius + 1;
 		double inner_radius_sq = inner_radius * inner_radius - 2 * inner_radius + 1;
 		Color c;
-		unsigned char *line_data;
+		uint8_t *line_data;
 		for (int y = 0; y < surface_height; ++y){
 			line_data = data + stride * y;
 			for (int x = 0; x < surface_width; ++x){
@@ -296,12 +289,12 @@ static void draw_wheel(GtkColorWheelPrivate *ns, cairo_t *cr, double radius, dou
 				int dy = y - surface_height / 2;
 				int dist = dx * dx + dy * dy;
 				if ((dist >= inner_radius_sq) && (dist <= radius_sq)){
-					double angle = atan2((double)dx, (double)dy) + M_PI;
-					wheel->hue_to_hsl(angle / (M_PI * 2), &c);
-					color_hsl_to_rgb(&c, &c);
-					line_data[2] = c.rgb.red * 255;
-					line_data[1] = c.rgb.green * 255;
-					line_data[0] = c.rgb.blue * 255;
+					double angle = atan2((double)dx, (double)dy) + math::PI;
+					wheel->hue_to_hsl(angle / (math::PI * 2), &c);
+					c = c.hslToRgb();
+					line_data[2] = static_cast<uint8_t>(c.rgb.red * 255);
+					line_data[1] = static_cast<uint8_t>(c.rgb.green * 255);
+					line_data[0] = static_cast<uint8_t>(c.rgb.blue * 255);
 					line_data[3] = 0xFF;
 				}
 				line_data += 4;
@@ -314,7 +307,7 @@ static void draw_wheel(GtkColorWheelPrivate *ns, cairo_t *cr, double radius, dou
 	cairo_set_source_surface(cr, surface, 0, 0);
 	cairo_set_line_width(cr, width);
 	cairo_new_path(cr);
-	cairo_arc(cr, radius, radius, (inner_radius + radius) / 2, 0, M_PI * 2);
+	cairo_arc(cr, radius, radius, (inner_radius + radius) / 2, 0, math::PI * 2);
 	cairo_stroke(cr);
 	cairo_restore(cr);
 }
@@ -332,8 +325,8 @@ static ColorPoint* get_cpoint_at(GtkColorWheelPrivate *ns, gint x, gint y)
 {
 	double dx, dy;
 	for (uint32_t i = 0; i != ns->n_cpoint; i++){
-		dx = ns->radius + (ns->radius - ns->circle_width / 2) * sin(ns->cpoint[i].hue * M_PI * 2) - x;
-		dy = ns->radius - (ns->radius - ns->circle_width / 2) * cos(ns->cpoint[i].hue * M_PI * 2) - y;
+		dx = ns->radius + (ns->radius - ns->circle_width / 2) * sin(ns->cpoint[i].hue * math::PI * 2) - x;
+		dy = ns->radius - (ns->radius - ns->circle_width / 2) * cos(ns->cpoint[i].hue * math::PI * 2) - y;
 		if (sqrt(dx * dx + dy * dy) < 16){
 			return &ns->cpoint[i];
 		}
@@ -364,21 +357,21 @@ static void offset_xy(GtkWidget *widget, gint &x, gint &y)
 static gboolean motion_notify(GtkWidget *widget, GdkEventMotion *event)
 {
 	GtkColorWheelPrivate *ns = GET_PRIVATE(widget);
-	int x = event->x, y = event->y;
+	int x = static_cast<int>(event->x), y = static_cast<int>(event->y);
 	offset_xy(widget, x, y);
 	if (ns->grab_active){
 		double dx = -(x - ns->radius);
 		double dy = y - ns->radius;
-		double angle = atan2(dx, dy) + M_PI;
-		ns->grab_active->hue = angle / (M_PI * 2);
+		double angle = atan2(dx, dy) + math::PI;
+		ns->grab_active->hue = angle / (math::PI * 2);
 		g_signal_emit(widget, signals[HUE_CHANGED], 0, get_color_index(ns, ns->grab_active));
 		gtk_widget_queue_draw(widget);
 		return true;
 	}else if (ns->grab_block){
 		double dx = event->x - ns->radius + ns->block_size / 2;
 		double dy = event->y - ns->radius + ns->block_size / 2;
-		ns->selected->saturation = clamp_float(dx / ns->block_size, 0, 1);
-		ns->selected->lightness = clamp_float(dy / ns->block_size, 0, 1);
+		ns->selected->saturation = math::clamp(static_cast<float>(dx / ns->block_size), 0.0f, 1.0f);
+		ns->selected->lightness = math::clamp(static_cast<float>(dy / ns->block_size), 0.0f, 1.0f);
 		g_signal_emit(widget, signals[SATURATION_VALUE_CHANGED], 0, get_color_index(ns, ns->selected));
 		gtk_widget_queue_draw(widget);
 		return true;
@@ -390,14 +383,14 @@ static gboolean draw(GtkWidget *widget, cairo_t *cr)
 	GtkColorWheelPrivate *ns = GET_PRIVATE(widget);
 	draw_wheel(ns, cr, ns->radius, ns->circle_width, ns->color_wheel_type);
 	if (ns->selected){
-		double block_size = 2 * (ns->radius - ns->circle_width) * sin(M_PI / 4) - 6;
+		double block_size = 2 * (ns->radius - ns->circle_width) * sin(math::PI / 4) - 6;
 		Color hsl;
 		ns->color_wheel_type->hue_to_hsl(ns->selected->hue, &hsl);
 		draw_sat_val_block(cr, ns->radius, ns->radius, block_size, hsl.hsl.hue);
 		draw_dot(cr, ns->radius - block_size / 2 + block_size * ns->selected->saturation, ns->radius - block_size / 2 + block_size * ns->selected->lightness, 4);
 	}
 	for (uint32_t i = 0; i != ns->n_cpoint; i++){
-		draw_dot(cr, ns->radius + (ns->radius - ns->circle_width / 2) * sin(ns->cpoint[i].hue * M_PI * 2), ns->radius - (ns->radius - ns->circle_width / 2) * cos(ns->cpoint[i].hue * M_PI * 2), (&ns->cpoint[i] == ns->selected) ? 7 : 4);
+		draw_dot(cr, ns->radius + (ns->radius - ns->circle_width / 2) * sin(ns->cpoint[i].hue * math::PI * 2), ns->radius - (ns->radius - ns->circle_width / 2) * cos(ns->cpoint[i].hue * math::PI * 2), (&ns->cpoint[i] == ns->selected) ? 7 : 4);
 	}
 	return FALSE;
 }
@@ -418,7 +411,7 @@ static gboolean expose(GtkWidget *widget, GdkEventExpose *event)
 static gboolean button_press(GtkWidget *widget, GdkEventButton *event)
 {
 	GtkColorWheelPrivate *ns = GET_PRIVATE(widget);
-	int x = event->x, y = event->y;
+	int x = static_cast<int>(event->x), y = static_cast<int>(event->y);
 	offset_xy(widget, x, y);
 	gtk_widget_grab_focus(widget);
 	ColorPoint *p;
diff --git a/source/gtk/ColorWheel.h b/source/gtk/ColorWheel.h
index 5dcb6fc..9abb781 100644
--- a/source/gtk/ColorWheel.h
+++ b/source/gtk/ColorWheel.h
@@ -20,8 +20,8 @@
 #define GPICK_GTK_COLOR_WHEEL_H_
 
 #include <gtk/gtk.h>
-#include "../Color.h"
-#include "../ColorWheelType.h"
+#include "Color.h"
+#include "ColorWheelType.h"
 
 #define GTK_TYPE_COLOR_WHEEL (gtk_color_wheel_get_type())
 #define GTK_COLOR_WHEEL(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), GTK_TYPE_COLOR_WHEEL, GtkColorWheel))
diff --git a/source/gtk/ColorWidget.cpp b/source/gtk/ColorWidget.cpp
index 835c01c..3c90020 100644
--- a/source/gtk/ColorWidget.cpp
+++ b/source/gtk/ColorWidget.cpp
@@ -17,12 +17,8 @@
  */
 
 #include "ColorWidget.h"
-#include "../Color.h"
-#include "../MathUtil.h"
-#include <math.h>
-#include <boost/math/special_functions/round.hpp>
-#include <iostream>
-using namespace std;
+#include "Color.h"
+#include "Shapes.h"
 
 #define GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), GTK_TYPE_COLOR, GtkColorPrivate))
 G_DEFINE_TYPE(GtkColor, gtk_color, GTK_TYPE_DRAWING_AREA);
@@ -35,18 +31,16 @@ static gboolean draw(GtkWidget *widget, cairo_t *cr);
 static gboolean expose(GtkWidget *widget, GdkEventExpose *event);
 static void size_request(GtkWidget *widget, GtkRequisition *requisition);
 #endif
-enum
-{
+enum {
 	ACTIVATED, LAST_SIGNAL,
 };
 static guint signals[LAST_SIGNAL] = {};
-struct GtkColorPrivate
-{
+struct GtkColorPrivate {
 	Color color, text_color, split_color;
 	std::string text;
 	bool rounded_rectangle, h_center, split;
 	bool secondary_color;
-	double roundness;
+	float roundness;
 	transformation::Chain *transformation_chain;
 };
 static void gtk_color_class_init(GtkColorClass *color_class)
@@ -74,9 +68,6 @@ GtkWidget* gtk_color_new()
 	GtkWidget* widget = (GtkWidget*)g_object_new(GTK_TYPE_COLOR, nullptr);
 	GtkColorPrivate *ns = GET_PRIVATE(widget);
 	new (ns) GtkColorPrivate();
-	color_set(&ns->color, 0);
-	color_set(&ns->text_color, 0);
-	color_set(&ns->split_color, 0);
 	ns->rounded_rectangle = false;
 	ns->h_center = false;
 	ns->secondary_color = false;
@@ -93,8 +84,6 @@ GtkWidget* gtk_color_new(const Color &color, ColorWidgetConfiguration configurat
 	GtkWidget* widget = (GtkWidget*)g_object_new(GTK_TYPE_COLOR, nullptr);
 	GtkColorPrivate *ns = GET_PRIVATE(widget);
 	new (ns) GtkColorPrivate();
-	color_set(&ns->text_color, 0);
-	color_set(&ns->split_color, 0);
 	ns->color = color;
 	ns->rounded_rectangle = true;
 	ns->h_center = true;
@@ -132,18 +121,18 @@ static void finalize(GObject *color_obj)
 void gtk_color_get_color(GtkColor* widget, Color* color)
 {
 	GtkColorPrivate *ns = GET_PRIVATE(widget);
-	color_copy(&ns->color, color);
+	*color = ns->color;
 }
 void gtk_color_set_text_color(GtkColor* widget, Color* color)
 {
 	GtkColorPrivate *ns = GET_PRIVATE(widget);
-	color_copy(color, &ns->text_color);
+	ns->text_color = *color;
 	gtk_widget_queue_draw(GTK_WIDGET(widget));
 }
 void gtk_color_set_roundness(GtkColor* widget, double roundness)
 {
 	GtkColorPrivate *ns = GET_PRIVATE(widget);
-	ns->roundness = roundness;
+	ns->roundness = static_cast<float>(roundness);
 	gint width = 32;
 	gint height = 16;
 #if GTK_MAJOR_VERSION < 3
@@ -151,35 +140,35 @@ void gtk_color_set_roundness(GtkColor* widget, double roundness)
 	height += GTK_WIDGET(widget)->style->ythickness * 2;
 #endif
 	if (ns->rounded_rectangle){
-		width += ns->roundness;
-		height += ns->roundness;
+		width += static_cast<int>(ns->roundness);
+		height += static_cast<int>(ns->roundness);
 	}
 	gtk_widget_set_size_request(GTK_WIDGET(widget), width, height);
 	gtk_widget_queue_draw(GTK_WIDGET(widget));
 }
 void gtk_color_set_color(GtkColor* widget, const Color &color) {
 	GtkColorPrivate *ns = GET_PRIVATE(widget);
-	color_copy(&color, &ns->color);
+	ns->color = color;
 	if (ns->transformation_chain){
 		Color c;
 		ns->transformation_chain->apply(&ns->color, &c);
-		color_get_contrasting(&c, &ns->text_color);
+		ns->text_color = c.getContrasting();
 	}else{
-		color_get_contrasting(&ns->color, &ns->text_color);
+		ns->text_color = ns->color.getContrasting();
 	}
 	gtk_widget_queue_draw(GTK_WIDGET(widget));
 }
 void gtk_color_set_color(GtkColor* widget, const Color &color, const std::string &text) {
 	GtkColorPrivate *ns = GET_PRIVATE(widget);
-	color_copy(&color, &ns->color);
+	ns->color = color;
 	if (ns->secondary_color){
 	}else{
 		if (ns->transformation_chain){
 			Color c;
 			ns->transformation_chain->apply(&ns->color, &c);
-			color_get_contrasting(&c, &ns->text_color);
+			ns->text_color = c.getContrasting();
 		}else{
-			color_get_contrasting(&ns->color, &ns->text_color);
+			ns->text_color = ns->color.getContrasting();
 		}
 	}
 	ns->text = text;
@@ -193,15 +182,15 @@ void gtk_color_set_text(GtkColor* widget, const std::string &text) {
 void gtk_color_set_color(GtkColor* widget, const Color* color, const char* text)
 {
 	GtkColorPrivate *ns = GET_PRIVATE(widget);
-	color_copy(color, &ns->color);
+	ns->color = *color;
 	if (ns->secondary_color){
 	}else{
 		if (ns->transformation_chain){
 			Color c;
 			ns->transformation_chain->apply(&ns->color, &c);
-			color_get_contrasting(&c, &ns->text_color);
+			ns->text_color = c.getContrasting();
 		}else{
-			color_get_contrasting(&ns->color, &ns->text_color);
+			ns->text_color = ns->color.getContrasting();
 		}
 	}
 	ns->text = text;
@@ -219,36 +208,6 @@ void gtk_color_set_hcenter(GtkColor* widget, bool hcenter)
 	ns->h_center = hcenter;
 	gtk_widget_queue_draw(GTK_WIDGET(widget));
 }
-static void cairo_rounded_rectangle(cairo_t *cr, double x, double y, double width, double height, double roundness)
-{
-	double strength = 0.3;
-	cairo_new_path(cr);
-	cairo_move_to(cr, x+roundness, y);
-	cairo_line_to(cr, x+width-roundness, y);
-	cairo_curve_to(cr, x+width-roundness*strength, y, x+width, y+roundness*strength, x+width, y+roundness);
-	cairo_line_to(cr, x+width, y+height-roundness);
-	cairo_curve_to(cr, x+width, y+height-roundness*strength, x+width-roundness*strength, y+height, x+width-roundness, y+height);
-	cairo_line_to(cr, x+roundness, y+height);
-	cairo_curve_to(cr, x+roundness*strength, y+height, x, y+height-roundness*strength, x, y+height-roundness);
-	cairo_line_to(cr, x, y+roundness);
-	cairo_curve_to(cr, x, y+roundness*strength, x+roundness*strength, y, x+roundness, y);
-	cairo_close_path(cr);
-}
-static void cairo_split_rectangle(cairo_t *cr, double x, double y, double width, double height, double tilt)
-{
-	cairo_new_path(cr);
-	cairo_move_to(cr, x, y + height / 2);
-	cairo_line_to(cr, x + width, y + height / 2 + tilt);
-	cairo_line_to(cr, x + width, y + height);
-	cairo_line_to(cr, x, y + height);
-	cairo_line_to(cr, x, y + height / 2);
-	cairo_close_path(cr);
-}
-static void cairo_set_color(cairo_t *cr, Color &color)
-{
-	using namespace boost::math;
-	cairo_set_source_rgb(cr, round(color.rgb.red * 255.0) / 255.0, round(color.rgb.green * 255.0) / 255.0, round(color.rgb.blue * 255.0) / 255.0);
-}
 static gboolean draw(GtkWidget *widget, cairo_t *cr)
 {
 	GtkColorPrivate *ns = GET_PRIVATE(widget);
@@ -267,27 +226,27 @@ static gboolean draw(GtkWidget *widget, cairo_t *cr)
 			ns->transformation_chain->apply(&ns->split_color, &split_color);
 		}
 	}else{
-		color_copy(&ns->color, &color);
+		color = ns->color;
 		if (ns->split){
-			color_copy(&ns->split_color, &split_color);
+			split_color = ns->split_color;
 		}
 	}
 	if (ns->rounded_rectangle){
 		if (sensitive){
-			cairo_rounded_rectangle(cr, 0, 0, width, height, ns->roundness);
-			cairo_set_color(cr, color);
+			gtk::roundedRectangle(cr, 0, 0, width, height, ns->roundness);
+			gtk::setColor(cr, color);
 			cairo_fill(cr);
 		}
 		if (ns->split && sensitive){
 			cairo_save(cr);
-			cairo_split_rectangle(cr, 0, 0, width, height, height / 6);
+			gtk::splitRectangle(cr, 0, 0, width, height, 0.2f);
 			cairo_clip_preserve(cr);
-			cairo_rounded_rectangle(cr, 0, 0, width, height, ns->roundness);
-			cairo_set_color(cr, split_color);
+			gtk::roundedRectangle(cr, 0, 0, width, height, ns->roundness);
+			gtk::setColor(cr, split_color);
 			cairo_fill(cr);
 			cairo_restore(cr);
 		}
-		cairo_rounded_rectangle(cr, 0, 0, width, height, ns->roundness);
+		gtk::roundedRectangle(cr, 0, 0, width, height, ns->roundness);
 		if (gtk_widget_has_focus(widget)){
 #if GTK_MAJOR_VERSION >= 3
 			//TODO: GTK3 get border color
@@ -307,15 +266,15 @@ static gboolean draw(GtkWidget *widget, cairo_t *cr)
 	}else{
 		if (ns->split && sensitive){
 			cairo_save(cr);
-			cairo_split_rectangle(cr, 0, 0, width, height, height / 6);
+			gtk::splitRectangle(cr, 0, 0, width, height, 0.2f);
 			cairo_clip_preserve(cr);
-			cairo_rounded_rectangle(cr, 0, 0, width, height, ns->roundness);
-			cairo_set_color(cr, split_color);
+			gtk::roundedRectangle(cr, 0, 0, width, height, ns->roundness);
+			gtk::setColor(cr, split_color);
 			cairo_fill(cr);
 			cairo_restore(cr);
 		}
 		if (sensitive){
-			cairo_set_color(cr, color);
+			gtk::setColor(cr, color);
 			cairo_paint(cr);
 		}
 	}
@@ -333,12 +292,12 @@ static gboolean draw(GtkWidget *widget, cairo_t *cr)
 			if (ns->secondary_color){
 				ns->transformation_chain->apply(&ns->text_color, &color);
 			}else{
-				color_copy(&ns->text_color, &color);
+				color = ns->text_color;
 			}
 		}else{
-			color_copy(&ns->text_color, &color);
+			color = ns->text_color;
 		}
-		cairo_set_color(cr, color);
+		gtk::setColor(cr, color);
 		pango_layout_set_markup(layout, ns->text.c_str(), -1);
 		pango_layout_set_width(layout, (width - 10) * PANGO_SCALE);
 		pango_layout_set_height(layout, height * PANGO_SCALE);
@@ -389,9 +348,9 @@ void gtk_color_set_transformation_chain(GtkColor* widget, transformation::Chain
 		if (ns->transformation_chain){
 			Color c;
 			ns->transformation_chain->apply(&ns->color, &c);
-			color_get_contrasting(&c, &ns->text_color);
+			ns->text_color = c.getContrasting();
 		}else{
-			color_get_contrasting(&ns->color, &ns->text_color);
+			ns->text_color = ns->color.getContrasting();
 		}
 	}
 	gtk_widget_queue_draw(GTK_WIDGET(widget));
@@ -399,13 +358,13 @@ void gtk_color_set_transformation_chain(GtkColor* widget, transformation::Chain
 void gtk_color_set_split_color(GtkColor* widget, const Color* color)
 {
 	GtkColorPrivate *ns = GET_PRIVATE(widget);
-	color_copy(color, &ns->split_color);
+	ns->split_color = *color;
 	gtk_widget_queue_draw(GTK_WIDGET(widget));
 }
 void gtk_color_get_split_color(GtkColor* widget, Color* color)
 {
 	GtkColorPrivate *ns = GET_PRIVATE(widget);
-	color_copy(&ns->split_color, color);
+	*color = ns->split_color;
 }
 void gtk_color_enable_split(GtkColor* widget, bool enable)
 {
diff --git a/source/gtk/ColorWidget.h b/source/gtk/ColorWidget.h
index 9e32f0d..29a4218 100644
--- a/source/gtk/ColorWidget.h
+++ b/source/gtk/ColorWidget.h
@@ -21,8 +21,8 @@
 
 #include <gtk/gtk.h>
 #include <string>
-#include "../Color.h"
-#include "../transformation/Chain.h"
+#include "Color.h"
+#include "transformation/Chain.h"
 
 #define GTK_TYPE_COLOR (gtk_color_get_type())
 #define GTK_COLOR(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), GTK_TYPE_COLOR, GtkColor))
diff --git a/source/gtk/LayoutPreview.cpp b/source/gtk/LayoutPreview.cpp
index 8bdd677..d4658da 100644
--- a/source/gtk/LayoutPreview.cpp
+++ b/source/gtk/LayoutPreview.cpp
@@ -17,12 +17,11 @@
  */
 
 #include "LayoutPreview.h"
-#include "../layout/System.h"
-#include "../transformation/Chain.h"
-#include "../Rect2.h"
+#include "layout/System.h"
+#include "transformation/Chain.h"
+#include "Rect2.h"
 #include <list>
 #include <typeinfo>
-using namespace std;
 using namespace math;
 using namespace layout;
 
@@ -118,7 +117,6 @@ static gboolean draw(GtkWidget *widget, cairo_t *cr)
 #if GTK_MAJOR_VERSION < 3
 static gboolean expose(GtkWidget *widget, GdkEventExpose *event)
 {
-	GtkLayoutPreviewPrivate *ns = GET_PRIVATE(widget);
 	cairo_t *cr = gdk_cairo_create(gtk_widget_get_window(widget));
 	cairo_rectangle(cr, event->area.x, event->area.y, event->area.width, event->area.height);
 	cairo_clip(cr);
@@ -135,7 +133,7 @@ static gboolean button_press(GtkWidget *widget, GdkEventButton *event)
 	gtk_widget_grab_focus(widget);
 	GtkLayoutPreviewPrivate *ns = GET_PRIVATE(widget);
 	if (ns->system){
-		Vec2<float> point = Vec2<float>((event->x-ns->area.getX()) / ns->area.getWidth(), (event->y-ns->area.getY()) / ns->area.getHeight());
+		Vec2<float> point = Vec2<float>(static_cast<float>((event->x-ns->area.getX()) / ns->area.getWidth()), static_cast<float>((event->y-ns->area.getY()) / ns->area.getHeight()));
 		if (set_selected_box(ns, ns->system->GetBoxAt(point))){
 			gtk_widget_queue_draw(GTK_WIDGET(widget));
 		}
@@ -151,7 +149,7 @@ int gtk_layout_preview_set_system(GtkLayoutPreview* widget, System* system)
 	if (system){
 		ns->system = static_cast<System*>(system->ref());
 		if (ns->system->box)
-			gtk_widget_set_size_request(GTK_WIDGET(widget), ns->system->box->rect.getWidth(), ns->system->box->rect.getHeight());
+			gtk_widget_set_size_request(GTK_WIDGET(widget), static_cast<int>(ns->system->box->rect.getWidth()), static_cast<int>(ns->system->box->rect.getHeight()));
 	}else ns->system = 0;
 	return 0;
 }
@@ -159,10 +157,10 @@ int gtk_layout_preview_set_color_at(GtkLayoutPreview* widget, Color* color, gdou
 {
 	GtkLayoutPreviewPrivate *ns = GET_PRIVATE(widget);
 	if (!ns->system) return -1;
-	Vec2<float> point = Vec2<float>((x-ns->area.getX()) / ns->area.getWidth(), (y-ns->area.getY()) / ns->area.getHeight());
+	Vec2<float> point = Vec2<float>(static_cast<float>((x-ns->area.getX()) / ns->area.getWidth()), static_cast<float>((y-ns->area.getY()) / ns->area.getHeight()));
 	Box* box = ns->system->GetBoxAt(point);
 	if (box && box->style && !box->locked){
-		color_copy(color, &box->style->color);
+		box->style->color = *color;
 		gtk_widget_queue_draw(GTK_WIDGET(widget));
 		return 0;
 	}
@@ -174,7 +172,7 @@ int gtk_layout_preview_set_color_named(GtkLayoutPreview* widget, Color* color, c
 	if (!ns->system) return -1;
 	Box* box = ns->system->GetNamedBox(name);
 	if (box && box->style && !box->locked){
-		color_copy(color, &box->style->color);
+		box->style->color = *color;
 		gtk_widget_queue_draw(GTK_WIDGET(widget));
 		return 0;
 	}
@@ -195,7 +193,7 @@ int gtk_layout_preview_set_focus_at(GtkLayoutPreview* widget, gdouble x, gdouble
 {
 	GtkLayoutPreviewPrivate *ns = GET_PRIVATE(widget);
 	if (!ns->system) return -1;
-	Vec2<float> point = Vec2<float>((x-ns->area.getX()) / ns->area.getWidth(), (y-ns->area.getY()) / ns->area.getHeight());
+	Vec2<float> point = Vec2<float>(static_cast<float>((x-ns->area.getX()) / ns->area.getWidth()), static_cast<float>((y-ns->area.getY()) / ns->area.getHeight()));
 	Box* box;
 	if (set_selected_box(ns, box = ns->system->GetBoxAt(point))){
 		gtk_widget_queue_draw(GTK_WIDGET(widget));
@@ -217,7 +215,7 @@ int gtk_layout_preview_get_current_color(GtkLayoutPreview* widget, Color* color)
 	GtkLayoutPreviewPrivate *ns = GET_PRIVATE(widget);
 	if (ns->system && ns->selected_style){
 		Box* box = ns->selected_box;
-		color_copy(&box->style->color, color);
+		*color = box->style->color;
 		return 0;
 	}
 	return -1;
@@ -227,7 +225,7 @@ int gtk_layout_preview_set_current_color(GtkLayoutPreview* widget, Color* color)
 	GtkLayoutPreviewPrivate *ns = GET_PRIVATE(widget);
 	if (ns->system && ns->selected_style && !ns->selected_box->locked){
 		Box* box = ns->selected_box;
-		color_copy(color, &box->style->color);
+		box->style->color = *color;
 		gtk_widget_queue_draw(GTK_WIDGET(widget));
 		return 0;
 	}
diff --git a/source/gtk/LayoutPreview.h b/source/gtk/LayoutPreview.h
index 0dc7093..5be3f7b 100644
--- a/source/gtk/LayoutPreview.h
+++ b/source/gtk/LayoutPreview.h
@@ -20,9 +20,9 @@
 #define GPICK_GTK_LAYOUT_PREVIEW_H_
 
 #include <gtk/gtk.h>
-#include "../ColorObject.h"
-#include "../layout/System.h"
-#include "../transformation/Chain.h"
+#include "ColorObject.h"
+#include "layout/System.h"
+#include "transformation/Chain.h"
 
 #define GTK_TYPE_LAYOUT_PREVIEW (gtk_layout_preview_get_type())
 #define GTK_LAYOUT_PREVIEW(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), GTK_TYPE_LAYOUT_PREVIEW, GtkLayoutPreview))
diff --git a/source/gtk/Range2D.cpp b/source/gtk/Range2D.cpp
index 5382c5d..b2f8266 100644
--- a/source/gtk/Range2D.cpp
+++ b/source/gtk/Range2D.cpp
@@ -17,13 +17,7 @@
  */
 
 #include "Range2D.h"
-#include "../Color.h"
-#include "../MathUtil.h"
-#include <math.h>
-#ifdef _MSC_VER
-#define M_PI 3.14159265359
-#endif
-#include <stdlib.h>
+#include "Color.h"
 using namespace std;
 
 #define GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE ((obj), GTK_TYPE_RANGE_2D, GtkRange2DPrivate))
@@ -36,18 +30,16 @@ static gboolean draw(GtkWidget *widget, cairo_t *cr);
 #else
 static gboolean expose(GtkWidget *range_2d, GdkEventExpose *event);
 #endif
-enum
-{
+enum {
 	VALUES_CHANGED, LAST_SIGNAL
 };
 static guint signals[LAST_SIGNAL] = {};
-struct GtkRange2DPrivate
-{
-	double x;
-	double y;
+struct GtkRange2DPrivate {
+	float x;
+	float y;
 	char *xname;
 	char *yname;
-	double block_size;
+	float block_size;
 	bool grab_block;
 	cairo_surface_t *cache_range_2d;
 #if GTK_MAJOR_VERSION >= 3
@@ -95,9 +87,9 @@ GtkWidget* gtk_range_2d_new()
 	ns->xname = 0;
 	ns->yname = 0;
 #if GTK_MAJOR_VERSION >= 3
-	gtk_widget_set_size_request(GTK_WIDGET(widget), ns->block_size, ns->block_size);
+	gtk_widget_set_size_request(GTK_WIDGET(widget), static_cast<int>(ns->block_size), static_cast<int>(ns->block_size));
 #else
-	gtk_widget_set_size_request(GTK_WIDGET(widget), ns->block_size + widget->style->xthickness * 2, ns->block_size + widget->style->ythickness * 2);
+	gtk_widget_set_size_request(GTK_WIDGET(widget), static_cast<int>(ns->block_size + widget->style->xthickness * 2), static_cast<int>(ns->block_size + widget->style->ythickness * 2));
 #endif
 	ns->cache_range_2d = 0;
 #if GTK_MAJOR_VERSION >= 3
@@ -109,8 +101,8 @@ GtkWidget* gtk_range_2d_new()
 void gtk_range_2d_set_values(GtkRange2D* range_2d, double x, double y)
 {
 	GtkRange2DPrivate *ns = GET_PRIVATE(range_2d);
-	ns->x = x;
-	ns->y = 1 - y;
+	ns->x = static_cast<float>(x);
+	ns->y = static_cast<float>(1 - y);
 	gtk_widget_queue_draw(GTK_WIDGET(range_2d));
 }
 double gtk_range_2d_get_x(GtkRange2D* range_2d)
@@ -125,11 +117,11 @@ double gtk_range_2d_get_y(GtkRange2D* range_2d)
 }
 static void draw_dot(cairo_t *cr, double x, double y, double size)
 {
-	cairo_arc(cr, x, y, size - 1, 0, 2 * M_PI);
+	cairo_arc(cr, x, y, size - 1, 0, 2 * math::PI);
 	cairo_set_source_rgba(cr, 1, 1, 1, 0.5);
 	cairo_set_line_width(cr, 2);
 	cairo_stroke(cr);
-	cairo_arc(cr, x, y, size, 0, 2 * M_PI);
+	cairo_arc(cr, x, y, size, 0, 2 * math::PI);
 	cairo_set_source_rgba(cr, 0, 0, 0, 1);
 	cairo_set_line_width(cr, 1);
 	cairo_stroke(cr);
@@ -140,24 +132,24 @@ static void draw_sat_val_block(GtkRange2DPrivate *ns, cairo_t *cr, double pos_x,
 	if (ns->cache_range_2d){
 		surface = ns->cache_range_2d;
 	}else{
-		surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, ceil(size), ceil(size));
+		surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, static_cast<int>(std::ceil(size)), static_cast<int>(std::ceil(size)));
 		unsigned char *data = cairo_image_surface_get_data(surface);
 		int stride = cairo_image_surface_get_stride(surface);
 		int surface_width = cairo_image_surface_get_width(surface);
 		int surface_height = cairo_image_surface_get_height(surface);
 		float v;
-		unsigned char *line_data;
+		uint8_t *line_data;
 		for (int y = 0; y < surface_height; ++y){
 			line_data = data + stride * y;
 			for (int x = 0; x < surface_width; ++x){
 				if ((x % 16 < 8) ^ (y % 16 < 8) ){
-					v = mix_float(0.5, 1.0, pow(x / size, 2));
+					v = math::mix(0.5f, 1.0f, static_cast<float>(std::pow(x / size, 2)));
 				}else{
-					v = mix_float(0.5, 0.0, pow(1 - (y / size), 2));
+					v = math::mix(0.5f, 0.0f, static_cast<float>(std::pow(1 - (y / size), 2)));
 				}
-				line_data[2] = v * 255;
-				line_data[1] = v / 2 * 255;
-				line_data[0] = v / 4 * 255;
+				line_data[2] = static_cast<uint8_t>(v * 255);
+				line_data[1] = static_cast<uint8_t>(v / 2 * 255);
+				line_data[0] = static_cast<uint8_t>(v / 4 * 255);
 				line_data[3] = 0xFF;
 				line_data += 4;
 			}
@@ -182,8 +174,8 @@ static gboolean motion_notify(GtkWidget *widget, GdkEventMotion *event)
 		double dx = (event->x - widget->style->xthickness);
 		double dy = (event->y - widget->style->ythickness);
 #endif
-		ns->x = clamp_float(dx / ns->block_size, 0, 1);
-		ns->y = clamp_float(dy / ns->block_size, 0, 1);
+		ns->x = math::clamp(static_cast<float>(dx / static_cast<float>(ns->block_size)));
+		ns->y = math::clamp(static_cast<float>(dy / static_cast<float>(ns->block_size)));
 		g_signal_emit(widget, signals[VALUES_CHANGED], 0);
 		gtk_widget_queue_draw(widget);
 		return true;
@@ -229,7 +221,7 @@ static gboolean draw(GtkWidget *widget, cairo_t *cr)
 		pango_layout_set_text(layout, ns->yname, -1);
 		pango_layout_get_pixel_size(layout, &layout_width, &layout_height);
 		cairo_move_to(cr, layout_height + 1, 0);
-		cairo_rotate(cr, 90 / (180.0 / M_PI));
+		cairo_rotate(cr, 90 / (180.0 / math::PI));
 		pango_cairo_update_layout(cr, layout);
 		pango_cairo_show_layout(cr, layout);
 		g_object_unref(layout);
@@ -271,8 +263,8 @@ static gboolean button_press(GtkWidget *widget, GdkEventButton *event)
 		double dx = (event->x - widget->style->xthickness);
 		double dy = (event->y - widget->style->ythickness);
 #endif
-		ns->x = clamp_float(dx / ns->block_size, 0, 1);
-		ns->y = clamp_float(dy / ns->block_size, 0, 1);
+		ns->x = math::clamp(static_cast<int>(dx / static_cast<float>(ns->block_size)));
+		ns->y = math::clamp(static_cast<int>(dy / static_cast<float>(ns->block_size)));
 		g_signal_emit(widget, signals[VALUES_CHANGED], 0);
 		gtk_widget_queue_draw(widget);
 		return true;
diff --git a/source/gtk/Shapes.cpp b/source/gtk/Shapes.cpp
new file mode 100644
index 0000000..7fa8c40
--- /dev/null
+++ b/source/gtk/Shapes.cpp
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2009-2020, Albertas Vyšniauskas
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+ *
+ *     * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the software author nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
+ * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "Shapes.h"
+#include <boost/math/special_functions/round.hpp>
+namespace gtk {
+void roundedRectangle(cairo_t *cr, float x, float y, float width, float height, float roundness) {
+	float strength = 0.3f;
+	cairo_new_path(cr);
+	if (roundness == 0.0f) {
+		cairo_move_to(cr, x, y);
+		cairo_line_to(cr, x + width, y);
+		cairo_line_to(cr, x + width, y + height);
+		cairo_line_to(cr, x, y + height);
+	} else {
+		cairo_move_to(cr, x + roundness, y);
+		cairo_line_to(cr, x + width - roundness, y);
+		cairo_curve_to(cr, x + width - roundness * strength, y, x + width, y + roundness * strength, x + width, y + roundness);
+		cairo_line_to(cr, x + width, y + height - roundness);
+		cairo_curve_to(cr, x + width, y + height - roundness * strength, x + width - roundness * strength, y + height, x + width - roundness, y + height);
+		cairo_line_to(cr, x + roundness, y + height);
+		cairo_curve_to(cr, x + roundness * strength, y + height, x, y + height - roundness * strength, x, y + height - roundness);
+		cairo_line_to(cr, x, y + roundness);
+		cairo_curve_to(cr, x, y + roundness * strength, x + roundness * strength, y, x + roundness, y);
+	}
+	cairo_close_path(cr);
+}
+void splitRectangle(cairo_t *cr, float x, float y, float width, float height, float tilt) {
+	cairo_new_path(cr);
+	cairo_move_to(cr, x, y);
+	cairo_line_to(cr, x + width / 2 + width * tilt / 2, y);
+	cairo_line_to(cr, x + width / 2 - width * tilt / 2, y + height);
+	cairo_line_to(cr, x, y + height);
+	cairo_close_path(cr);
+}
+void setColor(cairo_t *cr, const Color &color) {
+	using namespace boost::math;
+	cairo_set_source_rgb(cr, round(color.rgb.red * 255.0) / 255.0, round(color.rgb.green * 255.0) / 255.0, round(color.rgb.blue * 255.0) / 255.0);
+}
+}
diff --git a/source/ColorUtils.h b/source/gtk/Shapes.h
similarity index 78%
rename from source/ColorUtils.h
rename to source/gtk/Shapes.h
index d8904ed..900e5bb 100644
--- a/source/ColorUtils.h
+++ b/source/gtk/Shapes.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2009-2016, Albertas Vyšniauskas
+ * Copyright (c) 2009-2020, Albertas Vyšniauskas
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
@@ -16,19 +16,13 @@
  * OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#ifndef GPICK_COLOR_UTILS_H_
-#define GPICK_COLOR_UTILS_H_
-
+#ifndef GPICK_GTK_SHAPES_H_
+#define GPICK_GTK_SHAPES_H_
 #include "Color.h"
-namespace color_utils
-{
-	template<typename T>
-	void mix(const Color &a, const Color &b, T ratio, Color &result)
-	{
-		for (int i = 0; i < 4; i++){
-			result.ma[i] = a.ma[i] * (1 - ratio) + b.ma[i] * ratio;
-		}
-	};
+#include <cairo.h>
+namespace gtk {
+void roundedRectangle(cairo_t *cr, float x, float y, float width, float height, float roundness);
+void splitRectangle(cairo_t *cr, float x, float y, float width, float height, float tilt);
+void setColor(cairo_t *cr, const Color &color);
 }
-
-#endif /* GPICK_COLOR_UTILS_H_ */
+#endif /* GPICK_GTK_SHAPES_H_ */
diff --git a/source/gtk/Swatch.cpp b/source/gtk/Swatch.cpp
index ef9da1d..bb39244 100644
--- a/source/gtk/Swatch.cpp
+++ b/source/gtk/Swatch.cpp
@@ -17,8 +17,7 @@
  */
 
 #include "Swatch.h"
-#include "../Color.h"
-#include "../MathUtil.h"
+#include "Color.h"
 #include <math.h>
 #include <boost/math/special_functions/round.hpp>
 
@@ -31,8 +30,7 @@ static gboolean draw(GtkWidget *widget, cairo_t *cr);
 #else
 static gboolean expose(GtkWidget *widget, GdkEventExpose *event);
 #endif
-enum
-{
+enum {
 	ACTIVE_COLOR_CHANGED, COLOR_CHANGED, COLOR_ACTIVATED, CENTER_ACTIVATED, LAST_SIGNAL
 };
 static guint signals[LAST_SIGNAL] = {};
@@ -48,8 +46,8 @@ struct GtkSwatchPrivate
 };
 static void finalize(GObject *obj)
 {
-	GtkSwatchPrivate *ns = GET_PRIVATE(obj);
 #if GTK_MAJOR_VERSION >= 3
+	GtkSwatchPrivate *ns = GET_PRIVATE(obj);
 	g_object_unref(ns->context);
 #endif
 	G_OBJECT_CLASS(g_type_class_peek_parent(G_OBJECT_CLASS(GTK_SWATCH_GET_CLASS(obj))))->finalize(obj);
@@ -97,7 +95,7 @@ GtkWidget* gtk_swatch_new()
 	gtk_widget_set_size_request(GTK_WIDGET(widget), 150 + widget->style->xthickness * 2, 136 + widget->style->ythickness * 2);
 #endif
 	for (gint32 i = 0; i < 7; ++i)
-		color_set(&ns->color[i], i / 7.0);
+		ns->color[i] = Color(i / 7.0f);
 	ns->current_color = 1;
 	ns->transformation_chain = 0;
 	ns->active = false;
@@ -110,7 +108,7 @@ GtkWidget* gtk_swatch_new()
 void gtk_swatch_set_color_to_main(GtkSwatch* swatch)
 {
 	GtkSwatchPrivate *ns = GET_PRIVATE(swatch);
-	color_copy(&ns->color[0], &ns->color[ns->current_color]);
+	ns->color[ns->current_color] = ns->color[0];
 	gtk_widget_queue_draw(GTK_WIDGET(swatch));
 }
 void gtk_swatch_move_active(GtkSwatch* swatch, gint32 direction)
@@ -131,12 +129,12 @@ void gtk_swatch_move_active(GtkSwatch* swatch, gint32 direction)
 void gtk_swatch_get_color(GtkSwatch* swatch, guint32 index, Color* color)
 {
 	GtkSwatchPrivate *ns = GET_PRIVATE(swatch);
-	color_copy(&ns->color[index], color);
+	*color = ns->color[index];
 }
 void gtk_swatch_get_main_color(GtkSwatch* swatch, Color* color)
 {
 	GtkSwatchPrivate *ns = GET_PRIVATE(swatch);
-	color_copy(&ns->color[0], color);
+	*color = ns->color[0];
 }
 gint32 gtk_swatch_get_active_index(GtkSwatch* swatch)
 {
@@ -146,24 +144,24 @@ gint32 gtk_swatch_get_active_index(GtkSwatch* swatch)
 void gtk_swatch_get_active_color(GtkSwatch* swatch, Color* color)
 {
 	GtkSwatchPrivate *ns = GET_PRIVATE(swatch);
-	color_copy(&ns->color[ns->current_color], color);
+	*color = ns->color[ns->current_color];
 }
 void gtk_swatch_set_color(GtkSwatch* swatch, guint32 index, Color* color)
 {
 	GtkSwatchPrivate *ns = GET_PRIVATE(swatch);
-	color_copy(color, &ns->color[index]);
+	ns->color[index] = *color;
 	gtk_widget_queue_draw(GTK_WIDGET(swatch));
 }
 void gtk_swatch_set_color(GtkSwatch* swatch, guint32 index, const Color &color)
 {
 	GtkSwatchPrivate *ns = GET_PRIVATE(swatch);
-	color_copy(&color, &ns->color[index]);
+	ns->color[index] = color;
 	gtk_widget_queue_draw(GTK_WIDGET(swatch));
 }
 void gtk_swatch_set_main_color(GtkSwatch* swatch, Color* color)
 {
 	GtkSwatchPrivate *ns = GET_PRIVATE(swatch);
-	color_copy(color, &ns->color[0]);
+	ns->color[0] = *color;
 	gtk_widget_queue_draw(GTK_WIDGET(swatch));
 }
 void gtk_swatch_set_active_index(GtkSwatch* swatch, guint32 index)
@@ -175,36 +173,34 @@ void gtk_swatch_set_active_index(GtkSwatch* swatch, guint32 index)
 void gtk_swatch_set_active_color(GtkSwatch* swatch, Color* color)
 {
 	GtkSwatchPrivate *ns = GET_PRIVATE(swatch);
-	color_copy(color, &ns->color[ns->current_color]);
+	ns->color[ns->current_color] = *color;
 	gtk_widget_queue_draw(GTK_WIDGET(swatch));
 }
 void gtk_swatch_set_main_color(GtkSwatch* swatch, guint index, Color* color)
 {
 	GtkSwatchPrivate *ns = GET_PRIVATE(swatch);
-	color_copy(color, &ns->color[0]);
+	ns->color[0] = *color;
 	gtk_widget_queue_draw(GTK_WIDGET(swatch));
 }
 static int get_color_by_position(gint x, gint y)
 {
-	vector2 a, b;
-	vector2_set(&a, 1, 0);
-	vector2_set(&b, x - 75, y - (75 - 7));
-	float distance = vector2_length(&b);
+	math::Vector2f a = { 1.0f, 0.0f }, b = { x - 75.0f, y - (75.0f - 7) };
+	float distance = static_cast<float>(b.length());
 	if (distance < 20){ //center color
 		return 0;
 	}else if (distance > 70){ //outside
 		return -1;
 	}else{
-		vector2_normalize(&b, &b);
-		float angle = acos(vector2_dot(&a, &b));
+		b.normalize();
+		float angle = static_cast<float>(std::acos(a.dotProduct(b)));
 		if (b.y < 0)
-			angle = 2 * PI - angle;
-		angle += (PI / 6) * 3;
+			angle = static_cast<float>(2 * math::PI - angle);
+		angle += static_cast<float>((math::PI / 6) * 3);
 		if (angle < 0)
-			angle += PI * 2;
-		if (angle > 2 * PI)
-			angle -= PI * 2;
-		return 1 + (int)floor(angle / ((PI * 2) / 6));
+			angle += static_cast<float>(math::PI * 2);
+		if (angle > 2 * math::PI)
+			angle -= static_cast<float>(math::PI * 2);
+		return 1 + static_cast<int>(std::floor(angle / ((math::PI * 2) / 6)));
 	}
 }
 gint gtk_swatch_get_color_at(GtkSwatch* swatch, gint x, gint y)
@@ -219,10 +215,13 @@ static void draw_hexagon(cairo_t *cr, float x, float y, float radius)
 {
 	cairo_new_sub_path(cr);
 	for (int i = 0; i < 6; ++i) {
-		cairo_line_to(cr, x + sin(i * PI / 3) * radius, y + cos(i * PI / 3) * radius);
+		cairo_line_to(cr, x + std::sin(i * math::PI / 3) * radius, y + std::cos(i * math::PI / 3) * radius);
 	}
 	cairo_close_path(cr);
 }
+static void draw_hexagon(cairo_t *cr, double x, double y, double radius) {
+	draw_hexagon(cr, static_cast<float>(x), static_cast<float>(y), static_cast<float>(radius));
+}
 static gboolean draw(GtkWidget *widget, cairo_t *cr)
 {
 	GtkSwatchPrivate *ns = GET_PRIVATE(widget);
@@ -233,10 +232,10 @@ static gboolean draw(GtkWidget *widget, cairo_t *cr)
 		gtk_paint_focus(widget->style, widget->window, GTK_STATE_ACTIVE, nullptr, widget, 0, widget->style->xthickness, widget->style->ythickness, 150, 136);
 #endif
 		cairo_set_source_rgba(cr, 0, 0, 0, 0.5);
-		cairo_arc(cr, 150 - 11.5, 12.5, 6, 0, 2 * PI);
+		cairo_arc(cr, 150 - 11.5, 12.5, 6, 0, 2 * math::PI);
 		cairo_fill(cr);
 		cairo_set_source_rgb(cr, 1, 0, 0);
-		cairo_arc(cr, 150 - 12, 12, 6, 0, 2 * PI);
+		cairo_arc(cr, 150 - 12, 12, 6, 0, 2 * math::PI);
 		cairo_fill(cr);
 	}
 	cairo_select_font_face(cr, "monospace", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_NORMAL);
@@ -251,21 +250,21 @@ static gboolean draw(GtkWidget *widget, cairo_t *cr)
 	cairo_translate(cr, 75 + padding_x, 75 + padding_y - 7);
 	int edges = 6;
 	cairo_set_source_rgb(cr, 0, 0, 0);
-	float radius_multi = 50 * cos((180 / edges) / (180 / PI));
-	float rotation = -(PI/6 * 4);
+	float radius_multi = static_cast<float>(50 * std::cos((180 / edges) / (180 / math::PI)));
+	float rotation = static_cast<float>(-(math::PI/6 * 4));
 	//Draw stroke
 	cairo_set_source_rgb(cr, 0, 0, 0);
 	cairo_set_line_width(cr, 3);
 	for (int i = 1; i < 7; ++i) {
 		if (i == ns->current_color)
 			continue;
-		draw_hexagon(cr, radius_multi * cos(rotation + i * (2 * PI) / edges), radius_multi * sin(rotation + i * (2 * PI) / edges), 27);
+		draw_hexagon(cr, radius_multi * std::cos(rotation + i * (2 * math::PI) / edges), radius_multi * std::sin(rotation + i * (2 * math::PI) / edges), 27);
 	}
 	cairo_set_line_join(cr, CAIRO_LINE_JOIN_ROUND);
 	cairo_stroke(cr);
 	cairo_set_source_rgb(cr, 1, 1, 1);
-	draw_hexagon(cr, radius_multi * cos(rotation + (ns->current_color) * (2 * PI) / edges), radius_multi * sin(rotation + (ns->current_color) * (2
-			* PI) / edges), 27);
+	draw_hexagon(cr, radius_multi * std::cos(rotation + (ns->current_color) * (2 * math::PI) / edges), radius_multi * std::sin(rotation + (ns->current_color) * (2
+			* math::PI) / edges), 27);
 	cairo_stroke(cr);
 	Color color;
 	//Draw fill
@@ -275,25 +274,25 @@ static gboolean draw(GtkWidget *widget, cairo_t *cr)
 		if (ns->transformation_chain){
 			ns->transformation_chain->apply(&ns->color[i], &color);
 		}else{
-			color_copy(&ns->color[i], &color);
+			color = ns->color[i];
 		}
 		cairo_set_source_rgb(cr, boost::math::round(color.rgb.red * 255.0) / 255.0, boost::math::round(color.rgb.green * 255.0) / 255.0, boost::math::round(color.rgb.blue * 255.0) / 255.0);
-		draw_hexagon(cr, radius_multi * cos(rotation + i * (2 * PI) / edges), radius_multi * sin(rotation + i * (2 * PI) / edges), 25.5);
+		draw_hexagon(cr, radius_multi * std::cos(rotation + i * (2 * math::PI) / edges), radius_multi * std::sin(rotation + i * (2 * math::PI) / edges), 25.5);
 		cairo_fill(cr);
 	}
 	if (ns->transformation_chain){
 		ns->transformation_chain->apply(&ns->color[ns->current_color], &color);
 	}else{
-		color_copy(&ns->color[ns->current_color], &color);
+		color = ns->color[ns->current_color];
 	}
 	cairo_set_source_rgb(cr, boost::math::round(color.rgb.red * 255.0) / 255.0, boost::math::round(color.rgb.green * 255.0) / 255.0, boost::math::round(color.rgb.blue * 255.0) / 255.0);
-	draw_hexagon(cr, radius_multi * cos(rotation + (ns->current_color) * (2 * PI) / edges), radius_multi * sin(rotation + (ns->current_color) * (2 * PI) / edges), 25.5);
+	draw_hexagon(cr, radius_multi * std::cos(rotation + (ns->current_color) * (2 * math::PI) / edges), radius_multi * std::sin(rotation + (ns->current_color) * (2 * math::PI) / edges), 25.5);
 	cairo_fill(cr);
 	//Draw center
 	if (ns->transformation_chain){
 		ns->transformation_chain->apply(&ns->color[0], &color);
 	}else{
-		color_copy(&ns->color[0], &color);
+		color = ns->color[0];
 	}
 	cairo_set_source_rgb(cr, boost::math::round(color.rgb.red * 255.0) / 255.0, boost::math::round(color.rgb.green * 255.0) / 255.0, boost::math::round(color.rgb.blue * 255.0) / 255.0);
 	draw_hexagon(cr, 0, 0, 25.5);
@@ -305,15 +304,15 @@ static gboolean draw(GtkWidget *widget, cairo_t *cr)
 		if (ns->transformation_chain){
 			Color t;
 			ns->transformation_chain->apply(&ns->color[i], &t);
-			color_get_contrasting(&t, &c);
+			c = t.getContrasting();
 		}else{
-			color_get_contrasting(&ns->color[i], &c);
+			c = ns->color[i].getContrasting();
 		}
 		cairo_text_extents_t extends;
 		numb[0] = '0' + i;
 		cairo_text_extents(cr, numb, &extends);
 		cairo_set_source_rgb(cr, boost::math::round(c.rgb.red * 255.0) / 255.0, boost::math::round(c.rgb.green * 255.0) / 255.0, boost::math::round(c.rgb.blue * 255.0) / 255.0);
-		cairo_move_to(cr, radius_multi * cos(rotation + i * (2 * PI) / edges) - extends.width / 2, radius_multi * sin(rotation + i * (2 * PI) / edges)
+		cairo_move_to(cr, radius_multi * std::cos(rotation + i * (2 * math::PI) / edges) - extends.width / 2, radius_multi * std::sin(rotation + i * (2 * math::PI) / edges)
 				+ extends.height / 2);
 		cairo_show_text(cr, numb);
 	}
@@ -341,7 +340,7 @@ static void offset_xy(GtkWidget *widget, gint &x, gint &y)
 }
 static gboolean button_press(GtkWidget *widget, GdkEventButton *event) {
 	GtkSwatchPrivate *ns = GET_PRIVATE(widget);
-	int x = event->x, y = event->y;
+	int x = static_cast<int>(event->x), y = static_cast<int>(event->y);
 	offset_xy(widget, x, y);
 	int new_color = get_color_by_position(x, y);
 	gtk_widget_grab_focus(widget);
diff --git a/source/gtk/Swatch.h b/source/gtk/Swatch.h
index 53a6fc2..87b193b 100644
--- a/source/gtk/Swatch.h
+++ b/source/gtk/Swatch.h
@@ -20,8 +20,8 @@
 #define GPICK_GTK_SWATCH_H_
 
 #include <gtk/gtk.h>
-#include "../Color.h"
-#include "../transformation/Chain.h"
+#include "Color.h"
+#include "transformation/Chain.h"
 #define GTK_TYPE_SWATCH (gtk_swatch_get_type())
 #define GTK_SWATCH(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), GTK_TYPE_SWATCH, GtkSwatch))
 #define GTK_SWATCH_CLASS(obj) (G_TYPE_CHECK_CLASS_CAST((obj), GTK_SWATCH, GtkSwatchClass))
diff --git a/source/gtk/Zoomed.cpp b/source/gtk/Zoomed.cpp
index 878a67e..c64664b 100644
--- a/source/gtk/Zoomed.cpp
+++ b/source/gtk/Zoomed.cpp
@@ -17,14 +17,12 @@
  */
 
 #include "Zoomed.h"
-#include "../Color.h"
-#include "../MathUtil.h"
-#include <math.h>
+#include "Color.h"
+#include "MathUtil.h"
 #include <iomanip>
 #include <algorithm>
 #include <sstream>
 #include <vector>
-using namespace std;
 
 #define GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), GTK_TYPE_ZOOMED, GtkZoomedPrivate))
 G_DEFINE_TYPE(GtkZoomed, gtk_zoomed, GTK_TYPE_DRAWING_AREA);
@@ -35,15 +33,13 @@ static gboolean draw(GtkWidget *widget, cairo_t *cr);
 #else
 static gboolean expose(GtkWidget *widget, GdkEventExpose *event);
 #endif
-enum
-{
+enum {
 	COLOR_CHANGED,
 	ACTIVATED,
 	LAST_SIGNAL
 };
 static guint signals[LAST_SIGNAL] = { 0 };
-struct GtkZoomedPrivate
-{
+struct GtkZoomedPrivate {
 	Color color;
 	gfloat zoom;
 	cairo_surface_t *surface;
@@ -222,7 +218,7 @@ math::Vec2<int> gtk_zoomed_get_screen_position(GtkZoomed *zoomed, const math::Ve
 	gint32 xh = (((position.x + 1) - left) * ns->width_height) / area_width;
 	gint32 yl = ((position.y - top) * ns->width_height) / area_width;
 	gint32 yh = (((position.y + 1) - top) * ns->width_height) / area_width;
-	math::Vec2<int> result((xl + xh) / 2.0, (yl + yh) / 2.0);
+	math::Vec2<int> result(static_cast<int>((xl + xh) / 2.0f), static_cast<int>((yl + yh) / 2.0f));
 	return result;
 }
 void gtk_zoomed_update(GtkZoomed *zoomed, math::Vec2<int>& pointer, math::Rect2<int>& screen_rect, math::Vec2<int>& offset, cairo_surface_t *surface)
@@ -258,8 +254,8 @@ void gtk_zoomed_update(GtkZoomed *zoomed, math::Vec2<int>& pointer, math::Rect2<
 	gint32 xh = (((x + 1) - left) * ns->width_height) / area_width;
 	gint32 yl = ((y - top) * ns->width_height) / area_width;
 	gint32 yh = (((y + 1) - top) * ns->width_height) / area_width;
-	ns->point.x = (xl + xh) / 2.0;
-	ns->point.y = (yl + yh) / 2.0;
+	ns->point.x = (xl + xh) / 2.0f;
+	ns->point.y = (yl + yh) / 2.0f;
 	ns->point_size.x = xh - xl;
 	ns->point_size.y = yh - yl;
 	int width = right - left;
@@ -303,8 +299,8 @@ static gboolean draw(GtkWidget *widget, cairo_t *cr)
 	gint pixbuf_y = -padding_y;
 #endif
 	if (ns->surface){
-		gint pixbuf_width = min(ns->width_height - pixbuf_x, ns->width_height);
-		gint pixbuf_height = min(ns->width_height - pixbuf_y, ns->width_height);
+		gint pixbuf_width = math::min(ns->width_height - pixbuf_x, ns->width_height);
+		gint pixbuf_height = math::min(ns->width_height - pixbuf_y, ns->width_height);
 		if (pixbuf_width > 0 && pixbuf_height > 0){
 			cairo_set_source_surface(cr, ns->surface, pixbuf_x, pixbuf_y);
 			cairo_pattern_set_filter(cairo_get_source(cr), CAIRO_FILTER_NEAREST);
@@ -328,10 +324,10 @@ static gboolean draw(GtkWidget *widget, cairo_t *cr)
 			radius = 15;
 		}
 		cairo_set_source_rgba(cr, 0, 0, 0, 0.75);
-		cairo_arc(cr, ns->point.x, ns->point.y, radius + 0.5, -PI, PI);
+		cairo_arc(cr, ns->point.x, ns->point.y, radius + 0.5, -math::PI, math::PI);
 		cairo_stroke(cr);
 		cairo_set_source_rgba(cr, 1, 1, 1, 0.75);
-		cairo_arc(cr, ns->point.x, ns->point.y, radius, -PI, PI);
+		cairo_arc(cr, ns->point.x, ns->point.y, radius, -math::PI, math::PI);
 		cairo_stroke(cr);
 	}
 	PangoLayout *layout;
@@ -346,7 +342,7 @@ static gboolean draw(GtkWidget *widget, cairo_t *cr)
 	gtk_zoomed_get_current_screen_rect(GTK_ZOOMED(widget), &area_rect);
 	cairo_rectangle(cr, 0, 0, ns->width_height - padding_x * 2, ns->width_height - padding_y * 2);
 	cairo_clip(cr);
-	vector<math::Vec2<int> > relative_positions(2);
+	std::vector<math::Vec2<int> > relative_positions(2);
 	bool draw_distance = true;
 	for (int i = 0; i < 2; i++){
 		if (ns->marks[i].valid){
@@ -372,7 +368,7 @@ static gboolean draw(GtkWidget *widget, cairo_t *cr)
 		}
 		for (int i = 0; i < 2; i++){
 			if (ns->marks[i].valid){
-				cairo_arc(cr, relative_positions[i].x, relative_positions[i].y, 2, -PI, PI);
+				cairo_arc(cr, relative_positions[i].x, relative_positions[i].y, 2, -math::PI, math::PI);
 				if (layer == 0){
 					cairo_set_source_rgba(cr, 0, 0, 0, 1);
 					cairo_set_line_width(cr, 2);
@@ -381,7 +377,7 @@ static gboolean draw(GtkWidget *widget, cairo_t *cr)
 					cairo_set_source_rgba(cr, 1, 1, 1, 1);
 					cairo_fill(cr);
 				}
-				stringstream ss;
+				std::stringstream ss;
 				ss << ns->marks[i].position.x << "x" << ns->marks[i].position.y;
 				auto text = ss.str();
 				pango_layout_set_text(layout, text.c_str(), -1);
@@ -406,8 +402,8 @@ static gboolean draw(GtkWidget *widget, cairo_t *cr)
 				math::Vec2<double>(ns->marks[1].position.x, ns->marks[1].position.y)
 			);
 			math::Vec2<int> center = (ns->marks[0].position + ns->marks[1].position) * 0.5;
-			stringstream ss;
-			ss << fixed << setprecision(1) << distance << endl << 1 + abs(ns->marks[0].position.x - ns->marks[1].position.x) << "x" << 1 + abs(ns->marks[0].position.y - ns->marks[1].position.y);
+			std::stringstream ss;
+			ss << std::fixed << std::setprecision(1) << distance << std::endl << 1 + math::abs(ns->marks[0].position.x - ns->marks[1].position.x) << "x" << 1 + math::abs(ns->marks[0].position.y - ns->marks[1].position.y);
 			auto text = ss.str();
 			pango_layout_set_text(layout, text.c_str(), -1);
 			pango_cairo_update_layout(cr, layout);
diff --git a/source/gtk/Zoomed.h b/source/gtk/Zoomed.h
index 7c63d1a..972f0fc 100644
--- a/source/gtk/Zoomed.h
+++ b/source/gtk/Zoomed.h
@@ -21,9 +21,9 @@
 
 #include <gtk/gtk.h>
 #include <stdint.h>
-#include "../Color.h"
-#include "../Rect2.h"
-#include "../Vector2.h"
+#include "Color.h"
+#include "Rect2.h"
+#include "Vector2.h"
 
 #define GTK_TYPE_ZOOMED (gtk_zoomed_get_type())
 #define GTK_ZOOMED(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), GTK_TYPE_ZOOMED, GtkZoomed))
diff --git a/source/layout/Box.cpp b/source/layout/Box.cpp
index 377cb09..874a83e 100644
--- a/source/layout/Box.cpp
+++ b/source/layout/Box.cpp
@@ -124,7 +124,7 @@ void Text::Draw(Context *context, const Rect2<float>& parent_rect ){
 			if (context->getTransformationChain()){
 				context->getTransformationChain()->apply(&style->color, &color);
 			}else{
-				color_copy(&style->color, &color);
+				color = style->color;
 			}
 
 			cairo_set_source_rgb(cr, boost::math::round(color.rgb.red * 255.0) / 255.0, boost::math::round(color.rgb.green * 255.0) / 255.0, boost::math::round(color.rgb.blue * 255.0) / 255.0);
@@ -160,7 +160,7 @@ void Fill::Draw(Context *context, const Rect2<float>& parent_rect ){
 	if (context->getTransformationChain()){
 		context->getTransformationChain()->apply(&style->color, &color);
 	}else{
-		color_copy(&style->color, &color);
+		color = style->color;
 	}
 	cairo_set_source_rgb(cr, boost::math::round(color.rgb.red * 255.0) / 255.0, boost::math::round(color.rgb.green * 255.0) / 255.0, boost::math::round(color.rgb.blue * 255.0) / 255.0);
 	cairo_rectangle(cr, draw_rect.getX(), draw_rect.getY(), draw_rect.getWidth(), draw_rect.getHeight());
diff --git a/source/layout/Style.cpp b/source/layout/Style.cpp
index 6715095..76b93c4 100644
--- a/source/layout/Style.cpp
+++ b/source/layout/Style.cpp
@@ -43,7 +43,7 @@ Style::Style(const char* _name, Color* _color, float _font_size)
 			style_type = TYPE_BACKGROUND;
 		}
 	}
-	color_copy(_color, &color);
+	color = *_color;
 	font_size = _font_size;
 	dirty = true;
 	highlight = false;
diff --git a/source/lua/Color.cpp b/source/lua/Color.cpp
index 5bfa38f..8b0750f 100644
--- a/source/lua/Color.cpp
+++ b/source/lua/Color.cpp
@@ -30,11 +30,11 @@ static int newColor(lua_State *L)
 	luaL_getmetatable(L, "color");
 	lua_setmetatable(L, -2);
 	if (lua_type(L, 2) == LUA_TNUMBER && lua_type(L, 3) == LUA_TNUMBER && lua_type(L, 4) == LUA_TNUMBER ){
-		c->rgb.red = luaL_checknumber(L, 2);
-		c->rgb.green = luaL_checknumber(L, 3);
-		c->rgb.blue = luaL_checknumber(L, 4);
+		c->rgb.red = static_cast<float>(luaL_checknumber(L, 2));
+		c->rgb.green = static_cast<float>(luaL_checknumber(L, 3));
+		c->rgb.blue = static_cast<float>(luaL_checknumber(L, 4));
 	}else{
-		color_zero(c);
+		*c = { 0.0f };
 	}
 	return 1;
 }
@@ -49,7 +49,7 @@ int pushColor(lua_State *L, const Color &color)
 	Color *c = reinterpret_cast<Color*>(lua_newuserdata(L, sizeof(Color)));
 	luaL_getmetatable(L, "color");
 	lua_setmetatable(L, -2);
-	color_copy(&color, c);
+	*c = color;
 	return 1;
 }
 static int toString(lua_State *L)
@@ -62,9 +62,9 @@ static int colorRgb(lua_State *L)
 {
 	Color &c = checkColor(L, 1);
 	if (lua_type(L, 2) == LUA_TNUMBER && lua_type(L, 3) == LUA_TNUMBER && lua_type(L, 4) == LUA_TNUMBER){
-		c.rgb.red = luaL_checknumber(L, 2);
-		c.rgb.green = luaL_checknumber(L, 3);
-		c.rgb.blue = luaL_checknumber(L, 4);
+		c.rgb.red = static_cast<float>(luaL_checknumber(L, 2));
+		c.rgb.green = static_cast<float>(luaL_checknumber(L, 3));
+		c.rgb.blue = static_cast<float>(luaL_checknumber(L, 4));
 	}
 	lua_pushnumber(L, c.rgb.red);
 	lua_pushnumber(L, c.rgb.green);
@@ -75,7 +75,7 @@ static int colorRed(lua_State *L)
 {
 	Color &c = checkColor(L, 1);
 	if (lua_type(L, 2) == LUA_TNUMBER){
-		c.rgb.red = luaL_checknumber(L, 2);
+		c.rgb.red = static_cast<float>(luaL_checknumber(L, 2));
 	}
 	lua_pushnumber(L, c.rgb.red);
 	return 1;
@@ -84,7 +84,7 @@ static int colorGreen(lua_State *L)
 {
 	Color &c = checkColor(L, 1);
 	if (lua_type(L, 2) == LUA_TNUMBER){
-		c.rgb.green = luaL_checknumber(L, 2);
+		c.rgb.green = static_cast<float>(luaL_checknumber(L, 2));
 	}
 	lua_pushnumber(L, c.rgb.green);
 	return 1;
@@ -93,7 +93,7 @@ static int colorBlue(lua_State *L)
 {
 	Color &c = checkColor(L, 1);
 	if (lua_type(L, 2) == LUA_TNUMBER){
-		c.rgb.blue = luaL_checknumber(L, 2);
+		c.rgb.blue = static_cast<float>(luaL_checknumber(L, 2));
 	}
 	lua_pushnumber(L, c.rgb.blue);
 	return 1;
@@ -102,9 +102,9 @@ static int colorHsl(lua_State *L)
 {
 	Color &c = checkColor(L, 1);
 	if (lua_type(L, 2) == LUA_TNUMBER && lua_type(L, 3) == LUA_TNUMBER && lua_type(L, 4) == LUA_TNUMBER){
-		c.hsl.hue = luaL_checknumber(L, 2);
-		c.hsl.saturation = luaL_checknumber(L, 3);
-		c.hsl.lightness = luaL_checknumber(L, 4);
+		c.hsl.hue = static_cast<float>(luaL_checknumber(L, 2));
+		c.hsl.saturation = static_cast<float>(luaL_checknumber(L, 3));
+		c.hsl.lightness = static_cast<float>(luaL_checknumber(L, 4));
 	}
 	lua_pushnumber(L, c.hsl.hue);
 	lua_pushnumber(L, c.hsl.saturation);
@@ -115,7 +115,7 @@ static int colorHue(lua_State *L)
 {
 	Color &c = checkColor(L, 1);
 	if (lua_type(L, 2) == LUA_TNUMBER){
-		c.hsl.hue = luaL_checknumber(L, 2);
+		c.hsl.hue = static_cast<float>(luaL_checknumber(L, 2));
 	}
 	lua_pushnumber(L, c.hsl.hue);
 	return 1;
@@ -124,7 +124,7 @@ static int colorSaturation(lua_State *L)
 {
 	Color &c = checkColor(L, 1);
 	if (lua_type(L, 2) == LUA_TNUMBER){
-		c.hsl.saturation = luaL_checknumber(L, 2);
+		c.hsl.saturation = static_cast<float>(luaL_checknumber(L, 2));
 	}
 	lua_pushnumber(L, c.hsl.saturation);
 	return 1;
@@ -133,7 +133,7 @@ static int colorLightness(lua_State *L)
 {
 	Color &c = checkColor(L, 1);
 	if (lua_type(L, 2) == LUA_TNUMBER){
-		c.hsl.lightness = luaL_checknumber(L, 2);
+		c.hsl.lightness = static_cast<float>(luaL_checknumber(L, 2));
 	}
 	lua_pushnumber(L, c.hsl.lightness);
 	return 1;
@@ -142,10 +142,10 @@ static int colorCmyk(lua_State *L)
 {
 	Color &c = checkColor(L, 1);
 	if (lua_type(L, 2) == LUA_TNUMBER && lua_type(L, 3) == LUA_TNUMBER && lua_type(L, 4) == LUA_TNUMBER && lua_type(L, 5) == LUA_TNUMBER){
-		c.cmyk.c = luaL_checknumber(L, 2);
-		c.cmyk.m = luaL_checknumber(L, 3);
-		c.cmyk.y = luaL_checknumber(L, 4);
-		c.cmyk.k = luaL_checknumber(L, 5);
+		c.cmyk.c = static_cast<float>(luaL_checknumber(L, 2));
+		c.cmyk.m = static_cast<float>(luaL_checknumber(L, 3));
+		c.cmyk.y = static_cast<float>(luaL_checknumber(L, 4));
+		c.cmyk.k = static_cast<float>(luaL_checknumber(L, 5));
 	}
 	lua_pushnumber(L, c.cmyk.c);
 	lua_pushnumber(L, c.cmyk.m);
@@ -157,7 +157,7 @@ static int colorCyan(lua_State *L)
 {
 	Color &c = checkColor(L, 1);
 	if (lua_type(L, 2) == LUA_TNUMBER){
-		c.cmyk.c = luaL_checknumber(L, 2);
+		c.cmyk.c = static_cast<float>(luaL_checknumber(L, 2));
 	}
 	lua_pushnumber(L, c.cmyk.c);
 	return 1;
@@ -166,7 +166,7 @@ static int colorMagenta(lua_State *L)
 {
 	Color &c = checkColor(L, 1);
 	if (lua_type(L, 2) == LUA_TNUMBER){
-		c.cmyk.m = luaL_checknumber(L, 2);
+		c.cmyk.m = static_cast<float>(luaL_checknumber(L, 2));
 	}
 	lua_pushnumber(L, c.cmyk.m);
 	return 1;
@@ -175,7 +175,7 @@ static int colorYellow(lua_State *L)
 {
 	Color &c = checkColor(L, 1);
 	if (lua_type(L, 2) == LUA_TNUMBER){
-		c.cmyk.y = luaL_checknumber(L, 2);
+		c.cmyk.y = static_cast<float>(luaL_checknumber(L, 2));
 	}
 	lua_pushnumber(L, c.cmyk.y);
 	return 1;
@@ -184,7 +184,7 @@ static int colorKeyBlack(lua_State *L)
 {
 	Color &c = checkColor(L, 1);
 	if (lua_type(L, 2) == LUA_TNUMBER){
-		c.cmyk.k = luaL_checknumber(L, 2);
+		c.cmyk.k = static_cast<float>(luaL_checknumber(L, 2));
 	}
 	lua_pushnumber(L, c.cmyk.k);
 	return 1;
@@ -193,7 +193,7 @@ static int colorLabLightness(lua_State *L)
 {
 	Color &c = checkColor(L, 1);
 	if (lua_type(L, 2) == LUA_TNUMBER){
-		c.lab.L = luaL_checknumber(L, 2);
+		c.lab.L = static_cast<float>(luaL_checknumber(L, 2));
 	}
 	lua_pushnumber(L, c.lab.L);
 	return 1;
@@ -202,7 +202,7 @@ static int colorLabA(lua_State *L)
 {
 	Color &c = checkColor(L, 1);
 	if (lua_type(L, 2) == LUA_TNUMBER){
-		c.lab.a = luaL_checknumber(L, 2);
+		c.lab.a = static_cast<float>(luaL_checknumber(L, 2));
 	}
 	lua_pushnumber(L, c.lab.a);
 	return 1;
@@ -211,41 +211,31 @@ static int colorLabB(lua_State *L)
 {
 	Color &c = checkColor(L, 1);
 	if (lua_type(L, 2) == LUA_TNUMBER){
-		c.lab.b = luaL_checknumber(L, 2);
+		c.lab.b = static_cast<float>(luaL_checknumber(L, 2));
 	}
 	lua_pushnumber(L, c.lab.b);
 	return 1;
 }
 static int colorRgbToHsl(lua_State *L)
 {
-	Color &c = checkColor(L, 1);
-	Color c2;
-	color_rgb_to_hsl(&c, &c2);
-	pushColor(L, c2);
+	pushColor(L, checkColor(L, 1).rgbToHsl());
 	return 1;
 }
 static int colorHslToRgb(lua_State *L)
 {
-	Color &c = checkColor(L, 1);
-	Color c2;
-	color_hsl_to_rgb(&c, &c2);
-	pushColor(L, c2);
+	pushColor(L, checkColor(L, 1).hslToRgb());
 	return 1;
 }
 static int colorRgbToCmyk(lua_State *L)
 {
-	Color &c = checkColor(L, 1);
-	Color c2, c3;
-	color_rgb_to_cmy(&c, &c3);
-	color_cmy_to_cmyk(&c3, &c2);
-	pushColor(L, c2);
+	pushColor(L, checkColor(L, 1).rgbToCmyk());
 	return 1;
 }
 static int colorLchLightness(lua_State *L)
 {
 	Color &c = checkColor(L, 1);
 	if (lua_type(L, 2) == LUA_TNUMBER){
-		c.lch.L = luaL_checknumber(L, 2);
+		c.lch.L = static_cast<float>(luaL_checknumber(L, 2));
 	}
 	lua_pushnumber(L, c.lch.L);
 	return 1;
@@ -254,7 +244,7 @@ static int colorLchChroma(lua_State *L)
 {
 	Color &c = checkColor(L, 1);
 	if (lua_type(L, 2) == LUA_TNUMBER){
-		c.lch.C = luaL_checknumber(L, 2);
+		c.lch.C = static_cast<float>(luaL_checknumber(L, 2));
 	}
 	lua_pushnumber(L, c.lch.C);
 	return 1;
@@ -263,7 +253,7 @@ static int colorLchHue(lua_State *L)
 {
 	Color &c = checkColor(L, 1);
 	if (lua_type(L, 2) == LUA_TNUMBER){
-		c.lch.h = luaL_checknumber(L, 2);
+		c.lch.h = static_cast<float>(luaL_checknumber(L, 2));
 	}
 	lua_pushnumber(L, c.lch.h);
 	return 1;
diff --git a/source/lua/Layout.cpp b/source/lua/Layout.cpp
index 3b4afdf..cac3ab7 100644
--- a/source/lua/Layout.cpp
+++ b/source/lua/Layout.cpp
@@ -41,7 +41,7 @@ static int newLayoutStyle(lua_State *L)
 	Style **c = static_cast<Style**>(lua_newuserdata(L, sizeof(Style*)));
 	luaL_getmetatable(L, "layoutStyle");
 	lua_setmetatable(L, -2);
-	*c = new Style(name, &color, font_size);
+	*c = new Style(name, &color, static_cast<float>(font_size));
 	return 1;
 }
 Style *checkLayoutStyle(lua_State *L, int index)
@@ -86,7 +86,7 @@ static int newLayoutBox(lua_State *L)
 	Box **c = static_cast<Box**>(lua_newuserdata(L, sizeof(Box*)));
 	luaL_getmetatable(L, "layout");
 	lua_setmetatable(L, -2);
-	*c = new Box(name, x, y, w, h);
+	*c = new Box(name, static_cast<float>(x), static_cast<float>(y), static_cast<float>(w), static_cast<float>(h));
 	return 1;
 }
 static int newLayoutFill(lua_State *L)
@@ -100,7 +100,7 @@ static int newLayoutFill(lua_State *L)
 	Box **c = static_cast<Box**>(lua_newuserdata(L, sizeof(Box*)));
 	luaL_getmetatable(L, "layout");
 	lua_setmetatable(L, -2);
-	Fill *e = new Fill(name, x, y, w, h);
+	Fill *e = new Fill(name, static_cast<float>(x), static_cast<float>(y), static_cast<float>(w), static_cast<float>(h));
 	e->SetStyle(style);
 	*c = e;
 	return 1;
@@ -120,7 +120,7 @@ static int newLayoutText(lua_State *L)
 	Box **c = static_cast<Box**>(lua_newuserdata(L, sizeof(Box*)));
 	luaL_getmetatable(L, "layout");
 	lua_setmetatable(L, -2);
-	Text *e = new Text(name, x, y, w, h);
+	Text *e = new Text(name, static_cast<float>(x), static_cast<float>(y), static_cast<float>(w), static_cast<float>(h));
 	if (style) e->SetStyle(style);
 	e->text = text;
 	*c = e;
diff --git a/source/math/Algorithms.h b/source/math/Algorithms.h
new file mode 100644
index 0000000..19e8b0e
--- /dev/null
+++ b/source/math/Algorithms.h
@@ -0,0 +1,103 @@
+/*
+ * Copyright (c) 2009-2019, Albertas Vyšniauskas
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+ *
+ *     * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the software author nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
+ * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef GPICK_MATH_ALGORITHMS_H_
+#define GPICK_MATH_ALGORITHMS_H_
+#include <tuple>
+#include <cmath>
+namespace math {
+const double PI = 3.14159265359;
+template<typename T>
+inline T abs(T value) {
+	return value < 0 ? -value : value;
+}
+template<typename T>
+inline T clamp(T value, T min, T max) {
+	return value < min ? min : (value < max ? value : max);
+}
+inline float clamp(float value, float min = 0.0f, float max = 1.0f) {
+	return value < min ? min : (value < max ? value : max);
+}
+template<typename T, typename R>
+inline T mix(T a, T b, R ratio) {
+	return a * (1 - ratio) + b * ratio;
+}
+template<typename T>
+inline T mix(T a, T b, float ratio = 0.5f) {
+	return a * (1.0f - ratio) + b * ratio;
+}
+template<typename T>
+inline T wrap(T value, T min, T max) {
+	while (value < min)
+		value += max - min;
+	while (value >= max)
+		value -= max - min;
+	return value;
+}
+inline float wrap(float value) {
+	return static_cast<float>(value - std::floor(value));
+}
+template<typename T>
+inline T &min(T &val) {
+	return val;
+}
+template<typename T0, typename T1, typename... Ts>
+inline auto min(T0 &&val1, T1 &&val2, Ts &&... vs) {
+	return (val2 > val1) ? min(val1, vs...) : min(val2, vs...);
+}
+template<typename T>
+inline T &max(T &&val) {
+	return val;
+}
+template<typename T0, typename T1, typename... Ts>
+inline auto max(T0 &&val1, T1 &&val2, Ts &&... vs) {
+	return (val2 < val1) ? max(val1, vs...) : max(val2, vs...);
+}
+template<typename T, typename... Ts>
+inline auto minMax(T &&value, Ts &&... values) {
+	return std::make_tuple<T &&, T &&>(min(value, values...), max(value, values...));
+}
+template<typename T>
+inline auto minMax(T &&value1, T &&value2) {
+	if (value2 < value1)
+		return std::make_tuple<T &&, T &&>(value2, value1);
+	else
+		return std::make_tuple<T &&, T &&>(value1, value2);
+}
+template<typename T>
+inline auto minMax(T &&value1, T &&value2, T &&value3) {
+	if (value2 < value1) {
+		if (value3 < value2) {
+			return std::make_tuple<T &&, T &&>(value3, value1);
+		} else if (value1 < value3) {
+			return std::make_tuple<T &&, T &&>(value2, value3);
+		} else {
+			return std::make_tuple<T &&, T &&>(value2, value1);
+		}
+	} else {
+		if (value3 < value1) {
+			return std::make_tuple<T &&, T &&>(value3, value2);
+		} else if (value2 < value3) {
+			return std::make_tuple<T &&, T &&>(value1, value3);
+		} else {
+			return std::make_tuple<T &&, T &&>(value1, value2);
+		}
+	}
+}
+}
+#endif /* GPICK_MATH_ALGORITHMS_H_ */
diff --git a/source/math/Matrix.h b/source/math/Matrix.h
new file mode 100644
index 0000000..ad9f5bf
--- /dev/null
+++ b/source/math/Matrix.h
@@ -0,0 +1,202 @@
+/*
+ * Copyright (c) 2009-2020, Albertas Vyšniauskas
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+ *
+ *     * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the software author nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
+ * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef GPICK_MATH_MATRIX_H_
+#define GPICK_MATH_MATRIX_H_
+#include "Vector.h"
+#include <algorithm>
+#include <initializer_list>
+#include <type_traits>
+#include <stdexcept>
+#include <boost/optional.hpp>
+namespace math {
+namespace impl {
+template<typename T, unsigned int N, typename Matrix>
+struct CommonMatrix {
+	static const unsigned int Size = N;
+	enum class Initialize {
+		identity,
+		zero,
+		none,
+	};
+	CommonMatrix(Initialize initialize) {
+		if (initialize == Initialize::identity) {
+			for (unsigned int i = 0; i < N; ++i) {
+				for (unsigned int j = 0; j < N; ++j) {
+					data[j][i] = i == j ? 1 : 0;
+				}
+			}
+		} else if (initialize == Initialize::zero) {
+			for (unsigned int i = 0; i < N; ++i) {
+				for (unsigned int j = 0; j < N; ++j) {
+					data[j][i] = 0;
+				}
+			}
+		}
+	}
+	CommonMatrix(const CommonMatrix &matrix) {
+		for (unsigned int i = 0; i < N; ++i) {
+			for (unsigned int j = 0; j < N; ++j) {
+				data[j][i] = matrix.data[j][i];
+			}
+		}
+	}
+	CommonMatrix &operator=(const CommonMatrix &matrix) {
+		for (unsigned int i = 0; i < N * N; ++i) {
+			flatData[i] = matrix.flatData[i];
+		}
+		return *this;
+	}
+	CommonMatrix(const CommonMatrix<T, N + 1, Matrix> &matrix, unsigned int skipI, unsigned int skipJ) {
+		for (unsigned int i = 0; i < N; ++i) {
+			for (unsigned int j = 0; j < N; ++j) {
+				data[j][i] = matrix.data[j >= skipJ ? j + 1 : j][i >= skipI ? i + 1 : i];
+			}
+		}
+	}
+	bool operator==(const CommonMatrix &matrix) const {
+		for (unsigned int i = 0; i < N * N; ++i) {
+			if (flatData[i] != matrix.flatData[i])
+				return false;
+		}
+		return true;
+	}
+	template<unsigned int X = N, std::enable_if_t<(X == 1), int> = 0>
+	auto determinant() const {
+		return data[0][0];
+	}
+	template<unsigned int X = N, std::enable_if_t<(X == 2), int> = 0>
+	auto determinant() const {
+		return data[0][0] * data[1][1] - data[1][0] * data[0][1];
+	}
+	template<unsigned int X = N, std::enable_if_t<(X >= 3), int> = 0>
+	auto determinant() const {
+		double result = 0;
+		for (unsigned int i = 0; i < N; ++i) {
+			double t = 1;
+			for (unsigned int j = 0; j < N; ++j) {
+				t *= data[j][(i + j) % N];
+			}
+			result += t;
+		}
+		for (unsigned int i = 0; i < N; ++i) {
+			double t = 1;
+			for (unsigned int j = 0; j < N; ++j) {
+				t *= data[j][(i + N - j - 1) % N];
+			}
+			result -= t;
+		}
+		return result;
+	};
+	boost::optional<Matrix> inverse() const {
+		auto determinant = this->determinant();
+		if (determinant == 0)
+			return boost::optional<Matrix>();
+		double determinantInverse = 1.0 / determinant;
+		Matrix result;
+		for (unsigned int i = 0; i < N; ++i) {
+			for (unsigned int j = 0; j < N; ++j) {
+				if (((i + j) & 1) == 0)
+					result.data[i][j] = CommonMatrix<T, N - 1, Matrix>(*this, i, j).determinant() * determinantInverse;
+				else
+					result.data[i][j] = -CommonMatrix<T, N - 1, Matrix>(*this, i, j).determinant() * determinantInverse;
+			}
+		}
+		return result;
+	};
+	Matrix transpose() const {
+		Matrix result(Initialize::none);
+		for (unsigned int i = 0; i < N; ++i) {
+			for (unsigned int j = 0; j < N; ++j) {
+				result.data[j][i] = data[i][j];
+			}
+		}
+		return result;
+	};
+	Matrix operator*(const Matrix &matrix) const {
+		Matrix result(Initialize::zero);
+		for (unsigned int i = 0; i < N; ++i) {
+			for (unsigned int j = 0; j < N; ++j) {
+				for (unsigned int k = 0; k < N; ++k) {
+					result.data[j][i] += data[k][i] * matrix.data[j][k];
+				}
+			}
+		}
+		return result;
+	};
+	const T operator[](size_t index) const {
+		if (index >= N * N)
+			throw std::invalid_argument("index");
+		return data[index / N][index % N];
+	};
+	T &operator[](size_t index) {
+		if (index >= N * N)
+			throw std::invalid_argument("index");
+		return data[index / N][index % N];
+	};
+	union {
+		T data[N][N];
+		T flatData[N * N];
+	};
+protected:
+	template<typename... Args, std::enable_if_t<sizeof...(Args) == N * N, int> = 0>
+	CommonMatrix(Args... args) {
+		std::copy_n(std::initializer_list<T>({ args... }).begin(), N * N, this->flatData);
+	};
+private:
+	Matrix &asMatrix() {
+		return *reinterpret_cast<Matrix *>(this);
+	};
+};
+}
+template<typename T, unsigned int N>
+struct Matrix;
+template<typename T>
+struct Matrix<T, 3>: public impl::CommonMatrix<T, 3, Matrix<T, 3>> {
+	using Base = impl::CommonMatrix<T, 3, Matrix<T, 3>>;
+	using Initialize = typename Base::Initialize;
+	Matrix():
+		Base(Initialize::identity) {};
+	Matrix(Initialize initialize):
+		Base(initialize) {};
+	Matrix(const Matrix &matrix):
+		Base(matrix) {};
+	template<typename... Args, std::enable_if_t<sizeof...(Args) == 9, int> = 0>
+	Matrix(Args... args):
+		Base(args...) {};
+	Matrix &operator=(const Matrix &matrix) {
+		Base::operator=(matrix);
+		return *this;
+	}
+};
+using Matrix3f = Matrix<float, 3>;
+using Matrix3d = Matrix<double, 3>;
+template<typename T, unsigned int N>
+Vector<T, N> operator*(const Vector<T, N> &vector, const Matrix<T, N> &matrix) {
+	Vector<T, N> result;
+	for (unsigned int j = 0; j < N; ++j) {
+		T value = 0;
+		for (unsigned int i = 0; i < N; ++i) {
+			value += vector.data[i] * matrix.data[j][i];
+		}
+		result.data[j] = value;
+	}
+	return result;
+};
+}
+#endif /* GPICK_MATH_MATRIX_H_ */
diff --git a/source/math/Vector.h b/source/math/Vector.h
new file mode 100644
index 0000000..238eac8
--- /dev/null
+++ b/source/math/Vector.h
@@ -0,0 +1,291 @@
+/*
+ * Copyright (c) 2009-2020, Albertas Vyšniauskas
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+ *
+ *     * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the software author nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
+ * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef GPICK_MATH_VECTOR_H_
+#define GPICK_MATH_VECTOR_H_
+#include "Algorithms.h"
+#include <algorithm>
+#include <initializer_list>
+#include <type_traits>
+#include <stdexcept>
+#include <cmath>
+namespace math {
+namespace impl {
+template<typename T, unsigned int N>
+struct VectorBase;
+template<typename T>
+struct VectorBase<T, 2> {
+	union {
+#pragma pack(push, 1)
+		struct {
+			T x, y;
+		};
+		T data[2];
+#pragma pack(pop)
+	};
+	VectorBase():
+		x(0), y(0) {};
+	VectorBase(const T &x, const T &y):
+		x(x), y(y) {};
+	VectorBase(const VectorBase &value):
+		x(value.x), y(value.y) {};
+};
+template<typename T>
+struct VectorBase<T, 3> {
+	union {
+#pragma pack(push, 1)
+		struct {
+			T x, y, z;
+		};
+		struct {
+			T r, g, b;
+		};
+		T data[3];
+#pragma pack(pop)
+	};
+	VectorBase():
+		x(0), y(0), z(0) {};
+	VectorBase(const T &x, const T &y, const T &z):
+		x(x), y(y), z(z) {};
+	VectorBase(const VectorBase &value):
+		x(value.x), y(value.y), z(value.z) {};
+};
+template<typename T, unsigned int N, typename Vector>
+struct CommonVector: public VectorBase<T, N> {
+	CommonVector():
+		VectorBase<T, N>() {
+		for (unsigned int i = 0; i < N; i++) {
+			this->data[i] = 0;
+		}
+	};
+	CommonVector(const CommonVector &vector):
+		VectorBase<T, N>() {
+		for (unsigned int i = 0; i < N; i++) {
+			this->data[i] = vector.data[i];
+		}
+	};
+	template<typename Value>
+	Vector operator*(const Value value) const {
+		Vector result;
+		for (unsigned int i = 0; i < N; i++) {
+			result.data[i] = this->data[i] * value;
+		}
+		return result;
+	};
+	template<typename Value>
+	Vector operator/(const Value value) const {
+		Vector result;
+		for (unsigned int i = 0; i < N; i++) {
+			result.data[i] = this->data[i] / value;
+		}
+		return result;
+	};
+	template<typename Value>
+	Vector operator+(const Value value) const {
+		Vector result;
+		for (unsigned int i = 0; i < N; i++) {
+			result.data[i] = this->data[i] + value;
+		}
+		return result;
+	};
+	template<typename Value>
+	Vector operator-(const Value value) const {
+		Vector result;
+		for (unsigned int i = 0; i < N; i++) {
+			result.data[i] = this->data[i] - value;
+		}
+		return result;
+	};
+	template<typename Value>
+	Vector &operator*=(const Value value) {
+		for (unsigned int i = 0; i < N; i++) {
+			this->data[i] *= value;
+		}
+		return asVector();
+	};
+	template<typename Value>
+	Vector &operator/=(const Value value) {
+		for (unsigned int i = 0; i < N; i++) {
+			this->data[i] /= value;
+		}
+		return asVector();
+	};
+	template<typename Value>
+	Vector &operator+=(const Value value) {
+		for (unsigned int i = 0; i < N; i++) {
+			this->data[i] += value;
+		}
+		return asVector();
+	};
+	template<typename Value>
+	Vector &operator-=(const Value value) {
+		for (unsigned int i = 0; i < N; i++) {
+			this->data[i] -= value;
+		}
+		return asVector();
+	};
+	Vector operator-() const {
+		Vector result;
+		for (unsigned int i = 0; i < N; i++) {
+			result.data[i] = -this->data[i];
+		}
+		return result;
+	};
+	Vector &operator=(const Vector &vector) {
+		for (unsigned int i = 0; i < N; i++) {
+			this->data[i] = vector.data[i];
+		}
+		return asVector();
+	};
+	Vector &operator*=(const Vector &vector) {
+		for (unsigned int i = 0; i < N; i++) {
+			this->data[i] *= vector.data[i];
+		}
+		return asVector();
+	};
+	Vector operator*(const Vector &vector) const {
+		Vector result;
+		for (unsigned int i = 0; i < N; i++) {
+			result.data[i] = this->data[i] * vector.data[i];
+		}
+		return result;
+	};
+	Vector &operator/=(const Vector &vector) {
+		for (unsigned int i = 0; i < N; i++) {
+			this->data[i] /= vector.data[i];
+		}
+		return asVector();
+	};
+	Vector operator/(const Vector &vector) const {
+		Vector result;
+		for (unsigned int i = 0; i < N; i++) {
+			result.data[i] = this->data[i] / vector.data[i];
+		}
+		return result;
+	};
+	Vector operator+(const Vector &vector) const {
+		Vector result;
+		for (unsigned int i = 0; i < N; i++) {
+			result.data[i] = this->data[i] + vector.data[i];
+		}
+		return result;
+	};
+	Vector operator-(const Vector &vector) const {
+		Vector result;
+		for (unsigned int i = 0; i < N; i++) {
+			result.data[i] = this->data[i] - vector.data[i];
+		}
+		return result;
+	};
+	T &operator[](size_t index) {
+		if (index >= N)
+			throw std::invalid_argument("index");
+		return this->data[index];
+	};
+	const T operator[](size_t index) const {
+		if (index >= N)
+			throw std::invalid_argument("index");
+		return this->data[index];
+	};
+	auto squaredLength() const {
+		double result = 0;
+		for (unsigned int i = 0; i < N; i++) {
+			result += this->data[i] * this->data[i];
+		}
+		return result;
+	};
+	auto length() const {
+		return std::sqrt(squaredLength());
+	};
+	Vector &normalize() {
+		auto vectorLength = length();
+		for (unsigned int i = 0; i < N; i++) {
+			this->data[i] = static_cast<T>(this->data[i] / vectorLength);
+		}
+		return asVector();
+	};
+	Vector &clamp(T min, T max) {
+		for (unsigned int i = 0; i < N; i++) {
+			this->data[i] = math::clamp(this->data[i], min, max);
+		}
+		return asVector();
+	};
+	Vector normalizeCopy() const {
+		return Vector(*this).normalize();
+	};
+	Vector clampCopy(T min, T max) const {
+		return Vector(*this).clamp();
+	};
+	T dotProduct(const Vector &vector) const {
+		T result{};
+		for (unsigned int i = 0; i < N; i++) {
+			result += this->data[i] * vector.data[i];
+		}
+		return result;
+	};
+protected:
+	template<typename... Args, std::enable_if_t<sizeof...(Args) == N, int> = 0>
+	CommonVector(Args... args) {
+		std::copy_n(std::initializer_list<T>({ args... }).begin(), N, this->data);
+	};
+private:
+	Vector &asVector() {
+		return *reinterpret_cast<Vector *>(this);
+	};
+};
+}
+/** \struct Vector
+ * \brief N dimensional vector of type T
+ */
+template<typename T, unsigned int N>
+struct Vector;
+template<typename T>
+struct Vector<T, 2>: public impl::CommonVector<T, 2, Vector<T, 2>> {
+	using Base = impl::CommonVector<T, 2, Vector<T, 2>>;
+	Vector():
+		Base() {};
+	Vector(const T &x, const T &y):
+		Base(x, y) {};
+	Vector(const Vector &vector):
+		Base(vector) {}
+};
+template<typename T>
+struct Vector<T, 3>: public impl::CommonVector<T, 3, Vector<T, 3>> {
+	using Base = impl::CommonVector<T, 3, Vector<T, 3>>;
+	Vector():
+		Base() {};
+	Vector(const T &x, const T &y, const T &z):
+		Base(x, y, z) {};
+	Vector(const Vector &vector):
+		Base(vector) {}
+};
+using Vector2f = Vector<float, 2>;
+using Vector2d = Vector<double, 2>;
+using Vector2i = Vector<int, 2>;
+using Vector3f = Vector<float, 3>;
+using Vector3d = Vector<double, 3>;
+template<typename T, typename TFrom, unsigned int N>
+Vector<T, N> vectorCast(const Vector<TFrom, N> &vector) {
+	Vector<T, N> result;
+	for (unsigned int i = 0; i < N; i++) {
+		result[i] = static_cast<T>(vector[i]);
+	}
+	return result;
+}
+}
+#endif /* GPICK_MATH_VECTOR_H_ */
diff --git a/source/parser/TextFileParser.rl b/source/parser/TextFileParser.rl
index 0d237f0..db98109 100644
--- a/source/parser/TextFileParser.rl
+++ b/source/parser/TextFileParser.rl
@@ -52,39 +52,39 @@ struct FSM
 		{
 			Color color;
 			int start_index = with_hash_symbol ? 1 : 0;
-			color.rgb.red = hexPairToInt(ts + start_index) / 255.0;
-			color.rgb.green = hexPairToInt(ts + start_index + 2) / 255.0;
-			color.rgb.blue = hexPairToInt(ts + start_index + 4) / 255.0;
-			color.ma[3] = 0;
+			color.rgb.red = hexPairToInt(ts + start_index) / 255.0f;
+			color.rgb.green = hexPairToInt(ts + start_index + 2) / 255.0f;
+			color.rgb.blue = hexPairToInt(ts + start_index + 4) / 255.0f;
+			color[3] = 0;
 			addColor(color);
 		}
 		void colorHexShort(bool with_hash_symbol)
 		{
 			Color color;
 			int start_index = with_hash_symbol ? 1 : 0;
-			color.rgb.red = hexToInt(ts[start_index + 0]) / 15.0;
-			color.rgb.green = hexToInt(ts[start_index + 1]) / 15.0;
-			color.rgb.blue = hexToInt(ts[start_index + 2]) / 15.0;
-			color.ma[3] = 0;
+			color.rgb.red = hexToInt(ts[start_index + 0]) / 15.0f;
+			color.rgb.green = hexToInt(ts[start_index + 1]) / 15.0f;
+			color.rgb.blue = hexToInt(ts[start_index + 2]) / 15.0f;
+			color[3] = 0;
 			addColor(color);
 		}
 		void colorRgb()
 		{
 			Color color;
-			color.rgb.red = numbers_i64[0] / 255.0;
-			color.rgb.green = numbers_i64[1] / 255.0;
-			color.rgb.blue = numbers_i64[2] / 255.0;
-			color.ma[3] = 0;
+			color.rgb.red = numbers_i64[0] / 255.0f;
+			color.rgb.green = numbers_i64[1] / 255.0f;
+			color.rgb.blue = numbers_i64[2] / 255.0f;
+			color[3] = 0;
 			numbers_i64.clear();
 			addColor(color);
 		}
 		void colorRgba()
 		{
 			Color color;
-			color.rgb.red = numbers_i64[0] / 255.0;
-			color.rgb.green = numbers_i64[1] / 255.0;
-			color.rgb.blue = numbers_i64[2] / 255.0;
-			color.ma[3] = numbers_double[0];
+			color.rgb.red = numbers_i64[0] / 255.0f;
+			color.rgb.green = numbers_i64[1] / 255.0f;
+			color.rgb.blue = numbers_i64[2] / 255.0f;
+			color[3] = static_cast<float>(numbers_double[0]);
 			numbers_i64.clear();
 			numbers_double.clear();
 			addColor(color);
@@ -92,20 +92,20 @@ struct FSM
 		void colorValues()
 		{
 			Color color;
-			color.rgb.red = numbers_double[0];
-			color.rgb.green = numbers_double[1];
-			color.rgb.blue = numbers_double[2];
-			color.ma[3] = 0;
+			color.rgb.red = static_cast<float>(numbers_double[0]);
+			color.rgb.green = static_cast<float>(numbers_double[1]);
+			color.rgb.blue = static_cast<float>(numbers_double[2]);
+			color[3] = 0;
 			numbers_double.clear();
 			addColor(color);
 		}
 		void colorValueIntegers()
 		{
 			Color color;
-			color.rgb.red = numbers_i64[0] / 255.0;
-			color.rgb.green = numbers_i64[1] / 255.0;
-			color.rgb.blue = numbers_i64[2] / 255.0;
-			color.ma[3] = 0;
+			color.rgb.red = numbers_i64[0] / 255.0f;
+			color.rgb.green = numbers_i64[1] / 255.0f;
+			color.rgb.blue = numbers_i64[2] / 255.0f;
+			color[3] = 0;
 			numbers_i64.clear();
 			addColor(color);
 		}
@@ -175,9 +175,7 @@ bool scanner(TextFile &text_file, const Configuration &configuration)
 	fsm->buffer_offset = 0;
 	bool parse_error = false;
 	fsm->addColor = [&text_file](const Color &color){
-		Color c = color;
-		color_rgb_normalize(&c);
-		text_file.addColor(c);
+		text_file.addColor(color.normalizeRgb());
 	};
 	%% write init;
 	int have = 0;
diff --git a/source/test/Color.cpp b/source/test/Color.cpp
new file mode 100644
index 0000000..125f119
--- /dev/null
+++ b/source/test/Color.cpp
@@ -0,0 +1,88 @@
+/*
+ * Copyright (c) 2009-2020, Albertas Vyšniauskas
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+ *
+ *     * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the software author nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
+ * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <boost/test/unit_test.hpp>
+#include "Color.h"
+#include <iostream>
+const Color testColor = { 0.5f, 0.25f, 0.1f };
+static std::ostream &operator<<(std::ostream &stream, const Color &color) {
+	stream << color[0] << ", " << color[1] << ", " << color[2] << ", " << color[3];
+	return stream;
+}
+struct Initialize {
+	Initialize() {
+		Color::initialize();
+	}
+};
+BOOST_FIXTURE_TEST_SUITE(color, Initialize)
+BOOST_AUTO_TEST_CASE(basic) {
+	Color empty;
+	BOOST_CHECK_EQUAL(empty[0], 0.0f);
+	BOOST_CHECK_EQUAL(empty[1], 0.0f);
+	BOOST_CHECK_EQUAL(empty[2], 0.0f);
+	BOOST_CHECK_EQUAL(empty[3], 0.0f);
+	Color singleValue(1.0f);
+	BOOST_CHECK_EQUAL(singleValue[0], 1.0f);
+	BOOST_CHECK_EQUAL(singleValue[1], 1.0f);
+	BOOST_CHECK_EQUAL(singleValue[2], 1.0f);
+	BOOST_CHECK_EQUAL(singleValue[3], 1.0f);
+	Color singleValueInt(255);
+	BOOST_CHECK_EQUAL(singleValueInt[0], 1.0f);
+	BOOST_CHECK_EQUAL(singleValueInt[1], 1.0f);
+	BOOST_CHECK_EQUAL(singleValueInt[2], 1.0f);
+	BOOST_CHECK_EQUAL(singleValueInt[3], 1.0f);
+	Color assignment;
+	assignment = testColor;
+	BOOST_CHECK_EQUAL(assignment[0], testColor[0]);
+	BOOST_CHECK_EQUAL(assignment[1], testColor[1]);
+	BOOST_CHECK_EQUAL(assignment[2], testColor[2]);
+	BOOST_CHECK_EQUAL(assignment[3], testColor[3]);
+}
+BOOST_AUTO_TEST_CASE(hsv) {
+	Color result = testColor.rgbToHsv().hsvToRgb();
+	BOOST_CHECK_EQUAL(result, testColor);
+}
+BOOST_AUTO_TEST_CASE(hsl) {
+	Color result = testColor.rgbToHsl().hslToRgb();
+	BOOST_CHECK_EQUAL(result, testColor);
+}
+BOOST_AUTO_TEST_CASE(cmy) {
+	Color result = testColor.rgbToCmy().cmyToRgb();
+	BOOST_CHECK_EQUAL(result, testColor);
+}
+BOOST_AUTO_TEST_CASE(cmyk) {
+	Color result = testColor.rgbToCmyk().cmykToRgb();
+	BOOST_CHECK_EQUAL(result, testColor);
+}
+BOOST_AUTO_TEST_CASE(xyz) {
+	Color result = testColor.rgbToXyz(Color::sRGBMatrix).xyzToRgb(Color::sRGBInvertedMatrix);
+	BOOST_CHECK_EQUAL(result, testColor);
+}
+BOOST_AUTO_TEST_CASE(lab) {
+	Color result = testColor.rgbToLabD50().labToRgbD50();
+	BOOST_CHECK_EQUAL(result, testColor);
+}
+BOOST_AUTO_TEST_CASE(lch) {
+	Color result = testColor.rgbToLchD50().lchToRgbD50();
+	BOOST_CHECK_EQUAL(result, testColor);
+}
+BOOST_AUTO_TEST_CASE(sRGBMatrix) {
+	auto result = Color(testColor.rgbVector<double>() * Color::sRGBMatrix * Color::sRGBInvertedMatrix);
+	BOOST_CHECK_EQUAL(result, testColor);
+}
+BOOST_AUTO_TEST_SUITE_END()
diff --git a/source/test/Dynv.cpp b/source/test/Dynv.cpp
index 30ef07b..b454216 100644
--- a/source/test/Dynv.cpp
+++ b/source/test/Dynv.cpp
@@ -24,12 +24,12 @@
 #include "Color.h"
 using Map = dynv::Map;
 using Ref = dynv::Ref;
-std::ostream &operator<<(std::ostream &stream, const Color &color) {
-	stream << color.ma[0] << "," << color.ma[1] << "," << color.ma[2] << "," << color.ma[3];
+static std::ostream &operator<<(std::ostream &stream, const Color &color) {
+	stream << color[0] << "," << color[1] << "," << color[2] << "," << color[3];
 	return stream;
 }
 namespace dynv {
-std::ostream &operator<<(std::ostream &stream, const Ref &map) {
+static std::ostream &operator<<(std::ostream &stream, const Ref &map) {
 	if (map)
 		stream << &*map;
 	else
diff --git a/source/test/Matrix.cpp b/source/test/Matrix.cpp
new file mode 100644
index 0000000..a625660
--- /dev/null
+++ b/source/test/Matrix.cpp
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2009-2020, Albertas Vyšniauskas
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+ *
+ *     * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the software author nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
+ * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <boost/test/unit_test.hpp>
+#include "math/Matrix.h"
+#include <iostream>
+namespace math {
+static std::ostream &operator<<(std::ostream &stream, const math::Matrix3d &matrix) {
+	for (size_t i = 0; i < math::Matrix3d::Size * math::Matrix3d::Size; i++) {
+		if (i != 0)
+			stream << ", ";
+		stream << matrix.flatData[i];
+	}
+	return stream;
+}
+}
+BOOST_AUTO_TEST_SUITE(matrix)
+const static math::Matrix3d zero = { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };
+const static math::Matrix3d identity = { 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0 };
+BOOST_AUTO_TEST_CASE(determinant) {
+	BOOST_CHECK_EQUAL(zero.determinant(), 0.0);
+	BOOST_CHECK_EQUAL(identity.determinant(), 1.0);
+	BOOST_CHECK_EQUAL(math::Matrix3d(1.0, 2.0, 3.0, 0.0, 1.0, 4.0, 5.0, 6.0, 0.0).determinant(), 1.0);
+}
+BOOST_AUTO_TEST_CASE(multiplication) {
+	BOOST_CHECK_EQUAL(identity * zero, zero);
+	BOOST_CHECK_EQUAL(zero * identity, zero);
+	BOOST_CHECK_EQUAL(identity * identity, identity);
+}
+BOOST_AUTO_TEST_CASE(inverse) {
+	BOOST_CHECK_EQUAL(*identity.inverse(), identity);
+	BOOST_CHECK_EQUAL(*math::Matrix3d(1.0, 2.0, 3.0, 0.0, 1.0, 4.0, 5.0, 6.0, 0.0).inverse(), math::Matrix3d(-24.0, 18.0, 5.0, 20.0, -15.0, -4.0, -5.0, 4.0, 1.0));
+}
+BOOST_AUTO_TEST_SUITE_END()
diff --git a/source/test/TextFileParser.cpp b/source/test/TextFileParser.cpp
index 7ee6175..8013414 100644
--- a/source/test/TextFileParser.cpp
+++ b/source/test/TextFileParser.cpp
@@ -37,7 +37,7 @@ struct Parser: public TextFile {
 	virtual void outOfMemory() {
 		m_failed = true;
 	}
-	virtual void syntaxError(size_t start_line, size_t start_column, size_t end_line, size_t end_colunn) {
+	virtual void syntaxError(size_t startLine, size_t startColumn, size_t endLine, size_t endEolunn) {
 		m_failed = true;
 	}
 	virtual size_t read(char *buffer, size_t length) {
@@ -57,7 +57,7 @@ struct Parser: public TextFile {
 		return m_colors.size();
 	}
 	bool checkColor(size_t index, const Color &color) {
-		return color_equal(&m_colors[index], &color);
+		return m_colors[index] == color;
 	}
 	void parse() {
 		Configuration configuration;
@@ -70,8 +70,7 @@ BOOST_AUTO_TEST_CASE(full_hex) {
 	Parser parser(&file);
 	parser.parse();
 	BOOST_CHECK(parser.count() == 1);
-	Color color;
-	color_set(&color, 0xaa, 0xbb, 0xcc);
+	Color color = { 0xaa, 0xbb, 0xcc };
 	BOOST_CHECK(parser.checkColor(0, color));
 	file.close();
 }
@@ -81,8 +80,7 @@ BOOST_AUTO_TEST_CASE(short_hex) {
 	Parser parser(&file);
 	parser.parse();
 	BOOST_CHECK(parser.count() == 1);
-	Color color;
-	color_set(&color, 0xaa, 0xbb, 0xcc);
+	Color color = { 0xaa, 0xbb, 0xcc };
 	BOOST_CHECK(parser.checkColor(0, color));
 	file.close();
 }
@@ -92,8 +90,7 @@ BOOST_AUTO_TEST_CASE(css_rgb) {
 	Parser parser(&file);
 	parser.parse();
 	BOOST_CHECK(parser.count() == 1);
-	Color color;
-	color_set(&color, 0xaa, 0xbb, 0xcc);
+	Color color = { 0xaa, 0xbb, 0xcc };
 	BOOST_CHECK(parser.checkColor(0, color));
 	file.close();
 }
@@ -103,9 +100,8 @@ BOOST_AUTO_TEST_CASE(css_rgba) {
 	Parser parser(&file);
 	parser.parse();
 	BOOST_CHECK(parser.count() == 1);
-	Color color;
-	color_set(&color, 0xaa, 0xbb, 0xcc);
-	color.ma[3] = 0.5;
+	Color color = { 0xaa, 0xbb, 0xcc };
+	color[3] = 0.5f;
 	BOOST_CHECK(parser.checkColor(0, color));
 	file.close();
 }
@@ -115,8 +111,7 @@ BOOST_AUTO_TEST_CASE(int_values) {
 	Parser parser(&file);
 	parser.parse();
 	BOOST_CHECK(parser.count() == 1);
-	Color color;
-	color_set(&color, 0xaa, 0xbb, 0xcc);
+	Color color = { 0xaa, 0xbb, 0xcc };
 	BOOST_CHECK(parser.checkColor(0, color));
 	file.close();
 }
@@ -126,8 +121,7 @@ BOOST_AUTO_TEST_CASE(float_values_separated_by_comma) {
 	Parser parser(&file);
 	parser.parse();
 	BOOST_CHECK(parser.count() == 1);
-	Color color;
-	color_set(&color, 0xaa, 0xbb, 0xcc);
+	Color color = { 0xaa, 0xbb, 0xcc };
 	BOOST_CHECK(parser.checkColor(0, color));
 	file.close();
 }
@@ -137,8 +131,7 @@ BOOST_AUTO_TEST_CASE(float_values_separated_by_space) {
 	Parser parser(&file);
 	parser.parse();
 	BOOST_CHECK(parser.count() == 1);
-	Color color;
-	color_set(&color, 0xaa, 0xbb, 0xcc);
+	Color color = { 0xaa, 0xbb, 0xcc };
 	BOOST_CHECK(parser.checkColor(0, color));
 	file.close();
 }
@@ -148,8 +141,7 @@ BOOST_AUTO_TEST_CASE(single_line_c_comments) {
 	Parser parser(&file);
 	parser.parse();
 	BOOST_CHECK(parser.count() == 1);
-	Color color;
-	color_set(&color, 0xaa, 0xbb, 0xcc);
+	Color color = { 0xaa, 0xbb, 0xcc };
 	BOOST_CHECK(parser.checkColor(0, color));
 	file.close();
 }
@@ -159,8 +151,7 @@ BOOST_AUTO_TEST_CASE(multi_line_c_comments) {
 	Parser parser(&file);
 	parser.parse();
 	BOOST_CHECK(parser.count() == 1);
-	Color color;
-	color_set(&color, 0xaa, 0xbb, 0xcc);
+	Color color = { 0xaa, 0xbb, 0xcc };
 	BOOST_CHECK(parser.checkColor(0, color));
 	file.close();
 }
@@ -170,8 +161,7 @@ BOOST_AUTO_TEST_CASE(single_line_hash_comments) {
 	Parser parser(&file);
 	parser.parse();
 	BOOST_CHECK(parser.count() == 1);
-	Color color;
-	color_set(&color, 0xaa, 0xbb, 0xcc);
+	Color color = { 0xaa, 0xbb, 0xcc };
 	BOOST_CHECK(parser.checkColor(0, color));
 	file.close();
 }
@@ -181,8 +171,7 @@ BOOST_AUTO_TEST_CASE(out_of_range_float_value) {
 	Parser parser(&file);
 	parser.parse();
 	BOOST_CHECK(parser.count() == 1);
-	Color color;
-	color_set(&color, 0xaa, 0xbb, 0);
+	Color color = { 0xaa, 0xbb, 0 };
 	BOOST_CHECK(parser.checkColor(0, color));
 	file.close();
 }
diff --git a/source/tools/ColorSpaceSampler.cpp b/source/tools/ColorSpaceSampler.cpp
index 6317514..019b236 100644
--- a/source/tools/ColorSpaceSampler.cpp
+++ b/source/tools/ColorSpaceSampler.cpp
@@ -97,9 +97,9 @@ static void calc(ColorSpaceSamplerArgs *args, bool preview, size_t limit)
 			float y_value = (args->axis[1].samples > 1) ? (args->axis[1].min_value + (args->axis[1].max_value - args->axis[1].min_value) * (y / (float)(args->axis[1].samples - 1))) : args->axis[1].min_value;
 			for (int z = 0; z < args->axis[2].samples; z++){
 				float z_value = (args->axis[2].samples > 1) ? (args->axis[2].min_value + (args->axis[2].max_value - args->axis[2].min_value) * (z / (float)(args->axis[2].samples - 1))) : args->axis[2].min_value;
-				values[value_i].ma[0] = x_value;
-				values[value_i].ma[1] = y_value;
-				values[value_i].ma[2] = z_value;
+				values[value_i][0] = x_value;
+				values[value_i][1] = y_value;
+				values[value_i][2] = z_value;
 				value_i++;
 				if (preview && value_i >= limit){
 					x = args->axis[0].samples;
@@ -117,32 +117,32 @@ static void calc(ColorSpaceSamplerArgs *args, bool preview, size_t limit)
 		}
 		switch (args->color_space){
 			case 0:
-				color_copy(&values[i], &t);
+				t = values[i];
 				break;
 			case 1:
-				color_hsv_to_rgb(&values[i], &t);
+				t = values[i].hsvToRgb();
 				break;
 			case 2:
-				color_hsl_to_rgb(&values[i], &t);
+				t = values[i].hslToRgb();
 				break;
 			case 3:
-				color_copy(&values[i], &t);
+				t = values[i];
 				t.lab.L *= 100;
 				t.lab.a = (t.lab.a - 0.5f) * 290;
 				t.lab.b = (t.lab.b - 0.5f) * 290;
-				color_lab_to_rgb_d50(&t, &t);
+				t = t.labToRgbD50();
 				break;
 			case 4:
-				color_copy(&values[i], &t);
+				t = values[i];
 				t.lch.L *= 100;
 				t.lch.C *= 136;
 				t.lch.h *= 360;
-				color_lch_to_rgb_d50(&t, &t);
+				t = t.lchToRgbD50();
 				break;
 		}
 		if (args->linearization)
-			color_linear_get_rgb(&t, &t);
-		color_rgb_normalize(&t);
+			t.nonLinearRgbInplace();
+		t.normalizeRgbInplace();
 		ColorObject *color_object = color_list_new_color_object(color_list, &t);
 		name_assigner.assign(color_object, &t);
 		color_list_add_color_object(color_list, color_object, 1);
@@ -159,9 +159,9 @@ static void get_settings(ColorSpaceSamplerArgs *args)
 	args->color_space = gtk_combo_box_get_active(GTK_COMBO_BOX(args->combo_color_space));
 	args->linearization = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(args->toggle_linearization));
 	for (int i = 0; i < N_AXIS; i++){
-		args->axis[i].samples = gtk_spin_button_get_value(GTK_SPIN_BUTTON(args->axis[i].range_samples));
-		args->axis[i].min_value = gtk_spin_button_get_value(GTK_SPIN_BUTTON(args->axis[i].range_min_value));
-		args->axis[i].max_value = gtk_spin_button_get_value(GTK_SPIN_BUTTON(args->axis[i].range_max_value));
+		args->axis[i].samples = static_cast<int>(gtk_spin_button_get_value(GTK_SPIN_BUTTON(args->axis[i].range_samples)));
+		args->axis[i].min_value = static_cast<float>(gtk_spin_button_get_value(GTK_SPIN_BUTTON(args->axis[i].range_min_value)));
+		args->axis[i].max_value = static_cast<float>(gtk_spin_button_get_value(GTK_SPIN_BUTTON(args->axis[i].range_max_value)));
 	}
 }
 static dynv::Ref get_axis_config(int axis, ColorSpaceSamplerArgs *args)
diff --git a/source/tools/PaletteFromImage.cpp b/source/tools/PaletteFromImage.cpp
index 3f3ef27..19ad168 100644
--- a/source/tools/PaletteFromImage.cpp
+++ b/source/tools/PaletteFromImage.cpp
@@ -396,7 +396,7 @@ static void get_settings(PaletteFromImageArgs *args){
 		args->filename.clear();
 	}
 
-	args->n_colors = gtk_spin_button_get_value(GTK_SPIN_BUTTON(args->range_colors));
+	args->n_colors = static_cast<int>(gtk_spin_button_get_value(GTK_SPIN_BUTTON(args->range_colors)));
 }
 
 static void save_settings(PaletteFromImageArgs *args){
@@ -452,10 +452,6 @@ static void update(GtkWidget *widget, PaletteFromImageArgs *args ){
 	calc(args, true, 100);
 }
 
-static gchar* format_threshold_value_cb(GtkScale *scale, gdouble value){
-	return g_strdup_printf("%0.01f%%", value);
-}
-
 static void destroy_cb(GtkWidget* widget, PaletteFromImageArgs *args){
 
 	if (args->previous_node) node_delete(args->previous_node);
diff --git a/source/transformation/Chain.cpp b/source/transformation/Chain.cpp
index 70972fd..549b829 100644
--- a/source/transformation/Chain.cpp
+++ b/source/transformation/Chain.cpp
@@ -23,12 +23,12 @@ Chain::Chain():
 }
 void Chain::apply(const Color *input, Color *output) {
 	if (!m_enabled) {
-		color_copy(input, output);
+		*output = *input;
 		return;
 	}
 	Color tmp[2];
 	Color *tmp_p[3];
-	color_copy(input, &tmp[0]);
+	tmp[0] = *input;
 	tmp_p[0] = &tmp[0];
 	tmp_p[1] = &tmp[1];
 	for (auto &transformation: m_transformationChain) {
@@ -37,7 +37,7 @@ void Chain::apply(const Color *input, Color *output) {
 		tmp_p[0] = tmp_p[1];
 		tmp_p[1] = tmp_p[2];
 	}
-	color_copy(tmp_p[0], output);
+	*output = *tmp_p[0];
 }
 void Chain::add(std::unique_ptr<Transformation> transformation) {
 	m_transformationChain.push_back(std::move(transformation));
diff --git a/source/transformation/ColorVisionDeficiency.cpp b/source/transformation/ColorVisionDeficiency.cpp
index b8144d4..2b8cc11 100644
--- a/source/transformation/ColorVisionDeficiency.cpp
+++ b/source/transformation/ColorVisionDeficiency.cpp
@@ -22,7 +22,7 @@
 #include "uiUtilities.h"
 #include "I18N.h"
 #include <gtk/gtk.h>
-#include <math.h>
+#include <cmath>
 #include <string.h>
 #include <iostream>
 using namespace std;
@@ -188,11 +188,11 @@ static void load_vector(const Color *color, vector3 *vector)
 void ColorVisionDeficiency::apply(Color *input, Color *output)
 {
 	Color linear_input, linear_output;
-	color_rgb_get_linear(input, &linear_input);
+	linear_input = input->linearRgb();
 	vector3 vi, vo1, vo2;
 	load_vector(&linear_input, &vi);
 	matrix3x3 matrix1, matrix2;
-	int index = floor(strength * 10);
+	int index = static_cast<int>(std::floor(strength * 10));
 	int index_secondary = std::min(index + 1, 10);
 	float interpolation_factor = 1 - ((strength * 10) - index);
 
@@ -253,15 +253,14 @@ void ColorVisionDeficiency::apply(Color *input, Color *output)
 			interpolation_factor = strength;
 			break;
 		default:
-			color_copy(input, output);
+			*output = *input;
 			return;
 	}
 
 	linear_output.rgb.red = vo1.x * interpolation_factor + vo2.x * (1 - interpolation_factor);
 	linear_output.rgb.green = vo1.y * interpolation_factor + vo2.y * (1 - interpolation_factor);
 	linear_output.rgb.blue = vo1.z * interpolation_factor + vo2.z * (1 - interpolation_factor);
-	color_linear_get_rgb(&linear_output, output);
-	color_rgb_normalize(output);
+	*output = linear_output.nonLinearRgbInplace().normalizeRgbInplace();
 }
 
 ColorVisionDeficiency::ColorVisionDeficiency():Transformation(transformationId, getName())
diff --git a/source/transformation/GammaModification.cpp b/source/transformation/GammaModification.cpp
index 6d077fe..3110ee6 100644
--- a/source/transformation/GammaModification.cpp
+++ b/source/transformation/GammaModification.cpp
@@ -18,12 +18,10 @@
 
 #include "GammaModification.h"
 #include "dynv/Map.h"
-#include "../MathUtil.h"
 #include "../uiUtilities.h"
 #include "../I18N.h"
 #include <gtk/gtk.h>
-#include <math.h>
-#include <string.h>
+#include <cmath>
 namespace transformation {
 static const char *transformationId = "gamma_modification";
 const char *GammaModification::getId() {
@@ -34,12 +32,11 @@ const char *GammaModification::getName() {
 }
 void GammaModification::apply(Color *input, Color *output) {
 	Color linear_input, linear_output;
-	color_rgb_get_linear(input, &linear_input);
-	linear_output.rgb.red = pow(linear_input.rgb.red, value);
-	linear_output.rgb.green = pow(linear_input.rgb.green, value);
-	linear_output.rgb.blue = pow(linear_input.rgb.blue, value);
-	color_linear_get_rgb(&linear_output, output);
-	color_rgb_normalize(output);
+	linear_input = input->linearRgb();
+	linear_output.rgb.red = std::pow(linear_input.rgb.red, value);
+	linear_output.rgb.green = std::pow(linear_input.rgb.green, value);
+	linear_output.rgb.blue = std::pow(linear_input.rgb.blue, value);
+	*output = linear_output.nonLinearRgbInplace().normalizeRgbInplace();
 }
 GammaModification::GammaModification():
 	Transformation(transformationId, getName()) {
diff --git a/source/transformation/Quantization.cpp b/source/transformation/Quantization.cpp
index ebf2906..93bb76f 100644
--- a/source/transformation/Quantization.cpp
+++ b/source/transformation/Quantization.cpp
@@ -92,7 +92,7 @@ GtkWidget *Quantization::Configuration::getWidget() {
 	return main;
 }
 void Quantization::Configuration::apply(dynv::Map &system) {
-	system.set<float>("value", gtk_spin_button_get_value(GTK_SPIN_BUTTON(value)));
+	system.set<float>("value", static_cast<float>(gtk_spin_button_get_value(GTK_SPIN_BUTTON(value))));
 	system.set<bool>("clip-top", gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(clip_top)));
 }
 }
diff --git a/source/transformation/Transformation.cpp b/source/transformation/Transformation.cpp
index db21c34..8fe9dc5 100644
--- a/source/transformation/Transformation.cpp
+++ b/source/transformation/Transformation.cpp
@@ -26,7 +26,7 @@ Transformation::Transformation(const char *name_, const char *readable_name_) {
 Transformation::~Transformation() {
 }
 void Transformation::apply(Color *input, Color *output) {
-	color_copy(input, output);
+	*output = *input;
 }
 std::string Transformation::getName() const {
 	return name;
diff --git a/source/uiApp.cpp b/source/uiApp.cpp
index d940389..aea148c 100644
--- a/source/uiApp.cpp
+++ b/source/uiApp.cpp
@@ -1665,7 +1665,7 @@ AppArgs* app_create_main(const StartupOptions &startupOptions, int &return_value
 	AppArgs* args = new AppArgs;
 	args->initialization = true;
 	args->startupOptions = startupOptions;
-	color_init();
+	Color::initialize();
 	args->gs = new GlobalState();
 	args->gs->loadSettings();
 	if (args->startupOptions.single_color_pick_mode){
diff --git a/source/uiColorInput.cpp b/source/uiColorInput.cpp
index 80d8fa6..de808cb 100644
--- a/source/uiColorInput.cpp
+++ b/source/uiColorInput.cpp
@@ -246,7 +246,7 @@ void dialog_color_component_input_show(GtkWindow *parent, GtkColorComponent *col
 			gtk_table_attach(GTK_TABLE(table), gtk_label_aligned_new(color_space_type->items[i].name,0,0,0,0),0,1,i,i+1,GtkAttachOptions(GTK_FILL),GTK_FILL,5,5);
 			args->value[i] = gtk_spin_button_new_with_range(color_space_type->items[i].min_value, color_space_type->items[i].max_value, color_space_type->items[i].step);
 			gtk_entry_set_activates_default(GTK_ENTRY(args->value[i]), true);
-			gtk_spin_button_set_value(GTK_SPIN_BUTTON(args->value[i]), raw_color.ma[i] * color_space_type->items[i].raw_scale);
+			gtk_spin_button_set_value(GTK_SPIN_BUTTON(args->value[i]), raw_color[i] * color_space_type->items[i].raw_scale);
 			gtk_table_attach(GTK_TABLE(table), args->value[i],1,2,i,i+1,GtkAttachOptions(GTK_FILL | GTK_EXPAND),GTK_FILL,5,0);
 			if (i == component_id)
 				gtk_widget_grab_focus(args->value[i]);
@@ -261,7 +261,7 @@ void dialog_color_component_input_show(GtkWindow *parent, GtkColorComponent *col
 	if (gtk_dialog_run(GTK_DIALOG(dialog)) == GTK_RESPONSE_OK){
 		if (color_space_type){
 			for (int i = 0; i < color_space_type->n_items; i++){
-				raw_color.ma[i] = gtk_spin_button_get_value(GTK_SPIN_BUTTON(args->value[i])) / color_space_type->items[i].raw_scale;
+				raw_color[i] = static_cast<float>(gtk_spin_button_get_value(GTK_SPIN_BUTTON(args->value[i])) / color_space_type->items[i].raw_scale);
 			}
 			gtk_color_component_set_raw_color(color_component, &raw_color);
 		}
diff --git a/source/uiDialogAutonumber.cpp b/source/uiDialogAutonumber.cpp
index 88254be..c3aca88 100644
--- a/source/uiDialogAutonumber.cpp
+++ b/source/uiDialogAutonumber.cpp
@@ -19,7 +19,6 @@
 #include "uiDialogAutonumber.h"
 #include "uiListPalette.h"
 #include "uiUtilities.h"
-#include "MathUtil.h"
 #include "dynv/Map.h"
 #include "GlobalState.h"
 #include "ColorRYB.h"
@@ -57,8 +56,8 @@ static int default_nplaces(uint32_t selected_count)
 }
 static void update(GtkWidget *widget, DialogAutonumberArgs *args)
 {
-	int nplaces = gtk_spin_button_get_value (GTK_SPIN_BUTTON(args->nplaces));
-	int startindex = gtk_spin_button_get_value (GTK_SPIN_BUTTON(args->startindex));
+	int nplaces = static_cast<int>(gtk_spin_button_get_value(GTK_SPIN_BUTTON(args->nplaces)));
+	int startindex = static_cast<int>(gtk_spin_button_get_value(GTK_SPIN_BUTTON(args->startindex)));
 	const char *name = gtk_entry_get_text(GTK_ENTRY(args->name));
 	stringstream ss;
 	ss << name << "-";
@@ -75,7 +74,7 @@ static void update(GtkWidget *widget, DialogAutonumberArgs *args)
 }
 static void update_startindex(GtkWidget *widget, DialogAutonumberArgs *args)
 {
-	int startindex = gtk_spin_button_get_value (GTK_SPIN_BUTTON(args->startindex));
+	int startindex = static_cast<int>(gtk_spin_button_get_value(GTK_SPIN_BUTTON(args->startindex)));
 	int newindex;
 	gdouble min, max;
 	gtk_spin_button_get_range(GTK_SPIN_BUTTON(args->startindex), &min, &max);
diff --git a/source/uiDialogGenerate.cpp b/source/uiDialogGenerate.cpp
index ab118d0..df9fa92 100644
--- a/source/uiDialogGenerate.cpp
+++ b/source/uiDialogGenerate.cpp
@@ -85,9 +85,9 @@ struct GenerateColorNameAssigner: public ToolColorNameAssigner
 };
 static void rgb_hue2hue(double hue, Color* hsl)
 {
-	hsl->hsl.hue = hue;
+	hsl->hsl.hue = static_cast<float>(hue);
 	hsl->hsl.saturation = 1;
-	hsl->hsl.lightness = 0.5;
+	hsl->hsl.lightness = 0.5f;
 }
 static void rgb_rgbhue2hue(double rgbhue, double *hue)
 {
@@ -97,7 +97,7 @@ static void ryb1_hue2hue(double hue, Color* hsl)
 {
 	Color c;
 	color_rybhue_to_rgb(hue, &c);
-	color_rgb_to_hsl(&c, hsl);
+	*hsl = c.rgbToHsl();
 }
 static void ryb1_rgbhue2hue(double rgbhue, double *hue)
 {
@@ -105,9 +105,9 @@ static void ryb1_rgbhue2hue(double rgbhue, double *hue)
 }
 static void ryb2_hue2hue(double hue, Color* hsl)
 {
-	hsl->hsl.hue = color_rybhue_to_rgbhue_f(hue);
+	hsl->hsl.hue = static_cast<float>(color_rybhue_to_rgbhue_f(hue));
 	hsl->hsl.saturation = 1;
-	hsl->hsl.lightness = 0.5;
+	hsl->hsl.lightness = 0.5f;
 }
 static void ryb2_rgbhue2hue(double rgbhue, double *hue)
 {
@@ -123,10 +123,10 @@ static void calc(DialogGenerateArgs *args, bool preview, int limit)
 	int32_t type = gtk_combo_box_get_active(GTK_COMBO_BOX(args->gen_type));
 	int32_t wheel_type = gtk_combo_box_get_active(GTK_COMBO_BOX(args->wheel_type));
 	int32_t color_count = static_cast<int32_t>(gtk_spin_button_get_value(GTK_SPIN_BUTTON(args->range_colors)));
-	float chaos = gtk_spin_button_get_value(GTK_SPIN_BUTTON(args->range_chaos));
+	float chaos = static_cast<float>(gtk_spin_button_get_value(GTK_SPIN_BUTTON(args->range_chaos)));
 	int32_t chaos_seed = static_cast<int32_t>(gtk_spin_button_get_value(GTK_SPIN_BUTTON(args->range_chaos_seed)));
 	bool reverse = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(args->toggle_reverse));
-	float additional_rotation = gtk_spin_button_get_value(GTK_SPIN_BUTTON(args->range_additional_rotation));
+	float additional_rotation = static_cast<float>(gtk_spin_button_get_value(GTK_SPIN_BUTTON(args->range_additional_rotation)));
 	if (!preview){
 		args->options->set("type", type);
 		args->options->set("wheel_type", wheel_type);
@@ -149,14 +149,14 @@ static void calc(DialogGenerateArgs *args, bool preview, int limit)
 	struct Random* random = random_new("SHR3", chaos_seed);
 	const SchemeType *scheme_type;
 	SchemeType static_scheme_type = {_("Static"), 1, 1, {0}};
-	if (type >= generate_scheme_get_n_scheme_types()){
+	if (static_cast<size_t>(type) >= generate_scheme_get_n_scheme_types()){
 		scheme_type = &static_scheme_type;
 	}else{
 		scheme_type = generate_scheme_get_scheme_type(type);
 	}
 	for (ColorList::iter i = args->selected_color_list->colors.begin(); i != args->selected_color_list->colors.end(); ++i){
 		Color in = (*i)->getColor();
-		color_rgb_to_hsl(&in, &hsl);
+		hsl = in.rgbToHsl();
 		wheel->rgbhue_to_hue(hsl.hsl.hue, &hue);
 		wheel->hue_to_hsl(hue, &hsl_results);
 		double saturation = hsl.hsl.saturation * 1 / hsl_results.hsl.saturation;
@@ -170,19 +170,19 @@ static void calc(DialogGenerateArgs *args, bool preview, int limit)
 				limit--;
 			}
 			wheel->hue_to_hsl(hue, &hsl);
-			hsl.hsl.lightness = clamp_float(hsl.hsl.lightness + lightness, 0, 1);
-			hsl.hsl.saturation = clamp_float(hsl.hsl.saturation * saturation, 0, 1);
-			color_hsl_to_rgb(&hsl, &r);
+			hsl.hsl.lightness = math::clamp(static_cast<float>(hsl.hsl.lightness + lightness), 0.0f, 1.0f);
+			hsl.hsl.saturation = math::clamp(static_cast<float>(hsl.hsl.saturation * saturation), 0.0f, 1.0f);
+			r = hsl.hslToRgb();
 			ColorObject *color_object = color_list_new_color_object(color_list, &r);
 			name_assigner.assign(color_object, &r, i, scheme_type->name);
 			color_list_add_color_object(color_list, color_object, 1);
 			color_object->release();
-			hue_step = (scheme_type->turn[i % scheme_type->turn_types]) / (360.0)
-				+ chaos * (random_get_double(random) - 0.5) + additional_rotation / 360.0;
+			hue_step = (scheme_type->turn[i % scheme_type->turn_types]) / (360.0f)
+				+ chaos * (random_get_double(random) - 0.5f) + additional_rotation / 360.0f;
 			if (reverse){
-				hue = wrap_float(hue - hue_step);
+				hue = math::wrap(static_cast<float>(hue - hue_step));
 			}else{
-				hue = wrap_float(hue + hue_step);
+				hue = math::wrap(static_cast<float>(hue + hue_step));
 			}
 		}
 	}
diff --git a/source/uiDialogMix.cpp b/source/uiDialogMix.cpp
index df94027..10d5cb2 100644
--- a/source/uiDialogMix.cpp
+++ b/source/uiDialogMix.cpp
@@ -21,8 +21,6 @@
 #include "uiUtilities.h"
 #include "ColorList.h"
 #include "ColorObject.h"
-#include "ColorUtils.h"
-#include "MathUtil.h"
 #include "dynv/Map.h"
 #include "GlobalState.h"
 #include "ToolColorNaming.h"
@@ -154,7 +152,7 @@ static void calc( DialogMixArgs *args, bool preview, int limit)
 	for (ColorList::iter i=args->selected_color_list->colors.begin(); i != args->selected_color_list->colors.end(); ++i){
 		a = (*i)->getColor();
 		if (type == 0)
-			color_rgb_get_linear(&a, &a);
+			a.linearRgbInplace();
 		name_assigner.setStartName((*i)->getName().c_str());
 		j = i;
 		++j;
@@ -165,15 +163,15 @@ static void calc( DialogMixArgs *args, bool preview, int limit)
 			}
 			b = (*j)->getColor();
 			if (type == 0)
-				color_rgb_get_linear(&b, &b);
+				b.linearRgbInplace();
 			name_assigner.setEndName((*j)->getName().c_str());
 			name_assigner.setStepsAndStage(steps, 0);
 
 			switch (type){
 			case 0:
 				for (step_i = start_step; step_i < max_step; ++step_i) {
-					color_utils::mix(a, b, step_i / (float)(steps - 1), r);
-					color_linear_get_rgb(&r, &r);
+					r = math::mix(a, b, step_i / (float)(steps - 1));
+					r.nonLinearRgbInplace();
 					store(color_list, &r, step_i, name_assigner);
 				}
 				break;
@@ -181,20 +179,19 @@ static void calc( DialogMixArgs *args, bool preview, int limit)
 			case 1:
 				{
 					Color a_hsv, b_hsv, r_hsv;
-					color_rgb_to_hsv(&a, &a_hsv);
-					color_rgb_to_hsv(&b, &b_hsv);
-
+					a_hsv = a.rgbToHsv();
+					b_hsv = b.rgbToHsv();
 					if (a_hsv.hsv.hue>b_hsv.hsv.hue){
-						if (a_hsv.hsv.hue-b_hsv.hsv.hue>0.5)
+						if (a_hsv.hsv.hue-b_hsv.hsv.hue>0.5f)
 							a_hsv.hsv.hue-=1;
 					}else{
-						if (b_hsv.hsv.hue-a_hsv.hsv.hue>0.5)
+						if (b_hsv.hsv.hue-a_hsv.hsv.hue>0.5f)
 							b_hsv.hsv.hue-=1;
 					}
 					for (step_i = start_step; step_i < max_step; ++step_i) {
-						color_utils::mix(a_hsv, b_hsv, step_i / (float)(steps - 1), r_hsv);
+						r_hsv = math::mix(a_hsv, b_hsv, step_i / (float)(steps - 1));
 						if (r_hsv.hsv.hue < 0) r_hsv.hsv.hue += 1;
-						color_hsv_to_rgb(&r_hsv, &r);
+						r = r_hsv.hsvToRgb();
 						store(color_list, &r, step_i, name_assigner);
 					}
 				}
@@ -203,13 +200,11 @@ static void calc( DialogMixArgs *args, bool preview, int limit)
 			case 2:
 				{
 					Color a_lab, b_lab, r_lab;
-					color_rgb_to_lab_d50(&a, &a_lab);
-					color_rgb_to_lab_d50(&b, &b_lab);
-
+					a_lab = a.rgbToLabD50();
+					b_lab = b.rgbToLabD50();
 					for (step_i = start_step; step_i < max_step; ++step_i) {
-						color_utils::mix(a_lab, b_lab, step_i / (float)(steps - 1), r_lab);
-						color_lab_to_rgb_d50(&r_lab, &r);
-						color_rgb_normalize(&r);
+						r_lab = math::mix(a_lab, b_lab, step_i / (float)(steps - 1));
+						r = r_lab.labToRgbD50().normalizeRgbInplace();
 						store(color_list, &r, step_i, name_assigner);
 					}
 				}
@@ -218,9 +213,8 @@ static void calc( DialogMixArgs *args, bool preview, int limit)
 			case 3:
 				{
 					Color a_lch, b_lch, r_lch;
-					color_rgb_to_lch_d50(&a, &a_lch);
-					color_rgb_to_lch_d50(&b, &b_lch);
-
+					a_lch = a.rgbToLchD50();
+					b_lch = b.rgbToLchD50();
 					if (a_lch.lch.h>b_lch.lch.h){
 						if (a_lch.lch.h-b_lch.lch.h>180)
 							a_lch.lch.h-=360;
@@ -229,10 +223,9 @@ static void calc( DialogMixArgs *args, bool preview, int limit)
 							b_lch.lch.h-=360;
 					}
 					for (step_i = start_step; step_i < max_step; ++step_i) {
-						color_utils::mix(a_lch, b_lch, step_i / (float)(steps - 1), r_lch);
+						r_lch = math::mix(a_lch, b_lch, step_i / (float)(steps - 1));
 						if (r_lch.lch.h < 0) r_lch.lch.h += 360;
-						color_lch_to_rgb_d50(&r_lch, &r);
-						color_rgb_normalize(&r);
+						r = r_lch.lchToRgbD50().normalizeRgbInplace();
 						store(color_list, &r, step_i, name_assigner);
 					}
 				}
diff --git a/source/uiDialogOptions.cpp b/source/uiDialogOptions.cpp
index 73b5f8b..0bd92f7 100644
--- a/source/uiDialogOptions.cpp
+++ b/source/uiDialogOptions.cpp
@@ -110,8 +110,8 @@ static void calc( DialogOptionsArgs *args, bool preview, int limit)
 		options->set("options.hex_case", "lower");
 	else
 		options->set("options.hex_case", "upper");
-	options->set<int32_t>("picker.refresh_rate", gtk_spin_button_get_value(GTK_SPIN_BUTTON(args->refresh_rate)));
-	options->set<int32_t>("picker.zoom_size", gtk_spin_button_get_value(GTK_SPIN_BUTTON(args->zoom_size)));
+	options->set<int32_t>("picker.refresh_rate", static_cast<int32_t>(gtk_spin_button_get_value(GTK_SPIN_BUTTON(args->refresh_rate))));
+	options->set<int32_t>("picker.zoom_size", static_cast<int32_t>(gtk_spin_button_get_value(GTK_SPIN_BUTTON(args->zoom_size))));
 	options->set<bool>("picker.always_use_floating_picker", gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(args->always_use_floating_picker)));
 	options->set<bool>("picker.hide_cursor", gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(args->hide_cursor)));
 	options->set<bool>("picker.sampler.add_on_release", gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(args->add_on_release)));
diff --git a/source/uiDialogSort.cpp b/source/uiDialogSort.cpp
index b17b7c1..e15ca5e 100644
--- a/source/uiDialogSort.cpp
+++ b/source/uiDialogSort.cpp
@@ -80,57 +80,39 @@ static double sort_rgb_grayscale(Color *color)
 }
 static double sort_hsl_hue(Color *color)
 {
-	Color hsl;
-	color_rgb_to_hsl(color, &hsl);
-	return hsl.hsl.hue;
+	return color->rgbToHsl().hsl.hue;
 }
 static double sort_hsl_saturation(Color *color)
 {
-	Color hsl;
-	color_rgb_to_hsl(color, &hsl);
-	return hsl.hsl.saturation;
+	return color->rgbToHsl().hsl.saturation;
 }
 static double sort_hsl_lightness(Color *color)
 {
-	Color hsl;
-	color_rgb_to_hsl(color, &hsl);
-	return hsl.hsl.lightness;
+	return color->rgbToHsl().hsl.lightness;
 }
 static double sort_lab_lightness(Color *color)
 {
-	Color lab;
-	color_rgb_to_lab_d50(color, &lab);
-	return lab.lab.L;
+	return color->rgbToLabD50().lab.L;
 }
 static double sort_lab_a(Color *color)
 {
-	Color lab;
-	color_rgb_to_lab_d50(color, &lab);
-	return lab.lab.a;
+	return color->rgbToLabD50().lab.a;
 }
 static double sort_lab_b(Color *color)
 {
-	Color lab;
-	color_rgb_to_lab_d50(color, &lab);
-	return lab.lab.b;
+	return color->rgbToLabD50().lab.b;
 }
 static double sort_lch_lightness(Color *color)
 {
-	Color lch;
-	color_rgb_to_lch_d50(color, &lch);
-	return lch.lch.L;
+	return color->rgbToLchD50().lch.L;
 }
 static double sort_lch_chroma(Color *color)
 {
-	Color lch;
-	color_rgb_to_lch_d50(color, &lch);
-	return lch.lch.C;
+	return color->rgbToLchD50().lch.C;
 }
 static double sort_lch_hue(Color *color)
 {
-	Color lch;
-	color_rgb_to_lch_d50(color, &lch);
-	return lch.lch.h;
+	return color->rgbToLchD50().lch.h;
 }
 
 const SortType sort_types[] = {
@@ -167,57 +149,39 @@ static double group_rgb_grayscale(Color *color)
 }
 static double group_hsl_hue(Color *color)
 {
-	Color hsl;
-	color_rgb_to_hsl(color, &hsl);
-	return hsl.hsl.hue;
+	return color->rgbToHsl().hsl.hue;
 }
 static double group_hsl_saturation(Color *color)
 {
-	Color hsl;
-	color_rgb_to_hsl(color, &hsl);
-	return hsl.hsl.saturation;
+	return color->rgbToHsl().hsl.saturation;
 }
 static double group_hsl_lightness(Color *color)
 {
-	Color hsl;
-	color_rgb_to_hsl(color, &hsl);
-	return hsl.hsl.lightness;
+	return color->rgbToHsl().hsl.lightness;
 }
 static double group_lab_lightness(Color *color)
 {
-	Color lab;
-	color_rgb_to_lab_d50(color, &lab);
-	return lab.lab.L / 100.0;
+	return color->rgbToLabD50().lab.L / 100.0;
 }
 static double group_lab_a(Color *color)
 {
-	Color lab;
-	color_rgb_to_lab_d50(color, &lab);
-	return (lab.lab.a + 145) / 290.0;
+	return (color->rgbToLabD50().lab.a + 145) / 290.0;
 }
 static double group_lab_b(Color *color)
 {
-	Color lab;
-	color_rgb_to_lab_d50(color, &lab);
-	return (lab.lab.b + 145) / 290.0;
+	return (color->rgbToLabD50().lab.b + 145) / 290.0;
 }
 static double group_lch_lightness(Color *color)
 {
-	Color lch;
-	color_rgb_to_lch_d50(color, &lch);
-	return lch.lch.L / 100.0;
+	return color->rgbToLchD50().lch.L / 100.0;
 }
 static double group_lch_chroma(Color *color)
 {
-	Color lch;
-	color_rgb_to_lch_d50(color, &lch);
-	return lch.lch.C / 136.0;
+	return color->rgbToLchD50().lch.C / 136.0;
 }
 static double group_lch_hue(Color *color)
 {
-	Color lch;
-	color_rgb_to_lch_d50(color, &lch);
-	return lch.lch.h / 360.0;
+	return color->rgbToLchD50().lch.h / 360.0;
 }
 
 const GroupType group_types[] = {
@@ -428,8 +392,8 @@ static void node_update(Node *node, Range *range, double value, uint32_t max_dep
 
 static void calc(DialogSortArgs *args, bool preview, int limit){
 	int32_t group_type = gtk_combo_box_get_active(GTK_COMBO_BOX(args->group_type));
-	float group_sensitivity = gtk_spin_button_get_value(GTK_SPIN_BUTTON(args->group_sensitivity));
-	int max_groups = gtk_spin_button_get_value(GTK_SPIN_BUTTON(args->max_groups));
+	float group_sensitivity = static_cast<float>(gtk_spin_button_get_value(GTK_SPIN_BUTTON(args->group_sensitivity)));
+	int max_groups = static_cast<int>(gtk_spin_button_get_value(GTK_SPIN_BUTTON(args->max_groups)));
 	int32_t sort_type = gtk_combo_box_get_active(GTK_COMBO_BOX(args->sort_type));
 	bool reverse = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(args->toggle_reverse));
 	bool reverse_groups = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(args->toggle_reverse_groups));
diff --git a/source/uiDialogVariations.cpp b/source/uiDialogVariations.cpp
index 4a02777..34fca21 100644
--- a/source/uiDialogVariations.cpp
+++ b/source/uiDialogVariations.cpp
@@ -21,7 +21,6 @@
 #include "uiUtilities.h"
 #include "ColorList.h"
 #include "ColorObject.h"
-#include "MathUtil.h"
 #include "dynv/Map.h"
 #include "GlobalState.h"
 #include "ToolColorNaming.h"
@@ -67,10 +66,10 @@ struct VariationsColorNameAssigner: public ToolColorNameAssigner
 static void calc(DialogVariationsArgs *args, bool preview, int limit)
 {
 	gint steps = gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(args->range_steps));
-	float lightness_from = gtk_spin_button_get_value(GTK_SPIN_BUTTON(args->range_lightness_from));
-	float lightness_to = gtk_spin_button_get_value(GTK_SPIN_BUTTON(args->range_lightness_to));
-	float saturation_from = gtk_spin_button_get_value(GTK_SPIN_BUTTON(args->range_saturation_from));
-	float saturation_to = gtk_spin_button_get_value(GTK_SPIN_BUTTON(args->range_saturation_to));
+	float lightness_from = static_cast<float>(gtk_spin_button_get_value(GTK_SPIN_BUTTON(args->range_lightness_from)));
+	float lightness_to = static_cast<float>(gtk_spin_button_get_value(GTK_SPIN_BUTTON(args->range_lightness_to)));
+	float saturation_from = static_cast<float>(gtk_spin_button_get_value(GTK_SPIN_BUTTON(args->range_saturation_from)));
+	float saturation_to = static_cast<float>(gtk_spin_button_get_value(GTK_SPIN_BUTTON(args->range_saturation_to)));
 	bool multiplication = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(args->toggle_multiplication));
 	bool linearization = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(args->toggle_linearization));
 	if (!preview){
@@ -94,35 +93,35 @@ static void calc(DialogVariationsArgs *args, bool preview, int limit)
 		Color in = (*i)->getColor();
 		const char* name = (*i)->getName().c_str();
 		if (linearization)
-			color_rgb_get_linear(&in, &in);
+			in.linearRgbInplace();
 		for (step_i = 0; step_i < steps; ++step_i) {
 			if (preview){
 				if (limit <= 0) return;
 				limit--;
 			}
-			color_rgb_to_hsl(&in, &hsl);
+			hsl = in.rgbToHsl();
 			if (steps == 1){
 				if (multiplication){
-					hsl.hsl.saturation *= mix_float(saturation_from, saturation_to, 0);
-					hsl.hsl.lightness *= mix_float(lightness_from, lightness_to, 0);
+					hsl.hsl.saturation *= math::mix(saturation_from, saturation_to, 0);
+					hsl.hsl.lightness *= math::mix(lightness_from, lightness_to, 0);
 				}else{
-					hsl.hsl.saturation += mix_float(saturation_from, saturation_to, 0);
-					hsl.hsl.lightness += mix_float(lightness_from, lightness_to, 0);
+					hsl.hsl.saturation += math::mix(saturation_from, saturation_to, 0);
+					hsl.hsl.lightness += math::mix(lightness_from, lightness_to, 0);
 				}
 			}else{
 				if (multiplication){
-					hsl.hsl.saturation *= mix_float(saturation_from, saturation_to, (step_i / (float) (steps - 1)));
-					hsl.hsl.lightness *= mix_float(lightness_from, lightness_to, (step_i / (float) (steps - 1)));
+					hsl.hsl.saturation *= math::mix(saturation_from, saturation_to, (step_i / (float) (steps - 1)));
+					hsl.hsl.lightness *= math::mix(lightness_from, lightness_to, (step_i / (float) (steps - 1)));
 				}else{
-					hsl.hsl.saturation += mix_float(saturation_from, saturation_to, (step_i / (float) (steps - 1)));
-					hsl.hsl.lightness += mix_float(lightness_from, lightness_to, (step_i / (float) (steps - 1)));
+					hsl.hsl.saturation += math::mix(saturation_from, saturation_to, (step_i / (float) (steps - 1)));
+					hsl.hsl.lightness += math::mix(lightness_from, lightness_to, (step_i / (float) (steps - 1)));
 				}
 			}
-			hsl.hsl.saturation = clamp_float(hsl.hsl.saturation, 0, 1);
-			hsl.hsl.lightness = clamp_float(hsl.hsl.lightness, 0, 1);
-			color_hsl_to_rgb(&hsl, &r);
+			hsl.hsl.saturation = math::clamp(hsl.hsl.saturation, 0.0f, 1.0f);
+			hsl.hsl.lightness = math::clamp(hsl.hsl.lightness, 0.0f, 1.0f);
+			r = hsl.hslToRgb();
 			if (linearization)
-				color_linear_get_rgb(&r, &r);
+				r.nonLinearRgbInplace();
 			ColorObject *color_object = color_list_new_color_object(color_list, &r);
 			name_assigner.assign(color_object, &r, name, step_i);
 			color_list_add_color_object(color_list, color_object, 1);
